{
  "cat": [
    {
      "chunk": "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\build.rs"
    },
    {
      "chunk": "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod alignalloc;\npub mod binary_io;\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod close_stream;\npub mod closeout;\npub mod copy_file_range;\npub mod exitfail;\npub mod fadvise;\npub mod fclose;\npub mod fcntl;\npub mod fflush;\npub mod fpurge;\npub mod fseeko;\npub mod full_write;\npub mod hard_locale;\npub mod ialloc;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod safe_read;\npub mod safe_write;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod stdbit;\npub mod stdc_leading_zeros;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalignalloc;\npub mod xalloc_die;\npub mod xbinary_io;\npub mod xmalloc;\n}\n// mod src",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\lib.rs"
    },
    {
      "chunk": "use std::boxed::Box;\nuse std::alloc;\nuse ::libc;\nextern \"C\" {\n    fn free(_: *mut libc::c_void);\n    fn aligned_alloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n}\npub type size_t = libc::c_ulong;\npub type ptrdiff_t = libc::c_long;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn alignalloc(alignment: usize, size: usize) -> Option<Box<[u8]>> {\n    let alignment = if alignment.is_power_of_two() && alignment > 0 {\n        alignment\n    } else {\n        usize::MAX\n    };\n    \n    let size = if size > 0 {\n        size\n    } else {\n        usize::MAX\n    };\n\n    let layout = std::alloc::Layout::from_size_align(size, alignment).ok()?;\n    let ptr = unsafe { std::alloc::alloc(layout) };\n    if ptr.is_null() {\n        None\n    } else {\n        Some(unsafe { Box::from_raw(std::slice::from_raw_parts_mut(ptr, size)) })\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn alignfree(ptr: Box<dyn std::any::Any>) {\n    drop(ptr);\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\alignalloc.rs"
    },
    {
      "chunk": "use std::os::unix::io::AsRawFd;\nuse ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn set_binary_mode(fd: i32, mode: i32) -> i32 {\n    __gl_setmode(fd, mode)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn __gl_setmode(fd: i32, mode: i32) -> i32 {\n    return 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\binary_io.rs"
    },
    {
      "chunk": "#![allow(\n    dead_code,\n    mutable_transmutes,\n    non_camel_case_types,\n    non_snake_case,\n    non_upper_case_globals,\n    unused_assignments,\n    unused_mut,\n    unused_imports\n)]\n#![feature(extern_types)]\nuse libc;\nuse std::io;\nuse std::ptr;\nuse std::io::Write;\nuse rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn fpurge(gl_stream: *mut FILE) -> libc::c_int;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    static mut optind: libc::c_int;\n    fn ioctl(__fd: libc::c_int, __request: libc::c_ulong, _: ...) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn getpagesize() -> libc::c_int;\n    fn rpl_copy_file_range(\n        ifd: libc::c_int,\n        ipos: *mut off_t,\n        ofd: libc::c_int,\n        opos: *mut off_t,\n        len: size_t,\n        flags: libc::c_uint,\n    ) -> ssize_t;\n    fn memmove(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong)\n        -> *mut libc::c_void;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(_: *const libc::c_char, _: *const libc::c_char, _: libc::c_ulong) -> libc::c_int;\n    fn stpcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;\n    fn free(_: *mut libc::c_void);\n    fn __errno_location() -> *mut libc::c_int;\n    fn quotearg_n_style_colon(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    static mut Version: *const libc::c_char;\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn rpl_fcntl(fd: libc::c_int, action: libc::c_int, _: ...) -> libc::c_int;\n    fn setlocale(__category: libc::c_int, __locale: *const libc::c_char) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn xalloc_die();\n    fn close_stdout();\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    static mut program_name: *const libc::c_char;\n    fn set_program_name(argv0: *const libc::c_char);\n    fn error(__status: libc::c_int, __errnum: libc::c_int, __format: *const libc::c_char, _: ...);\n    fn atexit(__func: Option<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn exit(_: libc::c_int) -> !;\n    fn xalignalloc(_: idx_t, _: idx_t) -> *mut libc::c_void;\n    fn fdadvise(fd: libc::c_int, offset: off_t, len: off_t, advice: fadvice_t);\n    fn full_write(fd: libc::c_int, buf: *const libc::c_void, count: size_t) -> size_t;\n    fn safe_read(fd: libc::c_int, buf: *mut libc::c_void, count: size_t) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __ssize_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type ssize_t = __ssize_t;\npub type ptrdiff_t = libc::c_long;\npub type ino_t = __ino_t;\npub type dev_t = __dev_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const IO_BUFSIZE: C2RustUnnamed_0 = 262144;\npub type fadvice_t = libc::c_uint;\npub const FADVISE_RANDOM: fadvice_t = 1;\npub const FADVISE_WILLNEED: fadvice_t = 3;\npub const FADVISE_DONTNEED: fadvice_t = 4;\npub const FADVISE_NOREUSE: fadvice_t = 5;\npub const FADVISE_SEQUENTIAL: fadvice_t = 2;\npub const FADVISE_NORMAL: fadvice_t = 0;\n#[inline]\nfn is_ENOTSUP(err: i32) -> bool {\n    err == 95\n}\n#[inline]\nfn emit_stdin_note() {\n    let message = \"\\nWith no FILE, or when FILE is -, read standard input.\\n\";\n    let _ = std::io::stdout().write_all(message.as_bytes());\n}\n#[inline]\nfn emit_ancillary_info(program: &str) {\n    let infomap_0: [(&str, &str); 7] = [\n        (\"[\", \"test invocation\"),\n        (\"coreutils\", \"Multi-call invocation\"),\n        (\"sha224sum\", \"sha2 utilities\"),\n        (\"sha256sum\", \"sha2 utilities\"),\n        (\"sha384sum\", \"sha2 utilities\"),\n        (\"sha512sum\", \"sha2 utilities\"),\n        (\"\", \"\"),\n    ];\n\n    let mut node = program;\n    let mut map_prog = infomap_0.iter();\n\n    while let Some(&(prog, n)) = map_prog.next() {\n        if prog.is_empty() || program == prog {\n            node = n;\n            break;\n        }\n    }\n\n    println!(\n        \"{} online help: <{}>\",\n        \"GNU coreutils\", \"https://www.gnu.org/software/coreutils/\"\n    );\n\n    let lc_messages = unsafe { setlocale(5, std::ptr::null()) };\n    if !lc_messages.is_null() {\n        let lc_messages_str = unsafe { std::ffi::CStr::from_ptr(lc_messages).to_string_lossy() };\n        if !lc_messages_str.starts_with(\"en_\") {\n            eprint!(\n                \"{}\",\n                \"Report any translation bugs to <https://translationproject.org/team/>\"\n            );\n        }\n    }\n\n    let url_program = if program == \"[\" { \"test\" } else { program };\n\n    println!(\n        \"Full documentation <{}{}>\",\n        \"https://www.gnu.org/software/coreutils/\", url_program\n    );\n\n    println!(\n        \"or available locally via: info '(coreutils) {}{}'\",\n        node,\n        if node == program { \" invocation\" } else { \"\" }\n    );\n}\n#[inline]",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\cat.rs"
    },
    {
      "chunk": "fn write_error() {\n    let saved_errno: i32 = std::io::Error::last_os_error().raw_os_error().unwrap_or(0);\n    let _ = std::io::stdout().flush();\n\n    if false {\n        unsafe {\n            error(\n                1,\n                saved_errno,\n                gettext(b\"write error\\0\".as_ptr() as *const libc::c_char),\n            );\n        }\n        if true {\n            unreachable!();\n        }\n    } else {\n        {\n            let errstatus: i32 = 1;\n            unsafe {\n                error(\n                    errstatus,\n                    saved_errno,\n                    gettext(b\"write error\\0\".as_ptr() as *const libc::c_char),\n                );\n            }\n            if errstatus != 0 {\n                unreachable!();\n            }\n        }\n        {\n            let errstatus: i32 = 1;\n            unsafe {\n                error(\n                    errstatus,\n                    saved_errno,\n                    gettext(b\"write error\\0\".as_ptr() as *const libc::c_char),\n                );\n            }\n            if errstatus != 0 {\n                unreachable!();\n            }\n        }\n    }\n}\n#[inline]\nunsafe extern \"C\" fn alignfree(mut ptr: *mut libc::c_void) {\n    free(ptr);\n}\n#[inline]\nfn __gl_stdbit_clzll(n: u64) -> i32 {\n    if n != 0 {\n        n.leading_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u64>() as u32) as i32\n    }\n}\n#[inline]\nfn stdc_leading_zeros_ull(n: u64) -> u32 {\n    n.leading_zeros()\n}\n#[inline]\nfn io_blksize(st: &stat) -> idx_t {\n    let blocksize: idx_t = if st.st_blksize > 0 && st.st_blksize as usize <= (usize::MAX / 8) {\n        st.st_blksize as idx_t\n    } else {\n        512\n    };\n\n    let mut adjusted_blocksize =\n        blocksize + (IO_BUFSIZE as idx_t - 1) - (IO_BUFSIZE as idx_t - 1) % blocksize;\n\n    if (st.st_mode & 0o170000) == 0o100000 && adjusted_blocksize & (adjusted_blocksize - 1) != 0 {\n        let leading_zeros = stdc_leading_zeros_ull(adjusted_blocksize as u64) as i32;\n        if leading_zeros != 0 {\n            let power = 1u64 << (64 - leading_zeros);\n            if power <= i64::MAX as u64 {\n                adjusted_blocksize = power as idx_t;\n            }\n        }\n    }\n\n    let max_value = if (i64::MAX as u64) < u64::MAX {\n        i64::MAX as u64\n    } else {\n        u64::MAX\n    };\n\n    if max_value.wrapping_div(2) + 1 < adjusted_blocksize as u64 {\n        (max_value.wrapping_div(2) + 1) as idx_t\n    } else {\n        adjusted_blocksize as u64 as idx_t\n    }\n}\n#[inline]\nfn __gl_setmode(fd: i32, mode: i32) -> i32 {\n    0\n}\n#[inline]\nunsafe extern \"C\" fn set_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[inline]\nfn xset_binary_mode_error() {\n    // Implement the functionality that was previously unsafe or C API related.\n    // Since the original function does not have any implementation, we will assume\n    // it is meant to set some binary mode. Here we can use Rust's standard library\n    // features to achieve similar functionality if needed.\n    // For now, we will leave it empty, as the original function does nothing.\n}\n#[inline]\nfn xset_binary_mode(fd: i32, mode: i32) {\n    unsafe {\n        if set_binary_mode(fd, mode) < 0 {\n            xset_binary_mode_error();\n        }\n    }\n}\nstatic mut infile: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut input_desc: libc::c_int = 0;\nstatic mut line_buf: [libc::c_char; 20] = [\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    '0' as i32 as libc::c_char,\n    '\\t' as i32 as libc::c_char,\n    '\\0' as i32 as libc::c_char,\n];\nstatic mut line_num_print: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;\nstatic mut line_num_start: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;\nstatic mut line_num_end: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;\nstatic mut newlines2: libc::c_int = 0 as libc::c_int;\nstatic mut pending_cr: bool = 0 as libc::c_int != 0;\n#[no_mangle]\npub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8 as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(b\"Usage: %s [OPTION]... [FILE]...\\n\\0\" as *const u8 as *const libc::c_char),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Concatenate FILE(s) to standard output.\\n\\0\" as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_stdin_note();\n        fputs_unlocked(\n            gettext(\n                b\"\\n  -A, --show-all           equivalent to -vET\\n  -b, --number-nonblank    number nonempty output lines, overrides -n\\n  -e                       equivalent to -vE\\n  -E, --show-ends          display $ at end of each line\\n  -n, --number             number all output lines\\n  -s, --squeeze-blank      suppress repeated empty output lines\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -t                       equivalent to -vT\\n  -T, --show-tabs          display TAB characters as ^I\\n  -u                       (ignored)\\n  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        printf(\n            gettext(\n                b\"\\nExamples:\\n  %s f - g  Output f's contents, then standard input, then g's contents.\\n  %s        Copy standard input to standard output.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            program_name,\n            program_name,\n        );\n        let program_str = std::ffi::CStr::from_ptr(b\"cat\\0\".as_ptr() as *const libc::c_char)\n            .to_string_lossy()\n            .into_owned();\n        emit_ancillary_info(&program_str);\n    }\n    exit(status);\n}\nfn next_line_num() {\n    unsafe {\n        let mut endp = line_num_end;\n        loop {\n            let fresh0 = *endp;\n            *endp = (*endp as i32 + 1) as libc::c_char;\n            if (fresh0 as i32) < ('9' as i32) {\n                return;\n            }\n            let fresh1 = endp;\n            endp = endp.offset(-1);\n            *fresh1 = '0' as i32 as libc::c_char;\n            if endp < line_num_start {\n                break;\n            }\n        }\n        if line_num_start > line_buf.as_mut_ptr() {\n            line_num_start = line_num_start.offset(-1);\n            *line_num_start = '1' as i32 as libc::c_char;\n        } else {\n            *line_buf.as_mut_ptr() = '>' as i32 as libc::c_char;\n        }\n        if line_num_start < line_num_print {\n            line_num_print = line_num_print.offset(-1);\n        }\n    }\n}\nfn simple_cat(buf: &mut [u8]) -> bool {\n    loop {\n        let n_read = unsafe {\n            safe_read(\n                input_desc,\n                buf.as_mut_ptr() as *mut libc::c_void,\n                buf.len() as size_t,\n            )\n        };\n        if n_read == !(0 as libc::c_int) as size_t {\n            let errstatus: libc::c_int = 0;\n            unsafe {\n                error(\n                    errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(0 as libc::c_int, shell_escape_quoting_style, infile),\n                );\n            }\n            return false;\n        }\n        if n_read == 0 {\n            return true;\n        }\n        unsafe {\n            if full_write(\n                1 as libc::c_int,\n                buf.as_ptr() as *const libc::c_void,\n                n_read,\n            ) != n_read\n            {\n                write_error();\n            }\n        }\n    }\n}\n#[inline]\nunsafe extern \"C\" fn write_pending(\n    mut outbuf: *mut libc::c_char,\n    mut bpout: *mut *mut libc::c_char,\n) {\n    let mut n_write: idx_t = (*bpout).offset_from(outbuf) as libc::c_long;\n    if (0 as libc::c_int as libc::c_long) < n_write {\n        if full_write(\n            1 as libc::c_int,\n            outbuf as *const libc::c_void,\n            n_write as size_t,\n        ) != n_write as libc::c_ulong\n        {\n            write_error();\n        }\n        *bpout = outbuf;\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\cat.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn cat(\n    mut inbuf: *mut libc::c_char,\n    mut insize: idx_t,\n    mut outbuf: *mut libc::c_char,\n    mut outsize: idx_t,\n    mut show_nonprinting: bool,\n    mut show_tabs: bool,\n    mut number: bool,\n    mut number_nonblank: bool,\n    mut show_ends: bool,\n    mut squeeze_blank: bool,\n) -> bool {\n    let mut ch: libc::c_uchar = 0;\n    let mut newlines: libc::c_int = newlines2;\n    let mut use_fionread: bool = 1 as libc::c_int != 0;\n    let mut eob: *mut libc::c_char = inbuf;\n    let mut bpin: *mut libc::c_char = eob.offset(1 as libc::c_int as isize);\n    let mut bpout: *mut libc::c_char = outbuf;\n    loop {\n        let mut current_block_52: u64;\n        loop {\n            if (bpout as isize) < (outsize as isize) {\n                let mut wp: *mut i8 = outbuf;\n                let mut remaining_bytes: i64 = 0;\n                loop {\n                    if full_write(1, wp as *const libc::c_void, outsize as size_t)\n                        != outsize as libc::c_ulong\n                    {\n                        write_error();\n                    }\n                    wp = wp.offset(outsize as isize);\n                    remaining_bytes = bpout.offset_from(wp) as i64;\n                    if !(outsize as i64 <= remaining_bytes) {\n                        break;\n                    }\n                }\n                unsafe {\n                    std::ptr::copy(wp, outbuf, remaining_bytes as usize);\n                }\n                bpout = outbuf.offset(remaining_bytes as isize);\n            }\n            if bpin > eob {\n                let mut input_pending: bool = false;\n                let mut n_to_read: i32 = 0;\n\n                if use_fionread && ioctl(input_desc, 0x541b, &mut n_to_read) < 0 {\n                    match *__errno_location() {\n                        95 | 25 | 22 | 19 | 38 => {\n                            use_fionread = false;\n                        }\n                        _ => {\n                            error(\n                                0,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot do ioctl on %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, infile),\n                            );\n                            newlines2 = newlines;\n                            return false;\n                        }\n                    }\n                }\n\n                if n_to_read != 0 {\n                    input_pending = true;\n                }\n\n                if !input_pending {\n                    write_pending(outbuf, &mut bpout);\n                }\n\n                let n_read: u64 = safe_read(\n                    input_desc,\n                    inbuf as *mut libc::c_void,\n                    insize.try_into().unwrap(),\n                );\n                if n_read == u64::MAX {\n                    error(\n                        0,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(0, shell_escape_quoting_style, infile),\n                    );\n                    write_pending(outbuf, &mut bpout);\n                    newlines2 = newlines;\n                    return false;\n                }\n\n                if n_read == 0 {\n                    write_pending(outbuf, &mut bpout);\n                    newlines2 = newlines;\n                    return true;\n                }\n\n                bpin = inbuf;\n                eob = bpin.add(n_read as usize);\n                *eob = '\\n' as i32 as i8;\n                current_block_52 = 6476622998065200121;\n            } else {\n                newlines += 1;\n                if newlines > 0 {\n                    if newlines >= 2 {\n                        newlines = 2;\n                        if squeeze_blank {\n                            ch = unsafe { *bpin } as u8; // Dereference the raw pointer and cast to u8\n                            bpin = bpin.add(1); // Move the pointer forward\n                            current_block_52 = 16658872821858055392;\n                        } else {\n                            current_block_52 = 15597372965620363352;\n                        }\n                    } else {\n                        current_block_52 = 15597372965620363352;\n                    }\n                    match current_block_52 {\n                        16658872821858055392 => {}\n                        _ => {\n                            if number && !number_nonblank {\n                                next_line_num();\n                                bpout = stpcpy(bpout, line_num_print);\n                            }\n                            current_block_52 = 17784502470059252271;\n                        }\n                    }\n                } else {\n                    current_block_52 = 17784502470059252271;\n                }\n                match current_block_52 {\n                    16658872821858055392 => {}\n                    _ => {\n                        if show_ends {\n                            if pending_cr {\n                                unsafe {\n                                    *bpout = '^' as i8;\n                                    *(bpout.add(1)) = 'M' as i8;\n                                }\n                                bpout = bpout.add(2);\n                                pending_cr = false;\n                            }\n                            unsafe {\n                                *bpout = '$' as i8;\n                            }\n                            bpout = bpout.add(1);\n                        }\n                        unsafe {\n                            *bpout = '\\n' as i8;\n                        }\n                        bpout = bpout.add(1);\n                        current_block_52 = 6476622998065200121;\n                    }\n                }\n            }\n            match current_block_52 {\n                6476622998065200121 => {\n                    let fresh7 = bpin;\n                    bpin = bpin.offset(1);\n                    ch = *fresh7 as libc::c_uchar;\n                }\n                _ => {}\n            }\n            if !(ch as libc::c_int == '\\n' as i32) {\n                break;\n            }\n        }\n        if pending_cr {\n            *bpout = '\\r' as i8;\n            bpout = bpout.add(1);\n            pending_cr = false;\n        }\n        if newlines >= 0 && number {\n            next_line_num();\n            bpout = stpcpy(bpout, line_num_print);\n        }\n        if show_nonprinting {\n            loop {\n                if ch >= 32 {\n                    if ch < 127 {\n                        *bpout = ch as i8;\n                        bpout = bpout.add(1);\n                    } else if ch == 127 {\n                        *bpout = '^' as i8;\n                        bpout = bpout.add(1);\n                        *bpout = '?' as i8;\n                        bpout = bpout.add(1);\n                    } else {\n                        *bpout = 'M' as i8;\n                        bpout = bpout.add(1);\n                        *bpout = '-' as i8;\n                        if ch >= 128 + 32 {\n                            if ch < 128 + 127 {\n                                *bpout = (ch - 128) as i8;\n                                bpout = bpout.add(1);\n                            } else {\n                                *bpout = '^' as i8;\n                                bpout = bpout.add(1);\n                                *bpout = '?' as i8;\n                                bpout = bpout.add(1);\n                            }\n                        } else {\n                            *bpout = '^' as i8;\n                            bpout = bpout.add(1);\n                            *bpout = (ch + 64) as i8;\n                            bpout = bpout.add(1);\n                        }\n                    }\n                } else if ch == b'\\t' && !show_tabs {\n                    *bpout = ch as i8;\n                    bpout = bpout.add(1);\n                } else if ch == b'\\n' {\n                    newlines = -1;\n                    break;\n                } else {\n                    *bpout = '^' as i8;\n                    bpout = bpout.add(1);\n                    *bpout = (ch + 64) as i8;\n                    bpout = bpout.add(1);\n                }\n                ch = *bpin as u8;\n                bpin = bpin.add(1);\n            }\n        } else {\n            loop {\n                if ch == b'\\t' && show_tabs {\n                    *bpout = '^' as i8;\n                    bpout = bpout.add(1);\n                    *bpout = (ch + 64) as i8;\n                    bpout = bpout.add(1);\n                } else if ch != b'\\n' {\n                    if ch == b'\\r' && *bpin as i8 == b'\\n' as i8 && show_ends {\n                        if bpin == eob {\n                            pending_cr = true;\n                        } else {\n                            *bpout = '^' as i8;\n                            bpout = bpout.add(1);\n                            *bpout = 'M' as i8;\n                            bpout = bpout.add(1);\n                        }\n                    } else {\n                        *bpout = ch as i8;\n                        bpout = bpout.add(1);\n                    }\n                } else {\n                    newlines = -1;\n                    break;\n                }\n                ch = *bpin as u8;\n                bpin = bpin.add(1);\n            }\n        }\n        /*\n        The variables live at this point are:\n        (mut inbuf: *mut i8, mut insize: i64, mut outbuf: *mut i8, mut outsize: i64, mut show_nonprinting: bool, mut show_tabs: bool, mut number: bool, mut number_nonblank: bool, mut show_ends: bool, mut squeeze_blank: bool, mut ch: u8, mut newlines: i32, mut use_fionread: bool, mut eob: *mut i8, mut bpin: *mut i8, mut bpout: *mut i8, mut current_block_52: u64)\n        */\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\cat.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn copy_cat() -> libc::c_int {\n    let mut copy_max: ssize_t = (((if (9223372036854775807 as libc::c_long as libc::c_ulong)\n        < 18446744073709551615 as libc::c_ulong\n    {\n        9223372036854775807 as libc::c_long as libc::c_ulong\n    } else {\n        18446744073709551615 as libc::c_ulong\n    }) >> 30 as libc::c_int)\n        << 30 as libc::c_int) as ssize_t;\n    let mut some_copied: bool = 0 as libc::c_int != 0;\n    loop {\n        match rpl_copy_file_range(\n            input_desc,\n            0 as *mut off_t,\n            1 as libc::c_int,\n            0 as *mut off_t,\n            copy_max as size_t,\n            0 as libc::c_int as libc::c_uint,\n        ) {\n            0 => return some_copied as libc::c_int,\n            -1 => {\n                if *__errno_location() == 38 as libc::c_int\n                    || is_ENOTSUP(*__errno_location()) as libc::c_int != 0\n                    || *__errno_location() == 22 as libc::c_int\n                    || *__errno_location() == 9 as libc::c_int\n                    || *__errno_location() == 18 as libc::c_int\n                    || *__errno_location() == 26 as libc::c_int\n                    || *__errno_location() == 1 as libc::c_int\n                {\n                    return 0 as libc::c_int;\n                }\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {\n                    };\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {\n                        };\n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {\n                        };\n                    });\n                };\n                return -(1 as libc::c_int);\n            }\n            _ => {}\n        }\n        some_copied = 1 as libc::c_int != 0;\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\cat.rs"
    },
    {
      "chunk": "unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut *mut libc::c_char) -> libc::c_int {\n    let mut insize: idx_t = 0;\n    let mut inbuf: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut current_block: u64;\n    let mut have_read_stdin: bool = 0 as libc::c_int != 0;\n    let mut stat_buf: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec {\n            tv_sec: 0,\n            tv_nsec: 0,\n        },\n        st_mtim: timespec {\n            tv_sec: 0,\n            tv_nsec: 0,\n        },\n        st_ctim: timespec {\n            tv_sec: 0,\n            tv_nsec: 0,\n        },\n        __glibc_reserved: [0; 2],\n    };\n    let mut number: bool = 0 as libc::c_int != 0;\n    let mut number_nonblank: bool = 0 as libc::c_int != 0;\n    let mut squeeze_blank: bool = 0 as libc::c_int != 0;\n    let mut show_ends: bool = 0 as libc::c_int != 0;\n    let mut show_nonprinting: bool = 0 as libc::c_int != 0;\n    let mut show_tabs: bool = 0 as libc::c_int != 0;\n    let mut file_open_mode: libc::c_int = 0 as libc::c_int;\n    static mut long_options: [option; 10] = [\n        {\n            let mut init = option {\n                name: b\"number-nonblank\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'b' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"number\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'n' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"squeeze-blank\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 's' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-nonprinting\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'v' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-ends\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'E' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-tabs\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'T' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-all\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'A' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"help\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: GETOPT_HELP_CHAR as libc::c_int,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"version\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: GETOPT_VERSION_CHAR as libc::c_int,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: 0 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 0 as libc::c_int,\n            };\n            init\n        },\n    ];\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    let mut c: libc::c_int = 0;\n    loop {\n        c = getopt_long(\n            argc,\n            argv,\n            b\"benstuvAET\\0\" as *const u8 as *const libc::c_char,\n            long_options.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if !(c != -(1 as libc::c_int)) {\n            break;\n        }\n        match c {\n            98 => {\n                number = 1 as libc::c_int != 0;\n                number_nonblank = 1 as libc::c_int != 0;\n            }\n            101 => {\n                show_ends = 1 as libc::c_int != 0;\n                show_nonprinting = 1 as libc::c_int != 0;\n            }\n            110 => {\n                number = 1 as libc::c_int != 0;\n            }\n            115 => {\n                squeeze_blank = 1 as libc::c_int != 0;\n            }\n            116 => {\n                show_tabs = 1 as libc::c_int != 0;\n                show_nonprinting = 1 as libc::c_int != 0;\n            }\n            117 => {}\n            118 => {\n                show_nonprinting = 1 as libc::c_int != 0;\n            }\n            65 => {\n                show_nonprinting = 1 as libc::c_int != 0;\n                show_ends = 1 as libc::c_int != 0;\n                show_tabs = 1 as libc::c_int != 0;\n            }\n            69 => {\n                show_ends = 1 as libc::c_int != 0;\n            }\n            84 => {\n                show_tabs = 1 as libc::c_int != 0;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n            }\n            -3 => {\n                version_etc(\n                    stdout,\n                    b\"cat\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Torbjorn Granlund\\0\" as *const u8 as *const libc::c_char,\n                        b\"Torbj\\xC3\\xB6rn Granlund\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                        b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);\n            }\n            _ => {\n                usage(1 as libc::c_int);\n            }\n        }\n    }\n    if fstat(1 as libc::c_int, &mut stat_buf) < 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {\n            };\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {\n                };\n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {\n                };\n            });\n        };\n    }\n    let mut outsize: idx_t = io_blksize(&stat_buf);\n    let mut out_dev: dev_t = stat_buf.st_dev;\n    let mut out_ino: ino_t = stat_buf.st_ino;\n    let mut out_flags: libc::c_int = -(2 as libc::c_int);\n    let mut out_isreg: bool = (stat_buf.st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint) as libc::c_int\n        != 0 as libc::c_int;\n    if !(number as libc::c_int != 0\n        || show_ends as libc::c_int != 0\n        || squeeze_blank as libc::c_int != 0)\n    {\n        file_open_mode |= 0 as libc::c_int;\n        xset_binary_mode(1, 0);\n    }\n    infile = b\"-\\0\" as *const u8 as *const libc::c_char;\n    let mut argind: libc::c_int = optind;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut page_size: idx_t = getpagesize() as idx_t;\n    loop {\n        if argind < argc {\n            infile = *argv.offset(argind as isize);\n        }\n        let mut reading_stdin: bool =\n            strcmp(infile, b\"-\\0\" as *const u8 as *const libc::c_char) == 0 as libc::c_int;\n        if reading_stdin {\n            have_read_stdin = 1 as libc::c_int != 0;\n            input_desc = 0 as libc::c_int;\n            if file_open_mode & 0 as libc::c_int != 0 {\n                xset_binary_mode(0, 0);\n            }\n            current_block = 13321564401369230990;\n        } else {\n            input_desc = open(infile, file_open_mode);\n            if input_desc < 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {\n                    };\n                } else {\n                    ({",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\cat.rs"
    },
    {
      "chunk": "                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {\n                        };\n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {\n                        };\n                    });\n                };\n                ok = 0 as libc::c_int != 0;\n                current_block = 4567019141635105728;\n            } else {\n                current_block = 13321564401369230990;\n            }\n        }\n        match current_block {\n            13321564401369230990 => {\n                if fstat(input_desc, &mut stat_buf) < 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            0,\n                            std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                            b\"%s\\0\".as_ptr() as *const i8,\n                            quotearg_n_style_colon(0, shell_escape_quoting_style, infile),\n                        );\n                        if 0 != 0 {\n                            unreachable!();\n                        }\n                    } else {\n                        {\n                            let errstatus: i32 = 0;\n                            error(\n                                errstatus,\n                                std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                                b\"%s\\0\".as_ptr() as *const i8,\n                                quotearg_n_style_colon(0, shell_escape_quoting_style, infile),\n                            );\n                            if errstatus != 0 {\n                                unreachable!();\n                            }\n                        }\n                        {\n                            let errstatus: i32 = 0;\n                            error(\n                                errstatus,\n                                std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                                b\"%s\\0\".as_ptr() as *const i8,\n                                quotearg_n_style_colon(0, shell_escape_quoting_style, infile),\n                            );\n                            if errstatus != 0 {\n                                unreachable!();\n                            }\n                        }\n                    }\n                    ok = false;\n                } else {\n                    insize = io_blksize(&stat_buf);\n                    fdadvise(input_desc, 0, 0, FADVISE_SEQUENTIAL);\n                    if stat_buf.st_dev == out_dev && stat_buf.st_ino == out_ino {\n                        if out_flags < -1 {\n                            out_flags = rpl_fcntl(1, 3);\n                        }\n                        let mut exhausting = out_flags >= 0 && (out_flags & 0o2000) != 0;\n                        if !exhausting {\n                            let in_pos = lseek(input_desc, 0, 1);\n                            if in_pos >= 0 {\n                                exhausting = in_pos < lseek(1, 0, 1);\n                            }\n                        }\n                        if exhausting {\n                            error(\n                                0,\n                                0,\n                                gettext(\n                                    b\"%s: input file is output file\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quotearg_n_style_colon(0, shell_escape_quoting_style, infile),\n                            );\n                            ok = false;\n                            current_block = 7239751344758050955;\n                        } else {\n                            current_block = 5372832139739605200;\n                        }\n                    } else {\n                        current_block = 5372832139739605200;\n                    }\n                    match current_block {\n                        7239751344758050955 => {}\n                        _ => {\n                            let mut inbuf: *mut i8 = std::ptr::null_mut(); // Using a raw pointer initialized to null\n                            if !(number\n                                || show_ends\n                                || show_nonprinting\n                                || show_tabs\n                                || squeeze_blank)\n                            {\n                                let copy_cat_status =\n                                    if out_isreg && (stat_buf.st_mode & 0o170000) == 0o100000 {\n                                        copy_cat()\n                                    } else {\n                                        0\n                                    };\n\n                                if copy_cat_status != 0 {\n                                    inbuf = std::ptr::null_mut();\n                                    ok &= (0 < copy_cat_status);\n                                } else {\n                                    insize = insize.max(outsize);\n                                    let aligned_buf = xalignalloc(page_size, insize) as *mut u8;\n                                    let buf_slice = unsafe {\n                                        std::slice::from_raw_parts_mut(aligned_buf, insize as usize)\n                                    };\n                                    ok &= simple_cat(buf_slice);\n                                }\n                            } else {\n                                inbuf = xalignalloc(\n                                    page_size,\n                                    insize + 1 as libc::c_int as libc::c_long,\n                                ) as *mut libc::c_char;\n                                let mut bufsize: idx_t = 0;\n                                if (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                                    && ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        insize\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    && ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        4 as libc::c_int\n                                    }) - 1 as libc::c_int)\n                                        < 0 as libc::c_int\n                                    && (if (4 as libc::c_int) < 0 as libc::c_int {\n                                        if insize < 0 as libc::c_int as libc::c_long {\n                                            if ((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    -(1 as libc::c_int) as idx_t\n                                                }) + 4 as libc::c_int as libc::c_long\n                                            }) - 1 as libc::c_int as libc::c_long)\n                                                < 0 as libc::c_int as libc::c_long\n                                            {\n                                                (insize\n                                                    < -(1 as libc::c_int) as idx_t\n                                                        / 4 as libc::c_int as libc::c_long)\n                                                    as libc::c_int\n                                            } else {\n                                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    4 as libc::c_int\n                                                }) - 1 as libc::c_int)\n                                                    < 0 as libc::c_int\n                                                {\n                                                    !(((((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) + 1 as libc::c_int)\n                                                        << (::core::mem::size_of::<libc::c_int>()\n                                                            as libc::c_ulong)\n                                                            .wrapping_mul(\n                                                                8 as libc::c_int as libc::c_ulong,\n                                                            )\n                                                            .wrapping_sub(\n                                                                2 as libc::c_int as libc::c_ulong,\n                                                            ))\n                                                        - 1 as libc::c_int)\n                                                        * 2 as libc::c_int\n                                                        + 1 as libc::c_int)\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) + 0 as libc::c_int\n                                                }) < 0 as libc::c_int\n                                                {\n                                                    ((4 as libc::c_int)\n                                                        < -(if ((if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int\n                                                        } else {\n                                                            4 as libc::c_int\n                                                        }) - 1 as libc::c_int)\n                                                            < 0 as libc::c_int\n                                                        {\n                                                            ((((if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) + 1 as libc::c_int)\n                                                                << (::core::mem::size_of::<\n                                                                    libc::c_int,\n                                                                >(\n                                                                )\n                                                                    as libc::c_ulong)\n                                                                    .wrapping_mul(\n                                                                        8 as libc::c_int\n                                                                            as libc::c_ulong,\n                                                                    )\n                                                                    .wrapping_sub(\n                                                                        2 as libc::c_int\n                                                                            as libc::c_ulong,\n                                                                    ))\n                                                                - 1 as libc::c_int)\n                                                                * 2 as libc::c_int\n                                                                + 1 as libc::c_int\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) - 1 as libc::c_int\n                                                        }))\n                                                        as libc::c_int\n                                                } else {\n                                                    ((0 as libc::c_int) < 4 as libc::c_int)\n                                                        as libc::c_int\n                                                }) != 0\n                                                {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    })\n                                                        as libc::c_long\n                                                        + -(1 as libc::c_int) as idx_t\n                                                        >> (::core::mem::size_of::<libc::c_int>()\n                                                            as libc::c_ulong)\n                                                            .wrapping_mul(\n                                                                8 as libc::c_int as libc::c_ulong,\n                                                            )\n                                                            .wrapping_sub(\n                                                                1 as libc::c_int as libc::c_ulong,\n                                                            )\n                                                } else {\n                                                    -(1 as libc::c_int) as idx_t\n                                                        / -(4 as libc::c_int) as libc::c_long\n                                                }) <= -(1 as libc::c_int) as libc::c_long - insize)\n                                                    as libc::c_int\n                                            }\n                                        } else {\n                                            if {\n                                                let condition1 = if 1 != 0 {\n                                                    0\n                                                } else {\n                                                    (if 1 != 0 { 0 } else { 4 }) + 0\n                                                } - 1\n                                                    < 0;\n\n                                                if condition1 {\n                                                    let inner_value = (if 1 != 0 {\n                                                        0\n                                                    } else {\n                                                        (if 1 != 0 { 0 } else { 4 }) + 0\n                                                    } + 1)\n                                                        << (std::mem::size_of::<i64>() * 8 - 2) - 1;\n                                                    !((inner_value * 2) + 1) < 0\n                                                } else {\n                                                    let outer_value = if 1 != 0 {\n                                                        0\n                                                    } else {\n                                                        (if 1 != 0 { 0 } else { 4 }) + 0\n                                                    };\n                                                    outer_value < 0\n                                                }\n                                            } {\n                                                let condition2 = {\n                                                    let inner_value =\n                                                        if 1 != 0 { 0 } else { 4 + 0 };",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\cat.rs"
    },
    {
      "chunk": "                                                    inner_value < 0\n                                                        && (if 1 != 0 {\n                                                            0\n                                                        } else {\n                                                            (if 1 != 0 { 0 } else { 4 }) + 0\n                                                        } - 1\n                                                            < 0)\n                                                };\n\n                                                if condition2 {\n                                                    let inner_value = (if 1 != 0 {\n                                                        0\n                                                    } else {\n                                                        (if 1 != 0 { 0 } else { 4 }) + 0\n                                                    } + 1)\n                                                        << (std::mem::size_of::<i64>() * 8 - 2) - 1;\n                                                    inner_value * 2 + 1\n                                                } else {\n                                                    (if 1 != 0 {\n                                                        0\n                                                    } else {\n                                                        (if 1 != 0 { 0 } else { 4 }) + 0\n                                                    } - 1)\n                                                }\n                                            } else {\n                                                if (0 < (if 1 != 0 { 0 } else { 4 } + 0))\n                                                    && (4 == -1)\n                                                {\n                                                    if (if 1 != 0 { 0 } else { insize } - 1) < 0 {\n                                                        (0 < insize + 0) as i32\n                                                    } else {\n                                                        (0 < insize && (-1 - 0) < insize - 1) as i32\n                                                    }\n                                                } else {\n                                                    (0 / 4 < insize) as i32\n                                                }\n                                            }\n                                        }\n                                    } else {\n                                        if 4 as libc::c_int == 0 as libc::c_int {\n                                            0 as libc::c_int\n                                        } else {\n                                            if insize < 0 as libc::c_int as libc::c_long {\n                                                if (if (if ((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        insize\n                                                    }) + 0 as libc::c_int as idx_t\n                                                }) - 1 as libc::c_int as libc::c_long)\n                                                    < 0 as libc::c_int as libc::c_long\n                                                {\n                                                    !(((((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            insize\n                                                        }) + 0 as libc::c_int as idx_t\n                                                    }) + 1 as libc::c_int as libc::c_long)\n                                                        << (::core::mem::size_of::<libc::c_long>()\n                                                            as libc::c_ulong)\n                                                            .wrapping_mul(\n                                                                8 as libc::c_int as libc::c_ulong,\n                                                            )\n                                                            .wrapping_sub(\n                                                                2 as libc::c_int as libc::c_ulong,\n                                                            ))\n                                                        - 1 as libc::c_int as libc::c_long)\n                                                        * 2 as libc::c_int as libc::c_long\n                                                        + 1 as libc::c_int as libc::c_long)\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            insize\n                                                        }) + 0 as libc::c_int as idx_t\n                                                    }) + 0 as libc::c_int as libc::c_long\n                                                }) < 0 as libc::c_int as libc::c_long\n                                                {\n                                                    (((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        insize\n                                                    }) + 0 as libc::c_int as idx_t)\n                                                        < -(if ((if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int as libc::c_long\n                                                            } else {\n                                                                insize\n                                                            }) + 0 as libc::c_int as idx_t\n                                                        }) - 1 as libc::c_int\n                                                            as libc::c_long)\n                                                            < 0 as libc::c_int as libc::c_long\n                                                        {\n                                                            ((((if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int as libc::c_long\n                                                            } else {\n                                                                (if 1 as libc::c_int != 0 {\n                                                                    0 as libc::c_int as libc::c_long\n                                                                } else {\n                                                                    insize\n                                                                }) + 0 as libc::c_int as idx_t\n                                                            }) + 1 as libc::c_int\n                                                                as libc::c_long)\n                                                                << (::core::mem::size_of::<\n                                                                    libc::c_long,\n                                                                >(\n                                                                )\n                                                                    as libc::c_ulong)\n                                                                    .wrapping_mul(\n                                                                        8 as libc::c_int\n                                                                            as libc::c_ulong,\n                                                                    )\n                                                                    .wrapping_sub(\n                                                                        2 as libc::c_int\n                                                                            as libc::c_ulong,\n                                                                    ))\n                                                                - 1 as libc::c_int as libc::c_long)\n                                                                * 2 as libc::c_int as libc::c_long\n                                                                + 1 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int as libc::c_long\n                                                            } else {\n                                                                (if 1 as libc::c_int != 0 {\n                                                                    0 as libc::c_int as libc::c_long\n                                                                } else {\n                                                                    insize\n                                                                }) + 0 as libc::c_int as idx_t\n                                                            }) - 1 as libc::c_int as libc::c_long\n                                                        }))\n                                                        as libc::c_int\n                                                } else {\n                                                    ((0 as libc::c_int as libc::c_long)\n                                                        < (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            insize\n                                                        }) + 0 as libc::c_int as idx_t)\n                                                        as libc::c_int\n                                                }) != 0\n                                                    && insize == -(1 as libc::c_int) as libc::c_long\n                                                {\n                                                    if ((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) - 1 as libc::c_int)\n                                                        < 0 as libc::c_int\n                                                    {\n                                                        ((0 as libc::c_int as libc::c_long)\n                                                            < 4 as libc::c_int as libc::c_long\n                                                                + 0 as libc::c_int as idx_t)\n                                                            as libc::c_int\n                                                    } else {\n                                                        ((-(1 as libc::c_int) as libc::c_long\n                                                            - 0 as libc::c_int as idx_t)\n                                                            < (4 as libc::c_int - 1 as libc::c_int)\n                                                                as libc::c_long)\n                                                            as libc::c_int\n                                                    }\n                                                } else {\n                                                    (0 as libc::c_int as idx_t / insize\n                                                        < 4 as libc::c_int as libc::c_long)\n                                                        as libc::c_int\n                                                }\n                                            } else {\n                                                ((-(1 as libc::c_int) as idx_t\n                                                    / 4 as libc::c_int as libc::c_long)\n                                                    < insize)\n                                                    as libc::c_int\n                                            }\n                                        }\n                                    }) != 0\n                                {\n                                    let (fresh33, _fresh34) =\n                                        insize.overflowing_mul((4 as libc::c_int).into());\n                                    *(&mut bufsize as *mut idx_t) = fresh33;\n                                    1 as libc::c_int\n                                } else {\n                                    let (fresh35, fresh36) =\n                                        insize.overflowing_mul((4 as libc::c_int).into());\n                                    *(&mut bufsize as *mut idx_t) = fresh35;\n                                    fresh36 as libc::c_int\n                                }) != 0\n                                    || {\n                                        let (fresh37, fresh38) = bufsize.overflowing_add(outsize);\n                                        *(&mut bufsize as *mut idx_t) = fresh37;\n                                        fresh38 as libc::c_int != 0\n                                    }\n                                    || {\n                                        let (fresh39, fresh40) = bufsize.overflowing_add(\n                                            (20 as libc::c_int - 1 as libc::c_int).into(),\n                                        );\n                                        *(&mut bufsize as *mut idx_t) = fresh39;\n                                        fresh40 as libc::c_int != 0\n                                    }\n                                {\n                                    xalloc_die();\n                                }\n                                let mut outbuf: *mut libc::c_char =\n                                    xalignalloc(page_size, bufsize) as *mut libc::c_char;\n                                ok = (ok as libc::c_int\n                                    & cat(\n                                        inbuf,\n                                        insize,\n                                        outbuf,\n                                        outsize,\n                                        show_nonprinting,\n                                        show_tabs,\n                                        number,\n                                        number_nonblank,\n                                        show_ends,\n                                        squeeze_blank,\n                                    ) as libc::c_int)\n                                    != 0;\n                                alignfree(outbuf as *mut libc::c_void);\n                            }\n                            alignfree(inbuf as *mut libc::c_void); // Assuming alignfree can accept a pointer from Vec\n                        }\n                    }\n                }\n                if !reading_stdin && close(input_desc) < 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {\n                        };\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {\n                            };\n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {\n                            };\n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                }\n            }\n            _ => {}\n        }\n        argind += 1;\n        if !(argind < argc) {\n            break;\n        }\n    }\n    if pending_cr {\n        if full_write(\n            1 as libc::c_int,\n            b\"\\r\\0\" as *const u8 as *const libc::c_char as *const libc::c_void,\n            1 as libc::c_int as size_t,\n        ) != 1 as libc::c_int as libc::c_ulong\n        {",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\cat.rs"
    },
    {
      "chunk": "            write_error();\n        }\n    }\n    if have_read_stdin && close(0) < 0 {\n        if true {\n            error(\n                1,\n                *__errno_location(),\n                gettext(b\"closing standard input\\0\" as *const u8 as *const libc::c_char),\n            );\n            unreachable!();\n        } else {\n            let errstatus = 1;\n            error(\n                errstatus,\n                *__errno_location(),\n                gettext(b\"closing standard input\\0\" as *const u8 as *const libc::c_char),\n            );\n            if errstatus != 0 {\n                unreachable!();\n            }\n\n            let errstatus = 1;\n            error(\n                errstatus,\n                *__errno_location(),\n                gettext(b\"closing standard input\\0\" as *const u8 as *const libc::c_char),\n            );\n            if errstatus != 0 {\n                unreachable!();\n            }\n        }\n    }\n    return if ok { 0 } else { 1 };\n}\npub fn main() {\n    let mut args: Vec<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(main_0(\n            (args.len() - 1) as libc::c_int,\n            args.as_mut_ptr() as *mut *mut libc::c_char,\n        ) as i32)\n    }\n}\nunsafe extern \"C\" fn run_static_initializers() {\n    let line_buf_slice = &mut line_buf[..];\n    line_num_print = line_buf_slice.as_mut_ptr().offset(12); // 20 - 8\n    line_num_start = line_buf_slice.as_mut_ptr().offset(17); // 20 - 3\n    line_num_end = line_buf_slice.as_mut_ptr().offset(17); // 20 - 3\n}\n#[used]\n#[cfg_attr(target_os = \"linux\", link_section = \".init_array\")]\n#[cfg_attr(target_os = \"windows\", link_section = \".CRT$XIB\")]\n#[cfg_attr(target_os = \"macos\", link_section = \"__DATA,__mod_init_func\")]\nstatic INIT_ARRAY: [unsafe extern \"C\" fn(); 1] = [run_static_initializers];",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\cat.rs"
    },
    {
      "chunk": "use std::ffi::CString;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub fn close_stdout_set_file_name(file: &str) {\n    let c_string = std::ffi::CString::new(file).unwrap();\n    unsafe {\n        file_name = c_string.as_ptr();\n        std::mem::forget(c_string); // Prevent CString from being dropped\n    }\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\npub fn close_stdout_set_ignore_EPIPE(ignore: bool) {\n    unsafe {\n        ignore_EPIPE = ignore;\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\closeout.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn close_stream(stream: *mut _IO_FILE) -> libc::c_int {\n    let some_pending: bool = unsafe { __fpending(stream) != 0 };\n    let prev_fail: bool = unsafe { ferror_unlocked(stream) != 0 };\n    let fclose_fail: bool = unsafe { rpl_fclose(stream) != 0 };\n\n    if prev_fail\n        || (fclose_fail && (some_pending || unsafe { *__errno_location() != 9 }))\n    {\n        if !fclose_fail {\n            unsafe { *__errno_location() = 0 };\n        }\n        return -1;\n    }\n    return 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\close_stream.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn copy_file_range(\n        __infd: libc::c_int,\n        __pinoff: *mut __off64_t,\n        __outfd: libc::c_int,\n        __poutoff: *mut __off64_t,\n        __length: size_t,\n        __flags: libc::c_uint,\n    ) -> ssize_t;\n    fn __errno_location() -> *mut libc::c_int;\n    fn uname(__name: *mut utsname) -> libc::c_int;\n}\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __ssize_t = libc::c_long;\npub type ssize_t = __ssize_t;\npub type size_t = libc::c_ulong;\npub type off_t = __off_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct utsname {\n    pub sysname: [libc::c_char; 65],\n    pub nodename: [libc::c_char; 65],\n    pub release: [libc::c_char; 65],\n    pub version: [libc::c_char; 65],\n    pub machine: [libc::c_char; 65],\n    pub domainname: [libc::c_char; 65],\n}\n#[no_mangle]\npub fn rpl_copy_file_range(\n    infd: libc::c_int,\n    pinoff: &mut off_t,\n    outfd: libc::c_int,\n    poutoff: &mut off_t,\n    length: size_t,\n    flags: libc::c_uint,\n) -> ssize_t {\n    thread_local! {\n        static OK: std::cell::RefCell<Option<libc::c_schar>> = std::cell::RefCell::new(None);\n    }\n\n    let ok = OK.with(|ok_ref| {\n        let mut ok_value = ok_ref.borrow_mut();\n        if ok_value.is_none() {\n            let mut name: utsname = utsname {\n                sysname: [0; 65],\n                nodename: [0; 65],\n                release: [0; 65],\n                version: [0; 65],\n                machine: [0; 65],\n                domainname: [0; 65],\n            };\n            unsafe { uname(&mut name) };\n            let release = unsafe { std::ffi::CStr::from_ptr(name.release.as_ptr()) };\n            let release_str = release.to_str().unwrap_or(\"\");\n\n            let result = if release_str.len() > 1 && release_str.chars().nth(1) != Some('.')\n                || release_str.chars().nth(0).unwrap_or('0') > '5'\n                || (release_str.chars().nth(0) == Some('5') && (release_str.chars().nth(3) != Some('.') || release_str.chars().nth(2).unwrap_or('0') < '2'))\n            {\n                1\n            } else {\n                -1\n            };\n            *ok_value = Some(result as libc::c_schar);\n            result\n        } else {\n            ok_value.unwrap() as libc::c_int\n        }\n    });\n\n    if ok > 0 {\n        return unsafe { copy_file_range(infd, pinoff, outfd, poutoff, length, flags) };\n    }\n    unsafe { *__errno_location() = 38 };\n    return -1;\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\copy_file_range.rs"
    },
    {
      "chunk": "use std::convert::TryInto;\nuse std::ops::RangeInclusive;\nuse ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalnum(c: i32) -> bool {\n    (48..=57).contains(&c) || (65..=90).contains(&c) || (97..=122).contains(&c)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalpha(c: i32) -> bool {\n    (b'a'..=b'z').contains(&(c as u8)) || (b'A'..=b'Z').contains(&(c as u8))\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isascii(c: i32) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isblank(c: i32) -> bool {\n    c == ' ' as i32 || c == '\\t' as i32\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_iscntrl(c: i32) -> bool {\n    matches!(c, 0..=31 | 127)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isdigit(c: i32) -> bool {\n    matches!(c, 48..=57)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isgraph(c: i32) -> bool {\n    match c {\n        48..=57 | 97..=122 | 33..=47 | 58..=64 | 91..=96 | 123..=126 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_islower(c: i32) -> bool {\n    (97..=122).contains(&c)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isprint(c: i32) -> bool {\n    match c {\n        32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 \n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 \n        | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 \n        | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 91 | 92 | 93 | 94 | 95 \n        | 96 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 \n        | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 \n        | 123 | 124 | 125 | 126 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_ispunct(c: i32) -> bool {\n    matches!(c, 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n              | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n              | 126)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isspace(c: i32) -> bool {\n    matches!(c, 32 | 9 | 10 | 11 | 12 | 13)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isupper(c: i32) -> bool {\n    matches!(c, 65..=90)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isxdigit(c: i32) -> bool {\n    matches!(c, 48..=57 | 97..=102 | 65..=70)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_tolower(c: i32) -> i32 {\n    match c {\n        65..=90 => c + ('a' as i32 - 'A' as i32),\n        _ => c,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_toupper(c: i32) -> i32 {\n    if (b'a'..=b'z').contains(&(c as u8)) {\n        return c - b'a' as i32 + b'A' as i32;\n    }\n    c\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\c_ctype.rs"
    },
    {
      "chunk": "use std::char;\nuse ::libc;\n#[inline]\nfn c_tolower(c: i32) -> i32 {\n    match c {\n        65..=90 => c - 'A' as i32 + 'a' as i32,\n        _ => c,\n    }\n}\n#[no_mangle]\npub fn c_strcasecmp(s1: &str, s2: &str) -> libc::c_int {\n    let c1: Vec<_> = s1.chars().map(|c| c_tolower(c as i32) as u8 as char).collect();\n    let c2: Vec<_> = s2.chars().map(|c| c_tolower(c as i32) as u8 as char).collect();\n    \n    let len = c1.len().min(c2.len());\n    \n    for i in 0..len {\n        if c1[i] != c2[i] {\n            return c1[i] as libc::c_int - c2[i] as libc::c_int;\n        }\n    }\n    \n    c1.len() as libc::c_int - c2.len() as libc::c_int\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\c_strcasecmp.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\exitfail.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn posix_fadvise(\n        __fd: libc::c_int,\n        __offset: off_t,\n        __len: off_t,\n        __advise: libc::c_int,\n    ) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type fadvice_t = libc::c_uint;\npub const FADVISE_RANDOM: fadvice_t = 1;\npub const FADVISE_WILLNEED: fadvice_t = 3;\npub const FADVISE_DONTNEED: fadvice_t = 4;\npub const FADVISE_NOREUSE: fadvice_t = 5;\npub const FADVISE_SEQUENTIAL: fadvice_t = 2;\npub const FADVISE_NORMAL: fadvice_t = 0;\n#[no_mangle]\npub fn fdadvise(\n    fd: i32,\n    offset: i64,\n    len: i64,\n    advice: fadvice_t,\n) {\n    unsafe {\n        posix_fadvise(fd, offset, len, advice as i32);\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn fadvise(mut fp: *mut FILE, mut advice: fadvice_t) {\n    if !fp.is_null() {\n        let fd = fileno(fp);\nlet offset = 0i64;\nlet len = 0i64;\nfdadvise(fd, offset, len, advice);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\fadvise.rs"
    },
    {
      "chunk": "use std::os::raw::c_int;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn rpl_fclose(fp: &mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0;\n    let fd = unsafe { fileno(fp) };\n    \n    if fd < 0 {\n        return unsafe { fclose(fp) };\n    }\n    \n    if (!unsafe { __freading(fp) != 0 } || unsafe { lseek(fd, 0, 1) != -1 }) && unsafe { rpl_fflush(fp) != 0 } {\n        saved_errno = unsafe { *__errno_location() };\n    }\n    \n    let result = unsafe { fclose(fp) };\n    \n    if saved_errno != 0 {\n        unsafe { *__errno_location() = saved_errno };\n        return -1;\n    }\n    \n    result\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\fclose.rs"
    },
    {
      "chunk": "use std::ffi::VaList;\nuse ::libc;\nextern \"C\" {\n    fn fcntl(__fd: libc::c_int, __cmd: libc::c_int, _: ...) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\n#[no_mangle]\npub fn rpl_fcntl(\n    fd: libc::c_int,\n    action: libc::c_int,\n    args: &mut std::ffi::VaList,\n) -> libc::c_int {\n    let mut result: libc::c_int = -1;\n\n    match action {\n        0 => {\n            let target: libc::c_int = unsafe { args.arg::<libc::c_int>() };\n            result = unsafe { rpl_fcntl_DUPFD(fd, target) };\n        }\n        1030 => {\n            let target: libc::c_int = unsafe { args.arg::<libc::c_int>() };\n            result = unsafe { rpl_fcntl_DUPFD_CLOEXEC(fd, target) };\n        }\n        _ => {\n            match action {\n                1 | 3 => {\n                    result = unsafe { fcntl(fd, action) };\n                }\n                1025 => {\n                    let p: *mut libc::c_void = unsafe { args.arg::<*mut libc::c_void>() };\n                    result = unsafe { fcntl(fd, action, p) };\n                }\n                9 => {\n                    result = unsafe { fcntl(fd, action) };\n                }\n                1032 => {\n                    result = unsafe { fcntl(fd, action) };\n                }\n                1034 => {\n                    result = unsafe { fcntl(fd, action) };\n                }\n                11 => {\n                    result = unsafe { fcntl(fd, action) };\n                }\n                1033 => {\n                    result = unsafe { fcntl(fd, action) };\n                }\n                2 => {\n                    let x: libc::c_int = unsafe { args.arg::<libc::c_int>() };\n                    result = unsafe { fcntl(fd, action, x) };\n                }\n                4 => {\n                    let x: libc::c_int = unsafe { args.arg::<libc::c_int>() };\n                    result = unsafe { fcntl(fd, action, x) };\n                }\n                8 | 1031 => {\n                    result = unsafe { fcntl(fd, action) };\n                }\n                1024 | 10 => {\n                    let x: libc::c_int = unsafe { args.arg::<libc::c_int>() };\n                    result = unsafe { fcntl(fd, action, x) };\n                }\n                _ => {\n                    let p: *mut libc::c_void = unsafe { args.arg::<*mut libc::c_void>() };\n                    result = unsafe { fcntl(fd, action, p) };\n                }\n            }\n        }\n    }\n    result\n}\nfn rpl_fcntl_DUPFD(fd: i32, target: i32) -> i32 {\n    unsafe {\n        fcntl(fd, 0, target)\n    }\n}\nstatic mut have_dupfd_cloexec: libc::c_int = 0;\nunsafe extern \"C\" fn rpl_fcntl_DUPFD_CLOEXEC(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    if 0 as libc::c_int <= have_dupfd_cloexec {\n        result = fcntl(fd, 1030 as libc::c_int, target);\n        if 0 as libc::c_int <= result || *__errno_location() != 22 as libc::c_int {\n            have_dupfd_cloexec = 1 as libc::c_int;\n        } else {\n            let result = rpl_fcntl_DUPFD(fd, target);\n            if result >= 0 as libc::c_int {\n                have_dupfd_cloexec = -(1 as libc::c_int);\n            }\n        }\n    } else {\n        let result = rpl_fcntl_DUPFD(fd, target);\n    }\n    if 0 as libc::c_int <= result && have_dupfd_cloexec == -(1 as libc::c_int) {\n        let mut flags: libc::c_int = fcntl(result, 1 as libc::c_int);\n        if flags < 0 as libc::c_int\n            || fcntl(result, 2 as libc::c_int, flags | 1 as libc::c_int)\n                == -(1 as libc::c_int)\n        {\n            let mut saved_errno: libc::c_int = *__errno_location();\n            close(result);\n            *__errno_location() = saved_errno;\n            result = -(1 as libc::c_int);\n        }\n    }\n    return result;\n}\nunsafe extern \"C\" fn run_static_initializers() {\n    have_dupfd_cloexec = if 0 != 0 {\n        -(1)\n    } else {\n        0\n    };\n}\n#[used]\n#[cfg_attr(target_os = \"linux\", link_section = \".init_array\")]\n#[cfg_attr(target_os = \"windows\", link_section = \".CRT$XIB\")]\n#[cfg_attr(target_os = \"macos\", link_section = \"__DATA,__mod_init_func\")]\nstatic INIT_ARRAY: [unsafe extern \"C\" fn(); 1] = [run_static_initializers];",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\fcntl.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nfn clear_ungetc_buffer_preserving_position(fp: &mut *mut FILE) {\n    unsafe {\n        if (**fp)._flags & 0x100 != 0 {\n            rpl_fseeko(*fp, 0, 1); // 1 corresponds to SEEK_CUR\n        }\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(&mut stream);\n    return fflush(stream);\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\fflush.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __fpurge(__fp: *mut FILE);\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn fpurge(fp: *mut _IO_FILE) -> libc::c_int {\n    unsafe {\n        __fpurge(fp);\n    }\n    0\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\fpurge.rs"
    },
    {
      "chunk": "use std::os::raw::c_int;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub fn rpl_fseeko(\n    fp: &mut FILE,\n    offset: off_t,\n    whence: libc::c_int,\n) -> libc::c_int {\n    if fp._IO_read_end == fp._IO_read_ptr\n        && fp._IO_write_ptr == fp._IO_write_base && fp._IO_save_base.is_null()\n    {\n        let pos: off_t;\n        unsafe {\n            pos = lseek(fileno(fp), offset, whence);\n        }\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        fp._flags &= !(0x10 as libc::c_int);\n        fp._offset = pos;\n        return 0 as libc::c_int;\n    }\n    unsafe {\n        return fseeko(fp, offset, whence);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\fseeko.rs"
    },
    {
      "chunk": "use std::convert::TryInto;\nuse ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn safe_write(fd: libc::c_int, buf: *const libc::c_void, count: size_t) -> size_t;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn full_write(\n    fd: libc::c_int,\n    buf: &[u8],\n) -> usize {\n    let mut total: usize = 0;\n    let mut count = buf.len();\n    let mut ptr = buf.as_ptr();\n\n    while count > 0 {\n        let n_rw: u64;\n        unsafe {\n            n_rw = safe_write(fd, ptr as *const libc::c_void, count.try_into().unwrap());\n        }\n        if n_rw == !(0 as libc::c_int) as u64 {\n            break;\n        }\n        if n_rw == 0 {\n            unsafe { *__errno_location() = 28 as libc::c_int };\n            break;\n        } else {\n            total += n_rw as usize;\n            ptr = unsafe { ptr.add(n_rw as usize) };\n            count -= n_rw as usize;\n        }\n    }\n    total\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\full_write.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn hard_locale(category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    unsafe {\n        if setlocale_null_r(\n            category,\n            locale.as_mut_ptr(),\n            ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n        ) != 0\n        {\n            return false;\n        }\n    }\n    let locale_str = unsafe { CStr::from_ptr(locale.as_ptr()).to_string_lossy() };\n    if locale_str == \"C\" || locale_str == \"POSIX\" {\n        return false;\n    }\n    return true;\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\hard_locale.rs"
    },
    {
      "chunk": "use std::alloc::{self, Layout};\nuse std::option::Option;\nuse std::vec::Vec;\nuse ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn ireallocarray(\n    p: Option<Vec<u8>>,\n    n: idx_t,\n    s: idx_t,\n) -> Option<Vec<u8>> {\n    if n as usize <= usize::MAX && s as usize <= usize::MAX {\n        let mut nx: usize = n as usize;\n        let mut sx: usize = s as usize;\n        if n == 0 || s == 0 {\n            sx = 1;\n            nx = sx;\n        }\n        let mut vec = p.unwrap_or_else(|| Vec::with_capacity(nx * sx));\n        vec.resize(nx * sx, 0);\n        return Some(vec);\n    } else {\n        return None; // Assuming _gl_alloc_nomem() returns None or similar\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn icalloc(n: usize, s: usize) -> Option<Vec<u8>> {\n    if n > usize::MAX {\n        if s != 0 {\n            return None; // Equivalent to _gl_alloc_nomem()\n        }\n        return Some(Vec::new()); // Return an empty vector\n    }\n    if s > usize::MAX {\n        if n != 0 {\n            return None; // Equivalent to _gl_alloc_nomem()\n        }\n        return Some(Vec::new()); // Return an empty vector\n    }\n    let total_size = n.checked_mul(s)?;\n    Some(vec![0u8; total_size]) // Allocate and initialize the vector with zeros\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn irealloc(p: Option<&mut Vec<u8>>, s: usize) -> Option<Vec<u8>> {\n    if s <= usize::MAX {\n        let mut vec = p.map_or_else(Vec::new, |v| v.clone());\n        vec.resize(s, 0);\n        Some(vec)\n    } else {\n        None // Assuming _gl_alloc_nomem() returns None in the idiomatic Rust version\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn imalloc(s: idx_t) -> Option<Vec<u8>> {\n    if s as usize <= usize::MAX {\n        let vec = Vec::with_capacity(s as usize);\n        Some(vec)\n    } else {\n        None\n    }\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub fn _gl_alloc_nomem() -> *mut libc::c_void {\n    // Simulating allocation failure by setting errno and returning a null pointer\n    unsafe {\n        *__errno_location() = 12; // Set errno to ENOMEM\n    }\n    std::ptr::null_mut() // Return a null pointer\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\ialloc.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;\npub const _NL_WAM_STR: C2RustUnnamed = 131162;",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "pub const _NL_WMON_12: C2RustUnnamed = 131161;\npub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub fn locale_charset() -> String {\n    let codeset_ptr: *const libc::c_char = unsafe { nl_langinfo(CODESET as libc::c_int) };\n    let codeset = unsafe { CStr::from_ptr(codeset_ptr) };\n    \n    if codeset.to_bytes().is_empty() {\n        return \"ASCII\".to_string();\n    }\n    \n    codeset.to_string_lossy().into_owned()\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\mbrtoc32.rs"
    },
    {
      "chunk": "use std::mem;\nuse ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn mbszero(ps: &mut mbstate_t) {\n    *ps = mbstate_t {\n        __count: 0,\n        __value: unsafe { std::mem::zeroed() }, // Use zeroed to initialize __value\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\mbszero.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse std::process;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub fn set_program_name(argv0: *const libc::c_char) {\n    if argv0.is_null() {\n        eprintln!(\"A NULL argv[0] was passed through an exec system call.\");\n        std::process::abort();\n    }\n\n    let c_str = unsafe { std::ffi::CStr::from_ptr(argv0) };\n    let argv0_str = c_str.to_string_lossy();\n    \n    let slash = argv0_str.rfind('/').map(|index| &argv0_str[index + 1..]).unwrap_or(&argv0_str);\n    \n    if slash.len() >= 7 && slash.ends_with(\"/.libs/\") {\n        let base = &slash[7..];\n        if base.starts_with(\"lt-\") {\n            unsafe {\n                program_invocation_short_name = base[3..].as_ptr() as *mut libc::c_char;\n            }\n        }\n        unsafe {\n            program_name = base.as_ptr() as *const libc::c_char;\n            program_invocation_name = base.as_ptr() as *mut libc::c_char;\n        }\n    } else {\n        unsafe {\n            program_name = argv0;\n            program_invocation_name = argv0 as *mut libc::c_char;\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\progname.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\propername_lite.rs"
    },
    {
      "chunk": "use std::vec::Vec;\nuse std::boxed::Box;\nuse std::clone::Clone;\nuse std::option::Option;\nuse std::char;\nuse std::os::raw::c_char;\nuse std::ffi::CStr;\nuse std::convert::TryInto;\nuse std::ffi::CString;\nuse ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nfn c32isprint(wc: u32) -> i32 {\n    char::from_u32(wc).map_or(0, |c| c.is_ascii() as i32)\n}\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub fn clone_quoting_options(o: Option<&quoting_options>) -> Option<Box<quoting_options>> {\n    let options = o.unwrap_or_else(|| unsafe { &default_quoting_options });\n    let cloned_options = options.clone();\n    Some(Box::new(cloned_options))\n}\n#[no_mangle]\npub fn get_quoting_style(o: Option<&quoting_options>) -> quoting_style {\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &default_quoting_options },\n    };\n    options.style\n}\n#[no_mangle]\npub fn set_quoting_style(\n    o: Option<&mut quoting_options>,\n    s: quoting_style,\n) {\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &mut default_quoting_options },\n    };\n    options.style = s;\n}\n#[no_mangle]\npub fn set_char_quoting(\n    o: Option<&mut quoting_options>,\n    c: char,\n    i: i32,\n) -> i32 {\n    let uc: u8 = c as u8;\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &mut default_quoting_options },\n    };\n    let index = (uc as usize) / (std::mem::size_of::<u32>() * 8);\n    let shift = (uc as usize) % (std::mem::size_of::<u32>() * 8);\n    \n    let p = &mut options.quote_these_too[index];\n    let r = (*p >> shift) & 1;\n    *p ^= ((i & 1 ^ r as i32) << shift) as u32;\n    \n    r as i32\n}\n#[no_mangle]\npub fn set_quoting_flags(\n    mut o: Option<&mut quoting_options>,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    let options: &mut quoting_options;\n\n    if let Some(opts) = o {\n        options = opts;\n    } else {\n        options = unsafe { &mut default_quoting_options };\n    }\n\n    r = options.flags;\n    options.flags = i;\n    return r;\n}\n#[no_mangle]\npub fn set_custom_quoting(\n    o: *mut quoting_options,\n    left_quote: *const libc::c_char,\n    right_quote: *const libc::c_char,\n) {\n    let o = if o.is_null() {\n        unsafe { &mut default_quoting_options }\n    } else {\n        unsafe { &mut *o }\n    };\n    \n    o.style = custom_quoting_style;\n\n    if left_quote.is_null() || right_quote.is_null() {\n        panic!(\"Quotes cannot be null\");\n    }\n\n    o.left_quote = left_quote;\n    o.right_quote = right_quote;\n}\nfn quoting_options_from_style(style: quoting_style) -> quoting_options {\n    let mut o = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: std::ptr::null(),\n        right_quote: std::ptr::null(),\n    };\n\n    if style == custom_quoting_style {\n        panic!(\"Custom quoting style is not allowed\");\n    }\n\n    o.style = style;\n    o\n}\nfn gettext_quote(msgid: &str, s: quoting_style) -> String {\n    let translation = unsafe { std::ffi::CStr::from_ptr(gettext(msgid.as_ptr() as *const libc::c_char)) }\n        .to_string_lossy()\n        .into_owned();\n    let locale_code = unsafe { std::ffi::CStr::from_ptr(locale_charset()) }\n        .to_string_lossy()\n        .into_owned();\n    \n    if translation != msgid {\n        return translation;\n    }\n    \n    if unsafe { c_strcasecmp(locale_code.as_ptr() as *const libc::c_char, b\"UTF-8\\0\".as_ptr() as *const libc::c_char) } == 0 {\n        return if msgid.chars().next() == Some('`') {\n            \"\\u{2018}\".to_string() // Left single quotation mark\n        } else {\n            \"\\u{2019}\".to_string() // Right single quotation mark\n        };\n    }\n    \n    if unsafe { c_strcasecmp(locale_code.as_ptr() as *const libc::c_char, b\"GB18030\\0\".as_ptr() as *const libc::c_char) } == 0 {\n        return if msgid.chars().next() == Some('`') {\n            \"\\u{A1}07e\".to_string() // GB18030 left quote\n        } else {\n            \"\\u{A1}AF\".to_string() // GB18030 right quote\n        };\n    }\n    \n    if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        return \"\\\"\".to_string();\n    } else {\n        return \"'\".to_string();\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    let left_quote = gettext_quote(\"`\", quoting_style);\n                    let right_quote = gettext_quote(\"'\", quoting_style);\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: u8 = 0;\nlet mut esc: u8 = 0;\nlet mut is_right_quote: bool = false;\nlet mut escaping: bool = false;\nlet mut c_and_shell_quote_compat: bool = false;\n\nlet arg_slice = unsafe { std::slice::from_raw_parts(arg as *const u8, argsize as usize) };\n\nif backslash_escapes\n    && quoting_style != shell_always_quoting_style\n    && quote_string_len != 0\n    && i + quote_string_len <= if argsize == u64::MAX && 1 < quote_string_len {\n        argsize = unsafe { libc::strlen(arg) } as u64; // Assuming arg is a C string\n        argsize\n    } else {\n        argsize\n    }\n    && &arg_slice[i as usize..(i + quote_string_len) as usize] == unsafe { std::slice::from_raw_parts(quote_string as *const u8, quote_string_len as usize) }\n{\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    is_right_quote = true;\n}\n\nc = arg_slice[i as usize];\n\nmatch c {\n    0 => {\n         if backslash_escapes {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    escaping = true;\n    if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n        if len < buffersize {\n            unsafe {\n                *buffer.offset(len as isize) = b'\\'' as i8;\n            }\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe {\n                *buffer.offset(len as isize) = b'$' as i8;\n            }\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe {\n                *buffer.offset(len as isize) = b'\\'' as i8;\n            }\n        }\n        len += 1;\n        pending_shell_escape_end = true;\n    }\n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = b'\\\\' as i8;\n        }\n    }\n    len += 1;\n    if quoting_style != shell_always_quoting_style\n        && i + 1 < argsize\n        && ('0' as i8 <= unsafe { *arg.offset((i + 1) as isize) } && unsafe { *arg.offset((i + 1) as isize) } <= '9' as i8)\n    {\n        if len < buffersize {\n            unsafe {\n                *buffer.offset(len as isize) = b'0' as i8;\n            }\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe {\n                *buffer.offset(len as isize) = b'0' as i8;\n            }\n        }\n        len += 1;\n    }\n    c = b'0';\n    current_block = 253337042034819032;\n} else if flags & QA_ELIDE_NULL_BYTES as i32 != 0 {\n    current_block = 13619784596304402172;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n    63 => {\n         match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n\n    }\n    7 => {\n        esc = 'a' as u8;\n        current_block = 1190876092451756080;\n    }\n    8 => {\n        esc = 'b' as u8;\n        current_block = 1190876092451756080;\n    }\n    12 => {\n        esc = 'f' as u8;\n        current_block = 1190876092451756080;\n    }\n    10 => {\n        esc = 'n' as u8;\n        current_block = 9215498979640025612;\n    }\n    13 => {\n        esc = 'r' as u8;\n        current_block = 9215498979640025612;\n    }\n    9 => {\n        esc = 't' as u8;\n        current_block = 9215498979640025612;\n    }\n    11 => {\n        esc = 'v' as u8;\n        current_block = 1190876092451756080;\n    }\n    92 => {\n         esc = c;\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    current_block = 4476262310586904498;\n} else if backslash_escapes && elide_outer_quotes && quote_string_len != 0 {\n    current_block = 4476262310586904498;\n} else {\n    current_block = 9215498979640025612;\n}\n\n\n    }\n    123 | 125 => {\n         if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n\n    }\n    35 | 126 => {\n        current_block = 16442922512115311366;\n    }\n    32 => {\n        current_block = 4634307283396172174;\n    }\n    33 => {\n        current_block = 7549413860336125482;\n    }\n    34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n        current_block = 13059411171234995867;\n    }\n    62 | 91 | 94 => {\n        current_block = 16620298045565028098;\n    }\n    96 | 124 => {\n        current_block = 15155215915847730705;\n    }\n    39 => {\n         encountered_single_quote = true;\nc_and_shell_quote_compat = true;\n\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    if buffersize != 0 && orig_buffersize == 0 {\n        orig_buffersize = buffersize;\n        buffersize = 0;\n    }\n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\'' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    \n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\\\' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    \n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\'' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    \n    pending_shell_escape_end = false;\n    current_block = 253337042034819032;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n    37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n    | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n    | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n    | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n    | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n    | 120 | 121 | 122 => {\n        c_and_shell_quote_compat = true;\n        current_block = 253337042034819032;\n    }\n    _ => {\n         let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n\n         if m > 1 || (backslash_escapes && !printable) {\n    let ilim = i.wrapping_add(m);\n    let buffer_slice = unsafe { std::slice::from_raw_parts_mut(buffer, buffersize as usize) };\n    loop {\n        if backslash_escapes && !printable {\n            if elide_outer_quotes {\n                current_block = 7928555609993211441;\n                break 's_25;\n            }\n            escaping = true;\n            if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n                if len < buffersize {\n                    buffer_slice[len as usize] = '\\'' as i8;\n                }\n                len = len.wrapping_add(1);\n                if len < buffersize {\n                    buffer_slice[len as usize] = '$' as i8;\n                }\n                len = len.wrapping_add(1);\n                if len < buffersize {\n                    buffer_slice[len as usize] = '\\'' as i8;\n                }\n                len = len.wrapping_add(1);\n                pending_shell_escape_end = true;\n            }\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\\\' as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as i32 + (c as i32 >> 6)) as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as i32 + ((c as i32 >> 3) & 7)) as i8;\n            }\n            len = len.wrapping_add(1);\n            c = ('0' as i32 + (c as i32 & 7)) as u8;\n        } else if is_right_quote {",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "            if len < buffersize {\n                buffer_slice[len as usize] = '\\\\' as i8;\n            }\n            len = len.wrapping_add(1);\n            is_right_quote = false;\n        }\n        if ilim <= i.wrapping_add(1) {\n            break;\n        }\n        if pending_shell_escape_end && !escaping {\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\'' as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\'' as i8;\n            }\n            len = len.wrapping_add(1);\n            pending_shell_escape_end = false;\n        }\n        if len < buffersize {\n            buffer_slice[len as usize] = c as i8;\n        }\n        len = len.wrapping_add(1);\n        i = i.wrapping_add(1);\n        c = unsafe { *arg.offset(i as isize) } as u8;\n    }\n    current_block = 4476262310586904498;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n}\n\nmatch current_block {\n    16442922512115311366 => {\n        if i != 0 {\n            current_block = 253337042034819032;\n        } else {\n            current_block = 4634307283396172174;\n        }\n    }\n    9215498979640025612 => {\n        if quoting_style == shell_always_quoting_style && elide_outer_quotes {\n            current_block = 7928555609993211441;\n            break 's_25;\n        }\n        current_block = 1190876092451756080;\n    }\n    _ => {}\n}\n\nmatch current_block {\n    1190876092451756080 => {\n        if backslash_escapes {\n            c = esc;\n            current_block = 3173013908131212616;\n        } else {\n            current_block = 253337042034819032;\n        }\n    }\n    4634307283396172174 => {\n        c_and_shell_quote_compat = true;\n        current_block = 7549413860336125482;\n    }\n    _ => {}\n}\n\nmatch current_block {\n    7549413860336125482 => {\n        current_block = 13059411171234995867;\n    }\n    _ => {}\n}\n\nmatch current_block {\n    13059411171234995867 => {\n        current_block = 16620298045565028098;\n    }\n    _ => {}\n}\n\n            let mut current_block = match current_block {\n    16620298045565028098 => {\n        15155215915847730705\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    15155215915847730705 => {\n        if quoting_style == shell_always_quoting_style && elide_outer_quotes {\n            break 's_25;\n        }\n        253337042034819032\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    253337042034819032 => {\n        if !((backslash_escapes && quoting_style != shell_always_quoting_style) || elide_outer_quotes) \n            && !quote_these_too.is_null() \n            && (unsafe { *quote_these_too.offset(c as isize / (std::mem::size_of::<libc::c_int>() * 8) as isize) } >> (c as usize % (std::mem::size_of::<libc::c_int>() * 8)) & 1) != 0 \n            && !is_right_quote {\n            4476262310586904498\n        } else {\n            3173013908131212616\n        }\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    3173013908131212616 => {\n        if elide_outer_quotes {\n            break 's_25;\n        }\n        escaping = true;\n        if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '$' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            pending_shell_escape_end = true;\n        }\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '\\\\' as i8; }\n        }\n        len += 1;\n        4476262310586904498\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    4476262310586904498 => {\n        if pending_shell_escape_end && !escaping {\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            pending_shell_escape_end = false;\n        }\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = c as i8; }\n        }\n        len += 1;\n        if !c_and_shell_quote_compat {\n            all_c_and_shell_quote_compat = false;\n        }\n        current_block\n    }\n    _ => current_block,\n};\n\ni += 1;\n\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n    return quotearg_buffer_restyled(\n        buffer,\n        orig_buffersize,\n        arg,\n        argsize,\n        c_quoting_style,\n        flags,\n        quote_these_too,\n        left_quote,\n        right_quote,\n    );\n} else {\n    if !(buffersize == 0 && orig_buffersize != 0) {\n        current_block = 6412618891452676311;\n        break;\n    }\n    buffersize = orig_buffersize;\n    len = 0;\n}\n\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub fn quotearg_buffer(\n    buffer: &mut [c_char],\n    arg: &[c_char],\n    o: Option<&quoting_options>,\n) -> usize {\n    let p = o.unwrap_or_else(|| unsafe { &default_quoting_options });\n    let e = std::io::Error::last_os_error();\n    \n    let r = unsafe {\n        quotearg_buffer_restyled(\n            buffer.as_mut_ptr(),\n            buffer.len().try_into().unwrap(),\n            arg.as_ptr(),\n            arg.len().try_into().unwrap(),\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        )\n    };\n\n    std::mem::forget(e); // Avoid dropping the error\n    r.try_into().unwrap()\n}\n#[no_mangle]\npub fn quotearg_alloc(\n    arg: &CStr,\n    argsize: usize,\n    o: &quoting_options,\n) -> CString {\n    let arg_ptr = arg.as_ptr();\n    let argsize_ptr = argsize.try_into().unwrap(); // Assuming argsize is valid and convertible\n    let result_ptr = unsafe { quotearg_alloc_mem(arg_ptr, argsize_ptr, std::ptr::null_mut(), o) };\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};\nstatic mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub fn quotearg_free() {\n    unsafe {\n        let mut sv = Vec::from_raw_parts(slotvec, nslots as usize, nslots as usize); // Convert raw pointer to Vec\n        for i in 1..nslots {\n            if let Some(val) = sv.get_mut(i as usize) {\n                drop(Box::from_raw(val.val)); // Assuming val is a pointer to a heap-allocated value\n            }\n        }\n        if sv[0].val as *const libc::c_char != slot0.as_ptr() {\n            drop(Box::from_raw(sv[0].val)); // Assuming val is a pointer to a heap-allocated value\n            slotvec0.size = std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n            slotvec0.val = slot0.as_mut_ptr();\n        }\n        if sv.as_ptr() != &slotvec0 as *const _ as *mut _ {\n            drop(Box::from_raw(sv.as_mut_ptr())); // Assuming sv is a pointer to a heap-allocated value\n            slotvec = &mut slotvec0;\n        }\n        nslots = 1;\n    }\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}\n#[no_mangle]\npub fn quotearg_n_mem(\n    n: i32,\n    arg: &str,\n) -> *mut libc::c_char {\n    let arg_cstring = CString::new(arg).expect(\"CString::new failed\");\n    let argsize = arg_cstring.as_bytes_with_nul().len() as u64;\n\n    unsafe {\n        quotearg_n_options(n, arg_cstring.as_ptr(), argsize, &default_quoting_options)\n    }\n}\n#[no_mangle]\npub fn quotearg(arg: &CStr) -> CString {\n    unsafe {\n        let quoted_ptr = quotearg_n(0, arg.as_ptr());\n        CString::from_raw(quoted_ptr)\n    }\n}\n#[no_mangle]\npub fn quotearg_mem(arg: &CStr) -> CString {\n    let argsize = arg.to_bytes().len();\n    let result = quotearg_n_mem(0, arg.to_str().unwrap());\n    unsafe { CString::from_raw(result) }\n}\n#[no_mangle]\npub fn quotearg_n_style(\n    n: i32,\n    s: quoting_style,\n    arg: &CStr,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    unsafe {\n        quotearg_n_options(n, arg.as_ptr(), u64::MAX, &o)\n    }\n}\n#[no_mangle]\npub fn quotearg_n_style_mem(\n    n: i32,\n    s: quoting_style,\n    arg: &str,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    unsafe {\n        quotearg_n_options(n, arg.as_ptr() as *const libc::c_char, arg.len() as size_t, &o)\n    }\n}\n#[no_mangle]\npub fn quotearg_style(\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let result_ptr = quotearg_n_style(0, s, arg);\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let arg_str = unsafe { CString::from_raw(arg as *mut libc::c_char) }.into_string().unwrap();\nreturn quotearg_n_style_mem(0, s, &arg_str);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    let result = set_char_quoting(Some(&mut options), ch as u8 as char, 1);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}\n#[no_mangle]\npub fn quotearg_colon(arg: &str) -> String {\n    let ch: i8 = b':' as i8;\n    let c_string = std::ffi::CString::new(arg).unwrap();\n    let result_ptr;\n    unsafe {\n        result_ptr = quotearg_char(c_string.as_ptr(), ch);\n    }\n    unsafe { CString::from_raw(result_ptr).into_string().unwrap() }\n}\n#[no_mangle]\npub fn quotearg_colon_mem(arg: &CStr) -> CString {\n    let argsize = arg.to_bytes().len();\n    let result_ptr = unsafe {\n        quotearg_char_mem(arg.as_ptr(), argsize.try_into().unwrap(), ':' as i32 as c_char)\n    };\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    let result = set_char_quoting(Some(&mut options), ':' as u8 as char, 1);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o as *mut quoting_options, left_quote as *const libc::c_char, right_quote as *const libc::c_char);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub fn quotearg_custom(\n    left_quote: &str,\n    right_quote: &str,\n    arg: &str,\n) -> String {\n    let left_quote_c = std::ffi::CString::new(left_quote).unwrap();\n    let right_quote_c = std::ffi::CString::new(right_quote).unwrap();\n    let arg_c = std::ffi::CString::new(arg).unwrap();\n    \n    let result_ptr;\n    unsafe {\n        result_ptr = quotearg_n_custom(0, left_quote_c.as_ptr(), right_quote_c.as_ptr(), arg_c.as_ptr());\n    }\n    \n    unsafe {\n        CString::from_raw(result_ptr).into_string().unwrap()\n    }\n}\n#[no_mangle]\npub fn quotearg_custom_mem(\n    left_quote: &CStr,\n    right_quote: &CStr,\n    arg: &CStr,\n) -> CString {\n    let argsize = arg.to_bytes().len() as u64;\n    unsafe {\n        let result_ptr = quotearg_n_custom_mem(\n            0,\n            left_quote.as_ptr(),\n            right_quote.as_ptr(),\n            arg.as_ptr(),\n            argsize,\n        );\n        CString::from_raw(result_ptr)\n    }\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}\n#[no_mangle]\npub fn quote_mem(arg: &str) -> String {\n    let argsize = arg.len() as libc::size_t;\n    let c_string = std::ffi::CString::new(arg).expect(\"CString::new failed\");\n    \n    let result_ptr = unsafe { quote_n_mem(0, c_string.as_ptr(), argsize.try_into().unwrap()) };\n    \n    unsafe { std::ffi::CString::from_raw(result_ptr as *mut libc::c_char).into_string().expect(\"Failed to convert C string to Rust string\") }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}\n#[no_mangle]\npub fn quote(arg: &str) -> *const libc::c_char {\n    let c_string = std::ffi::CString::new(arg).expect(\"CString::new failed\");\n    unsafe { quote_n(0, c_string.as_ptr()) }\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type ssize_t = __ssize_t;\npub type __ssize_t = libc::c_long;\npub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn safe_read(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = read(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\safe_read.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn write(__fd: libc::c_int, __buf: *const libc::c_void, __n: size_t) -> ssize_t;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type ssize_t = __ssize_t;\npub type __ssize_t = libc::c_long;\npub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn safe_write(\n    mut fd: libc::c_int,\n    mut buf: *const libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = write(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\safe_write.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn setlocale_null_r(\n    category: libc::c_int,\n    buf: &mut [u8],\n) -> libc::c_int {\n    let bufsize = buf.len() as u64;\n    let buf_ptr = buf.as_mut_ptr() as *mut libc::c_char;\n    unsafe {\n        return setlocale_null_r_unlocked(category, buf_ptr, bufsize);\n    }\n}\n#[no_mangle]\npub fn setlocale_null(category: libc::c_int) -> Option<String> {\n    let locale = unsafe { setlocale_null_unlocked(category) };\n    if locale.is_null() {\n        None\n    } else {\n        unsafe { Some(CStr::from_ptr(locale).to_string_lossy().into_owned()) }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\setlocale_null.rs"
    },
    {
      "chunk": "use std::ptr;\nuse ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub fn setlocale_null_r_unlocked(\n    category: libc::c_int,\n    buf: &mut Vec<u8>,\n) -> libc::c_int {\n    let result: *const libc::c_char;\n    unsafe {\n        result = setlocale_null_unlocked(category);\n    }\n    \n    if result.is_null() {\n        if !buf.is_empty() {\n            buf[0] = b'\\0';\n        }\n        return 22;\n    } else {\n        let length: usize;\n        unsafe {\n            length = strlen(result) as usize;\n        }\n        \n        if length < buf.len() {\n            unsafe {\n                std::ptr::copy_nonoverlapping(result as *const u8, buf.as_mut_ptr(), length);\n            }\n            buf[length] = b'\\0';\n            return 0;\n        } else {\n            if !buf.is_empty() {\n                let copy_length = buf.len() - 1;\n                unsafe {\n                    std::ptr::copy_nonoverlapping(result as *const u8, buf.as_mut_ptr(), copy_length);\n                }\n                buf[copy_length] = b'\\0';\n            }\n            return 34;\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\setlocale_null_unlocked.rs"
    },
    {
      "chunk": "use std::u32;\nuse std::u64;\nuse std::mem;\nuse ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn __gl_stdbit_clz(n: u32) -> i32 {\n    if n != 0 {\n        n.leading_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u32>() as i32)\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn __gl_stdbit_clzl(n: u64) -> i32 {\n    if n != 0 {\n        n.leading_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u64>() as u64) as i32\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn __gl_stdbit_clzll(n: u64) -> i32 {\n    if n != 0 {\n        n.leading_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u64>() as u64) as i32\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn __gl_stdbit_ctz(n: u32) -> i32 {\n    if n != 0 {\n        n.trailing_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u32>() as i32)\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn __gl_stdbit_ctzl(n: u64) -> i32 {\n    if n != 0 {\n        n.trailing_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u64>() as u64) as i32\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn __gl_stdbit_ctzll(n: u64) -> i32 {\n    if n != 0 {\n        n.trailing_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u64>() as u32) as i32\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\stdbit.rs"
    },
    {
      "chunk": "use std::u32;\nuse std::mem;\nuse std::convert::TryInto;\nuse ::libc;\n#[inline]\nfn __gl_stdbit_clz(n: u32) -> i32 {\n    if n != 0 {\n        n.leading_zeros() as i32\n    } else {\n        (std::mem::size_of::<u32>() * 8) as i32\n    }\n}\n#[inline]\nfn __gl_stdbit_clzl(n: u64) -> i32 {\n    if n != 0 {\n        n.leading_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u64>() as u32) as i32\n    }\n}\n#[inline]\nfn __gl_stdbit_clzll(n: u64) -> i32 {\n    if n != 0 {\n        n.leading_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u64>() as u32) as i32\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn stdc_leading_zeros_ui(n: u32) -> u32 {\n    let leading_zeros = n.leading_zeros();\n    leading_zeros\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn stdc_leading_zeros_uc(n: u8) -> u32 {\n    let leading_zeros = stdc_leading_zeros_ui(n as u32);\n    let size_diff = (std::mem::size_of::<u32>() as u64) - (std::mem::size_of::<u8>() as u64);\n    (leading_zeros as u64).wrapping_sub(8 * size_diff) as u32\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn stdc_leading_zeros_us(n: u16) -> u32 {\n    let leading_zeros = stdc_leading_zeros_ui(n as u32);\n    let size_difference = (std::mem::size_of::<u32>() - std::mem::size_of::<u16>()) * 8;\n    leading_zeros.wrapping_sub(size_difference as u32)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn stdc_leading_zeros_ul(n: u64) -> u32 {\n    return n.leading_zeros();\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn stdc_leading_zeros_ull(n: u64) -> u32 {\n    return __gl_stdbit_clzll(n) as u32;\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\stdc_leading_zeros.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\version.rs"
    },
    {
      "chunk": "use std::println;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\version_etc.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub fn emit_bug_reporting_address() {\n    println!();\n    println!(\n        \"Report bugs to: {}\",\n        \"bug-coreutils@gnu.org\"\n    );\n    println!(\n        \"{} home page: <{}>\",\n        \"GNU coreutils\",\n        \"https://www.gnu.org/software/coreutils/\"\n    );\n    println!(\n        \"General help using GNU software: <{}>\",\n        \"https://www.gnu.org/gethelp/\"\n    );\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\version_etc.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\version_etc_fsf.rs"
    },
    {
      "chunk": "use std::alloc::{alloc, Layout};\nuse ::libc;\nextern \"C\" {\n    fn aligned_alloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn xalloc_die();\n}\npub type size_t = libc::c_ulong;\npub type ptrdiff_t = libc::c_long;\npub type idx_t = ptrdiff_t;\n#[inline]\nfn alignalloc(alignment: usize, size: usize) -> *mut libc::c_void {\n    let alignment = if alignment.is_power_of_two() && alignment != 0 {\n        alignment\n    } else {\n        usize::MAX\n    };\n    \n    let size = if size != 0 {\n        size\n    } else {\n        usize::MAX\n    };\n\n    let layout = std::alloc::Layout::from_size_align(size, alignment).ok();\n    if let Some(layout) = layout {\n        unsafe {\n            let ptr = std::alloc::alloc(layout);\n            if ptr.is_null() {\n                std::ptr::null_mut()\n            } else {\n                ptr as *mut libc::c_void\n            }\n        }\n    } else {\n        std::ptr::null_mut()\n    }\n}\n#[no_mangle]\npub fn xalignalloc(alignment: usize, size: usize) -> Box<[u8]> {\n    let layout = Layout::from_size_align(size, alignment).expect(\"Invalid layout\");\n    let ptr = unsafe { alloc(layout) };\n    if ptr.is_null() {\n        unsafe { xalloc_die() };\n    }\n    let slice = unsafe { std::slice::from_raw_parts_mut(ptr, size) };\n    let box_slice = unsafe { Box::from_raw(slice) };\n    box_slice\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\xalignalloc.rs"
    },
    {
      "chunk": "use std::process;\nuse ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub fn xalloc_die() {\n    unsafe {\n        if 0 != 0 {\n            error(\n                exit_failure,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if exit_failure != 0 {\n                unreachable!();\n            }\n        } else {\n            let errstatus = exit_failure;\n            error(\n                errstatus,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if errstatus != 0 {\n                unreachable!();\n            }\n\n            let errstatus = exit_failure;\n            error(\n                errstatus,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if errstatus != 0 {\n                unreachable!();\n            }\n        }\n    }\n    std::process::abort();\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\xalloc_die.rs"
    },
    {
      "chunk": "use std::os::unix::io::AsRawFd;\nuse ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn xset_binary_mode(fd: impl AsRawFd, mode: libc::c_int) {\n    if set_binary_mode(fd.as_raw_fd(), mode) < 0 {\n        xset_binary_mode_error();\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn xset_binary_mode_error() {\n    // Implementation of setting binary mode error goes here.\n    // This is a placeholder for the actual logic that would be used\n    // to set the binary mode error in a safe manner.\n}\n#[inline]\nfn set_binary_mode(fd: i32, mode: i32) -> i32 {\n    __gl_setmode(fd, mode)\n}\n#[inline]\nfn __gl_setmode(fd: i32, mode: i32) -> i32 {\n    return 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\xbinary_io.rs"
    },
    {
      "chunk": "use std::string::String;\nuse std::slice;\nuse std::vec::Vec;\nuse std::mem;\nuse std::convert::TryInto;\nuse ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nfn irealloc(s: usize) -> *mut libc::c_void {\n    if s <= usize::MAX {\n        let mut vec = Vec::with_capacity(s);\n        let ptr = vec.as_mut_ptr();\n        std::mem::forget(vec); // Prevent Vec from deallocating the memory\n        return ptr;\n    } else {\n        return _gl_alloc_nomem();\n    }\n}\n#[inline]\nfn icalloc(n: i64, s: i64) -> *mut libc::c_void {\n    let n_usize = n.try_into().unwrap_or(0);\n    let s_usize = s.try_into().unwrap_or(0);\n\n    if n_usize > usize::MAX / s_usize {\n        if s_usize != 0 {\n            return _gl_alloc_nomem();\n        }\n        return std::ptr::null_mut(); // Equivalent to returning null for zero allocation\n    }\n    if s_usize > usize::MAX / n_usize {\n        if n_usize != 0 {\n            return _gl_alloc_nomem();\n        }\n        return std::ptr::null_mut(); // Equivalent to returning null for zero allocation\n    }\n    let total_size = n_usize.checked_mul(s_usize).unwrap_or(0);\n    let ptr = unsafe { libc::calloc(total_size, 1) };\n    ptr\n}\n#[inline]\nfn ireallocarray(\n    p: *mut libc::c_void,\n    n: usize,\n    s: usize,\n) -> *mut libc::c_void {\n    if n <= usize::MAX && s <= usize::MAX {\n        let mut nx: usize = n;\n        let mut sx: usize = s;\n        if n == 0 || s == 0 {\n            sx = 1;\n            nx = sx;\n        }\n        let new_size = nx.checked_mul(sx).unwrap_or(0);\n        let new_p = unsafe { libc::reallocarray(p, nx, sx) };\n        new_p\n    } else {\n        _gl_alloc_nomem()\n    }\n}\n#[cold]\n#[inline]\nfn _gl_alloc_nomem() -> *mut libc::c_void {\n    unsafe {\n        *__errno_location() = 12; // Set errno to 12\n    }\n    std::ptr::null_mut() // Return a null pointer\n}\n#[inline]\nfn imalloc(s: usize) -> *mut libc::c_void {\n    if s <= usize::MAX {\n        let layout = std::alloc::Layout::from_size_align(s, 1).unwrap();\n        let ptr = unsafe { std::alloc::alloc(layout) };\n        if ptr.is_null() {\n            _gl_alloc_nomem()\n        } else {\n            ptr as *mut libc::c_void\n        }\n    } else {\n        _gl_alloc_nomem()\n    }\n}\nfn check_nonnull(p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        unsafe { xalloc_die() };\n    }\n    p\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    let allocated_memory = imalloc(s.try_into().unwrap());\nreturn check_nonnull(allocated_memory);\n}\n#[no_mangle]\npub fn xcharalloc(n: usize) -> Vec<libc::c_char> {\n    let size = mem::size_of::<libc::c_char>();\n    if size == 1 {\n        let ptr = unsafe { xmalloc(n.try_into().unwrap()) };\n        unsafe { Vec::from_raw_parts(ptr as *mut libc::c_char, n, n) }\n    } else {\n        let ptr = unsafe { xnmalloc(n.try_into().unwrap(), size.try_into().unwrap()) };\n        unsafe { Vec::from_raw_parts(ptr as *mut libc::c_char, n, n) }\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub fn xirealloc(\n    p: &[u8],\n    s: usize,\n) -> Option<Vec<u8>> {\n    let new_size = s.try_into().ok()?;\n    let mut new_vec = Vec::with_capacity(new_size);\n    new_vec.copy_from_slice(p);\n    Some(new_vec)\n}\n#[no_mangle]\npub fn xreallocarray(vec: &mut Vec<u8>, n: usize, s: usize) {\n    let new_size = n.checked_mul(s).expect(\"Overflow in size calculation\");\n    if new_size > vec.len() {\n        vec.resize(new_size, 0);\n    } else {\n        vec.truncate(new_size);\n    }\n}\n#[no_mangle]\npub fn xireallocarray(\n    p: Option<&mut [u8]>,\n    n: usize,\n    s: usize,\n) -> *mut libc::c_void {\n    let size = n.checked_mul(s).unwrap_or(0);\n    let new_ptr = check_nonnull(unsafe { ireallocarray(p.map_or(std::ptr::null_mut(), |slice| slice.as_mut_ptr() as *mut libc::c_void), n, s) });\n    if new_ptr.is_null() {\n        return std::ptr::null_mut();\n    }\n    new_ptr\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    let capacity = n.checked_mul(s).expect(\"Overflow in capacity calculation\");\nlet mut vec = Vec::with_capacity(capacity.try_into().unwrap());\nxreallocarray(&mut vec, n.try_into().unwrap(), s.try_into().unwrap());\nreturn vec.as_mut_ptr() as *mut libc::c_void;\n}\n#[no_mangle]\npub fn xinmalloc(n: idx_t, s: idx_t) -> Vec<u8> {\n    let total_size: usize = (n as usize).checked_mul(s as usize).expect(\"Overflow in multiplication\");\n    Vec::with_capacity(total_size)\n}\n#[no_mangle]\npub fn x2realloc(\n    p: Option<&mut [u8]>,\n    ps: &mut usize,\n) -> Option<Vec<u8>> {\n    let new_size = ps.checked_add(1)?;\n    let new_vec = Vec::with_capacity(new_size);\n    *ps = new_size;\n    Some(new_vec)\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    let mut vec = Vec::from_raw_parts(p as *mut u8, n.try_into().unwrap(), s.try_into().unwrap());\nxreallocarray(&mut vec, n.try_into().unwrap(), s.try_into().unwrap());\np = vec.as_mut_ptr() as *mut libc::c_void;\nstd::mem::forget(vec);\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub fn xzalloc(s: usize) -> Vec<u8> {\n    vec![0; s]\n}\n#[no_mangle]\npub fn xizalloc(s: idx_t) -> Vec<u8> {\n    let size: usize = s.try_into().expect(\"Conversion failed\");\n    let vec = vec![0u8; size];\n    vec\n}\n#[no_mangle]\npub fn xcalloc(n: usize, s: usize) -> Option<Box<[u8]>> {\n    let total_size = n.checked_mul(s)?;\n    let vec = vec![0u8; total_size];\n    Some(vec.into_boxed_slice())\n}\n#[no_mangle]\npub fn xicalloc(n: usize, s: usize) -> *mut libc::c_void {\n    let total_size = n.checked_mul(s).expect(\"Overflow in multiplication\");\n    let allocation = vec![0u8; total_size].into_boxed_slice();\n    Box::into_raw(allocation) as *mut libc::c_void\n}\n#[no_mangle]\npub fn xmemdup(p: &[u8]) -> Vec<u8> {\n    let mut result = vec![0; p.len()];\n    result.copy_from_slice(p);\n    result\n}\n#[no_mangle]\npub fn ximemdup(p: &[u8]) -> Vec<u8> {\n    let s = p.len();\n    let mut new_vec = Vec::with_capacity(s);\n    new_vec.copy_from_slice(p);\n    new_vec\n}\n#[no_mangle]\npub fn ximemdup0(p: &[u8]) -> Vec<u8> {\n    let s = p.len();\n    let mut result = vec![0u8; s + 1]; // Allocate space for the data plus a null terminator\n    result[..s].copy_from_slice(p); // Copy the data\n    result[s] = 0; // Null-terminate the string\n    result // Return the vector\n}\n#[no_mangle]\npub fn xstrdup(string: &str) -> String {\n    let length = string.len();\n    let mut vec = Vec::with_capacity(length + 1);\n    vec.extend_from_slice(string.as_bytes());\n    vec.push(0); // Null-terminator\n    String::from_utf8(vec).expect(\"Failed to convert to String\")\n}",
      "file_name": "c2saferrust/coreutils/src\\cat\\rust_WIP\\src\\xmalloc.rs"
    }
  ],
  "head": [
    {
      "chunk": "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\build.rs"
    },
    {
      "chunk": "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(label_break_value)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod binary_io;\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod close_stream;\npub mod closeout;\npub mod exitfail;\npub mod fclose;\npub mod fflush;\npub mod fpurge;\npub mod fseeko;\npub mod full_read;\npub mod hard_locale;\npub mod ialloc;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod offtostr;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod safe_read;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod umaxtostr;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalloc_die;\npub mod xbinary_io;\npub mod xdectoumax;\npub mod xmalloc;\npub mod xstrtoumax;\n}\n// mod src",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\lib.rs"
    },
    {
      "chunk": "use std::os::unix::io::AsRawFd;\nuse ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn set_binary_mode(fd: i32, mode: i32) -> i32 {\n    __gl_setmode(fd, mode)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn __gl_setmode(fd: i32, mode: i32) -> i32 {\n    0\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\binary_io.rs"
    },
    {
      "chunk": "use std::ffi::CString;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub fn close_stdout_set_file_name(file: &str) {\n    let c_string = std::ffi::CString::new(file).unwrap();\n    unsafe {\n        file_name = c_string.as_ptr();\n        std::mem::forget(c_string); // Prevent CString from being dropped\n    }\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\closeout.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn close_stream(stream: *mut _IO_FILE) -> libc::c_int {\n    let some_pending: bool = unsafe { __fpending(stream) != 0 };\n    let prev_fail: bool = unsafe { ferror_unlocked(stream) != 0 };\n    let fclose_fail: bool = unsafe { rpl_fclose(stream) != 0 };\n\n    if prev_fail\n        || (fclose_fail && (some_pending || unsafe { *__errno_location() != 9 }))\n    {\n        if !fclose_fail {\n            unsafe { *__errno_location() = 0 };\n        }\n        return -1;\n    }\n    return 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\close_stream.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalnum(c: i32) -> bool {\n    match c {\n        48..=57 | 65..=90 | 97..=122 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalpha(c: i32) -> bool {\n    matches!(c, 97..=122 | 65..=90)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isascii(c: i32) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isblank(c: i32) -> bool {\n    c == ' ' as i32 || c == '\\t' as i32\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_iscntrl(c: i32) -> bool {\n    match c {\n        0..=31 | 127 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isdigit(c: i32) -> bool {\n    matches!(c, 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isgraph(c: i32) -> bool {\n    match c {\n        48..=57 | 97..=122 | 33..=47 | 58..=64 | 91..=96 | 123..=126 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_islower(c: i32) -> bool {\n    match c {\n        97..=122 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isprint(c: i32) -> bool {\n    match c {\n        32 | 48..=57 | 97..=122 | 33..=47 | 58..=64 | 91..=96 | 123..=126 | 65..=90 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_ispunct(c: i32) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isspace(c: i32) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isupper(c: i32) -> bool {\n    matches!(c, 65..=90)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isxdigit(c: i32) -> bool {\n    matches!(c, 48..=57 | 97..=102 | 65..=70)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_tolower(c: i32) -> i32 {\n    match c {\n        65..=90 => c + ('a' as i32 - 'A' as i32),\n        _ => c,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_toupper(c: i32) -> i32 {\n    match c {\n        97..=122 => c - ('a' as i32) + ('A' as i32),\n        _ => c,\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\c_ctype.rs"
    },
    {
      "chunk": "use std::char;\nuse ::libc;\n#[inline]\nfn c_tolower(c: i32) -> i32 {\n    match c {\n        65..=90 => c - 'A' as i32 + 'a' as i32,\n        _ => c,\n    }\n}\n#[no_mangle]\npub fn c_strcasecmp(s1: &str, s2: &str) -> libc::c_int {\n    let c1 = s1.chars().map(|c| c_tolower(c as i32));\n    let c2 = s2.chars().map(|c| c_tolower(c as i32));\n    \n    for (ch1, ch2) in c1.zip(c2) {\n        if ch1 != ch2 {\n            return ch1 - ch2;\n        }\n    }\n    \n    // If one string is a prefix of the other, we need to compare their lengths\n    if s1.len() != s2.len() {\n        return s1.len() as libc::c_int - s2.len() as libc::c_int;\n    }\n    \n    0\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\c_strcasecmp.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\exitfail.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn rpl_fclose(fp: &mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0;\n    \n    // Unsafe block to call unsafe functions\n    let fd = unsafe { fileno(fp) };\n    \n    if fd < 0 {\n        return unsafe { fclose(fp) };\n    }\n    \n    let is_reading = unsafe { __freading(fp) != 0 };\n    let seek_result = unsafe { lseek(fd, 0, libc::SEEK_CUR) };\n    \n    if (!is_reading || seek_result == -1) && unsafe { rpl_fflush(fp) } != 0 {\n        saved_errno = unsafe { *__errno_location() };\n    }\n    \n    let result = unsafe { fclose(fp) };\n    \n    if saved_errno != 0 {\n        unsafe { *__errno_location() = saved_errno };\n        return -1;\n    }\n    \n    result\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\fclose.rs"
    },
    {
      "chunk": "use std::ptr;\nuse std::option::Option;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nfn clear_ungetc_buffer_preserving_position(fp: *mut FILE) {\n    if unsafe { (*fp)._flags & 0x100 } != 0 {\n        unsafe { rpl_fseeko(fp, 0, 1) };\n    }\n}\n#[no_mangle]\npub fn rpl_fflush(stream: Option<&mut FILE>) -> libc::c_int {\n    unsafe {\n        if let Some(s) = stream {\n            if __freading(s) != 0 {\n                clear_ungetc_buffer_preserving_position(s);\n            }\n            fflush(s)\n        } else {\n            fflush(std::ptr::null_mut())\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\fflush.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __fpurge(__fp: *mut FILE);\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn fpurge(fp: *mut _IO_FILE) -> libc::c_int {\n    unsafe {\n        __fpurge(fp);\n    }\n    0\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\fpurge.rs"
    },
    {
      "chunk": "use std::os::raw::c_int;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub fn rpl_fseeko(\n    fp: &mut FILE,\n    offset: off_t,\n    whence: libc::c_int,\n) -> libc::c_int {\n    if fp._IO_read_end == fp._IO_read_ptr\n        && fp._IO_write_ptr == fp._IO_write_base && fp._IO_save_base.is_null()\n    {\n        let pos: off_t;\n        unsafe {\n            pos = lseek(fileno(fp), offset, whence);\n        }\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        fp._flags &= !(0x10 as libc::c_int);\n        fp._offset = pos;\n        return 0 as libc::c_int;\n    }\n    unsafe {\n        return fseeko(fp, offset, whence);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\fseeko.rs"
    },
    {
      "chunk": "use std::convert::TryInto;\nuse ::libc;\nextern \"C\" {\n    fn safe_read(fd: libc::c_int, buf: *mut libc::c_void, count: size_t) -> size_t;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn full_read(\n    fd: libc::c_int,\n    buf: &mut [u8],\n) -> usize {\n    let mut total: usize = 0;\n    let mut count = buf.len();\n    let mut ptr = buf.as_mut_ptr();\n\n    while count > 0 {\n        let n_rw: u64;\n        unsafe {\n            n_rw = safe_read(fd, ptr as *mut libc::c_void, count.try_into().unwrap());\n        }\n        if n_rw == !(0 as libc::c_int) as u64 {\n            break;\n        }\n        if n_rw == 0 {\n            unsafe { *__errno_location() = 0; }\n            break;\n        } else {\n            total += n_rw as usize;\n            ptr = unsafe { ptr.add(n_rw as usize) };\n            count -= n_rw as usize;\n        }\n    }\n    total\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\full_read.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn hard_locale(category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    unsafe {\n        if setlocale_null_r(\n            category,\n            locale.as_mut_ptr(),\n            ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n        ) != 0\n        {\n            return false;\n        }\n    }\n    let locale_str = unsafe { CStr::from_ptr(locale.as_ptr()).to_string_lossy() };\n    if locale_str == \"C\" || locale_str == \"POSIX\" {\n        return false;\n    }\n    return true;\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\hard_locale.rs"
    },
    {
      "chunk": "#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut, unused_imports)]\n#![feature(extern_types, label_break_value)]\nuse std::os::unix::io::AsRawFd;\nuse std::ffi::CString;\nuse std::os::raw::c_char;\nuse std::io::Write;\nuse std::ffi::CStr;\nuse std::ffi::c_void;\nuse std::convert::TryInto;\nuse ::rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn fwrite_unlocked(\n        __ptr: *const libc::c_void,\n        __size: size_t,\n        __n: size_t,\n        __stream: *mut FILE,\n    ) -> size_t;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn fpurge(gl_stream: *mut FILE) -> libc::c_int;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    static mut optarg: *mut libc::c_char;\n    static mut optind: libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memchr(\n        _: *const libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn rawmemchr(__s: *const libc::c_void, __c: libc::c_int) -> *mut libc::c_void;\n    fn memrchr(\n        __s: *const libc::c_void,\n        __c: libc::c_int,\n        __n: size_t,\n    ) -> *mut libc::c_void;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn free(_: *mut libc::c_void);\n    fn __errno_location() -> *mut libc::c_int;\n    fn quotearg_n_style_colon(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn umaxtostr(_: uintmax_t, _: *mut libc::c_char) -> *mut libc::c_char;\n    fn offtostr(_: off_t, _: *mut libc::c_char) -> *mut libc::c_char;\n    static mut Version: *const libc::c_char;\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn xmalloc(s: size_t) -> *mut libc::c_void;\n    fn xreallocarray(p: *mut libc::c_void, n: size_t, s: size_t) -> *mut libc::c_void;\n    fn xnmalloc(n: size_t, s: size_t) -> *mut libc::c_void;\n    fn close_stdout();\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    static mut program_name: *const libc::c_char;\n    fn set_program_name(argv0: *const libc::c_char);\n    fn exit(_: libc::c_int) -> !;\n    fn atexit(__func: Option::<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn full_read(fd: libc::c_int, buf: *mut libc::c_void, count: size_t) -> size_t;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn safe_read(fd: libc::c_int, buf: *mut libc::c_void, count: size_t) -> size_t;\n    fn xdectoumax(\n        n_str: *const libc::c_char,\n        min: uintmax_t,\n        max: uintmax_t,\n        suffixes: *const libc::c_char,\n        err: *const libc::c_char,\n        err_exit: libc::c_int,\n    ) -> uintmax_t;\n}\npub type size_t = libc::c_ulong;\npub type __uintmax_t = libc::c_ulong;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\npub type uintmax_t = __uintmax_t;\npub type C2RustUnnamed = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type header_mode = libc::c_uint;\npub const never: header_mode = 2;\npub const always: header_mode = 1;\npub const multiple_files: header_mode = 0;\npub type Copy_fd_status = libc::c_uint;\npub const COPY_FD_UNEXPECTED_EOF: Copy_fd_status = 2;\npub const COPY_FD_READ_ERROR: Copy_fd_status = 1;\npub const COPY_FD_OK: Copy_fd_status = 0;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const PRESUME_INPUT_PIPE_OPTION: C2RustUnnamed_0 = 256;\npub type LBUFFER = linebuffer;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct linebuffer {\n    pub buffer: [libc::c_char; 8193],\n    pub nbytes: size_t,\n    pub nlines: size_t,\n    pub next: *mut linebuffer,\n}\n#[inline]\nfn usable_st_size(sb: &stat) -> bool {\n    let mode = sb.st_mode;\n    mode & 0o170000 == 0o100000 || \n    mode & 0o170000 == 0o120000 || \n    mode.wrapping_sub(mode) != 0 || \n    false\n}\n#[inline]",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\head.rs"
    },
    {
      "chunk": "fn emit_ancillary_info(program: &CStr) {\n    let infomap_0: [infomap; 7] = [\n        infomap {\n            program: CStr::from_bytes_with_nul(b\"[\\0\").unwrap().as_ptr(),\n            node: CStr::from_bytes_with_nul(b\"test invocation\\0\").unwrap().as_ptr(),\n        },\n        infomap {\n            program: CStr::from_bytes_with_nul(b\"coreutils\\0\").unwrap().as_ptr(),\n            node: CStr::from_bytes_with_nul(b\"Multi-call invocation\\0\").unwrap().as_ptr(),\n        },\n        infomap {\n            program: CStr::from_bytes_with_nul(b\"sha224sum\\0\").unwrap().as_ptr(),\n            node: CStr::from_bytes_with_nul(b\"sha2 utilities\\0\").unwrap().as_ptr(),\n        },\n        infomap {\n            program: CStr::from_bytes_with_nul(b\"sha256sum\\0\").unwrap().as_ptr(),\n            node: CStr::from_bytes_with_nul(b\"sha2 utilities\\0\").unwrap().as_ptr(),\n        },\n        infomap {\n            program: CStr::from_bytes_with_nul(b\"sha384sum\\0\").unwrap().as_ptr(),\n            node: CStr::from_bytes_with_nul(b\"sha2 utilities\\0\").unwrap().as_ptr(),\n        },\n        infomap {\n            program: CStr::from_bytes_with_nul(b\"sha512sum\\0\").unwrap().as_ptr(),\n            node: CStr::from_bytes_with_nul(b\"sha2 utilities\\0\").unwrap().as_ptr(),\n        },\n        infomap {\n            program: std::ptr::null(),\n            node: std::ptr::null(),\n        },\n    ];\n    \n    let mut node = program.as_ptr();\n    let mut map_prog = infomap_0.as_ptr();\n    \n    while !map_prog.is_null() && unsafe { strcmp(program.as_ptr(), (*map_prog).program) } != 0 {\n        map_prog = unsafe { map_prog.add(1) };\n    }\n    \n    if !unsafe { (*map_prog).node }.is_null() {\n        node = unsafe { (*map_prog).node };\n    }\n    \n    println!(\n        \"{} online help: <{}>\",\n        \"GNU coreutils\",\n        \"https://www.gnu.org/software/coreutils/\"\n    );\n    \n    let lc_messages: *const libc::c_char;\n    unsafe {\n        lc_messages = setlocale(5, std::ptr::null());\n    }\n    \n    if !lc_messages.is_null() && unsafe { strncmp(lc_messages, b\"en_\\0\".as_ptr() as *const i8, 3) } != 0 {\n        eprintln!(\n            \"{}\",\n            \"Report any translation bugs to <https://translationproject.org/team/>\"\n        );\n    }\n    \n    let url_program = if unsafe { strcmp(program.as_ptr(), b\"[\\0\".as_ptr() as *const i8) } == 0 {\n        CStr::from_bytes_with_nul(b\"test\\0\").unwrap().as_ptr()\n    } else {\n        program.as_ptr()\n    };\n    \n    println!(\n        \"Full documentation <{}{}>\",\n        \"https://www.gnu.org/software/coreutils/\",\n        unsafe { CStr::from_ptr(url_program).to_str().unwrap() }\n    );\n    \n    println!(\n        \"or available locally via: info '(coreutils) {}{}'\",\n        unsafe { CStr::from_ptr(node).to_str().unwrap() },\n        if node == program.as_ptr() {\n            \" invocation\"\n        } else {\n            \"\"\n        }\n    );\n}\n#[inline]\nunsafe extern \"C\" fn xnrealloc(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return xreallocarray(p, n, s);\n}\n#[inline]\nfn emit_stdin_note() {\n    let message = \"\\nWith no FILE, or when FILE is -, read standard input.\\n\";\n    let translated_message = unsafe { gettext(message.as_ptr() as *const libc::c_char) };\n    let stdout_handle = std::io::stdout();\n    let mut handle = stdout_handle.lock();\n    handle.write_all(unsafe { std::ffi::CStr::from_ptr(translated_message).to_bytes() }).unwrap();\n}\n#[inline]\nfn emit_mandatory_arg_note() {\n    let message = \"\\nMandatory arguments to long options are mandatory for short options too.\\n\";\n    let stdout_handle = std::io::stdout();\n    let mut handle = stdout_handle.lock();\n    handle.write_all(message.as_bytes()).expect(\"Failed to write to stdout\");\n}\n#[inline]\nfn __gl_setmode(fd: i32, mode: i32) -> i32 {\n    0\n}\n#[inline]\nfn set_binary_mode(fd: i32, mode: i32) -> i32 {\n    __gl_setmode(fd, mode)\n}\n#[inline]\nfn xset_binary_mode_error() {\n    // Function body can be implemented here if needed.\n}\n#[inline]\nfn xset_binary_mode(fd: i32, mode: i32) {\n    unsafe {\n        if set_binary_mode(fd, mode) < 0 {\n            xset_binary_mode_error();\n        }\n    }\n}\nstatic mut presume_input_pipe: bool = false;\nstatic mut print_headers: bool = false;\nstatic mut line_end: libc::c_char = 0;\nstatic mut have_read_stdin: bool = false;\nstatic mut long_options: [option; 10] = [\n    {\n        let mut init = option {\n            name: b\"bytes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'c' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"lines\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'n' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"-presume-input-pipe\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: PRESUME_INPUT_PIPE_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"quiet\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'q' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"silent\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'q' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"verbose\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'v' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"zero-terminated\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'z' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];\n#[no_mangle]\npub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [FILE]...\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        printf(\n            gettext(\n                b\"Print the first %d lines of each FILE to standard output.\\nWith more than one FILE, precede each with a header giving the file name.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            10 as libc::c_int,\n        );\n        emit_stdin_note();\n        emit_mandatory_arg_note();\n        printf(\n            gettext(\n                b\"  -c, --bytes=[-]NUM       print the first NUM bytes of each file;\\n                             with the leading '-', print all but the last\\n                             NUM bytes of each file\\n  -n, --lines=[-]NUM       print the first NUM lines instead of the first %d;\\n                             with the leading '-', print all but the last\\n                             NUM lines of each file\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            10 as libc::c_int,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -q, --quiet, --silent    never print headers giving file names\\n  -v, --verbose            always print headers giving file names\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -z, --zero-terminated    line delimiter is NUL, not newline\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"\\nNUM may have a multiplier suffix:\\nb 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\\nGB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        let program_cstr = CStr::from_bytes_with_nul(b\"head\\0\").unwrap();\nemit_ancillary_info(&program_cstr);\n    }\n    exit(status);\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\head.rs"
    },
    {
      "chunk": "fn diagnose_copy_fd_failure(\n    err: Copy_fd_status,\n    filename: *const libc::c_char,\n) {\n    let filename_str = unsafe { std::ffi::CStr::from_ptr(filename).to_str().unwrap() };\n    \n    match err as libc::c_uint {\n        1 => {\n            let errstatus: libc::c_int = 0;\n            unsafe {\n                error(\n                    errstatus,\n                    std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n            }\n            if errstatus != 0 {\n                unreachable!();\n            }\n        }\n        2 => {\n            let errstatus: libc::c_int = 0;\n            unsafe {\n                error(\n                    errstatus,\n                    std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                    gettext(b\"%s: file has shrunk too much\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_n_style_colon(0, shell_escape_quoting_style, filename),\n                );\n            }\n            if errstatus != 0 {\n                unreachable!();\n            }\n        }\n        _ => {\n            panic!(\"Unexpected Copy_fd_status value\");\n        }\n    }\n}\nfn write_header(filename: &str) {\n    static mut FIRST_FILE: bool = true;\n    let prefix = if unsafe { FIRST_FILE } { \"\" } else { \"\\n\" };\n    println!(\"{}==> {} <==\", prefix, filename);\n    unsafe { FIRST_FILE = false; }\n}\nunsafe extern \"C\" fn xwrite_stdout(\n    mut buffer: *const libc::c_char,\n    mut n_bytes: size_t,\n) {\n    if n_bytes > 0 as libc::c_int as libc::c_ulong\n        && fwrite_unlocked(\n            buffer as *const libc::c_void,\n            1 as libc::c_int as size_t,\n            n_bytes,\n            stdout,\n        ) < n_bytes\n    {\n        clearerr_unlocked(stdout);\n        fpurge(stdout);\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n}\nfn copy_fd(src_fd: libc::c_int, mut n_bytes: uintmax_t) -> Copy_fd_status {\n    let mut buf = [0; 8192];\n    let buf_size = buf.len();\n\n    while n_bytes > 0 {\n        let n_to_read = buf_size.min(n_bytes as usize);\n        \n        let n_read = unsafe {\n            safe_read(src_fd, buf.as_mut_ptr() as *mut libc::c_void, n_to_read.try_into().unwrap())\n        };\n\n        if n_read == -(1 as libc::c_int) as size_t {\n            return COPY_FD_READ_ERROR;\n        }\n\n        n_bytes -= n_read as uintmax_t;\n\n        if n_read == 0 && n_bytes != 0 {\n            return COPY_FD_UNEXPECTED_EOF;\n        }\n\n        unsafe {\n            xwrite_stdout(buf.as_mut_ptr(), n_read);\n        }\n    }\n    COPY_FD_OK\n}\nunsafe extern \"C\" fn elseek(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n    mut filename: *const libc::c_char,\n) -> off_t {\n    let mut new_offset: off_t = lseek(fd, offset, whence);\n    let mut buf: [libc::c_char; 21] = [0; 21];\n    if new_offset < 0 as libc::c_int as libc::c_long {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    if whence == 0 as libc::c_int {\n                        b\"%s: cannot seek to offset %s\\0\" as *const u8\n                            as *const libc::c_char\n                    } else {\n                        b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                            as *const libc::c_char\n                    },\n                ),\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    filename,\n                ),\n                offtostr(offset, buf.as_mut_ptr()),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        if whence == 0 as libc::c_int {\n                            b\"%s: cannot seek to offset %s\\0\" as *const u8\n                                as *const libc::c_char\n                        } else {\n                            b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                                as *const libc::c_char\n                        },\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                    offtostr(offset, buf.as_mut_ptr()),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        if whence == 0 as libc::c_int {\n                            b\"%s: cannot seek to offset %s\\0\" as *const u8\n                                as *const libc::c_char\n                        } else {\n                            b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                                as *const libc::c_char\n                        },\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                    offtostr(offset, buf.as_mut_ptr()),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    return new_offset;\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\head.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn elide_tail_bytes_pipe(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_elide_0: uintmax_t,\n    mut current_pos: off_t,\n) -> bool {\n    let mut n_elide: u64 = n_elide_0;\nlet mut desired_pos: u64 = current_pos as u64;\nlet mut ok: bool = true;\n\nif n_elide_0.wrapping_add(8192) > u64::MAX {\n    let mut umax_buf: [libc::c_char; 21] = [0; 21];\n    umaxtostr(n_elide_0, umax_buf.as_mut_ptr());\n    error(\n        1,\n        0,\n        gettext(b\"%s: number of bytes is too large\\0\" as *const u8 as *const libc::c_char),\n        umax_buf.as_mut_ptr(),\n    );\n    unreachable!();\n}\n\nif n_elide <= (1024 * 1024) as u64 {\n     let mut first: bool = 1 as libc::c_int != 0;\n        let mut eof: bool = 0 as libc::c_int != 0;\n        let mut n_to_read: size_t = (8192 as libc::c_int as libc::c_ulong)\n            .wrapping_add(n_elide);\n        let mut i: bool = false;\n        let mut b: [*mut libc::c_char; 2] = [0 as *mut libc::c_char; 2];\n        b[0 as libc::c_int\n            as usize] = xnmalloc(2 as libc::c_int as size_t, n_to_read)\n            as *mut libc::c_char;\n        b[1 as libc::c_int\n            as usize] = (b[0 as libc::c_int as usize]).offset(n_to_read as isize);\n        i = 0 as libc::c_int != 0;\n        while !eof {\n            let mut n_read: size_t = full_read(\n                fd,\n                b[i as usize] as *mut libc::c_void,\n                n_to_read,\n            );\n            let mut delta: size_t = 0 as libc::c_int as size_t;\n            if n_read < n_to_read {\n                if *__errno_location() != 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, filename),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, filename),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, filename),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                    break;\n                } else {\n                    if n_read <= n_elide {\n                        if !first {\n                            delta = n_elide.wrapping_sub(n_read);\n                        }\n                    }\n                    eof = 1 as libc::c_int != 0;\n                }\n            }\n            if !first {\n                desired_pos = (desired_pos as libc::c_ulong)\n                    .wrapping_add(n_elide.wrapping_sub(delta)) as uintmax_t as uintmax_t;\n                xwrite_stdout(\n                    (b[!i as libc::c_int as usize]).offset(8192 as libc::c_int as isize),\n                    n_elide.wrapping_sub(delta),\n                );\n            }\n            first = 0 as libc::c_int != 0;\n            if n_elide < n_read {\n                desired_pos = (desired_pos as libc::c_ulong)\n                    .wrapping_add(n_read.wrapping_sub(n_elide)) as uintmax_t\n                    as uintmax_t;\n                xwrite_stdout(b[i as usize], n_read.wrapping_sub(n_elide));\n            }\n            i = !i;\n        }\n        free(b[0 as libc::c_int as usize] as *mut libc::c_void);\n\n} else {\n     let mut current_block_69: u64;\n        let mut eof_0: bool = 0 as libc::c_int != 0;\n        let mut n_read_0: size_t = 0;\n        let mut buffered_enough: bool = false;\n        let mut i_0: size_t = 0;\n        let mut i_next: size_t = 0;\n        let mut b_0: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n        let mut rem: size_t = (8192 as libc::c_int as libc::c_ulong)\n            .wrapping_sub(n_elide.wrapping_rem(8192 as libc::c_int as libc::c_ulong));\n        let mut n_elide_round: size_t = n_elide.wrapping_add(rem);\n        let mut n_bufs: size_t = n_elide_round\n            .wrapping_div(8192 as libc::c_int as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong);\n        let mut n_alloc: size_t = 0 as libc::c_int as size_t;\n        let mut n_array_alloc: size_t = 0 as libc::c_int as size_t;\n        buffered_enough = 0 as libc::c_int != 0;\n        i_0 = 0 as libc::c_int as size_t;\n        i_next = 1 as libc::c_int as size_t;\n        loop {\n            if eof_0 {\n                current_block_69 = 10753070352654377903;\n                break;\n            }\n            if n_array_alloc == i_0 {\n                if n_array_alloc == 0 as libc::c_int as libc::c_ulong {\n                    n_array_alloc = if n_bufs < 16 as libc::c_int as libc::c_ulong {\n                        n_bufs\n                    } else {\n                        16 as libc::c_int as libc::c_ulong\n                    };\n                } else if n_array_alloc\n                    <= n_bufs.wrapping_div(2 as libc::c_int as libc::c_ulong)\n                {\n                    n_array_alloc = (n_array_alloc as libc::c_ulong)\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong) as size_t\n                        as size_t;\n                } else {\n                    n_array_alloc = n_bufs;\n                }\n                b_0 = xnrealloc(\n                    b_0 as *mut libc::c_void,\n                    n_array_alloc,\n                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,\n                ) as *mut *mut libc::c_char;\n            }\n            if !buffered_enough {\n                let ref mut fresh0 = *b_0.offset(i_0 as isize);\n                *fresh0 = xmalloc(8192 as libc::c_int as size_t) as *mut libc::c_char;\n                n_alloc = i_0.wrapping_add(1 as libc::c_int as libc::c_ulong);\n            }\n            n_read_0 = full_read(\n                fd,\n                *b_0.offset(i_0 as isize) as *mut libc::c_void,\n                8192 as libc::c_int as size_t,\n            );\n            if n_read_0 < 8192 as libc::c_int as libc::c_ulong {\n                if *__errno_location() != 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, filename),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, filename),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, filename),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                    current_block_69 = 10121186216371937393;\n                    break;\n                } else {\n                    eof_0 = 1 as libc::c_int != 0;\n                }\n            }\n            if i_0.wrapping_add(1 as libc::c_int as libc::c_ulong) == n_bufs {\n                buffered_enough = 1 as libc::c_int != 0;\n            }\n            if buffered_enough {\n                desired_pos = (desired_pos as libc::c_ulong).wrapping_add(n_read_0)\n                    as uintmax_t as uintmax_t;\n                xwrite_stdout(*b_0.offset(i_next as isize), n_read_0);\n            }\n            i_0 = i_next;\n            i_next = i_next\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                .wrapping_rem(n_bufs);\n        }\n\n     match current_block_69 {\n    10753070352654377903 => {\n        if rem != 0 {\n            if buffered_enough {\n                let n_bytes_left_in_b_i: usize = 8192 - n_read_0 as usize;\n                desired_pos = desired_pos.wrapping_add(rem);\n                if rem < n_bytes_left_in_b_i as u64 {\n                    xwrite_stdout((*b_0.offset(i_0 as isize)).offset(n_read_0 as isize), rem);\n                } else {\n                    xwrite_stdout((*b_0.offset(i_0 as isize)).offset(n_read_0 as isize), n_bytes_left_in_b_i as u64);\n                    xwrite_stdout(*b_0.offset(i_next as isize), rem.wrapping_sub(n_bytes_left_in_b_i as u64));\n                }\n            } else if i_0 + 1 == n_bufs {\n                let y: usize = 8192 - rem as usize;\n                let x: usize = n_read_0 as usize - y;\n                desired_pos = desired_pos.wrapping_add(x as u64);\n                xwrite_stdout(*b_0.offset(i_next as isize), x as u64);\n            }\n        }\n    }\n    _ => {}\n}\n\nfor i in 0..n_alloc {\n    free(*b_0.offset(i as isize) as *mut libc::c_void);\n}\nfree(b_0 as *mut libc::c_void);\n\n\n}\n\nif current_pos >= 0 && elseek(fd, desired_pos as i64, 0, filename) < 0 {\n    ok = false;\n}\n\nok\n\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\head.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn elide_tail_bytes_file(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_elide: uintmax_t,\n    mut st: *const stat,\n    mut current_pos: off_t,\n) -> bool {\n    let mut size: off_t = (*st).st_size;\n    if presume_input_pipe as libc::c_int != 0\n        || current_pos < 0 as libc::c_int as libc::c_long\n        || size\n            <= (if (0 as libc::c_int) < (*st).st_blksize\n                && (*st).st_blksize as libc::c_ulong\n                    <= (-(1 as libc::c_int) as size_t)\n                        .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            {\n                (*st).st_blksize\n            } else {\n                512 as libc::c_int\n            }) as libc::c_long\n    {\n        return elide_tail_bytes_pipe(filename, fd, n_elide, current_pos)\n    } else {\n        let mut diff: off_t = size - current_pos;\n        let mut bytes_remaining: off_t = if diff < 0 as libc::c_int as libc::c_long {\n            0 as libc::c_int as libc::c_long\n        } else {\n            diff\n        };\n        if bytes_remaining as libc::c_ulong <= n_elide {\n            return 1 as libc::c_int != 0;\n        }\n        let bytes_to_copy = (bytes_remaining as libc::c_ulong).wrapping_sub(n_elide);\nlet err: Copy_fd_status = copy_fd(fd, bytes_to_copy);\n        if err as libc::c_uint == COPY_FD_OK as libc::c_int as libc::c_uint {\n            return 1 as libc::c_int != 0;\n        }\n        diagnose_copy_fd_failure(err, filename);\n        return 0 as libc::c_int != 0;\n    };\n}\nunsafe extern \"C\" fn elide_tail_lines_pipe(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_elide: uintmax_t,\n    mut current_pos: off_t,\n) -> bool {\n    let mut desired_pos: uintmax_t = current_pos as uintmax_t;\n    let mut first: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut last: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut tmp: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut total_lines: size_t = 0 as libc::c_int as size_t;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut n_read: size_t = 0;\n    last = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong) as *mut LBUFFER;\n    first = last;\n    (*first).nlines = 0 as libc::c_int as size_t;\n    (*first).nbytes = (*first).nlines;\n    (*first).next = 0 as *mut linebuffer;\n    tmp = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong) as *mut LBUFFER;\n    loop {\n        n_read = safe_read(\n            fd,\n            ((*tmp).buffer).as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if n_read == 0 as libc::c_int as libc::c_ulong\n            || n_read == -(1 as libc::c_int) as size_t\n        {\n            break;\n        }\n        if n_elide == 0 {\n            desired_pos = (desired_pos as libc::c_ulong).wrapping_add(n_read)\n                as uintmax_t as uintmax_t;\n            xwrite_stdout(((*tmp).buffer).as_mut_ptr(), n_read);\n        } else {\n            (*tmp).nbytes = n_read;\n            (*tmp).nlines = 0 as libc::c_int as size_t;\n            (*tmp).next = 0 as *mut linebuffer;\n            let mut buffer_end: *mut libc::c_char = ((*tmp).buffer)\n                .as_mut_ptr()\n                .offset(n_read as isize);\n            *buffer_end = line_end;\n            let mut p: *const libc::c_char = ((*tmp).buffer).as_mut_ptr();\n            loop {\n                p = rawmemchr(p as *const libc::c_void, line_end as libc::c_int)\n                    as *const libc::c_char;\n                if !(p < buffer_end as *const libc::c_char) {\n                    break;\n                }\n                p = p.offset(1);\n                p;\n                (*tmp).nlines = ((*tmp).nlines).wrapping_add(1);\n                (*tmp).nlines;\n            }\n            total_lines = (total_lines as libc::c_ulong).wrapping_add((*tmp).nlines)\n                as size_t as size_t;\n            if ((*tmp).nbytes).wrapping_add((*last).nbytes)\n                < 8192 as libc::c_int as libc::c_ulong\n            {\n                memcpy(\n                    &mut *((*last).buffer).as_mut_ptr().offset((*last).nbytes as isize)\n                        as *mut libc::c_char as *mut libc::c_void,\n                    ((*tmp).buffer).as_mut_ptr() as *const libc::c_void,\n                    (*tmp).nbytes,\n                );\n                (*last)\n                    .nbytes = ((*last).nbytes as libc::c_ulong)\n                    .wrapping_add((*tmp).nbytes) as size_t as size_t;\n                (*last)\n                    .nlines = ((*last).nlines as libc::c_ulong)\n                    .wrapping_add((*tmp).nlines) as size_t as size_t;\n            } else {\n                (*last).next = tmp;\n                last = (*last).next;\n                if n_elide < total_lines.wrapping_sub((*first).nlines) {\n                    desired_pos = (desired_pos as libc::c_ulong)\n                        .wrapping_add((*first).nbytes) as uintmax_t as uintmax_t;\n                    xwrite_stdout(((*first).buffer).as_mut_ptr(), (*first).nbytes);\n                    tmp = first;\n                    total_lines = (total_lines as libc::c_ulong)\n                        .wrapping_sub((*first).nlines) as size_t as size_t;\n                    first = (*first).next;\n                } else {\n                    tmp = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong)\n                        as *mut LBUFFER;\n                }\n            }\n        }\n    }\n    free(tmp as *mut libc::c_void);\n    if n_read == u64::MAX {\n    error(\n        0,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        gettext(filename),\n    );\n    ok = false;\n} else {\n    if unsafe { (*last).nbytes } != 0 && unsafe { (*last).buffer[(*last).nbytes as usize - 1] } != line_end {\n        unsafe { (*last).nlines += 1 };\n        total_lines += 1;\n    }\n    let mut tmp = first;\n    while n_elide < total_lines - unsafe { (*tmp).nlines } {\n        desired_pos += unsafe { (*tmp).nbytes };\n        xwrite_stdout(unsafe { (*tmp).buffer.as_ptr() }, unsafe { (*tmp).nbytes });\n        total_lines -= unsafe { (*tmp).nlines };\n        tmp = unsafe { (*tmp).next };\n    }\n    if n_elide < total_lines {\n        let mut n = total_lines - n_elide;\n        let buffer_end = unsafe { &(*tmp).buffer[(*tmp).nbytes as usize..] };\n        let mut p = unsafe { &(*tmp).buffer[..] };\n        while n != 0 && p.iter().position(|&x| x == line_end).is_some() {\n            p = &p[1..];\n            unsafe { (*tmp).nlines += 1 };\n            n -= 1;\n        }\n        desired_pos += p.as_ptr().offset_from(unsafe { (*tmp).buffer.as_ptr() }) as u64;\n        xwrite_stdout(unsafe { (*tmp).buffer.as_ptr() }, p.as_ptr().offset_from(unsafe { (*tmp).buffer.as_ptr() }) as u64);\n    }\n}\nwhile !first.is_null() {\n    let next = unsafe { (*first).next };\n    free(first as *mut libc::c_void);\n    first = next;\n}\nif current_pos >= 0 && elseek(fd, desired_pos as i64, 0, filename) < 0 {\n    ok = false;\n}\nok\n\n}\nunsafe extern \"C\" fn elide_tail_lines_seekable(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_lines: uintmax_t,\n    mut start_pos: off_t,\n    mut size: off_t,\n) -> bool {\n    let mut buffer: [i8; 8192] = [0; 8192];\nlet mut bytes_read: u64 = 0;\nlet mut pos: i64 = size;\nbytes_read = ((pos - start_pos) % 8192) as u64;\nif bytes_read == 0 {\n    bytes_read = 8192;\n}\npos -= bytes_read as i64;\n\nif elseek(fd, pos, 0, pretty_filename) < 0 {\n    return false;\n}\n\nbytes_read = safe_read(fd, buffer.as_mut_ptr() as *mut libc::c_void, bytes_read);\nif bytes_read == u64::MAX {\n    error(\n        0,\n        *__errno_location(),\n        gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n    );\n    return false;\n}\n\nlet all_lines: bool = n_lines == 0;\nif n_lines != 0 && bytes_read != 0\n    && buffer[bytes_read.wrapping_sub(1) as usize] != line_end\n{\n    n_lines = n_lines.wrapping_sub(1);\n}\n\n    loop {\n    let mut n: usize = bytes_read as usize;\n    while n != 0 {\n        if all_lines {\n            n = n.wrapping_sub(1);\n        } else {\n            if let Some(nl) = buffer[..n as usize].iter().rposition(|&x| x == line_end as i8) {\n                n = nl;\n            } else {\n                break;\n            }\n        }\n        let fresh1 = n_lines;\n        n_lines = n_lines.wrapping_sub(1);\n        if fresh1 == 0 {\n            if start_pos < pos {\n                let mut err: Copy_fd_status = COPY_FD_OK;\n                if elseek(fd, start_pos, 0, pretty_filename) < 0 {\n                    return false;\n                }\n                err = copy_fd(fd, (pos - start_pos) as u64);\n                if err as u32 != COPY_FD_OK as i32 as u32 {\n                    diagnose_copy_fd_failure(err, pretty_filename);\n                    return false;\n                }\n            }\n            xwrite_stdout(buffer.as_ptr(), (n + 1) as u64);\n            return elseek(fd, (pos as u64 + n as u64 + 1) as i64, 0, pretty_filename) <= 0;\n        }\n    }\n    if pos == start_pos {\n        return true;\n    }\n    pos -= 8192;\n    if elseek(fd, pos, 0, pretty_filename) < 0 {\n        return false;\n    }\n    bytes_read = safe_read(fd, buffer.as_mut_ptr() as *mut libc::c_void, 8192);\n    if bytes_read == usize::MAX.try_into().unwrap() {\n        error(\n            0,\n            *__errno_location(),\n            gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n            quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n        );\n        return false;\n    }\n    if bytes_read == 0 {\n        return true;\n    }\n}\n\n}\nunsafe extern \"C\" fn elide_tail_lines_file(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_elide: uintmax_t,\n    mut st: *const stat,\n    mut current_pos: off_t,\n) -> bool {\n    let mut size: off_t = (*st).st_size;\n    if presume_input_pipe as libc::c_int != 0\n        || current_pos < 0 as libc::c_int as libc::c_long\n        || size\n            <= (if (0 as libc::c_int) < (*st).st_blksize\n                && (*st).st_blksize as libc::c_ulong\n                    <= (-(1 as libc::c_int) as size_t)\n                        .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            {\n                (*st).st_blksize\n            } else {\n                512 as libc::c_int\n            }) as libc::c_long\n    {\n        return elide_tail_lines_pipe(filename, fd, n_elide, current_pos)\n    } else {\n        return size <= current_pos\n            || elide_tail_lines_seekable(filename, fd, n_elide, current_pos, size)\n                as libc::c_int != 0\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\head.rs"
    },
    {
      "chunk": "fn head_bytes(\n    filename: &CStr,\n    fd: std::os::unix::io::RawFd,\n    mut bytes_to_write: u64,\n) -> bool {\n    let mut buffer = [0; 8192];\n    let mut bytes_to_read = buffer.len() as u64;\n\n    while bytes_to_write != 0 {\n        if bytes_to_write < bytes_to_read {\n            bytes_to_read = bytes_to_write;\n        }\n\n        let bytes_read = unsafe {\n            safe_read(fd, buffer.as_mut_ptr() as *mut libc::c_void, bytes_to_read)\n        };\n\n        if bytes_read == !(0 as libc::c_int) as u64 {\n            let errno = unsafe { *__errno_location() };\n            unsafe {\n                error(\n                    0,\n                    errno,\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename.as_ptr()),\n                );\n            }\n            return false;\n        }\n\n        if bytes_read == 0 {\n            break;\n        }\n\n        std::io::stdout().write_all(&buffer[..bytes_read as usize]).unwrap();\n        bytes_to_write -= bytes_read;\n    }\n    true\n}\nunsafe extern \"C\" fn head_lines(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut lines_to_write: uintmax_t,\n) -> bool {\n    let mut buffer: [libc::c_char; 8192] = [0; 8192];\n    while lines_to_write != 0 {\n        let mut bytes_read: size_t = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        let mut bytes_to_write: size_t = 0 as libc::c_int as size_t;\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n        if bytes_read == 0 as libc::c_int as libc::c_ulong {\n            break;\n        }\n        while bytes_to_write < bytes_read {\n            let fresh2 = bytes_to_write;\n            bytes_to_write = bytes_to_write.wrapping_add(1);\n            if !(buffer[fresh2 as usize] as libc::c_int == line_end as libc::c_int\n                && {\n                    lines_to_write = lines_to_write.wrapping_sub(1);\n                    lines_to_write == 0 as libc::c_int as libc::c_ulong\n                })\n            {\n                continue;\n            }\n            let mut n_bytes_past_EOL: off_t = bytes_read.wrapping_sub(bytes_to_write)\n                as off_t;\n            if lseek(fd, -n_bytes_past_EOL, 1 as libc::c_int)\n                < 0 as libc::c_int as libc::c_long\n            {\n                let mut st: stat = stat {\n                    st_dev: 0,\n                    st_ino: 0,\n                    st_mode: 0,\n                    st_nlink: 0,\n                    st_uid: 0,\n                    st_gid: 0,\n                    st_rdev: 0,\n                    __pad1: 0,\n                    st_size: 0,\n                    st_blksize: 0,\n                    __pad2: 0,\n                    st_blocks: 0,\n                    st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    __glibc_reserved: [0; 2],\n                };\n                if fstat(fd, &mut st) != 0 as libc::c_int\n                    || st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                        == 0o100000 as libc::c_int as libc::c_uint\n                {\n                    elseek(fd, -n_bytes_past_EOL, 1 as libc::c_int, filename);\n                }\n            }\n            break;\n        }\n        xwrite_stdout(buffer.as_mut_ptr(), bytes_to_write);\n    }\n    return 1 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn head(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_units: uintmax_t,\n    mut count_lines: bool,\n    mut elide_from_end: bool,\n) -> bool {\n    if print_headers {\n        let filename_str = unsafe { CStr::from_ptr(filename).to_string_lossy().into_owned() };\nwrite_header(&filename_str);\n    }\n    if elide_from_end {\n        let mut current_pos: off_t = -(1 as libc::c_int) as off_t;\n        let mut st: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        if fstat(fd, &mut st) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n        if !presume_input_pipe && usable_st_size(&mut st) as libc::c_int != 0 {\n            current_pos = elseek(\n                fd,\n                0 as libc::c_int as off_t,\n                1 as libc::c_int,\n                filename,\n            );\n            if current_pos < 0 as libc::c_int as libc::c_long {\n                return 0 as libc::c_int != 0;\n            }\n        }\n        if count_lines {\n            return elide_tail_lines_file(filename, fd, n_units, &mut st, current_pos)\n        } else {\n            return elide_tail_bytes_file(filename, fd, n_units, &mut st, current_pos)\n        }\n    }\n    if count_lines {\n        return head_lines(filename, fd, n_units)\n    } else {\n    let filename_cstr = CStr::from_ptr(filename);\n    return head_bytes(filename_cstr, fd, n_units.try_into().unwrap());\n};\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\head.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn head_file(\n    mut filename: *const libc::c_char,\n    mut n_units: uintmax_t,\n    mut count_lines: bool,\n    mut elide_from_end: bool,\n) -> bool {\n    let mut fd: libc::c_int = 0;\n    let mut ok: bool = false;\n    let mut is_stdin: bool = strcmp(filename, b\"-\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int;\n    if is_stdin {\n        have_read_stdin = 1 as libc::c_int != 0;\n        fd = 0 as libc::c_int;\n        filename = gettext(b\"standard input\\0\" as *const u8 as *const libc::c_char);\n        let fd2: i32 = 0;\nlet mode2: i32 = 0;\nxset_binary_mode(fd2, mode2);\n    } else {\n        fd = open(filename, 0 as libc::c_int | 0 as libc::c_int);\n        if fd < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open %s for reading\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot open %s for reading\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot open %s for reading\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n    }\n    ok = head(filename, fd, n_units, count_lines, elide_from_end);\n    if !is_stdin && close(fd) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"failed to close %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to close %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to close %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    return ok;\n}\nfn string_to_integer(count_lines: bool, n_string: &CStr) -> u64 {\n    let max_value = 18446744073709551615u64;\n    let error_message = if count_lines {\n        unsafe { gettext(b\"invalid number of lines\\0\" as *const u8 as *const libc::c_char) }\n    } else {\n        unsafe { gettext(b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char) }\n    };\n\n    unsafe {\n        xdectoumax(\n            n_string.as_ptr(),\n            0,\n            max_value,\n            b\"bkKmMGTPEZYRQ0\\0\" as *const u8 as *const libc::c_char,\n            error_message,\n            0,\n        )\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\head.rs"
    },
    {
      "chunk": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut header_mode: header_mode = multiple_files;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut c: libc::c_int = 0;\n    let mut i: size_t = 0;\n    let mut n_units: uintmax_t = 10 as libc::c_int as uintmax_t;\n    let mut count_lines: bool = 1 as libc::c_int != 0;\n    let mut elide_from_end: bool = 0 as libc::c_int != 0;\n    static mut default_file_list: [*const libc::c_char; 2] = [\n        b\"-\\0\" as *const u8 as *const libc::c_char,\n        0 as *const libc::c_char,\n    ];\n    let mut file_list: *const *const libc::c_char = 0 as *const *const libc::c_char;\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    have_read_stdin = 0 as libc::c_int != 0;\n    print_headers = 0 as libc::c_int != 0;\n    line_end = '\\n' as i32 as libc::c_char;\n    if (1 as libc::c_int) < argc\n        && *(*argv.offset(1 as libc::c_int as isize)).offset(0 as libc::c_int as isize)\n            as libc::c_int == '-' as i32\n        && (*(*argv.offset(1 as libc::c_int as isize)).offset(1 as libc::c_int as isize)\n            as libc::c_uint)\n            .wrapping_sub('0' as i32 as libc::c_uint) <= 9 as libc::c_int as libc::c_uint\n    {\n        let mut a: *mut libc::c_char = *argv.offset(1 as libc::c_int as isize);\n        a = a.offset(1);\n        let mut n_string: *mut libc::c_char = a;\n        let mut end_n_string: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut multiplier_char: libc::c_char = 0 as libc::c_int as libc::c_char;\n        loop {\n            a = a.offset(1);\n            a;\n            if !((*a as libc::c_uint).wrapping_sub('0' as i32 as libc::c_uint)\n                <= 9 as libc::c_int as libc::c_uint)\n            {\n                break;\n            }\n        }\n        end_n_string = a;\n        while *a != 0 {\n            match *a as libc::c_int {\n                99 => {\n                    count_lines = 0 as libc::c_int != 0;\n                    multiplier_char = 0 as libc::c_int as libc::c_char;\n                }\n                98 | 107 | 109 => {\n                    count_lines = 0 as libc::c_int != 0;\n                    multiplier_char = *a;\n                }\n                108 => {\n                    count_lines = 1 as libc::c_int != 0;\n                }\n                113 => {\n                    header_mode = never;\n                }\n                118 => {\n                    header_mode = always;\n                }\n                122 => {\n                    line_end = '\\0' as i32 as libc::c_char;\n                }\n                _ => {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"invalid trailing option -- %c\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            *a as libc::c_int,\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid trailing option -- %c\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                *a as libc::c_int,\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid trailing option -- %c\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                *a as libc::c_int,\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n            }\n            a = a.offset(1);\n            a;\n        }\n        *end_n_string = multiplier_char;\n        if multiplier_char != 0 {\n            end_n_string = end_n_string.offset(1);\n            *end_n_string = 0 as libc::c_int as libc::c_char;\n        }\n        let n_string_ref = unsafe { CStr::from_ptr(n_string) };\nn_units = string_to_integer(count_lines, n_string_ref);\n        let ref mut fresh3 = *argv.offset(1 as libc::c_int as isize);\n        *fresh3 = *argv.offset(0 as libc::c_int as isize);\n        argv = argv.offset(1);\n        argv;\n        argc -= 1;\n        argc;\n    }\n    loop {\n    c = getopt_long(\n        argc,\n        argv,\n        b\"c:n:qvz0123456789\\0\" as *const u8 as *const libc::c_char,\n        long_options.as_ptr(),\n        std::ptr::null_mut::<libc::c_int>(),\n    );\n    if c == -1 {\n        break;\n    }\n    let optarg_str = unsafe { std::ffi::CStr::from_ptr(optarg) };\n    match c {\n        256 => {\n            presume_input_pipe = true;\n        }\n        99 => {\n            count_lines = false;\n            elide_from_end = optarg_str.to_bytes().starts_with(b\"-\");\n            if elide_from_end {\n                optarg = optarg.add(1);\n            }\n            n_units = string_to_integer(count_lines, unsafe { std::ffi::CStr::from_ptr(optarg) });\n        }\n        110 => {\n            count_lines = true;\n            elide_from_end = optarg_str.to_bytes().starts_with(b\"-\");\n            if elide_from_end {\n                optarg = optarg.add(1);\n            }\n            n_units = string_to_integer(count_lines, unsafe { std::ffi::CStr::from_ptr(optarg) });\n        }\n        113 => {\n            header_mode = never;\n        }\n        118 => {\n            header_mode = always;\n        }\n        122 => {\n            line_end = '\\0' as i32 as libc::c_char;\n        }\n        -2 => {\n            usage(0);\n        }\n        -3 => {\n            version_etc(\n                stdout,\n                b\"head\\0\" as *const u8 as *const libc::c_char,\n                b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                Version,\n                proper_name_lite(\n                    b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                    b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                ),\n                proper_name_lite(\n                    b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                    b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                ),\n                std::ptr::null_mut::<libc::c_void>(),\n            );\n            std::process::exit(0);\n        }\n        _ => {\n            if (c as u32).wrapping_sub('0' as i32 as u32) <= 9 {\n                error(\n                    0,\n                    0,\n                    gettext(b\"invalid trailing option -- %c\\0\" as *const u8 as *const libc::c_char),\n                );\n            } else {\n                usage(1);\n            }\n        }\n    }\n}\nif header_mode == always || (header_mode == multiple_files && optind < argc - 1) {\n    print_headers = true;\n}\n\n    if !count_lines && elide_from_end as libc::c_int != 0\n        && ((if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n            -(1 as libc::c_int) as off_t\n        } else {\n            (((1 as libc::c_int as off_t)\n                << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        }) as libc::c_ulong) < n_units\n    {\n        let mut umax_buf: [libc::c_char; 21] = [0; 21];\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                75 as libc::c_int,\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                gettext(\n                    b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote(umaxtostr(n_units, umax_buf.as_mut_ptr())),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    75 as libc::c_int,\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(\n                        b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(umaxtostr(n_units, umax_buf.as_mut_ptr())),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    75 as libc::c_int,\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(\n                        b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(umaxtostr(n_units, umax_buf.as_mut_ptr())),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    file_list = if optind < argc {\n        &mut *argv.offset(optind as isize) as *mut *mut libc::c_char\n            as *const *const libc::c_char\n    } else {\n        default_file_list.as_ptr()\n    };\n    let fd1: i32 = 1;\nlet mode1: i32 = 0;\nxset_binary_mode(fd1, mode1);\n    i = 0 as libc::c_int as size_t;\n    while !(*file_list.offset(i as isize)).is_null() {\n        ok = (ok as libc::c_int\n            & head_file(\n                *file_list.offset(i as isize),\n                n_units,\n                count_lines,\n                elide_from_end,\n            ) as libc::c_int) != 0;\n        i = i.wrapping_add(1);\n        i;\n    }",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\head.rs"
    },
    {
      "chunk": "    if have_read_stdin as libc::c_int != 0 && close(0 as libc::c_int) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"-\\0\" as *const u8 as *const libc::c_char,\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    return if ok as libc::c_int != 0 { 0 as libc::c_int } else { 1 as libc::c_int };\n}\npub fn main() {\n    let args: Vec<CString> = ::std::env::args()\n        .map(|arg| CString::new(arg).expect(\"Failed to convert argument into CString\"))\n        .collect();\n    \n    let argc = args.len() as libc::c_int;\n    let argv: Vec<*mut libc::c_char> = args.iter()\n        .map(|arg| arg.as_ptr() as *mut libc::c_char)\n        .chain(std::iter::once(std::ptr::null_mut()))\n        .collect();\n    \n    let result = unsafe {\n        main_0(argc, argv.as_ptr() as *mut *mut libc::c_char)\n    };\n    ::std::process::exit(result as i32);\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\head.rs"
    },
    {
      "chunk": "use std::option::Option;\nuse std::mem;\nuse std::vec::Vec;\nuse std::alloc;\nuse std::ptr;\nuse ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn ireallocarray(\n    p: &mut Vec<u8>,\n    n: idx_t,\n    s: idx_t,\n) -> Option<&mut Vec<u8>> {\n    if n as usize <= usize::MAX && s as usize <= usize::MAX {\n        let mut nx: usize = n as usize;\n        let mut sx: usize = s as usize;\n        if n == 0 || s == 0 {\n            sx = 1;\n            nx = sx;\n        }\n        p.resize(nx * sx, 0);\n        Some(p)\n    } else {\n        unsafe {\n            _gl_alloc_nomem();\n        }\n        None\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn icalloc(n: usize, s: usize) -> Option<Vec<u8>> {\n    if n > usize::MAX / s {\n        if s != 0 {\n            return None; // _gl_alloc_nomem();\n        }\n        return Some(Vec::new());\n    }\n    if s > usize::MAX / n {\n        if n != 0 {\n            return None; // _gl_alloc_nomem();\n        }\n        return Some(Vec::new());\n    }\n    let total_size = n * s;\n    let mut vec = Vec::with_capacity(total_size);\n    unsafe {\n        // This is safe because we are allocating a Vec, which guarantees the memory is valid.\n        let ptr = vec.as_mut_ptr();\n        std::mem::forget(vec); // Prevent Vec from deallocating the memory\n        Some(Vec::from_raw_parts(ptr, total_size, total_size))\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn irealloc(p: Option<&mut [u8]>, s: usize) -> Option<Vec<u8>> {\n    if s <= usize::MAX {\n        let new_size = if s == 0 { 0 } else { s };\n        let mut vec = match p {\n            Some(slice) => {\n                let mut new_vec = Vec::with_capacity(new_size);\n                new_vec.extend_from_slice(slice);\n                new_vec\n            },\n            None => Vec::with_capacity(new_size),\n        };\n        vec.resize(new_size, 0);\n        Some(vec)\n    } else {\n        None // Assuming _gl_alloc_nomem() returns None in this context\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn imalloc(s: idx_t) -> Option<Box<[u8]>> {\n    if s as usize <= usize::MAX {\n        let layout = std::alloc::Layout::from_size_align(s as usize, 1).ok()?;\n        let ptr = unsafe { std::alloc::alloc(layout) };\n        if ptr.is_null() {\n            None\n        } else {\n            Some(unsafe { Box::from_raw(std::slice::from_raw_parts_mut(ptr, s as usize)) })\n        }\n    } else {\n        None // Assuming _gl_alloc_nomem() returns a null pointer, we return None here.\n    }\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\ialloc.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse std::os::raw::c_char;\nuse ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "pub const _NL_WAM_STR: C2RustUnnamed = 131162;\npub const _NL_WMON_12: C2RustUnnamed = 131161;\npub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub fn locale_charset() -> String {\n    let codeset_ptr: *const libc::c_char = unsafe { nl_langinfo(CODESET as libc::c_int) };\n    let codeset = unsafe { CStr::from_ptr(codeset_ptr) };\n    \n    if codeset.to_bytes().is_empty() {\n        return \"ASCII\".to_string();\n    }\n    \n    codeset.to_string_lossy().into_owned()\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nfn mbszero(ps: &mut mbstate_t) {\n    let size = std::mem::size_of::<mbstate_t>();\n    let bytes: &mut [u8] = unsafe { std::slice::from_raw_parts_mut(ps as *mut _ as *mut u8, size) };\n    for byte in bytes.iter_mut() {\n        *byte = 0;\n    }\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(&mut *ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\mbrtoc32.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\mbszero.rs"
    },
    {
      "chunk": "use ::libc;\npub type __off_t = libc::c_long;\npub type off_t = __off_t;\n#[no_mangle]\npub fn offtostr(i: off_t, buf: &mut [libc::c_char]) -> &mut [libc::c_char] {\n    let mut p = buf.len() as isize - 1;\n    buf[p as usize] = 0;\n\n    let mut num = i;\n    if num < 0 {\n        num = -num;\n        loop {\n            p -= 1;\n            buf[p as usize] = ('0' as i32 - (num % 10) as i32) as libc::c_char;\n            num /= 10;\n            if num == 0 {\n                break;\n            }\n        }\n        p -= 1;\n        buf[p as usize] = '-' as i32 as libc::c_char;\n    } else {\n        loop {\n            p -= 1;\n            buf[p as usize] = ('0' as i32 + (num % 10) as i32) as libc::c_char;\n            num /= 10;\n            if num == 0 {\n                break;\n            }\n        }\n    }\n    &mut buf[p as usize..]\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\offtostr.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\progname.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\propername_lite.rs"
    },
    {
      "chunk": "use std::os::raw::c_int;\nuse std::vec::Vec;\nuse std::option::Option;\nuse std::clone::Clone;\nuse std::mem;\nuse std::io;\nuse std::ffi::CStr;\nuse std::ffi::CString;\nuse std::os::raw::c_char;\nuse std::convert::TryInto;\nuse ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nfn c32isprint(wc: wint_t) -> libc::c_int {\n    unsafe { iswprint(wc) }\n}\n#[inline]\nfn mbszero(ps: &mut mbstate_t) {\n    *ps = mbstate_t {\n        __count: 0,\n        __value: unsafe { std::mem::zeroed() }, // Using zeroed to initialize __value\n    };\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub fn clone_quoting_options(o: Option<&quoting_options>) -> quoting_options {\n    let options = o.unwrap_or_else(|| unsafe { &default_quoting_options });\n    options.clone()\n}\n#[no_mangle]\npub fn get_quoting_style(o: Option<&quoting_options>) -> quoting_style {\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &default_quoting_options },\n    };\n    options.style\n}\n#[no_mangle]\npub fn set_quoting_style(\n    o: Option<&mut quoting_options>,\n    s: quoting_style,\n) {\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &mut default_quoting_options },\n    };\n    options.style = s;\n}\n#[no_mangle]\npub fn set_char_quoting(\n    o: Option<&mut quoting_options>,\n    c: char,\n    i: i32,\n) -> i32 {\n    let uc: u8 = c as u8;\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &mut default_quoting_options },\n    };\n    let index = (uc as usize) / (std::mem::size_of::<u32>() * 8);\n    let shift = (uc as usize) % (std::mem::size_of::<u32>() * 8);\n    \n    let p = &mut options.quote_these_too[index];\n    let r = (*p >> shift & 1) as i32;\n    *p ^= ((i & 1 ^ r) << shift) as u32;\n    \n    r\n}\n#[no_mangle]\npub fn set_quoting_flags(\n    mut o: Option<&mut quoting_options>,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    let options = match o {\n        Some(ref mut opt) => opt,\n        None => unsafe { &mut default_quoting_options },\n    };\n    r = options.flags;\n    options.flags = i;\n    return r;\n}\n#[no_mangle]\npub fn set_custom_quoting(\n    mut o: Option<&mut quoting_options>,\n    left_quote: &str,\n    right_quote: &str,\n) {\n    let o = o.get_or_insert_with(|| {\n        // Create a mutable reference to the default quoting options\n        unsafe { &mut default_quoting_options }\n    });\n    o.style = custom_quoting_style;\n\n    if left_quote.is_empty() || right_quote.is_empty() {\n        panic!(\"Quotes cannot be null\");\n    }\n\n    o.left_quote = CString::new(left_quote).expect(\"CString::new failed\").into_raw();\n    o.right_quote = CString::new(right_quote).expect(\"CString::new failed\").into_raw();\n}\nfn quoting_options_from_style(style: quoting_style) -> quoting_options {\n    if style == custom_quoting_style {\n        panic!(\"Custom quoting style is not allowed\");\n    }\n    \n    quoting_options {\n        style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: std::ptr::null(),\n        right_quote: std::ptr::null(),\n    }\n}\nfn gettext_quote(msgid: &str, s: quoting_style) -> String {\n    let translation_ptr = unsafe { gettext(msgid.as_ptr() as *const libc::c_char) };\n    let translation = unsafe { std::ffi::CStr::from_ptr(translation_ptr).to_string_lossy().into_owned() };\n    let locale_code_ptr = unsafe { locale_charset() };\n    let locale_code = unsafe { std::ffi::CStr::from_ptr(locale_code_ptr).to_string_lossy().into_owned() };\n\n    if translation != msgid {\n        return translation;\n    }\n\n    if locale_code.eq_ignore_ascii_case(\"UTF-8\") {\n        return if msgid.chars().next() == Some('`') {\n            \"\\u{2018}\".to_string() // Left single quotation mark\n        } else {\n            \"\\u{2019}\".to_string() // Right single quotation mark\n        };\n    }\n\n    if locale_code.eq_ignore_ascii_case(\"GB18030\") {\n        return if msgid.chars().next() == Some('`') {\n            \"\\u{A1}e\".to_string() // Specific character for GB18030\n        } else {\n            \"\\u{A1}AF\".to_string() // Specific character for GB18030\n        };\n    }\n\n    if s as u32 == clocale_quoting_style as u32 {\n        return \"\\\"\".to_string(); // Double quote\n    } else {\n        return \"'\".to_string(); // Single quote\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    let left_quote = gettext_quote(\n    \"`\",\n    quoting_style,\n);\n                    let right_quote = gettext_quote(\n    \"'\",\n    quoting_style,\n);\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    escaping = true;\n    if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '\\'' as i8 };\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '$' as i8 };\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '\\'' as i8 };\n        }\n        len += 1;\n        pending_shell_escape_end = true;\n    }\n    if len < buffersize {\n        unsafe { *buffer.offset(len as isize) = '\\\\' as i8 };\n    }\n    len += 1;\n    if quoting_style != shell_always_quoting_style\n        && i + 1 < argsize\n        && ('0' as i8 <= unsafe { *arg.offset((i + 1) as isize) } && unsafe { *arg.offset((i + 1) as isize) } <= '9' as i8)\n    {\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '0' as i8 };\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '0' as i8 };\n        }\n        len += 1;\n    }\n    c = '0' as u8;\n    current_block = 253337042034819032;\n} else if (flags & QA_ELIDE_NULL_BYTES as i32) != 0 {\n    current_block = 13619784596304402172;\n} else {\n    current_block = 253337042034819032;\n}\n\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    current_block = 4476262310586904498;\n} else if backslash_escapes && elide_outer_quotes && quote_string_len != 0 {\n    current_block = 4476262310586904498;\n} else {\n    current_block = 9215498979640025612;\n}\n\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = true;\nc_and_shell_quote_compat = true;\n\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    if buffersize != 0 && orig_buffersize == 0 {\n        orig_buffersize = buffersize;\n        buffersize = 0;\n    }\n    if len < buffersize {\n        let byte_buffer = unsafe { std::slice::from_raw_parts_mut(buffer, buffersize as usize) };\n        byte_buffer[len as usize] = '\\'' as i8;\n    }\n    len = len.wrapping_add(1);\n    \n    if len < buffersize {\n        let byte_buffer = unsafe { std::slice::from_raw_parts_mut(buffer, buffersize as usize) };\n        byte_buffer[len as usize] = '\\\\' as i8;\n    }\n    len = len.wrapping_add(1);\n    \n    if len < buffersize {\n        let byte_buffer = unsafe { std::slice::from_raw_parts_mut(buffer, buffersize as usize) };\n        byte_buffer[len as usize] = '\\'' as i8;\n    }\n    len = len.wrapping_add(1);\n    \n    pending_shell_escape_end = false;\n    current_block = 253337042034819032;\n} else {\n    current_block = 253337042034819032;\n}\n\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if m > 1 || (backslash_escapes && !printable) {\n    let ilim = i.wrapping_add(m);\n    let buffer_slice = unsafe { std::slice::from_raw_parts_mut(buffer, buffersize as usize) };\n    loop {\n        if backslash_escapes && !printable {\n            if elide_outer_quotes {\n                current_block = 7928555609993211441;\n                break 's_25;\n            }\n            escaping = true;\n            if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n                if len < buffersize {\n                    buffer_slice[len as usize] = b'\\'' as i8; // Add single quote\n                }\n                len += 1;\n                if len < buffersize {\n                    buffer_slice[len as usize] = b'$' as i8; // Add dollar sign\n                }\n                len += 1;\n                if len < buffersize {\n                    buffer_slice[len as usize] = b'\\'' as i8; // Add single quote\n                }\n                len += 1;\n                pending_shell_escape_end = true;\n            }\n            if len < buffersize {\n                buffer_slice[len as usize] = b'\\\\' as i8; // Add backslash\n            }\n            len += 1;\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as u8 + (c >> 6)) as i8; // Add first octet\n            }\n            len += 1;\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as u8 + ((c >> 3) & 7)) as i8; // Add second octet\n            }\n            len += 1;\n            c = ('0' as u8 + (c & 7)) as u8; // Update c to last octet\n        } else if is_right_quote {\n            if len < buffersize {\n                buffer_slice[len as usize] = b'\\\\' as i8; // Add backslash\n            }\n            len += 1;\n            is_right_quote = false;\n        }\n        if ilim <= i.wrapping_add(1) {\n            break;\n        }\n        if pending_shell_escape_end && !escaping {\n            if len < buffersize {\n                buffer_slice[len as usize] = b'\\'' as i8; // Add single quote",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "            }\n            len += 1;\n            if len < buffersize {\n                buffer_slice[len as usize] = b'\\'' as i8; // Add single quote\n            }\n            len += 1;\n            pending_shell_escape_end = false;\n        }\n        if len < buffersize {\n            buffer_slice[len as usize] = c as i8; // Add current character\n        }\n        len += 1;\n        i += 1;\n        c = unsafe { *arg.offset(i as isize) } as u8; // Update c to next character\n    }\n    current_block = 4476262310586904498;\n} else {\n    current_block = 253337042034819032;\n}\n\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n    return quotearg_buffer_restyled(\n        buffer,\n        orig_buffersize,\n        arg,\n        argsize,\n        c_quoting_style,\n        flags,\n        quote_these_too,\n        left_quote,\n        right_quote,\n    );\n} else {\n    if !(buffersize == 0 && orig_buffersize != 0) {\n        current_block = 6412618891452676311;\n        break;\n    }\n    buffersize = orig_buffersize;\n    len = 0;\n}\n\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub fn quotearg_buffer(\n    buffer: &mut [u8],\n    arg: &[u8],\n    o: Option<&quoting_options>,\n) -> usize {\n    let p: &quoting_options;\n    if let Some(options) = o {\n        p = options;\n    } else {\n        p = unsafe { &default_quoting_options };\n    }\n    \n    let buffersize = buffer.len() as size_t;\n    let argsize = arg.len() as size_t;\n\n    let e = std::io::Error::last_os_error();\n    \n    let r = unsafe {\n        quotearg_buffer_restyled(\n            buffer.as_mut_ptr() as *mut libc::c_char,\n            buffersize,\n            arg.as_ptr() as *const libc::c_char,\n            argsize,\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        )\n    };\n    \n    std::mem::forget(e); // Restore the previous error state if needed\n    r.try_into().unwrap() // Convert u64 to usize\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub fn quotearg_alloc(\n    arg: &CStr,\n    argsize: usize,\n    o: &quoting_options,\n) -> CString {\n    let mut size: size_t = 0; // Use size_t for compatibility with the C function\n    let result_ptr: *mut libc::c_char;\n\n    unsafe {\n        result_ptr = quotearg_alloc_mem(arg.as_ptr(), argsize.try_into().unwrap(), &mut size, o);\n    }\n\n    unsafe { CString::from_raw(result_ptr) } // Convert the raw pointer to CString\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};\nstatic mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub fn quotearg_free() {\n    unsafe {\n        let sv = Vec::from_raw_parts(slotvec, nslots as usize, nslots as usize);\n        for i in 1..nslots {\n            let val = (*sv.get_unchecked(i as usize)).val;\n            drop(Box::from_raw(val)); // Assuming val is a pointer to a type that needs to be dropped\n        }\n        if (*sv.get_unchecked(0)).val != slot0.as_mut_ptr() {\n            let val = (*sv.get_unchecked(0)).val;\n            drop(Box::from_raw(val)); // Assuming val is a pointer to a type that needs to be dropped\n            slotvec0.size = std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n            slotvec0.val = slot0.as_mut_ptr();\n        }\n        if sv.as_ptr() != &slotvec0 as *const _ as *mut _ {\n            drop(sv); // Assuming sv is a type that implements Drop\n            slotvec = &mut slotvec0;\n        }\n        nslots = 1;\n    }\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub fn quotearg_n(n: i32, arg: &CStr) -> *mut libc::c_char {\n    unsafe {\n        let options = &default_quoting_options;\n        quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            u64::MAX,\n            options,\n        )\n    }\n}\n#[no_mangle]\npub fn quotearg_n_mem(\n    n: i32,\n    arg: &str,\n) -> *mut libc::c_char {\n    let arg_cstring = CString::new(arg).expect(\"CString::new failed\");\n    let argsize = arg_cstring.as_bytes().len() as libc::c_ulong; // Convert to u64\n    unsafe {\n        quotearg_n_options(n, arg_cstring.as_ptr(), argsize, &default_quoting_options)\n    }\n}\n#[no_mangle]\npub fn quotearg(arg: &CStr) -> CString {\n    let result = quotearg_n(0, arg);\n    unsafe { CString::from_raw(result) }\n}\n#[no_mangle]\npub fn quotearg_mem(arg: &CStr) -> CString {\n    let arg_str = arg.to_str().expect(\"Failed to convert CStr to &str\");\n    let result = quotearg_n_mem(0, arg_str);\n    unsafe { CString::from_raw(result) }\n}\n#[no_mangle]\npub fn quotearg_n_style(\n    n: i32,\n    s: quoting_style,\n    arg: &str,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    unsafe {\n        quotearg_n_options(n, arg.as_ptr() as *const libc::c_char, u64::MAX, &o)\n    }\n}\n#[no_mangle]\npub fn quotearg_n_style_mem(\n    n: i32,\n    s: quoting_style,\n    arg: &str,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    let arg_len = arg.len() as u64; // Convert to u64\n    unsafe {\n        quotearg_n_options(n, arg.as_ptr() as *const libc::c_char, arg_len, &o)\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let result = quotearg_n_style(0, s, std::ffi::CStr::from_ptr(arg).to_str().unwrap());\nreturn result;\n}\n#[no_mangle]\npub fn quotearg_style_mem(\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let arg_str = arg.to_str().expect(\"Failed to convert CStr to &str\");\n    let result = quotearg_n_style_mem(0, s, arg_str);\n    unsafe { CString::from_raw(result) }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(Some(&mut options), ch as u8 as char, 1);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub fn quotearg_char(arg: &CStr, ch: char) -> *mut c_char {\n    let ch_as_c_char = ch as u8 as c_char;\n    unsafe { quotearg_char_mem(arg.as_ptr(), u64::MAX, ch_as_c_char) }\n}\n#[no_mangle]\npub fn quotearg_colon(arg: &CStr) -> CString {\n    let result_ptr = quotearg_char(arg, ':' as char);\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub fn quotearg_colon_mem(arg: &str) -> String {\n    let argsize = arg.len() as u64;\n    let ch = ':' as i8;\n    let c_string = unsafe { quotearg_char_mem(arg.as_ptr() as *const libc::c_char, argsize, ch) };\n    unsafe { CString::from_raw(c_string).into_string().unwrap() }\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub fn quotearg_n_style_colon(\n    n: i32,\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: std::ptr::null(),\n        right_quote: std::ptr::null(),\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(Some(&mut options), ':' as char, 1);\n    \n    let result = unsafe {\n        quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            u64::MAX,\n            &mut options,\n        )\n    };\n    \n    unsafe { CString::from_raw(result) }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    let left_quote_str = unsafe { CStr::from_ptr(left_quote).to_string_lossy().into_owned() };\nlet right_quote_str = unsafe { CStr::from_ptr(right_quote).to_string_lossy().into_owned() };\nset_custom_quoting(Some(&mut o), &left_quote_str, &right_quote_str);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub fn quotearg_custom(\n    left_quote: &str,\n    right_quote: &str,\n    arg: &str,\n) -> String {\n    let left_quote_c = CString::new(left_quote).unwrap();\n    let right_quote_c = CString::new(right_quote).unwrap();\n    let arg_c = CString::new(arg).unwrap();\n    \n    let result = unsafe {\n        quotearg_n_custom(0, left_quote_c.as_ptr(), right_quote_c.as_ptr(), arg_c.as_ptr())\n    };\n    \n    unsafe { CStr::from_ptr(result).to_string_lossy().into_owned() }\n}\n#[no_mangle]\npub fn quotearg_custom_mem(\n    left_quote: &CStr,\n    right_quote: &CStr,\n    arg: &CStr,\n) -> CString {\n    let argsize: usize = arg.to_bytes().len();\n    let result_ptr: *mut libc::c_char = unsafe {\n        quotearg_n_custom_mem(\n            0,\n            left_quote.as_ptr(),\n            right_quote.as_ptr(),\n            arg.as_ptr(),\n            argsize.try_into().unwrap(),\n        )\n    };\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub fn quote_n_mem(\n    n: i32,\n    arg: &CStr,\n) -> *const libc::c_char {\n    let argsize = arg.to_bytes().len() as u64;\n    let quoted = unsafe { quotearg_n_options(n, arg.as_ptr(), argsize, &quote_quoting_options) };\n    quoted\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    let arg_cstr = CStr::from_ptr(arg);\nreturn quote_n_mem(0, arg_cstr);\n}\n#[no_mangle]\npub fn quote_n(n: i32, arg: &CStr) -> *const libc::c_char {\n    quote_n_mem(n, arg)\n}\n#[no_mangle]\npub fn quote(arg: &str) -> String {\n    let c_str = CString::new(arg).expect(\"CString::new failed\");\n    let result = quote_n(0, &c_str);\n    unsafe { CStr::from_ptr(result).to_string_lossy().into_owned() }\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "use std::convert::TryInto;\nuse ::libc;\nextern \"C\" {\n    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type ssize_t = __ssize_t;\npub type __ssize_t = libc::c_long;\npub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub fn safe_read(fd: libc::c_int, buf: &mut [u8]) -> usize {\n    let mut count = buf.len() as u64;\n    let mut total_read = 0;\n\n    loop {\n        let result = unsafe { read(fd, buf.as_mut_ptr() as *mut libc::c_void, count) };\n        if result >= 0 {\n            total_read += result as usize;\n            return total_read;\n        } else {\n            let err = unsafe { *__errno_location() };\n            if err == 4 { // Interrupted system call\n                continue;\n            }\n            if err == 22 && (SYS_BUFSIZE_MAX as libc::c_ulong) < count {\n                count = SYS_BUFSIZE_MAX as libc::c_int as u64;\n            } else {\n                return total_read;\n            }\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\safe_read.rs"
    },
    {
      "chunk": "use std::convert::TryInto;\nuse std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn setlocale_null_r(\n    category: libc::c_int,\n    buf: &mut [u8],\n) -> libc::c_int {\n    let bufsize = buf.len() as u64; // Convert usize to u64\n    let buf_ptr = buf.as_mut_ptr() as *mut libc::c_char;\n\n    unsafe {\n        return setlocale_null_r_unlocked(category, buf_ptr, bufsize);\n    }\n}\n#[no_mangle]\npub fn setlocale_null(category: libc::c_int) -> Option<String> {\n    let result = unsafe { setlocale_null_unlocked(category) };\n    if result.is_null() {\n        None\n    } else {\n        unsafe { Some(CStr::from_ptr(result).to_string_lossy().into_owned()) }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\setlocale_null.rs"
    },
    {
      "chunk": "use std::slice;\nuse ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub fn setlocale_null_r_unlocked(\n    category: libc::c_int,\n    buf: &mut Vec<u8>,\n) -> libc::c_int {\n    let result: *const libc::c_char;\n\n    unsafe {\n        result = setlocale_null_unlocked(category);\n    }\n\n    if result.is_null() {\n        if !buf.is_empty() {\n            buf[0] = 0; // Set the first byte to null terminator\n        }\n        return 22; // EINVAL\n    } else {\n        let length: usize = unsafe { strlen(result) } as usize; // Cast to usize\n        if length < buf.len() {\n            buf[..length].copy_from_slice(unsafe { std::slice::from_raw_parts(result as *const u8, length) });\n            buf[length] = 0; // Null terminate\n            return 0; // Success\n        } else {\n            let copy_length = buf.len() - 1;\n            if !buf.is_empty() {\n                buf[..copy_length].copy_from_slice(unsafe { std::slice::from_raw_parts(result as *const u8, copy_length) });\n                buf[copy_length] = 0; // Null terminate\n            }\n            return 34; // ERANGE\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\setlocale_null_unlocked.rs"
    },
    {
      "chunk": "use std::string::String;\nuse ::libc;\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\n#[no_mangle]\npub fn umaxtostr(i: uintmax_t, buf: &mut [libc::c_char]) -> String {\n    let mut p = buf.len() as isize - 1;\n    buf[p as usize] = 0;\n\n    if i < 0 {\n        let mut num = i;\n        loop {\n            p -= 1;\n            buf[p as usize] = ('0' as i32 as uintmax_t).wrapping_sub(num % 10) as libc::c_char;\n            num /= 10;\n            if num == 0 {\n                break;\n            }\n        }\n        p -= 1;\n        buf[p as usize] = '-' as i32 as libc::c_char;\n    } else {\n        let mut num = i;\n        loop {\n            p -= 1;\n            buf[p as usize] = ('0' as i32 as uintmax_t).wrapping_add(num % 10) as libc::c_char;\n            num /= 10;\n            if num == 0 {\n                break;\n            }\n        }\n    }\n    let len = buf.len() - p as usize - 1;\n    let slice = &buf[p as usize..p as usize + len];\n    String::from_utf8_lossy(&slice.iter().map(|&c| c as u8).collect::<Vec<u8>>()).into_owned()\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\umaxtostr.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\version.rs"
    },
    {
      "chunk": "use std::println;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\version_etc.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub fn emit_bug_reporting_address() {\n    println!();\n    println!(\n        \"Report bugs to: {}\",\n        \"bug-coreutils@gnu.org\"\n    );\n    println!(\n        \"{} home page: <{}>\",\n        \"GNU coreutils\",\n        \"https://www.gnu.org/software/coreutils/\"\n    );\n    println!(\n        \"General help using GNU software: <{}>\",\n        \"https://www.gnu.org/gethelp/\"\n    );\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\version_etc.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\version_etc_fsf.rs"
    },
    {
      "chunk": "use std::process;\nuse ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub fn xalloc_die() {\n    if 0 != 0 {\n        unsafe {\n            error(\n                exit_failure,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n        }\n        if unsafe { exit_failure } != 0 {\n            unreachable!();\n        }\n    } else {\n        let errstatus = unsafe { exit_failure };\n        unsafe {\n            error(\n                errstatus,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n        }\n        if errstatus != 0 {\n            unreachable!();\n        }\n\n        let errstatus = unsafe { exit_failure };\n        unsafe {\n            error(\n                errstatus,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n        }\n        if errstatus != 0 {\n            unreachable!();\n        }\n    }\n    std::process::abort();\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\xalloc_die.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn xset_binary_mode(fd: i32, mode: i32) {\n    let result = unsafe { set_binary_mode(fd, mode) };\n    if result < 0 {\n        xset_binary_mode_error();\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn xset_binary_mode_error() {\n    // Implement the functionality in a safe manner\n    // Assuming the original function was intended to set binary mode for I/O operations,\n    // we can use standard Rust functionality to achieve this.\n    \n    // Example: If this function is meant to set binary mode for standard input/output,\n    // we can use the `std::io` module to handle this safely.\n    use std::io::{self, Write};\n\n    // Here we would set the binary mode for standard output as an example.\n    // Note: Rust's standard library does not have a direct equivalent for setting binary mode,\n    // but we can ensure that we write bytes directly if needed.\n    let _ = io::stdout().flush(); // Ensure any buffered output is flushed.\n}\n#[inline]\nunsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    let result = __gl_setmode(fd, mode);\nreturn result;\n}\n#[inline]\nfn __gl_setmode(fd: i32, mode: i32) -> i32 {\n    return 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\xbinary_io.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn xstrtoumax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut uintmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n}\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\npub const LONGINT_OK: strtol_error = 0;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\n#[no_mangle]\npub unsafe extern \"C\" fn xdectoumax(\n    mut n_str: *const libc::c_char,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    return xnumtoumax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnumtoumax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: uintmax_t = 0;\n    s_err = xstrtoumax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_ulong {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\xdectoumax.rs"
    },
    {
      "chunk": "use std::vec;\nuse std::option::Option;\nuse std::string::String;\nuse std::mem;\nuse std::slice;\nuse std::vec::Vec;\nuse ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nfn irealloc(s: usize) -> *mut libc::c_void {\n    if s <= usize::MAX {\n        let p = if s == 0 { Vec::new() } else { vec![0u8; s] };\n        Box::into_raw(p.into_boxed_slice()) as *mut libc::c_void\n    } else {\n        _gl_alloc_nomem()\n    }\n}\n#[inline]\nfn icalloc(n: usize, s: usize) -> *mut libc::c_void {\n    if n > usize::MAX {\n        if s != 0 {\n            return _gl_alloc_nomem();\n        }\n        return std::ptr::null_mut();\n    }\n    if s > usize::MAX {\n        if n != 0 {\n            return _gl_alloc_nomem();\n        }\n        return std::ptr::null_mut();\n    }\n    let total_size = n.checked_mul(s).unwrap_or(0);\n    let vec = vec![0u8; total_size];\n    let boxed_slice = vec.into_boxed_slice();\n    Box::into_raw(boxed_slice) as *mut libc::c_void\n}\n#[inline]\nfn ireallocarray(n: i64, s: i64) -> *mut libc::c_void {\n    if n as u64 <= 18446744073709551615 && s as u64 <= 18446744073709551615 {\n        let mut nx: usize = n.try_into().unwrap();\n        let mut sx: usize = s.try_into().unwrap();\n        if n == 0 || s == 0 {\n            sx = 1;\n            nx = sx;\n        }\n        unsafe {\n            let p = reallocarray(std::ptr::null_mut(), nx as u64, sx as u64);\n            return p;\n        }\n    } else {\n        return _gl_alloc_nomem();\n    }\n}\n#[cold]\n#[inline]\nfn _gl_alloc_nomem() -> *mut libc::c_void {\n    unsafe {\n        *__errno_location() = 12 as libc::c_int;\n    }\n    0 as *mut libc::c_void\n}\n#[inline]\nfn imalloc(s: usize) -> *mut libc::c_void {\n    if s <= usize::MAX {\n        let layout = std::alloc::Layout::from_size_align(s, 1).unwrap();\n        let ptr = unsafe { std::alloc::alloc(layout) };\n        if ptr.is_null() {\n            std::ptr::null_mut()\n        } else {\n            ptr as *mut libc::c_void\n        }\n    } else {\n        std::ptr::null_mut()\n    }\n}\nfn check_nonnull(p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        unsafe { xalloc_die() };\n    }\n    p\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}\n#[no_mangle]\npub fn ximalloc(s: usize) -> *mut libc::c_void {\n    let ptr = imalloc(s);\n    if ptr.is_null() {\n        std::ptr::null_mut()\n    } else {\n        ptr\n    }\n}\n#[no_mangle]\npub fn xcharalloc(n: usize) -> Vec<libc::c_char> {\n    if mem::size_of::<libc::c_char>() == 1 {\n        let mut vec = Vec::with_capacity(n);\n        unsafe {\n            vec.set_len(n);\n        }\n        vec\n    } else {\n        let mut vec = Vec::with_capacity(n * mem::size_of::<libc::c_char>());\n        unsafe {\n            vec.set_len(n * mem::size_of::<libc::c_char>());\n        }\n        vec\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub fn xirealloc(p: Option<&mut [u8]>, s: usize) -> Option<Vec<u8>> {\n    match p {\n        Some(slice) => {\n            let mut vec = Vec::with_capacity(s);\n            vec.extend_from_slice(slice);\n            Some(vec)\n        },\n        None => Some(vec![0; s]),\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let result = ireallocarray(n, s);\nreturn check_nonnull(result);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub fn xinmalloc(n: usize, s: usize) -> Option<Vec<u8>> {\n    let total_size = n.checked_mul(s)?;\n    let vec = Vec::with_capacity(total_size);\n    Some(vec)\n}\n#[no_mangle]\npub fn x2realloc(\n    p: &mut Vec<u8>,\n    ps: &mut usize,\n) -> Vec<u8> {\n    let new_size = *ps + 1; // Assuming we want to increase the size by 1\n    p.resize(new_size, 0); // Resize the vector, filling new elements with 0\n    *ps = new_size; // Update the size\n    p.clone() // Return a clone of the vector\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub fn xzalloc(s: usize) -> Vec<u8> {\n    let size = s * std::mem::size_of::<u8>();\n    Vec::with_capacity(size)\n}\n#[no_mangle]\npub fn xizalloc(s: usize) -> Vec<u8> {\n    let size = s * std::mem::size_of::<u8>();\n    let vec = vec![0u8; size];\n    vec\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}\n#[no_mangle]\npub fn xicalloc(n: usize, s: usize) -> *mut libc::c_void {\n    let total_size = n.checked_mul(s).expect(\"Overflow in allocation size\");\n    let allocation = vec![0u8; total_size].into_boxed_slice();\n    Box::into_raw(allocation) as *mut libc::c_void\n}\n#[no_mangle]\npub fn xmemdup(p: &[u8]) -> Vec<u8> {\n    let mut result = vec![0; p.len()];\n    result.copy_from_slice(p);\n    result\n}\n#[no_mangle]\npub fn ximemdup(p: &[u8]) -> Vec<u8> {\n    let s = p.len();\n    let mut new_vec = Vec::with_capacity(s);\n    new_vec.copy_from_slice(p);\n    new_vec\n}\n#[no_mangle]\npub fn ximemdup0(p: &[u8]) -> Vec<u8> {\n    let s = p.len();\n    let mut result = vec![0; s + 1]; // Allocate space for the data plus a null terminator\n    result[..s].copy_from_slice(p); // Copy the data\n    result[s] = 0; // Null terminate the result\n    result\n}\n#[no_mangle]\npub fn xstrdup(string: &str) -> String {\n    let length = string.len();\n    let mut vec = Vec::with_capacity(length + 1);\n    vec.extend_from_slice(string.as_bytes());\n    vec.push(0); // Null-terminate the string\n    String::from_utf8(vec).expect(\"Failed to convert to String\")\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtoumax(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __base: libc::c_int,\n    ) -> uintmax_t;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n}\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub const _ISspace: C2RustUnnamed = 8192;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\xstrtoumax.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn bkm_scale(\n    mut x: *mut uintmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: uintmax_t = 0;\n    if if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t\n        && (if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_ulong } else { *x })\n            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n            < 0 as libc::c_int as libc::c_ulong\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_ulong {\n                if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        -(1 as libc::c_int) as uintmax_t\n                    })\n                        .wrapping_add(scale_factor as libc::c_ulong)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    (*x\n                        < (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(scale_factor as libc::c_ulong)) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(-(1 as libc::c_int) as uintmax_t)\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(-scale_factor as libc::c_ulong)\n                    }) <= (-(1 as libc::c_int) as libc::c_ulong).wrapping_sub(*x))\n                        as libc::c_int\n                }\n            } else {\n                let scale_factor_value = if scale_factor != 0 { scale_factor } else { 0 };\nlet x_value = *x;\n\nif (if (if (if 1 != 0 {\n                    0\n                } else {\n                    (scale_factor_value as u64).wrapping_add(0)\n                })\n                    .wrapping_sub(1)\n                    < 0 {\n                    !((if 1 != 0 {\n                        0\n                    } else {\n                        (scale_factor_value as u64).wrapping_add(0)\n                    })\n                        .wrapping_add(1)\n                        << (std::mem::size_of::<u64>() as u64 * 8 - 2)\n                        .wrapping_sub(1)\n                        .wrapping_mul(2)\n                        .wrapping_add(1)\n                    )\n                } else {\n                    (scale_factor_value as u64).wrapping_add(0)\n                }) < 0 {\n                    (((if 1 != 0 {\n                        0\n                    } else {\n                        scale_factor_value\n                    }) as u64)\n                        .wrapping_add(0)\n                        < (if (if 1 != 0 {\n                            0\n                        } else {\n                            (scale_factor_value as u64).wrapping_add(0)\n                        })\n                            .wrapping_sub(1)\n                            < 0 {\n                            ((if 1 != 0 {\n                                0\n                            } else {\n                                scale_factor_value\n                            }) as u64)\n                                .wrapping_add(1)\n                                << (std::mem::size_of::<u64>() as u64 * 8 - 2)\n                                .wrapping_sub(1)\n                                .wrapping_mul(2)\n                                .wrapping_add(1)\n                        } else {\n                            (if 1 != 0 {\n                                0\n                            } else {\n                                scale_factor_value\n                            }).wrapping_sub(1) as u64\n                        })\n                            .wrapping_neg()) as i32\n                } else {\n                    (0 < (scale_factor_value as u64)) as i32\n                }) != 0 && scale_factor == -1 {\n                    if (if 1 != 0 {\n                        0\n                    } else {\n                        x_value\n                    })\n                        .wrapping_sub(1)\n                        < 0 {\n                        (0 < x_value.wrapping_add(0)) as i32\n                    } else {\n                        (0 < x_value && (-1i32 as u64).wrapping_sub(0) < x_value.wrapping_sub(1)) as i32\n                    }\n                } else {\n                    (0u64.wrapping_div(scale_factor as u64) < x_value) as i32\n                }\n\n            }\n        } else {\n            if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_ulong {\n                    if (if (if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        !((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                    }) < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                            < (if (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    *x\n                                })\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                < 0 as libc::c_int as libc::c_ulong\n                            {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                    << (::core::mem::size_of::<libc::c_ulong>()\n                                        as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            })\n                                .wrapping_neg()) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_ulong\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_ulong)\n                                < (scale_factor as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_ulong)\n                                as libc::c_int\n                        }\n                    } else {\n                        ((0 as libc::c_int as uintmax_t).wrapping_div(*x)\n                            < scale_factor as libc::c_ulong) as libc::c_int\n                    }\n                } else {",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\xstrtoumax.rs"
    },
    {
      "chunk": "                    ((-(1 as libc::c_int) as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_ulong {\n            !if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n                -(1 as libc::c_int) as uintmax_t\n            } else {\n                ((1 as libc::c_int as uintmax_t)\n                    << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            }\n        } else if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n            -(1 as libc::c_int) as uintmax_t\n        } else {\n            ((1 as libc::c_int as uintmax_t)\n                << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}\nfn bkm_scale_by_power(\n    x: &mut u64,\n    base: i32,\n    mut power: i32,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    while power > 0 {\n        power -= 1;\n        // Call to bkm_scale is unsafe, so we need to wrap it in an unsafe block\n        err = unsafe {\n            (err as u32 | bkm_scale(x, base) as u32) as strtol_error\n        };\n    }\n    err\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrtoumax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut uintmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: uintmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 79],\n                &[libc::c_char; 79],\n            >(\n                b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2256: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 79],\n                    &[libc::c_char; 79],\n                >(\n                    b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoumax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as uintmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if !(*p).is_null() && **p != 0 {\n    let mut base: i32 = 1024;\n    let mut suffixes: i32 = 1;\n    let mut overflow: strtol_error = LONGINT_OK;\n\n    let valid_suffixes_slice = unsafe { std::ffi::CStr::from_ptr(valid_suffixes).to_string_lossy() };\n    let current_char = **p as u8 as char;\n    if !valid_suffixes_slice.contains(current_char) {\n        *val = tmp;\n        return (err | LONGINT_INVALID_SUFFIX_CHAR) as strtol_error;\n    }\n\n    match current_char {\n        'E' | 'G' | 'g' | 'k' | 'K' | 'M' | 'm' | 'P' | 'Q' | 'R' | 'T' | 't' | 'Y' | 'Z' => {\n            if valid_suffixes_slice.contains('0') {\n                match unsafe { *(*p).offset(1) } as u8 as char {\n                    'i' => {\n                        if unsafe { *(*p).offset(2) } as u8 as char == 'B' {\n                            suffixes += 2;\n                        }\n                    }\n                    'B' | 'D' => {\n                        base = 1000;\n                        suffixes += 1;\n                    }\n                    _ => {}\n                }\n            }\n        }\n        _ => {}\n    }\n\n    match current_char {\n        'b' => {\n            overflow = bkm_scale(&mut tmp, 512);\n        }\n        'B' => {\n            overflow = bkm_scale(&mut tmp, 1024);\n        }\n        'c' => {\n            overflow = LONGINT_OK;\n        }\n        'E' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 6);\n        }\n        'G' | 'g' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 3);\n        }\n        'k' | 'K' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 1);\n        }\n        'M' | 'm' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 2);\n        }\n        'P' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 5);\n        }\n        'Q' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 10);\n        }\n        'R' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 9);\n        }\n        'T' | 't' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 4);\n        }\n        'w' => {\n            overflow = bkm_scale(&mut tmp, 2);\n        }\n        'Y' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 8);\n        }\n        'Z' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 7);\n        }\n        _ => {\n            *val = tmp;\n            return (err | LONGINT_INVALID_SUFFIX_CHAR) as strtol_error;\n        }\n    }\n\n    err |= overflow as u32;\n    *p = unsafe { (*p).offset(suffixes as isize) };\n    if **p != 0 {\n        err |= LONGINT_INVALID_SUFFIX_CHAR;\n    }\n}\n*val = tmp;\nreturn err;\n\n}",
      "file_name": "c2saferrust/coreutils/src\\head\\rust_WIP\\src\\xstrtoumax.rs"
    }
  ],
  "pwd": [
    {
      "chunk": "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\build.rs"
    },
    {
      "chunk": "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod close_stream;\npub mod closeout;\npub mod exitfail;\npub mod fclose;\npub mod fflush;\npub mod fseeko;\npub mod hard_locale;\npub mod ialloc;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod root_dev_ino;\npub mod same_inode;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalloc_die;\npub mod xgetcwd;\npub mod xmalloc;\n}\n// mod src",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\lib.rs"
    },
    {
      "chunk": "use std::ffi::CString;\nuse std::os::raw::c_char;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub fn close_stdout_set_file_name(file: &str) {\n    let c_string = CString::new(file).expect(\"CString::new failed\");\n    unsafe {\n        file_name = c_string.as_ptr();\n    }\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\npub fn close_stdout_set_ignore_EPIPE(ignore: bool) {\n    unsafe {\n        ignore_EPIPE = ignore;\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\closeout.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn close_stream(stream: *mut _IO_FILE) -> libc::c_int {\n    let some_pending: bool = unsafe { __fpending(stream) != 0 };\n    let prev_fail: bool = unsafe { ferror_unlocked(stream) != 0 };\n    let fclose_fail: bool = unsafe { rpl_fclose(stream) != 0 };\n\n    if prev_fail\n        || fclose_fail && (some_pending || unsafe { *__errno_location() != 9 })\n    {\n        if !fclose_fail {\n            unsafe { *__errno_location() = 0 };\n        }\n        return -1;\n    }\n    return 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\close_stream.rs"
    },
    {
      "chunk": "use std::os::raw::c_int;\nuse std::ops::RangeInclusive;\nuse std::char;\nuse ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalnum(c: libc::c_int) -> bool {\n    (c >= 48 && c <= 57) || (c >= 65 && c <= 90) || (c >= 97 && c <= 122)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalpha(c: i32) -> bool {\n    matches!(c, 97..=122 | 65..=90)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isascii(c: i32) -> bool {\n    (0..=127).contains(&c)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isblank(c: i32) -> bool {\n    c == ' ' as i32 || c == '\\t' as i32\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_iscntrl(c: i32) -> bool {\n    match c {\n        0..=31 | 127 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isdigit(c: i32) -> bool {\n    c >= 48 && c <= 57\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isgraph(c: i32) -> bool {\n    match c {\n        48..=57 | 97..=122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 \n        | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 \n        | 65..=90 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_islower(c: i32) -> bool {\n    (b'a'..=b'z').contains(&(c as u8))\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isprint(c: c_int) -> bool {\n    (32..=126).contains(&c) // ASCII printable characters range\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_ispunct(c: char) -> bool {\n    c.is_ascii_punctuation()\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isspace(c: i32) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isupper(c: i32) -> bool {\n    matches!(c, 65..=90)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isxdigit(c: i32) -> bool {\n    matches!(c, 48..=57 | 97..=102 | 65..=70)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_tolower(c: i32) -> i32 {\n    if c >= 'A' as i32 && c <= 'Z' as i32 {\n        return c - ('A' as i32 - 'a' as i32);\n    }\n    c\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_toupper(c: char) -> char {\n    if c.is_ascii_lowercase() {\n        return (c as u8 - b'a' + b'A') as char;\n    }\n    c\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\c_ctype.rs"
    },
    {
      "chunk": "use ::libc;\n#[inline]\nfn c_tolower(c: i32) -> i32 {\n    match c {\n        65..=90 => c - 'A' as i32 + 'a' as i32,\n        _ => c,\n    }\n}\n#[no_mangle]\npub fn c_strcasecmp(s1: &str, s2: &str) -> libc::c_int {\n    let c1: Vec<u8> = s1.bytes().map(|b| c_tolower(b as i32) as u8).collect();\n    let c2: Vec<u8> = s2.bytes().map(|b| c_tolower(b as i32) as u8).collect();\n\n    let min_len = c1.len().min(c2.len());\n    for i in 0..min_len {\n        if c1[i] != c2[i] {\n            return c1[i] as libc::c_int - c2[i] as libc::c_int;\n        }\n    }\n    \n    c1.len() as libc::c_int - c2.len() as libc::c_int\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\c_strcasecmp.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\exitfail.rs"
    },
    {
      "chunk": "use libc::{c_int, c_long};\nuse std::os::raw::c_void;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn rpl_fclose(fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0;\n    let fd = unsafe { fileno(fp) };\n    \n    if fd < 0 {\n        return unsafe { fclose(fp) };\n    }\n    \n    if (unsafe { __freading(fp) } == 0 || unsafe { lseek(fd, 0, 1) } == -1) && unsafe { rpl_fflush(fp) } != 0 {\n        saved_errno = unsafe { *__errno_location() };\n    }\n    \n    let result = unsafe { fclose(fp) };\n    \n    if saved_errno != 0 {\n        unsafe { *__errno_location() = saved_errno };\n        return -1;\n    }\n    \n    result\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\fclose.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nunsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\fflush.rs"
    },
    {
      "chunk": "use std::os::raw::c_int;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub fn rpl_fseeko(\n    fp: &mut FILE,\n    offset: off_t,\n    whence: libc::c_int,\n) -> libc::c_int {\n    if fp._IO_read_end == fp._IO_read_ptr\n        && fp._IO_write_ptr == fp._IO_write_base && fp._IO_save_base.is_null()\n    {\n        let pos: off_t;\n        unsafe {\n            pos = lseek(fileno(fp), offset, whence);\n        }\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        fp._flags &= !(0x10 as libc::c_int);\n        fp._offset = pos;\n        return 0 as libc::c_int;\n    }\n    unsafe {\n        return fseeko(fp, offset, whence);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\fseeko.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn hard_locale(category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    unsafe {\n        if setlocale_null_r(\n            category,\n            locale.as_mut_ptr(),\n            locale.len() as libc::c_ulong,\n        ) != 0 {\n            return false;\n        }\n    }\n    let locale_str = unsafe { CStr::from_ptr(locale.as_ptr()).to_string_lossy() };\n    if locale_str == \"C\" || locale_str == \"POSIX\" {\n        return false;\n    }\n    return true;\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\hard_locale.rs"
    },
    {
      "chunk": "use std::usize;\nuse std::mem;\nuse std::option::Option;\nuse std::vec::Vec;\nuse ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn ireallocarray(\n    p: Option<&mut [u8]>,\n    n: usize,\n    s: usize,\n) -> *mut libc::c_void {\n    if n <= usize::MAX && s <= usize::MAX {\n        let mut nx = n;\n        let mut sx = s;\n        if n == 0 || s == 0 {\n            sx = 1;\n            nx = sx;\n        }\n        let new_size = nx.checked_mul(sx).unwrap_or(0);\n        let mut vec = p.map(|slice| slice.to_vec()).unwrap_or_else(Vec::new);\n        vec.resize(new_size, 0);\n        vec.as_mut_ptr() as *mut libc::c_void\n    } else {\n        unsafe { _gl_alloc_nomem() }\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn icalloc(n: usize, s: usize) -> Option<Vec<u8>> {\n    if n > usize::MAX / s {\n        if s != 0 {\n            return None; // Equivalent to _gl_alloc_nomem()\n        }\n        return Some(Vec::new()); // Return an empty Vec\n    }\n    if s > usize::MAX / n {\n        if n != 0 {\n            return None; // Equivalent to _gl_alloc_nomem()\n        }\n        return Some(Vec::new()); // Return an empty Vec\n    }\n    let total_size = n * s;\n    Some(vec![0u8; total_size]) // Allocate and initialize the Vec with zeroes\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn irealloc(p: Option<Vec<u8>>, s: usize) -> Option<Vec<u8>> {\n    if s <= usize::MAX {\n        let mut new_vec = Vec::with_capacity(s);\n        if let Some(mut vec) = p {\n            new_vec.extend(vec);\n        }\n        Some(new_vec)\n    } else {\n        None\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn imalloc(s: idx_t) -> Option<Vec<u8>> {\n    if s as usize <= usize::MAX {\n        let vec = Vec::with_capacity(s as usize);\n        Some(vec)\n    } else {\n        None\n    }\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\ialloc.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;\npub const _NL_WAM_STR: C2RustUnnamed = 131162;",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "pub const _NL_WMON_12: C2RustUnnamed = 131161;\npub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub fn locale_charset() -> String {\n    let codeset_ptr: *const libc::c_char = unsafe { nl_langinfo(CODESET as libc::c_int) };\n    let codeset = unsafe { CStr::from_ptr(codeset_ptr) };\n    \n    if codeset.to_bytes().is_empty() {\n        return \"ASCII\".to_string();\n    }\n    \n    codeset.to_string_lossy().into_owned()\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nfn mbszero(ps: &mut mbstate_t) {\n    let size = std::mem::size_of::<mbstate_t>();\n    let bytes: &mut [u8] = unsafe { std::slice::from_raw_parts_mut(ps as *mut _ as *mut u8, size) };\n    bytes.fill(0);\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(&mut *ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\mbrtoc32.rs"
    },
    {
      "chunk": "use std::mem;\nuse ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn mbszero(ps: &mut mbstate_t) {\n    *ps = mbstate_t {\n        __count: 0,\n        __value: unsafe { std::mem::zeroed() }, // Zero-initialize __value\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\mbszero.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\progname.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\propername_lite.rs"
    },
    {
      "chunk": "#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut, unused_imports)]\n#![feature(extern_types)]\nuse std::ffi::CStr;\nuse std::ffi::CString;\nuse std::ffi;\nuse std::os::raw::c_char;\nuse std::process;\nuse ::rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    pub type __dirstream;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    static mut optind: libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn puts(__s: *const libc::c_char) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn chdir(__path: *const libc::c_char) -> libc::c_int;\n    fn fchdir(__fd: libc::c_int) -> libc::c_int;\n    fn lstat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn free(_: *mut libc::c_void);\n    fn __errno_location() -> *mut libc::c_int;\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn set_program_name(argv0: *const libc::c_char);\n    static mut program_name: *const libc::c_char;\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn close_stdout();\n    static mut Version: *const libc::c_char;\n    fn opendir(__name: *const libc::c_char) -> *mut DIR;\n    fn closedir(__dirp: *mut DIR) -> libc::c_int;\n    fn readdir(__dirp: *mut DIR) -> *mut dirent;\n    fn dirfd(__dirp: *mut DIR) -> libc::c_int;\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn xmalloc(s: size_t) -> *mut libc::c_void;\n    fn xnmalloc(n: size_t, s: size_t) -> *mut libc::c_void;\n    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;\n    fn exit(_: libc::c_int) -> !;\n    fn atexit(__func: Option::<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn get_root_dev_ino(root_d_i: *mut dev_ino) -> *mut dev_ino;\n    fn xgetcwd() -> *mut libc::c_char;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\npub type size_t = libc::c_ulong;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type ino_t = __ino_t;\npub type dev_t = __dev_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct dirent {\n    pub d_ino: __ino_t,\n    pub d_off: __off_t,\n    pub d_reclen: libc::c_ushort,\n    pub d_type: libc::c_uchar,\n    pub d_name: [libc::c_char; 256],\n}\npub type DIR = __dirstream;\npub type C2RustUnnamed = libc::c_uint;\npub const NOT_AN_INODE_NUMBER: C2RustUnnamed = 0;\npub type C2RustUnnamed_0 = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed_0 = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed_0 = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct dev_ino {\n    pub st_ino: ino_t,\n    pub st_dev: dev_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct file_name {\n    pub buf: *mut libc::c_char,\n    pub n_alloc: size_t,\n    pub start: *mut libc::c_char,\n}\n#[inline]\nfn emit_ancillary_info(program: &str) {\n    let infomap_0: [( &'static str, &'static str); 7] = [\n        ( \"[\", \"test invocation\" ),\n        ( \"coreutils\", \"Multi-call invocation\" ),\n        ( \"sha224sum\", \"sha2 utilities\" ),\n        ( \"sha256sum\", \"sha2 utilities\" ),\n        ( \"sha384sum\", \"sha2 utilities\" ),\n        ( \"sha512sum\", \"sha2 utilities\" ),\n        ( \"\", \"\" ),\n    ];\n\n    let mut node = program;\n    let mut map_prog = infomap_0.iter();\n\n    while let Some(&(prog, n)) = map_prog.next() {\n        if prog.is_empty() || program != prog {\n            continue;\n        }\n        node = n;\n        break;\n    }\n\n    let help_message = unsafe { std::ffi::CStr::from_ptr(gettext(b\"GNU coreutils\\0\".as_ptr() as *const libc::c_char)).to_string_lossy() };\n    println!(\n        \"{} online help: <{}>\",\n        help_message,\n        \"https://www.gnu.org/software/coreutils/\"\n    );\n\n    let lc_messages: *const libc::c_char;\n    unsafe {\n        lc_messages = setlocale(5, std::ptr::null());\n    }\n\n    if !lc_messages.is_null() && unsafe { std::ffi::CStr::from_ptr(lc_messages).to_string_lossy() }.starts_with(\"en_\") {\n        let report_message = unsafe { std::ffi::CStr::from_ptr(gettext(b\"Report any translation bugs to <https://translationproject.org/team/>\\0\".as_ptr() as *const libc::c_char)).to_string_lossy() };\n        eprintln!(\"{}\", report_message);\n    }\n\n    let url_program = if program == \"[\" { \"test\" } else { program };\n\n    println!(\n        \"Full documentation <{}{}>\",\n        \"https://www.gnu.org/software/coreutils/\",\n        url_program\n    );\n\n    println!(\n        \"or available locally via: info '(coreutils) {}{}'\",\n        node,\n        if node == program { \" invocation\" } else { \"\" }\n    );\n}\n#[inline]\nunsafe extern \"C\" fn readdir_ignoring_dot_and_dotdot(\n    mut dirp: *mut DIR,\n) -> *const dirent {\n    loop {\n        let mut dp: *const dirent = readdir(dirp);\n        if dp.is_null() || !dot_or_dotdot(((*dp).d_name).as_ptr()) {\n            return dp;\n        }\n    };\n}\n#[inline]\nfn dot_or_dotdot(file_name: *const libc::c_char) -> bool {\n    let c_str = unsafe { std::ffi::CStr::from_ptr(file_name) };\n    let file_name_str = c_str.to_string_lossy();\n\n    if file_name_str.starts_with('.') {\n        let sep = file_name_str.chars().nth(1);\n        return sep.is_none() || sep.unwrap() == '/';\n    } else {\n        return false;\n    }\n}\n#[inline]",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\pwd.rs"
    },
    {
      "chunk": "fn psame_inode(a: &stat, b: &stat) -> bool {\n    a.st_dev == b.st_dev && a.st_ino == b.st_ino\n}\nstatic mut longopts: [option; 5] = [\n    {\n        let mut init = option {\n            name: b\"logical\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'L' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"physical\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'P' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];\n#[no_mangle]\npub fn usage(status: i32) {\n    if status != 0 {\n        eprintln!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(format!(\"Try '{} --help' for more information.\\n\", unsafe { std::ffi::CStr::from_ptr(program_name).to_str().unwrap() }).as_ptr() as *const i8)).to_string_lossy() }\n        );\n    } else {\n        println!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(format!(\"Usage: {} [OPTION]...\\n\", unsafe { std::ffi::CStr::from_ptr(program_name).to_str().unwrap() }).as_ptr() as *const i8)).to_string_lossy() }\n        );\n        println!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"Print the full filename of the current working directory.\\n\\0\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        println!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"  -L, --logical   use PWD from environment, even if it contains symlinks\\n\\0\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        println!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"  -P, --physical  resolve all symlinks\\n\\0\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        println!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"      --help        display this help and exit\\n\\0\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        println!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"      --version     output version information and exit\\n\\0\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        println!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"\\nIf no option is specified, -P is assumed.\\n\\0\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        println!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(format!(\"\\nYour shell may have its own version of {}, which usually supersedes\\nthe version described here.  Please refer to your shell's documentation\\nfor details about the options it supports.\\n\\0\", \"pwd\").as_ptr() as *const i8)).to_string_lossy() }\n        );\n        emit_ancillary_info(\"pwd\");\n    }\n    std::process::exit(status);\n}\nunsafe extern \"C\" fn file_name_free(mut p: *mut file_name) {\n    free((*p).buf as *mut libc::c_void);\n    free(p as *mut libc::c_void);\n}\nfn file_name_init() -> file_name {\n    let n_alloc = if (2 * 4096) < (32 * 1024) {\n        2 * 4096\n    } else {\n        32 * 1024\n    } as u64;\n\n    let mut buf = vec![0; n_alloc as usize]; // Allocate a buffer of n_alloc size initialized to 0\n    let start;\n\n    unsafe {\n        start = buf.as_mut_ptr().add(n_alloc as usize - 1); // Pointer to the end of the buffer\n        *start = '\\0' as i8; // Null-terminate the buffer\n    }\n\n    let file_name = file_name {\n        n_alloc,\n        buf: buf.as_mut_ptr(), // Store the raw pointer to the buffer\n        start,\n    };\n\n    std::mem::forget(buf); // Prevent buf from being dropped, as we are using its pointer\n\n    file_name\n}\nunsafe extern \"C\" fn file_name_prepend(\n    mut p: *mut file_name,\n    mut s: *const libc::c_char,\n    mut s_len: size_t,\n) {\n    let mut n_free: size_t = ((*p).start).offset_from((*p).buf) as libc::c_long\n        as size_t;\n    if n_free < (1 as libc::c_int as libc::c_ulong).wrapping_add(s_len) {\n        let mut half: size_t = ((*p).n_alloc)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            .wrapping_add(s_len);\n        let mut q: *mut libc::c_char = xnmalloc(2 as libc::c_int as size_t, half)\n            as *mut libc::c_char;\n        let mut n_used: size_t = ((*p).n_alloc).wrapping_sub(n_free);\n        (*p)\n            .start = q\n            .offset((2 as libc::c_int as libc::c_ulong).wrapping_mul(half) as isize)\n            .offset(-(n_used as isize));\n        memcpy(\n            (*p).start as *mut libc::c_void,\n            ((*p).buf).offset(n_free as isize) as *const libc::c_void,\n            n_used,\n        );\n        free((*p).buf as *mut libc::c_void);\n        (*p).buf = q;\n        (*p).n_alloc = (2 as libc::c_int as libc::c_ulong).wrapping_mul(half);\n    }\n    (*p)\n        .start = ((*p).start)\n        .offset(-((1 as libc::c_int as libc::c_ulong).wrapping_add(s_len) as isize));\n    *((*p).start).offset(0 as libc::c_int as isize) = '/' as i32 as libc::c_char;\n    memcpy(\n        ((*p).start).offset(1 as libc::c_int as isize) as *mut libc::c_void,\n        s as *const libc::c_void,\n        s_len,\n    );\n}\nfn nth_parent(n: u64) -> *const libc::c_char {\n    let n = n as usize; // Convert u64 to usize\n    let mut buf = Vec::with_capacity(n * 3 + 1); // +1 for null terminator\n    for _ in 0..n {\n        buf.extend_from_slice(b\"../\");\n    }\n    buf.push(0); // Null terminator\n    buf.as_ptr() as *const libc::c_char // Return a pointer to the buffer as *const libc::c_char\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\pwd.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn find_dir_entry(\n    mut dot_sb: *mut stat,\n    mut file_name: *mut file_name,\n    mut parent_height: size_t,\n) {\n    let mut dirp: *mut DIR = 0 as *mut DIR;\n    let mut fd: libc::c_int = 0;\n    let mut parent_sb: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut use_lstat: bool = false;\n    let mut found: bool = false;\n    dirp = opendir(b\"..\\0\" as *const u8 as *const libc::c_char);\n    if dirp.is_null() {\n        if 0 != 0 {\n            let parent_path = nth_parent(parent_height.try_into().unwrap());\nerror(\n    1,\n    *__errno_location(),\n    gettext(b\"cannot open directory %s\\0\" as *const u8 as *const libc::c_char),\n    quote(parent_path),\n);\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                let parent_path = nth_parent(parent_height.try_into().unwrap());\nerror(\n    __errstatus,\n    *__errno_location(),\n    gettext(b\"cannot open directory %s\\0\" as *const u8 as *const libc::c_char),\n    quote(parent_path),\n);\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                let parent_path = nth_parent(parent_height.try_into().unwrap());\nerror(\n    __errstatus,\n    *__errno_location(),\n    gettext(b\"cannot open directory %s\\0\" as *const u8 as *const libc::c_char),\n    quote(parent_path),\n);\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    fd = dirfd(dirp);\n    if (if 0 as libc::c_int <= fd {\n        fchdir(fd)\n    } else {\n        chdir(b\"..\\0\" as *const u8 as *const libc::c_char)\n    }) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            let parent_path = nth_parent(parent_height.try_into().unwrap());\nerror(\n    1,\n    *__errno_location(),\n    gettext(b\"failed to chdir to %s\\0\" as *const u8 as *const libc::c_char),\n    quote(parent_path),\n);\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                let parent_path = nth_parent(parent_height.try_into().unwrap());\nerror(\n    __errstatus,\n    *__errno_location(),\n    gettext(b\"failed to chdir to %s\\0\" as *const u8 as *const libc::c_char),\n    quote(parent_path),\n);\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                let parent_path = nth_parent(parent_height.try_into().unwrap());\nerror(\n    __errstatus,\n    *__errno_location(),\n    gettext(b\"failed to chdir to %s\\0\" as *const u8 as *const libc::c_char),\n    quote(parent_path),\n);\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if (if 0 as libc::c_int <= fd {\n        fstat(fd, &mut parent_sb)\n    } else {\n        stat(b\".\\0\" as *const u8 as *const libc::c_char, &mut parent_sb)\n    }) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            let parent_path = nth_parent(parent_height.try_into().unwrap());\nerror(\n    1,\n    *__errno_location(),\n    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n    quote(parent_path),\n);\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                let parent_path = nth_parent(parent_height.try_into().unwrap());\nerror(\n    __errstatus,\n    *__errno_location(),\n    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n    quote(parent_path),\n);\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                let parent_path = nth_parent(parent_height.try_into().unwrap());\nerror(\n    __errstatus,\n    *__errno_location(),\n    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n    quote(parent_path),\n);\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    use_lstat = parent_sb.st_dev != (*dot_sb).st_dev;\n    found = 0 as libc::c_int != 0;\n    loop {\n        let mut dp: *const dirent = 0 as *const dirent;\n        let mut ent_sb: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        let mut ino: ino_t = 0;\n        *__errno_location() = 0 as libc::c_int;\n        dp = readdir_ignoring_dot_and_dotdot(dirp);\n        if dp.is_null() {\n            if *__errno_location() != 0 {\n                let mut e: libc::c_int = *__errno_location();\n                closedir(dirp);\n                *__errno_location() = e;\n                dirp = 0 as *mut DIR;\n            }\n            break;\n        } else {\n            ino = (*dp).d_ino;\n            if ino == NOT_AN_INODE_NUMBER as libc::c_int as libc::c_ulong\n                || use_lstat as libc::c_int != 0\n            {\n                if lstat(((*dp).d_name).as_ptr(), &mut ent_sb) < 0 as libc::c_int {\n                    continue;\n                }\n                ino = ent_sb.st_ino;\n            }\n            if ino != (*dot_sb).st_ino {\n                continue;\n            }\n            if !(!use_lstat || ent_sb.st_dev == (*dot_sb).st_dev) {\n                continue;\n            }\n            file_name_prepend(\n                file_name,\n                ((*dp).d_name).as_ptr(),\n                strlen(((*dp).d_name).as_ptr()),\n            );\n            found = 1 as libc::c_int != 0;\n            break;\n        }\n    }\n    if dirp.is_null() || closedir(dirp) != 0 as libc::c_int {\n        if 0 != 0 {\n            let parent_path = nth_parent(parent_height.try_into().unwrap());\nerror(\n    1,\n    *__errno_location(),\n    gettext(b\"reading directory %s\\0\" as *const u8 as *const libc::c_char),\n    quote(parent_path),\n);\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                let parent_path = nth_parent(parent_height.try_into().unwrap());\nerror(\n    __errstatus,\n    *__errno_location(),\n    gettext(b\"reading directory %s\\0\" as *const u8 as *const libc::c_char),\n    quote(parent_path),\n);\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                let parent_path = nth_parent(parent_height.try_into().unwrap());\nerror(\n    __errstatus,\n    *__errno_location(),\n    gettext(b\"reading directory %s\\0\" as *const u8 as *const libc::c_char),\n    quote(parent_path),\n);\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if !found {\n    let errstatus = 1;\n    let message = gettext(\n        b\"couldn't find directory entry in %s with matching i-node\\0\" as *const u8 as *const libc::c_char,\n    );\n    error(errstatus, 0, message, quote(nth_parent(parent_height)));\n\n    if errstatus != 0 {\n        unreachable!();\n    }\n}\n*dot_sb = parent_sb;\n\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\pwd.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn robust_getcwd(mut file_name: *mut file_name) {\n    let mut height: size_t = 1 as libc::c_int as size_t;\n    let mut dev_ino_buf: dev_ino = dev_ino { st_ino: 0, st_dev: 0 };\n    let mut root_dev_ino: *mut dev_ino = get_root_dev_ino(&mut dev_ino_buf);\n    let mut dot_sb: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    if root_dev_ino.is_null() {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"failed to get attributes of %s\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\"/\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to get attributes of %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"/\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to get attributes of %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"/\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if stat(b\".\\0\" as *const u8 as *const libc::c_char, &mut dot_sb) < 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\".\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\".\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\".\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    while !(dot_sb.st_dev ^ (*root_dev_ino).st_dev\n        | dot_sb.st_ino ^ (*root_dev_ino).st_ino == 0)\n    {\n        let fresh0 = height;\n        height = height.wrapping_add(1);\n        find_dir_entry(&mut dot_sb, file_name, fresh0);\n    }\n    if *((*file_name).start).offset(0 as libc::c_int as isize) as libc::c_int\n        == '\\0' as i32\n    {\n        file_name_prepend(\n            file_name,\n            b\"\\0\" as *const u8 as *const libc::c_char,\n            0 as libc::c_int as size_t,\n        );\n    }\n}\nunsafe extern \"C\" fn logical_getcwd() -> *mut libc::c_char {\n    let mut st1: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut st2: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut wd: *mut libc::c_char = getenv(b\"PWD\\0\" as *const u8 as *const libc::c_char);\n    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;\n    if wd.is_null() || *wd.offset(0 as libc::c_int as isize) as libc::c_int != '/' as i32\n    {\n        return 0 as *mut libc::c_char;\n    }\n    p = wd;\n    loop {\n        p = strstr(p, b\"/.\\0\" as *const u8 as *const libc::c_char);\n        if p.is_null() {\n            break;\n        }\n        if *p.offset(2 as libc::c_int as isize) == 0\n            || *p.offset(2 as libc::c_int as isize) as libc::c_int == '/' as i32\n            || *p.offset(2 as libc::c_int as isize) as libc::c_int == '.' as i32\n                && (*p.offset(3 as libc::c_int as isize) == 0\n                    || *p.offset(3 as libc::c_int as isize) as libc::c_int == '/' as i32)\n        {\n            return 0 as *mut libc::c_char;\n        }\n        p = p.offset(1);\n        p;\n    }\n    if stat(wd, &mut st1) == 0 as libc::c_int\n        && stat(b\".\\0\" as *const u8 as *const libc::c_char, &mut st2) == 0 as libc::c_int\n        && psame_inode(&mut st1, &mut st2) as libc::c_int != 0\n    {\n        return wd;\n    }\n    return 0 as *mut libc::c_char;\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\pwd.rs"
    },
    {
      "chunk": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut wd: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut logical: bool = !(getenv(\n        b\"POSIXLY_CORRECT\\0\" as *const u8 as *const libc::c_char,\n    ))\n        .is_null();\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    loop {\n        let mut c: libc::c_int = getopt_long(\n            argc,\n            argv,\n            b\"LP\\0\" as *const u8 as *const libc::c_char,\n            longopts.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if c == -(1 as libc::c_int) {\n            break;\n        }\n        match c {\n            76 => {\n                logical = 1 as libc::c_int != 0;\n            }\n            80 => {\n                logical = 0 as libc::c_int != 0;\n            }\n            -2 => {\n                usage(0);\n            }\n            -3 => {\n                version_etc(\n                    stdout,\n                    b\"pwd\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);\n            }\n            _ => {\n                usage(1);\n            }\n        }\n    }\n    if optind < argc {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"ignoring non-option arguments\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"ignoring non-option arguments\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"ignoring non-option arguments\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if logical {\n        wd = logical_getcwd();\n        if !wd.is_null() {\n            puts(wd);\n            return 0 as libc::c_int;\n        }\n    }\n    wd = xgetcwd();\n    if !wd.is_null() {\n        puts(wd);\n        free(wd as *mut libc::c_void);\n    } else {\n        let mut file_name = Box::into_raw(Box::new(file_name_init())); // Convert to raw pointer\n        robust_getcwd(file_name);\n        puts((*file_name).start);\n        file_name_free(file_name);\n    }\n    return 0 as libc::c_int;\n}\npub fn main() {\n    let args: Vec<String> = ::std::env::args().collect();\n    let mut c_args: Vec<*mut libc::c_char> = Vec::new();\n    \n    for arg in args {\n        let c_string = ::std::ffi::CString::new(arg).expect(\"Failed to convert argument into CString.\");\n        c_args.push(c_string.into_raw());\n    }\n    \n    c_args.push(::std::ptr::null_mut());\n    \n    let status;\n    unsafe {\n        status = main_0(\n            (c_args.len() - 1) as libc::c_int,\n            c_args.as_mut_ptr(),\n        );\n    }\n    \n    ::std::process::exit(status as i32);\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\pwd.rs"
    },
    {
      "chunk": "use std::clone::Clone;\nuse std::option::Option;\nuse std::ffi::CString;\nuse std::convert::TryInto;\nuse std::os::raw::c_char;\nuse std::mem;\nuse std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nfn c32isprint(wc: u32) -> libc::c_int {\n    unsafe { iswprint(wc) }\n}\n#[inline]\nfn mbszero(ps: &mut mbstate_t) {\n    unsafe {\n        std::ptr::write_bytes(ps, 0, std::mem::size_of::<mbstate_t>());\n    }\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub fn clone_quoting_options(o: Option<&quoting_options>) -> Box<quoting_options> {\n    let options = o.unwrap_or(unsafe { &default_quoting_options });\n    let cloned_options = options.clone();\n    Box::new(cloned_options)\n}\n#[no_mangle]\npub fn get_quoting_style(o: Option<&quoting_options>) -> quoting_style {\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &default_quoting_options },\n    };\n    options.style\n}\n#[no_mangle]\npub fn set_quoting_style(\n    o: Option<&mut quoting_options>,\n    s: quoting_style,\n) {\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &mut default_quoting_options },\n    };\n    options.style = s;\n}\n#[no_mangle]\npub fn set_char_quoting(\n    o: Option<&mut quoting_options>,\n    c: u8,\n    i: i32,\n) -> i32 {\n    let index = (c as usize) / (std::mem::size_of::<u32>() * 8);\n    let shift = (c as usize) % (std::mem::size_of::<u32>() * 8);\n    \n    let p: &mut u32 = match o {\n        Some(options) => &mut options.quote_these_too[index],\n        None => {\n            // Use an unsafe block to mutate the static variable\n            unsafe { &mut default_quoting_options.quote_these_too[index] }\n        },\n    };\n\n    let r: i32 = ((*p >> shift) & 1) as i32;\n    *p ^= ((i & 1 ^ r) << shift) as u32;\n    r\n}\n#[no_mangle]\npub fn set_quoting_flags(\n    o: Option<&mut quoting_options>,\n    i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int;\n    let options = match o {\n        Some(opt) => opt,\n        None => unsafe { &mut default_quoting_options },\n    };\n    r = options.flags;\n    options.flags = i;\n    r\n}\n#[no_mangle]\npub fn set_custom_quoting(\n    mut o: Option<&mut quoting_options>,\n    left_quote: &CStr,\n    right_quote: &CStr,\n) {\n    let default_options = unsafe { &mut default_quoting_options };\n    let o = o.unwrap_or(default_options);\n    o.style = custom_quoting_style;\n\n    o.left_quote = left_quote.as_ptr();\n    o.right_quote = right_quote.as_ptr();\n}\nfn quoting_options_from_style(style: quoting_style) -> quoting_options {\n    let mut o = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: std::ptr::null(),\n        right_quote: std::ptr::null(),\n    };\n\n    if style as u32 == custom_quoting_style as i32 as u32 {\n        panic!(\"Custom quoting style is not allowed\");\n    }\n\n    o.style = style;\n    o\n}\nfn gettext_quote(msgid: &str, s: quoting_style) -> String {\n    let translation = unsafe { std::ffi::CStr::from_ptr(gettext(msgid.as_ptr() as *const libc::c_char)) }\n        .to_string_lossy()\n        .into_owned();\n    let locale_code = unsafe { std::ffi::CStr::from_ptr(locale_charset()) }\n        .to_string_lossy()\n        .into_owned();\n    \n    if translation != msgid {\n        return translation;\n    }\n    \n    unsafe {\n        if c_strcasecmp(locale_code.as_ptr() as *const libc::c_char, b\"UTF-8\\0\".as_ptr() as *const libc::c_char) == 0 {\n            return if msgid.chars().next() == Some('`') {\n                \"\\u{2018}\".to_string() // Left single quotation mark\n            } else {\n                \"\\u{2019}\".to_string() // Right single quotation mark\n            };\n        }\n        \n        if c_strcasecmp(locale_code.as_ptr() as *const libc::c_char, b\"GB18030\\0\".as_ptr() as *const libc::c_char) == 0 {\n            return if msgid.chars().next() == Some('`') {\n                \"\\u{A1E7}\".to_string() // Left single quotation mark in GB18030\n            } else {\n                \"\\u{A1AF}\".to_string() // Right single quotation mark in GB18030\n            };\n        }\n    }\n    \n    if s as u32 == clocale_quoting_style as i32 as u32 {\n        return \"\\\"\".to_string();\n    } else {\n        return \"'\".to_string();\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    let left_quote = gettext_quote(\"`\", quoting_style);\n                    let right_quote = gettext_quote(\"'\", quoting_style);\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    escaping = true;\n    if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = b'\\'' as i8 }; // Add single quote\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = b'$' as i8 }; // Add dollar sign\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = b'\\'' as i8 }; // Add single quote\n        }\n        len += 1;\n        pending_shell_escape_end = true;\n    }\n    if len < buffersize {\n        unsafe { *buffer.offset(len as isize) = b'\\\\' as i8 }; // Add backslash\n    }\n    len += 1;\n\n    if quoting_style != shell_always_quoting_style\n        && i + 1 < argsize\n        && (unsafe { *arg.offset((i + 1) as isize) } as u8).is_ascii_digit()\n    {\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = b'0' as i8 }; // Add zero\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = b'0' as i8 }; // Add zero\n        }\n        len += 1;\n    }\n    c = b'0'; // Set c to zero\n    current_block = 253337042034819032;\n} else if flags & QA_ELIDE_NULL_BYTES as i32 != 0 {\n    current_block = 13619784596304402172;\n} else {\n    current_block = 253337042034819032;\n}\n\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    current_block = 4476262310586904498;\n} else if backslash_escapes && elide_outer_quotes && quote_string_len != 0 {\n    current_block = 4476262310586904498;\n} else {\n    current_block = 9215498979640025612;\n}\n\n                }\n                123 | 125 => {\n                    let new_current_block = if argsize == u64::MAX {\n    let arg_slice = unsafe { std::ffi::CStr::from_ptr(arg) };\n    arg_slice.to_bytes().get(1).map_or(false, |&b| b == 0)\n} else {\n    argsize == 1\n};\n\ncurrent_block = if !new_current_block {\n    253337042034819032\n} else {\n    16442922512115311366\n};\n\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    let mut encountered_single_quote = true;\nlet mut c_and_shell_quote_compat = true;\n\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    if buffersize != 0 && orig_buffersize == 0 {\n        orig_buffersize = buffersize;\n        buffersize = 0;\n    }\n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\'' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\\\' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\'' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    pending_shell_escape_end = false;\n    current_block = 253337042034819032;\n} else {\n    current_block = 253337042034819032;\n}\n\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if m > 1 || (backslash_escapes && !printable) {\n    let ilim = i.wrapping_add(m);\n    let buffer_slice = unsafe { std::slice::from_raw_parts_mut(buffer, buffersize as usize) };\n    loop {\n        if backslash_escapes && !printable {\n            if elide_outer_quotes {\n                current_block = 7928555609993211441;\n                break 's_25;\n            }\n            escaping = true;\n            if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n                if len < buffersize {\n                    buffer_slice[len as usize] = b'\\'' as i8; // Add single quote\n                }\n                len += 1;\n                if len < buffersize {\n                    buffer_slice[len as usize] = b'$' as i8; // Add dollar sign\n                }\n                len += 1;\n                if len < buffersize {\n                    buffer_slice[len as usize] = b'\\'' as i8; // Add single quote\n                }\n                len += 1;\n                pending_shell_escape_end = true;\n            }\n            if len < buffersize {\n                buffer_slice[len as usize] = b'\\\\' as i8; // Add backslash\n            }\n            len += 1;\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as u8 + (c >> 6)) as i8; // Add first octet\n            }\n            len += 1;\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as u8 + ((c >> 3) & 7)) as i8; // Add second octet\n            }\n            len += 1;\n            c = ('0' as u8 + (c & 7)) as u8; // Update c to last octet\n        } else if is_right_quote {\n            if len < buffersize {\n                buffer_slice[len as usize] = b'\\\\' as i8; // Add backslash\n            }\n            len += 1;\n            is_right_quote = false;\n        }\n        if ilim <= i.wrapping_add(1) {\n            break;\n        }\n        if pending_shell_escape_end && !escaping {\n            if len < buffersize {\n                buffer_slice[len as usize] = b'\\'' as i8; // Add single quote\n            }\n            len += 1;\n            if len < buffersize {",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "                buffer_slice[len as usize] = b'\\'' as i8; // Add single quote\n            }\n            len += 1;\n            pending_shell_escape_end = false;\n        }\n        if len < buffersize {\n            buffer_slice[len as usize] = c as i8; // Add current character\n        }\n        len += 1;\n        i += 1;\n        c = *arg.offset(i as isize) as u8; // Update c to next character\n    }\n    current_block = 4476262310586904498;\n} else {\n    current_block = 253337042034819032;\n}\n\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            let mut current_block = match current_block {\n    16620298045565028098 => {\n        15155215915847730705\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    15155215915847730705 => {\n        if quoting_style == shell_always_quoting_style && elide_outer_quotes {\n            break 's_25;\n        }\n        253337042034819032\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    253337042034819032 => {\n        if !((backslash_escapes && quoting_style != shell_always_quoting_style) || elide_outer_quotes)\n            && !quote_these_too.is_null()\n            && (unsafe { *quote_these_too.offset(c as isize / (std::mem::size_of::<libc::c_int>() * 8) as isize) } >> (c as usize % (std::mem::size_of::<libc::c_int>() * 8)) & 1) != 0\n            && !is_right_quote {\n            4476262310586904498\n        } else {\n            3173013908131212616\n        }\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    3173013908131212616 => {\n        if elide_outer_quotes {\n            break 's_25;\n        }\n        escaping = true;\n        if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '$' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            pending_shell_escape_end = true;\n        }\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '\\\\' as i8; }\n        }\n        len += 1;\n        4476262310586904498\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    4476262310586904498 => {\n        if pending_shell_escape_end && !escaping {\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            pending_shell_escape_end = false;\n        }\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = c as i8; }\n        }\n        len += 1;\n        if !c_and_shell_quote_compat {\n            all_c_and_shell_quote_compat = false;\n        }\n        current_block\n    }\n    _ => current_block,\n};\n\ni += 1;\n\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n    return quotearg_buffer_restyled(\n        buffer,\n        orig_buffersize,\n        arg,\n        argsize,\n        c_quoting_style,\n        flags,\n        quote_these_too,\n        left_quote,\n        right_quote,\n    );\n} else {\n    if !(buffersize == 0 && orig_buffersize != 0) {\n        current_block = 6412618891452676311;\n        break;\n    }\n    buffersize = orig_buffersize;\n    len = 0;\n}\n\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub fn quotearg_buffer(\n    buffer: &mut [u8],\n    arg: &[u8],\n    o: Option<&quoting_options>,\n) -> usize {\n    let p = o.unwrap_or(unsafe { &default_quoting_options });\n    \n    let r = unsafe {\n        quotearg_buffer_restyled(\n            buffer.as_mut_ptr() as *mut libc::c_char,\n            buffer.len().try_into().unwrap(),\n            arg.as_ptr() as *const libc::c_char,\n            arg.len().try_into().unwrap(),\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        )\n    };\n\n    r.try_into().unwrap()\n}\n#[no_mangle]\npub fn quotearg_alloc(\n    arg: &CStr,\n    argsize: usize,\n    o: &quoting_options,\n) -> CString {\n    let arg_ptr = arg.as_ptr();\n    let mut size: u64 = 0; // Use u64 to match the expected type\n    let result_ptr;\n\n    unsafe {\n        result_ptr = quotearg_alloc_mem(arg_ptr, argsize.try_into().unwrap(), &mut size as *mut u64, o);\n    }\n\n    unsafe { CString::from_raw(result_ptr) } // Convert the raw pointer back to CString\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};\nstatic mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub fn quotearg_n(n: i32, arg: &CStr) -> *mut libc::c_char {\n    unsafe {\n        let options = &default_quoting_options;\n        quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            u64::MAX,\n            options,\n        )\n    }\n}\n#[no_mangle]\npub fn quotearg_n_mem(\n    n: i32,\n    arg: &CStr,\n    argsize: usize,\n) -> *mut libc::c_char {\n    unsafe {\n        let options = &default_quoting_options;\n        quotearg_n_options(n, arg.as_ptr(), argsize.try_into().unwrap(), options)\n    }\n}\n#[no_mangle]\npub fn quotearg(arg: &CStr) -> CString {\n    let result_ptr = quotearg_n(0, arg);\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub fn quotearg_mem(arg: &CStr) -> *mut libc::c_char {\n    let argsize = arg.to_bytes().len();\n    quotearg_n_mem(0, arg, argsize)\n}\n#[no_mangle]\npub fn quotearg_n_style(\n    n: i32,\n    s: quoting_style,\n    arg: &CStr,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    unsafe {\n        quotearg_n_options(n, arg.as_ptr(), u64::MAX, &o)\n    }\n}\n#[no_mangle]\npub fn quotearg_n_style_mem(\n    n: i32,\n    s: quoting_style,\n    arg: &CStr,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    let argsize = arg.to_bytes().len() as u64; // Convert to u64\n    unsafe {\n        quotearg_n_options(n, arg.as_ptr(), argsize, &o)\n    }\n}\n#[no_mangle]\npub fn quotearg_style(\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let result_ptr = quotearg_n_style(0, s, arg);\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub fn quotearg_style_mem(\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let result_ptr = quotearg_n_style_mem(0, s, arg);\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    let result = set_char_quoting(Some(&mut options), ch as u8, 1);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub fn quotearg_char(arg: &CStr, ch: char) -> *mut libc::c_char {\n    let ch_as_c_char = ch as u8 as libc::c_char;\n    unsafe {\n        quotearg_char_mem(arg.as_ptr(), 18446744073709551615 as libc::c_ulong, ch_as_c_char)\n    }\n}\n#[no_mangle]\npub fn quotearg_colon(arg: &CStr) -> String {\n    let ch: char = ':'; // Define the character to be used\n    let result_ptr = quotearg_char(arg, ch); // Call the original function\n    unsafe { CStr::from_ptr(result_ptr).to_string_lossy().into_owned() } // Convert the result to a String\n}\n#[no_mangle]\npub fn quotearg_colon_mem(arg: &CStr) -> String {\n    let argsize = arg.to_bytes().len() as u64;\n    let result_ptr: *mut libc::c_char = unsafe { quotearg_char_mem(arg.as_ptr(), argsize, ':' as i32 as libc::c_char) };\n    unsafe { CStr::from_ptr(result_ptr).to_string_lossy().into_owned() }\n}\n#[no_mangle]\npub fn quotearg_n_style_colon(\n    n: i32,\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: std::ptr::null(),\n        right_quote: std::ptr::null(),\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(Some(&mut options), ':' as u8, 1);\n    \n    let result_ptr = unsafe {\n        quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            u64::MAX,\n            &mut options,\n        )\n    };\n    \n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub fn quotearg_n_custom(\n    n: i32,\n    left_quote: &CStr,\n    right_quote: &CStr,\n    arg: &CStr,\n) -> CString {\n    unsafe {\n        let result_ptr = quotearg_n_custom_mem(\n            n,\n            left_quote.as_ptr(),\n            right_quote.as_ptr(),\n            arg.as_ptr(),\n            u64::MAX,\n        );\n        CStr::from_ptr(result_ptr).to_owned()\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(Some(&mut o), CStr::from_ptr(left_quote), CStr::from_ptr(right_quote));\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub fn quotearg_custom(\n    left_quote: &str,\n    right_quote: &str,\n    arg: &str,\n) -> String {\n    let left_quote_c = CString::new(left_quote).unwrap();\n    let right_quote_c = CString::new(right_quote).unwrap();\n    let arg_c = CString::new(arg).unwrap();\n    \n    let result = quotearg_n_custom(0, left_quote_c.as_c_str(), right_quote_c.as_c_str(), arg_c.as_c_str());\n    result.to_string_lossy().into_owned()\n}\n#[no_mangle]\npub fn quotearg_custom_mem(\n    left_quote: &CStr,\n    right_quote: &CStr,\n    arg: &CStr,\n) -> String {\n    let argsize = arg.to_bytes().len() as u64;\n    let result_ptr: *mut libc::c_char;\n\n    unsafe {\n        result_ptr = quotearg_n_custom_mem(\n            0,\n            left_quote.as_ptr(),\n            right_quote.as_ptr(),\n            arg.as_ptr(),\n            argsize,\n        );\n        CStr::from_ptr(result_ptr).to_string_lossy().into_owned()\n    }\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub fn quote_n_mem(\n    n: i32,\n    arg: &CStr,\n    argsize: u64,\n) -> *const libc::c_char {\n    unsafe {\n        quotearg_n_options(n, arg.as_ptr(), argsize, &quote_quoting_options)\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    let arg_cstr = CStr::from_ptr(arg);\nreturn quote_n_mem(0, arg_cstr, argsize.try_into().unwrap());\n}\n#[no_mangle]\npub fn quote_n(n: i32, arg: &CStr) -> *const libc::c_char {\n    quote_n_mem(n, arg, u64::MAX)\n}\n#[no_mangle]\npub fn quote(arg: &CStr) -> &CStr {\n    let result = unsafe { quote_n(0, arg) };\n    unsafe { CStr::from_ptr(result) }\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "use std::ffi::CString;\nuse std::option::Option;\nuse ::libc;\nextern \"C\" {\n    fn lstat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n}\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\npub type ino_t = __ino_t;\npub type dev_t = __dev_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct dev_ino {\n    pub st_ino: ino_t,\n    pub st_dev: dev_t,\n}\n#[no_mangle]\npub fn get_root_dev_ino(root_d_i: &mut dev_ino) -> Option<&dev_ino> {\n    let mut statbuf: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    \n    let path = std::ffi::CString::new(\"/\").unwrap();\n    if unsafe { lstat(path.as_ptr(), &mut statbuf) } != 0 {\n        return None;\n    }\n    \n    root_d_i.st_ino = statbuf.st_ino;\n    root_d_i.st_dev = statbuf.st_dev;\n    Some(root_d_i)\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\root_dev_ino.rs"
    },
    {
      "chunk": "use libc::stat as libc_stat;\nuse ::libc;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn psame_inode(a: &libc::stat, b: &libc::stat) -> bool {\n    a.st_dev == b.st_dev && a.st_ino == b.st_ino\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\same_inode.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn setlocale_null_r(\n    category: libc::c_int,\n    buf: &mut [u8],\n) -> libc::c_int {\n    let bufsize = buf.len() as u64; // Convert usize to u64\n    let buf_ptr = buf.as_mut_ptr() as *mut libc::c_char;\n\n    unsafe {\n        return setlocale_null_r_unlocked(category, buf_ptr, bufsize);\n    }\n}\n#[no_mangle]\npub fn setlocale_null(category: libc::c_int) -> Option<String> {\n    unsafe {\n        let result = setlocale_null_unlocked(category);\n        if result.is_null() {\n            None\n        } else {\n            Some(CStr::from_ptr(result).to_string_lossy().into_owned())\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\setlocale_null.rs"
    },
    {
      "chunk": "use std::slice;\nuse ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub fn setlocale_null_r_unlocked(\n    category: libc::c_int,\n    buf: &mut Vec<u8>,\n) -> libc::c_int {\n    let result: *const libc::c_char = unsafe { setlocale_null_unlocked(category) };\n    if result.is_null() {\n        if !buf.is_empty() {\n            buf[0] = 0; // Null-terminate the buffer\n        }\n        return 22; // EINVAL\n    } else {\n        let length: usize = unsafe { strlen(result) } as usize; // Cast to usize\n        if length < buf.len() {\n            buf[..length].copy_from_slice(unsafe { std::slice::from_raw_parts(result as *const u8, length) });\n            buf[length] = 0; // Null-terminate the buffer\n            return 0; // Success\n        } else {\n            let copy_length = buf.len() - 1;\n            if !buf.is_empty() {\n                buf[..copy_length].copy_from_slice(unsafe { std::slice::from_raw_parts(result as *const u8, copy_length) });\n                buf[copy_length] = 0; // Null-terminate the buffer\n            }\n            return 34; // ERANGE\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\setlocale_null_unlocked.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\version.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse std::os::raw::c_char;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n    0 => {}\n    1 => {\n        let msg = gettext(b\"Written by %s.\\n\\0\".as_ptr() as *const libc::c_char);\n        unsafe {\n            fprintf(stream, msg, *authors.offset(0));\n        }\n    }\n    2 => {\n        let msg = gettext(b\"Written by %s and %s.\\n\\0\".as_ptr() as *const libc::c_char);\n        unsafe {\n            fprintf(stream, msg, *authors.offset(0), *authors.offset(1));\n        }\n    }\n    3 => {\n        let msg = gettext(b\"Written by %s, %s, and %s.\\n\\0\".as_ptr() as *const libc::c_char);\n        unsafe {\n            fprintf(stream, msg, *authors.offset(0), *authors.offset(1), *authors.offset(2));\n        }\n    }\n    4 => {\n        let msg = gettext(b\"Written by %s, %s, %s, and %s.\\n\\0\".as_ptr() as *const libc::c_char);\n        unsafe {\n            fprintf(stream, msg, *authors.offset(0), *authors.offset(1), *authors.offset(2), *authors.offset(3));\n        }\n    }\n    5 => {\n        let msg = gettext(b\"Written by %s, %s, %s, %s, and %s.\\n\\0\".as_ptr() as *const libc::c_char);\n        unsafe {\n            fprintf(stream, msg, *authors.offset(0), *authors.offset(1), *authors.offset(2), *authors.offset(3), *authors.offset(4));\n        }\n    }\n    6 => {\n        let msg = gettext(b\"Written by %s, %s, %s, %s, %s, and %s.\\n\\0\".as_ptr() as *const libc::c_char);\n        unsafe {\n            fprintf(stream, msg, *authors.offset(0), *authors.offset(1), *authors.offset(2), *authors.offset(3), *authors.offset(4), *authors.offset(5));\n        }\n    }\n    7 => {\n        let msg = gettext(b\"Written by %s, %s, %s, %s, %s, %s, and %s.\\n\\0\".as_ptr() as *const libc::c_char);\n        unsafe {\n            fprintf(stream, msg, *authors.offset(0), *authors.offset(1), *authors.offset(2), *authors.offset(3), *authors.offset(4), *authors.offset(5), *authors.offset(6));\n        }\n    }\n    8 => {\n        let msg = gettext(b\"Written by %s, %s, %s, %s, %s, %s, %s, and %s.\\n\\0\".as_ptr() as *const libc::c_char);\n        unsafe {\n            fprintf(stream, msg, *authors.offset(0), *authors.offset(1), *authors.offset(2), *authors.offset(3), *authors.offset(4), *authors.offset(5), *authors.offset(6), *authors.offset(7));\n        }\n    }\n    9 => {\n        let msg = gettext(b\"Written by %s, %s, %s, %s, %s, %s, %s, %s, and %s.\\n\\0\".as_ptr() as *const libc::c_char);\n        unsafe {\n            fprintf(stream, msg, *authors.offset(0), *authors.offset(1), *authors.offset(2), *authors.offset(3), *authors.offset(4), *authors.offset(5), *authors.offset(6), *authors.offset(7), *authors.offset(8));\n        }\n    }\n    _ => {\n        let msg = gettext(b\"Written by %s, %s, %s, %s, %s, %s, %s, %s, and others.\\n\\0\".as_ptr() as *const libc::c_char);\n        unsafe {\n            fprintf(stream, msg, *authors.offset(0), *authors.offset(1), *authors.offset(2), *authors.offset(3), *authors.offset(4), *authors.offset(5), *authors.offset(6), *authors.offset(7), *authors.offset(8));\n        }\n    }\n};\n\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub fn emit_bug_reporting_address() {\n    println!();\n    println!(\n        \"{}\",\n        unsafe { CStr::from_ptr(gettext(b\"Report bugs to: \\0\".as_ptr() as *const c_char)).to_string_lossy() }\n    );\n    println!(\n        \"{} home page: <{}>\",\n        unsafe { CStr::from_ptr(gettext(b\"GNU coreutils\\0\".as_ptr() as *const c_char)).to_string_lossy() },\n        unsafe { CStr::from_ptr(b\"https://www.gnu.org/software/coreutils/\\0\".as_ptr() as *const c_char).to_string_lossy() }\n    );\n    println!(\n        \"General help using GNU software: <{}>\",\n        unsafe { CStr::from_ptr(b\"https://www.gnu.org/gethelp/\\0\".as_ptr() as *const c_char).to_string_lossy() }\n    );\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\version_etc.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\version_etc_fsf.rs"
    },
    {
      "chunk": "use std::process;\nuse ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub fn xalloc_die() {\n    unsafe {\n        if 0 != 0 {\n            error(\n                exit_failure,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if exit_failure != 0 {\n                unreachable!();\n            }\n        } else {\n            let errstatus = exit_failure;\n            error(\n                errstatus,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if errstatus != 0 {\n                unreachable!();\n            }\n\n            let errstatus = exit_failure;\n            error(\n                errstatus,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if errstatus != 0 {\n                unreachable!();\n            }\n        }\n    }\n    std::process::abort();\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\xalloc_die.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn getcwd(__buf: *mut libc::c_char, __size: size_t) -> *mut libc::c_char;\n    fn xalloc_die();\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn xgetcwd() -> *mut libc::c_char {\n    let mut cwd: *mut libc::c_char = getcwd(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n    );\n    if cwd.is_null() && *__errno_location() == 12 as libc::c_int {\n        xalloc_die();\n    }\n    return cwd;\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\xgetcwd.rs"
    },
    {
      "chunk": "use std::slice;\nuse std::option::Option;\nuse std::vec;\nuse std::vec::Vec;\nuse std::io;\nuse std::ffi::CString;\nuse ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nunsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[inline]\nfn icalloc(n: i64, s: i64) -> *mut libc::c_void {\n    let n_usize = n.try_into().unwrap_or(0);\n    let s_usize = s.try_into().unwrap_or(0);\n\n    if n_usize > usize::MAX / s_usize {\n        if s_usize != 0 {\n            return unsafe { _gl_alloc_nomem() }; // Call the unsafe function within an unsafe block\n        }\n        return std::ptr::null_mut(); // Return a null pointer\n    }\n    if s_usize > usize::MAX / n_usize {\n        if n_usize != 0 {\n            return unsafe { _gl_alloc_nomem() }; // Call the unsafe function within an unsafe block\n        }\n        return std::ptr::null_mut(); // Return a null pointer\n    }\n    let total_size = n_usize * s_usize;\n    let vec = vec![0u8; total_size];\n    let boxed_slice = vec.into_boxed_slice();\n    Box::into_raw(boxed_slice) as *mut libc::c_void\n}\n#[inline]\nfn ireallocarray(n: usize, s: usize) -> *mut libc::c_void {\n    if n <= usize::MAX && s <= usize::MAX {\n        let mut nx = n;\n        let mut sx = s;\n        if n == 0 || s == 0 {\n            sx = 1;\n            nx = sx;\n        }\n        let p = unsafe { reallocarray(std::ptr::null_mut(), nx.try_into().unwrap(), sx.try_into().unwrap()) };\n        return p;\n    } else {\n        return std::ptr::null_mut(); // Handle out of memory or invalid allocation\n    }\n}\n#[cold]\n#[inline]\nunsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}\n#[inline]\nfn imalloc(s: usize) -> *mut libc::c_void {\n    if s <= usize::MAX {\n        let layout = std::alloc::Layout::from_size_align(s, 1).unwrap();\n        let ptr = unsafe { std::alloc::alloc(layout) };\n        if ptr.is_null() {\n            std::ptr::null_mut()\n        } else {\n            ptr as *mut libc::c_void\n        }\n    } else {\n        std::ptr::null_mut()\n    }\n}\nfn check_nonnull(p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        unsafe { xalloc_die() };\n    }\n    p\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    let allocated_memory = imalloc(s.try_into().unwrap());\nreturn check_nonnull(allocated_memory);\n}\n#[no_mangle]\npub fn xcharalloc(n: usize) -> Result<CString, std::io::Error> {\n    let buffer = vec![0u8; n];\n    CString::from_vec_with_nul(buffer).map_err(|_| std::io::Error::new(std::io::ErrorKind::InvalidInput, \"Failed to create CString\"))\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub fn xirealloc(p: Option<&mut Vec<u8>>, s: usize) -> Option<Vec<u8>> {\n    match p {\n        Some(vec) => {\n            let mut new_vec = vec.clone();\n            new_vec.resize(s, 0);\n            Some(new_vec)\n        },\n        None => {\n            let mut new_vec = Vec::with_capacity(s);\n            new_vec.resize(s, 0);\n            Some(new_vec)\n        }\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub fn xireallocarray(n: usize, s: usize) -> *mut libc::c_void {\n    let total_size = n.checked_mul(s).expect(\"Overflow in allocation size\");\n    let mut vec = Vec::with_capacity(total_size);\n    let ptr = vec.as_mut_ptr();\n    std::mem::forget(vec); // Prevent Vec from deallocating the memory\n    ptr\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub fn xinmalloc(n: idx_t, s: idx_t) -> Result<Vec<u8>, io::Error> {\n    let size = n.checked_mul(s).ok_or(io::Error::new(io::ErrorKind::InvalidInput, \"Overflow in size calculation\"))?;\n    let vec = Vec::with_capacity(size as usize);\n    Ok(vec)\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub fn xzalloc(s: usize) -> Vec<u8> {\n    vec![0; s]\n}\n#[no_mangle]\npub fn xizalloc(s: idx_t) -> Vec<u8> {\n    let size = s as usize; // Assuming idx_t can be safely cast to usize\n    let vec = vec![0u8; size]; // Allocate a vector of the specified size initialized to zero\n    vec\n}\n#[no_mangle]\npub fn xcalloc(n: usize, s: usize) -> Option<Box<[u8]>> {\n    let total_size = n.checked_mul(s)?;\n    let vec = vec![0u8; total_size];\n    Some(vec.into_boxed_slice())\n}\n#[no_mangle]\npub fn xicalloc(n: usize, s: usize) -> *mut libc::c_void {\n    let total_size = n.checked_mul(s).expect(\"Overflow in allocation size\");\n    let allocation = vec![0u8; total_size].into_boxed_slice();\n    Box::into_raw(allocation) as *mut libc::c_void\n}\n#[no_mangle]\npub fn xmemdup(p: &[u8]) -> Vec<u8> {\n    let mut result = vec![0; p.len()];\n    result.copy_from_slice(p);\n    result\n}\n#[no_mangle]\npub fn ximemdup(p: &[u8]) -> Vec<u8> {\n    let mut result = vec![0u8; p.len()];\n    result.copy_from_slice(p);\n    result\n}\n#[no_mangle]\npub fn ximemdup0(p: &[u8]) -> CString {\n    let mut result = Vec::with_capacity(p.len() + 1);\n    result.extend_from_slice(p);\n    result.push(0); // Null-terminate the string\n    CString::new(result).expect(\"Failed to create CString\")\n}\n#[no_mangle]\npub fn xstrdup(string: &str) -> String {\n    string.to_owned()\n}",
      "file_name": "c2saferrust/coreutils/src\\pwd\\rust_WIP\\src\\xmalloc.rs"
    }
  ],
  "split": [
    {
      "chunk": "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\build.rs"
    },
    {
      "chunk": "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(label_break_value)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod alignalloc;\npub mod basename_lgpl;\npub mod binary_io;\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod close_stream;\npub mod closeout;\npub mod dup_safer;\npub mod dup_safer_flag;\npub mod exitfail;\npub mod fadvise;\npub mod fclose;\npub mod fcntl;\npub mod fd_reopen;\npub mod fd_safer;\npub mod fd_safer_flag;\npub mod fflush;\npub mod fpurge;\npub mod fseeko;\npub mod full_write;\npub mod hard_locale;\npub mod ialloc;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod mkstemp_safer;\npub mod open_safer;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod safe_write;\npub mod same_inode;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod sig2str;\npub mod stdbit;\npub mod stdc_leading_zeros;\npub mod temp_stream;\npub mod tmpdir;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalignalloc;\npub mod xalloc_die;\npub mod xbinary_io;\npub mod xdectoimax;\npub mod xdectoumax;\npub mod xmalloc;\npub mod xstrtoimax;\npub mod xstrtoumax;\n}\n// mod src",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\lib.rs"
    },
    {
      "chunk": "use std::any::Any;\nuse ::libc;\nextern \"C\" {\n    fn free(_: *mut libc::c_void);\n    fn aligned_alloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n}\npub type size_t = libc::c_ulong;\npub type ptrdiff_t = libc::c_long;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn alignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    if (-(1 as libc::c_int) as size_t) < alignment as libc::c_ulong {\n        alignment = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    if (-(1 as libc::c_int) as size_t) < size as libc::c_ulong {\n        size = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    return aligned_alloc(alignment as libc::c_ulong, size as libc::c_ulong);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn alignfree(ptr: Option<Box<dyn std::any::Any>>) {\n    if let Some(boxed) = ptr {\n        drop(boxed);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\alignalloc.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn last_component(\n    mut name: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut base: *const libc::c_char = name.offset(0 as libc::c_int as isize);\n    let mut p: *const libc::c_char = 0 as *const libc::c_char;\n    let mut last_was_slash: bool = 0 as libc::c_int != 0;\n    while *base as libc::c_int == '/' as i32 {\n        base = base.offset(1);\n        base;\n    }\n    p = base;\n    while *p != 0 {\n        if *p as libc::c_int == '/' as i32 {\n            last_was_slash = 1 as libc::c_int != 0;\n        } else if last_was_slash {\n            base = p;\n            last_was_slash = 0 as libc::c_int != 0;\n        }\n        p = p.offset(1);\n        p;\n    }\n    return base as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn base_len(mut name: *const libc::c_char) -> size_t {\n    let mut len: size_t = 0;\n    let mut prefix_len: size_t = 0 as libc::c_int as size_t;\n    len = strlen(name);\n    while (1 as libc::c_int as libc::c_ulong) < len\n        && *name.offset(len.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_int == '/' as i32\n    {\n        len = len.wrapping_sub(1);\n        len;\n    }\n    if 0 as libc::c_int != 0 && len == 1 as libc::c_int as libc::c_ulong\n        && *name.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32\n        && *name.offset(1 as libc::c_int as isize) as libc::c_int == '/' as i32\n        && *name.offset(2 as libc::c_int as isize) == 0\n    {\n        return 2 as libc::c_int as size_t;\n    }\n    if 0 as libc::c_int != 0 && prefix_len != 0 && len == prefix_len\n        && *name.offset(prefix_len as isize) as libc::c_int == '/' as i32\n    {\n        return prefix_len.wrapping_add(1 as libc::c_int as libc::c_ulong);\n    }\n    return len;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\basename_lgpl.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\binary_io.rs"
    },
    {
      "chunk": "use std::ffi::CString;\nuse std::process;\nuse std::io;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub fn close_stdout_set_file_name(file: &str) {\n    let c_string = std::ffi::CString::new(file).expect(\"CString::new failed\");\n    unsafe {\n        file_name = c_string.as_ptr();\n    }\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}\n#[no_mangle]\npub fn close_stdout() {\n    unsafe {\n        if close_stream(stdout) != 0 \n            && !(ignore_EPIPE && std::io::Error::last_os_error().kind() == std::io::ErrorKind::BrokenPipe)\n        {\n            let write_error = gettext(b\"write error\\0\".as_ptr() as *const libc::c_char);\n            if !file_name.is_null() {\n                if false {\n                    error(\n                        0,\n                        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                        b\"%s: %s\\0\".as_ptr() as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    unreachable!();\n                } else {\n                    let __errstatus = 0;\n                    error(\n                        __errstatus,\n                        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                        b\"%s: %s\\0\".as_ptr() as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 {\n                        unreachable!();\n                    }\n                    error(\n                        __errstatus,\n                        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                        b\"%s: %s\\0\".as_ptr() as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 {\n                        unreachable!();\n                    }\n                }\n            } else {\n                if false {\n                    error(\n                        0,\n                        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                        b\"%s\\0\".as_ptr() as *const libc::c_char,\n                        write_error,\n                    );\n                    unreachable!();\n                } else {\n                    let __errstatus = 0;\n                    error(\n                        __errstatus,\n                        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                        b\"%s\\0\".as_ptr() as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 {\n                        unreachable!();\n                    }\n                    error(\n                        __errstatus,\n                        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                        b\"%s\\0\".as_ptr() as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 {\n                        unreachable!();\n                    }\n                }\n            }\n            std::process::exit(exit_failure);\n        }\n        if SANITIZE_ADDRESS == 0 && close_stream(stderr) != 0 {\n            std::process::exit(exit_failure);\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\closeout.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn close_stream(stream: *mut _IO_FILE) -> libc::c_int {\n    let some_pending: bool = unsafe { __fpending(stream) != 0 };\n    let prev_fail: bool = unsafe { ferror_unlocked(stream) != 0 };\n    let fclose_fail: bool = unsafe { rpl_fclose(stream) != 0 };\n\n    if prev_fail || (fclose_fail && (some_pending || unsafe { *__errno_location() != 9 })) {\n        if !fclose_fail {\n            unsafe { *__errno_location() = 0 };\n        }\n        return -1;\n    }\n    return 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\close_stream.rs"
    },
    {
      "chunk": "use std::os::raw::c_int;\nuse std::ops::RangeInclusive;\nuse std::convert::TryFrom;\nuse std::char;\nuse ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalnum(c: i32) -> bool {\n    (c >= 48 && c <= 57) || (c >= 65 && c <= 90) || (c >= 97 && c <= 122)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalpha(c: libc::c_int) -> bool {\n    c >= 65 && c <= 90 || c >= 97 && c <= 122\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isascii(c: i32) -> bool {\n    (0..=127).contains(&c)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_iscntrl(c: i32) -> bool {\n    match c {\n        0..=31 | 127 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isdigit(c: i32) -> bool {\n    c >= 48 && c <= 57\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isgraph(c: i32) -> bool {\n    match c {\n        48..=57 | 97..=122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62\n        | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_islower(c: i32) -> bool {\n    (c >= 97 && c <= 122)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isprint(c: i32) -> bool {\n    char::from_u32(c as u32).map_or(false, |ch| ch.is_ascii() && (ch.is_alphanumeric() || ch.is_ascii_punctuation() || ch.is_whitespace()))\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_ispunct(c: i32) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isupper(c: i32) -> bool {\n    matches!(c, 65..=90)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_tolower(c: i32) -> i32 {\n    if let Some(ch) = char::from_u32(c as u32) {\n        if ch.is_ascii_uppercase() {\n            return ch.to_ascii_lowercase() as i32;\n        }\n    }\n    c\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_toupper(c: i32) -> i32 {\n    if let Some(ch) = char::from_u32(c as u32) {\n        if ch.is_ascii_lowercase() {\n            return c - ('a' as i32 - 'A' as i32);\n        }\n    }\n    c\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\c_ctype.rs"
    },
    {
      "chunk": "use ::libc;\n#[inline]\nunsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\npub fn c_strcasecmp(s1: &str, s2: &str) -> libc::c_int {\n    let mut iter1 = s1.chars().map(|c| c.to_ascii_lowercase());\n    let mut iter2 = s2.chars().map(|c| c.to_ascii_lowercase());\n\n    loop {\n        let c1 = iter1.next().unwrap_or('\\0');\n        let c2 = iter2.next().unwrap_or('\\0');\n\n        if c1 == '\\0' {\n            return 0;\n        }\n\n        if c1 != c2 {\n            return c1 as libc::c_int - c2 as libc::c_int;\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\c_strcasecmp.rs"
    },
    {
      "chunk": "use std::os::unix::io::FromRawFd;\nuse ::libc;\nextern \"C\" {\n    fn rpl_fcntl(fd: libc::c_int, action: libc::c_int, _: ...) -> libc::c_int;\n}\n#[no_mangle]\npub fn dup_safer(fd: i32) -> i32 {\n    use std::os::unix::io::AsRawFd;\n    use std::os::unix::io::FromRawFd;\n\n    let new_fd = unsafe { rpl_fcntl(fd, 0, libc::F_DUPFD + 1) };\n    new_fd\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\dup_safer.rs"
    },
    {
      "chunk": "use std::io;\nuse ::libc;\nextern \"C\" {\n    fn rpl_fcntl(fd: libc::c_int, action: libc::c_int, _: ...) -> libc::c_int;\n}\n#[no_mangle]\npub fn dup_safer_flag(fd: i32, flag: i32) -> Result<i32, std::io::Error> {\n    let command = if flag & 0o2000000 != 0 {\n        1030\n    } else {\n        0\n    };\n    let result = unsafe { rpl_fcntl(fd, command, 2 + 1) };\n    if result == -1 {\n        Err(std::io::Error::last_os_error())\n    } else {\n        Ok(result)\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\dup_safer_flag.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\exitfail.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn posix_fadvise(\n        __fd: libc::c_int,\n        __offset: off_t,\n        __len: off_t,\n        __advise: libc::c_int,\n    ) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type fadvice_t = libc::c_uint;\npub const FADVISE_RANDOM: fadvice_t = 1;\npub const FADVISE_WILLNEED: fadvice_t = 3;\npub const FADVISE_DONTNEED: fadvice_t = 4;\npub const FADVISE_NOREUSE: fadvice_t = 5;\npub const FADVISE_SEQUENTIAL: fadvice_t = 2;\npub const FADVISE_NORMAL: fadvice_t = 0;\n#[no_mangle]\npub unsafe extern \"C\" fn fdadvise(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut len: off_t,\n    mut advice: fadvice_t,\n) {\n    posix_fadvise(fd, offset, len, advice as libc::c_int);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn fadvise(mut fp: *mut FILE, mut advice: fadvice_t) {\n    if !fp.is_null() {\n        fdadvise(\n            fileno(fp),\n            0 as libc::c_int as off_t,\n            0 as libc::c_int as off_t,\n            advice,\n        );\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\fadvise.rs"
    },
    {
      "chunk": "use std::os::raw::c_int;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn rpl_fclose(fp: &mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0;\n    let fd = unsafe { fileno(fp) };\n    \n    if fd < 0 {\n        return unsafe { fclose(fp) };\n    }\n    \n    let is_reading = unsafe { __freading(fp) != 0 };\n    let seek_result = unsafe { lseek(fd, 0, 1) };\n    \n    if (!is_reading || seek_result != -1) && unsafe { rpl_fflush(fp) != 0 } {\n        saved_errno = unsafe { *__errno_location() };\n    }\n    \n    let result = unsafe { fclose(fp) };\n    \n    if saved_errno != 0 {\n        unsafe { *__errno_location() = saved_errno };\n        return -1;\n    }\n    \n    result\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\fclose.rs"
    },
    {
      "chunk": "use std::ffi::VaList;\nuse ::libc;\nextern \"C\" {\n    fn fcntl(__fd: libc::c_int, __cmd: libc::c_int, _: ...) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\n#[no_mangle]\npub fn rpl_fcntl(\n    fd: libc::c_int,\n    action: libc::c_int,\n    args: &mut std::ffi::VaList,\n) -> libc::c_int {\n    let mut result: libc::c_int = -1;\n\n    match action {\n        0 => {\n            let target: libc::c_int;\n            unsafe {\n                target = args.arg::<libc::c_int>();\n            }\n            result = rpl_fcntl_DUPFD(fd, target);\n        }\n        1030 => {\n            let target: libc::c_int;\n            unsafe {\n                target = args.arg::<libc::c_int>();\n            }\n            result = rpl_fcntl_DUPFD_CLOEXEC(fd, target);\n        }\n        _ => {\n            match action {\n                1 | 3 => {\n                    result = unsafe { fcntl(fd, action) };\n                }\n                1025 => {\n                    let p: *mut libc::c_void;\n                    unsafe {\n                        p = args.arg::<*mut libc::c_void>();\n                    }\n                    result = unsafe { fcntl(fd, action, p) };\n                }\n                9 | 1032 | 1034 | 11 | 1033 => {\n                    result = unsafe { fcntl(fd, action) };\n                }\n                2 | 4 => {\n                    let x: libc::c_int;\n                    unsafe {\n                        x = args.arg::<libc::c_int>();\n                    }\n                    result = unsafe { fcntl(fd, action, x) };\n                }\n                1024 | 10 => {\n                    let x: libc::c_int;\n                    unsafe {\n                        x = args.arg::<libc::c_int>();\n                    }\n                    result = unsafe { fcntl(fd, action, x) };\n                }\n                _ => {\n                    let p: *mut libc::c_void;\n                    unsafe {\n                        p = args.arg::<*mut libc::c_void>();\n                    }\n                    result = unsafe { fcntl(fd, action, p) };\n                }\n            }\n        }\n    }\n    result\n}\nfn rpl_fcntl_DUPFD(fd: i32, target: i32) -> i32 {\n    unsafe {\n        fcntl(fd, libc::F_DUPFD, target)\n    }\n}\nstatic mut have_dupfd_cloexec: libc::c_int = 0;\nfn rpl_fcntl_DUPFD_CLOEXEC(fd: libc::c_int, target: libc::c_int) -> libc::c_int {\n    static mut HAVE_DUPFD_CLOEXEC: libc::c_int = 0;\n    let mut result: libc::c_int;\n\n    unsafe {\n        if HAVE_DUPFD_CLOEXEC <= 0 {\n            result = fcntl(fd, 1030);\n            if result > 0 || *__errno_location() != 22 {\n                HAVE_DUPFD_CLOEXEC = 1;\n            } else {\n                result = rpl_fcntl_DUPFD(fd, target);\n                if result >= 0 {\n                    HAVE_DUPFD_CLOEXEC = -1;\n                }\n            }\n        } else {\n            result = rpl_fcntl_DUPFD(fd, target);\n        }\n\n        if result >= 0 && HAVE_DUPFD_CLOEXEC == -1 {\n            let flags = fcntl(result, 1);\n            if flags < 0 || fcntl(result, 2, flags | 1) == -1 {\n                let saved_errno = *__errno_location();\n                close(result);\n                *__errno_location() = saved_errno;\n                result = -1;\n            }\n        }\n    }\n    result\n}\nunsafe extern \"C\" fn run_static_initializers() {\n    have_dupfd_cloexec = if 0 as libc::c_int != 0 {\n        -(1 as libc::c_int)\n    } else {\n        0 as libc::c_int\n    };\n}\n#[used]\n#[cfg_attr(target_os = \"linux\", link_section = \".init_array\")]\n#[cfg_attr(target_os = \"windows\", link_section = \".CRT$XIB\")]\n#[cfg_attr(target_os = \"macos\", link_section = \"__DATA,__mod_init_func\")]\nstatic INIT_ARRAY: [unsafe extern \"C\" fn(); 1] = [run_static_initializers];",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\fcntl.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn dup2(__fd: libc::c_int, __fd2: libc::c_int) -> libc::c_int;\n}\npub type __mode_t = libc::c_uint;\npub type mode_t = __mode_t;\n#[no_mangle]\npub unsafe extern \"C\" fn fd_reopen(\n    mut desired_fd: libc::c_int,\n    mut file: *const libc::c_char,\n    mut flags: libc::c_int,\n    mut mode: mode_t,\n) -> libc::c_int {\n    let mut fd: libc::c_int = open(file, flags, mode);\n    if fd == desired_fd || fd < 0 as libc::c_int {\n        return fd\n    } else {\n        let mut fd2: libc::c_int = dup2(fd, desired_fd);\n        let mut saved_errno: libc::c_int = *__errno_location();\n        close(fd);\n        *__errno_location() = saved_errno;\n        return fd2;\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\fd_reopen.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn dup_safer(_: libc::c_int) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n}\n#[no_mangle]\npub fn fd_safer(fd: i32) -> i32 {\n    if (0..=2).contains(&fd) {\n        let f = unsafe { dup_safer(fd) };\n        let e = std::io::Error::last_os_error(); // Capture the current error\n        unsafe { close(fd) };\n        // Note: Restoring the error is not directly possible in safe Rust.\n        // We will just return the new file descriptor.\n        return f;\n    }\n    fd\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\fd_safer.rs"
    },
    {
      "chunk": "use std::os::unix::io::{AsRawFd, RawFd};\nuse std::fs::File;\nuse std::io::{self, ErrorKind};\nuse ::libc;\nextern \"C\" {\n    fn dup_safer_flag(_: libc::c_int, _: libc::c_int) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n}\n#[no_mangle]\npub fn fd_safer_flag(fd: i32, flag: i32) -> Result<i32, io::Error> {\n    if (0..=2).contains(&fd) {\n        let f = unsafe { dup_safer_flag(fd, flag) }; // Call to unsafe function\n        let e = std::io::Error::last_os_error();\n        unsafe { libc::close(fd) }; // Close the file descriptor safely\n        return Ok(f);\n    }\n    Ok(fd)\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\fd_safer_flag.rs"
    },
    {
      "chunk": "use std::ptr;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nfn clear_ungetc_buffer_preserving_position(fp: *mut FILE) {\n    if unsafe { (*fp)._flags & 0x100 } != 0 {\n        unsafe { rpl_fseeko(fp, 0, 1) };\n    }\n}\n#[no_mangle]\npub fn rpl_fflush(stream: Option<&mut FILE>) -> libc::c_int {\n    unsafe {\n        if let Some(s) = stream {\n            if __freading(s) != 0 {\n                clear_ungetc_buffer_preserving_position(s);\n            }\n            return fflush(s);\n        }\n        fflush(std::ptr::null_mut())\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\fflush.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __fpurge(__fp: *mut FILE);\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn fpurge(fp: *mut _IO_FILE) -> libc::c_int {\n    unsafe {\n        __fpurge(fp);\n    }\n    0\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\fpurge.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\fseeko.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn safe_write(fd: libc::c_int, buf: *const libc::c_void, count: size_t) -> size_t;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn full_write(\n    mut fd: libc::c_int,\n    mut buf: *const libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    let mut total: size_t = 0 as libc::c_int as size_t;\n    let mut ptr: *const libc::c_char = buf as *const libc::c_char;\n    while count > 0 as libc::c_int as libc::c_ulong {\n        let mut n_rw: size_t = safe_write(fd, ptr as *const libc::c_void, count);\n        if n_rw == -(1 as libc::c_int) as size_t {\n            break;\n        }\n        if n_rw == 0 as libc::c_int as libc::c_ulong {\n            *__errno_location() = 28 as libc::c_int;\n            break;\n        } else {\n            total = (total as libc::c_ulong).wrapping_add(n_rw) as size_t as size_t;\n            ptr = ptr.offset(n_rw as isize);\n            count = (count as libc::c_ulong).wrapping_sub(n_rw) as size_t as size_t;\n        }\n    }\n    return total;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\full_write.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn hard_locale(category: libc::c_int) -> bool {\n    let mut locale = vec![0; 257];\n    \n    let result = unsafe {\n        setlocale_null_r(category, locale.as_mut_ptr(), locale.len() as u64)\n    };\n    \n    if result != 0 {\n        return false;\n    }\n\n    let locale_str = unsafe { CStr::from_ptr(locale.as_ptr()).to_string_lossy().into_owned() };\n    \n    if locale_str == \"C\" || locale_str == \"POSIX\" {\n        return false;\n    }\n    \n    true\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\hard_locale.rs"
    },
    {
      "chunk": "use std::usize;\nuse std::vec::Vec;\nuse std::alloc;\nuse std::ptr;\nuse std::slice;\nuse ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn ireallocarray(\n    p: Option<&mut [u8]>,\n    n: idx_t,\n    s: idx_t,\n) -> Option<Vec<u8>> {\n    if n as usize <= usize::MAX && s as usize <= usize::MAX {\n        let mut nx: usize = n as usize;\n        let mut sx: usize = s as usize;\n        if n == 0 || s == 0 {\n            sx = 1;\n            nx = sx;\n        }\n        let new_size = nx.checked_mul(sx)?;\n        let mut vec = match p {\n            Some(slice) => {\n                let mut new_vec = Vec::with_capacity(new_size);\n                new_vec.extend_from_slice(slice);\n                new_vec\n            }\n            None => Vec::with_capacity(new_size),\n        };\n        vec.resize(new_size, 0);\n        Some(vec)\n    } else {\n        return None; // Handle memory allocation failure appropriately\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn icalloc(n: usize, s: usize) -> Option<Vec<u8>> {\n    if n > usize::MAX / s {\n        if s != 0 {\n            return None; // _gl_alloc_nomem();\n        }\n        return Some(Vec::new()); // Return an empty Vec\n    }\n    if s > usize::MAX / n {\n        if n != 0 {\n            return None; // _gl_alloc_nomem();\n        }\n        return Some(Vec::new()); // Return an empty Vec\n    }\n    let total_size = n * s;\n    let vec = vec![0u8; total_size];\n    Some(vec)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn irealloc(p: Option<&mut [u8]>, s: usize) -> Option<Vec<u8>> {\n    if s <= usize::MAX {\n        let new_size = if s == 0 { 0 } else { s };\n        let mut vec = match p {\n            Some(slice) => {\n                let mut new_vec = Vec::with_capacity(new_size);\n                new_vec.extend_from_slice(slice);\n                new_vec\n            },\n            None => Vec::with_capacity(new_size),\n        };\n        vec.resize(new_size, 0);\n        Some(vec)\n    } else {\n        None // Assuming _gl_alloc_nomem() returns None in this context\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn imalloc(s: usize) -> Option<Box<[u8]>> {\n    if s <= usize::MAX {\n        let layout = std::alloc::Layout::from_size_align(s, 1).ok()?;\n        let ptr = unsafe { std::alloc::alloc(layout) };\n        if ptr.is_null() {\n            None\n        } else {\n            Some(unsafe { Box::from_raw(std::slice::from_raw_parts_mut(ptr, s)) })\n        }\n    } else {\n        None // Assuming _gl_alloc_nomem() returns None in idiomatic Rust\n    }\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\ialloc.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;\npub const _NL_WAM_STR: C2RustUnnamed = 131162;\npub const _NL_WMON_12: C2RustUnnamed = 131161;",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "pub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\mbrtoc32.rs"
    },
    {
      "chunk": "use std::mem;\nuse ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn mbszero(ps: &mut mbstate_t) {\n    *ps = mbstate_t {\n        __count: 0,\n        __value: unsafe { std::mem::zeroed() }, // Use zeroed to initialize __value\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\mbszero.rs"
    },
    {
      "chunk": "use std::ffi::CString;\nuse ::libc;\nextern \"C\" {\n    fn mkostemp(__template: *mut libc::c_char, __flags: libc::c_int) -> libc::c_int;\n    fn mkstemp(__template: *mut libc::c_char) -> libc::c_int;\n    fn fd_safer(_: libc::c_int) -> libc::c_int;\n    fn fd_safer_flag(_: libc::c_int, _: libc::c_int) -> libc::c_int;\n}\n#[no_mangle]\npub fn mkstemp_safer(templ: &mut String) -> libc::c_int {\n    let c_str = std::ffi::CString::new(templ.clone()).expect(\"CString::new failed\");\n    let fd = unsafe { mkstemp(c_str.as_ptr() as *mut libc::c_char) };\n    if fd == -1 {\n        return -1; // Handle error appropriately\n    }\n    unsafe { fd_safer(fd) }\n}\n#[no_mangle]\npub fn mkostemp_safer(templ: &mut CString, flags: libc::c_int) -> libc::c_int {\n    let templ_ptr = templ.as_ptr() as *mut libc::c_char;\n    unsafe {\n        return fd_safer_flag(mkostemp(templ_ptr, flags), flags);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\mkstemp_safer.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn fd_safer(_: libc::c_int) -> libc::c_int;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type __mode_t = libc::c_uint;\npub type mode_t = __mode_t;\npub type va_list = __builtin_va_list;\n#[no_mangle]\npub unsafe extern \"C\" fn open_safer(\n    mut file: *const libc::c_char,\n    mut flags: libc::c_int,\n    mut args: ...\n) -> libc::c_int {\n    let mut mode: mode_t = 0 as libc::c_int as mode_t;\n    if flags & 0o100 as libc::c_int != 0 {\n        let mut ap: ::core::ffi::VaListImpl;\n        ap = args.clone();\n        mode = ap.arg::<mode_t>();\n    }\n    return fd_safer(open(file, flags, mode));\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\open_safer.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse std::process;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub fn set_program_name(argv0: *const libc::c_char) {\n    if argv0.is_null() {\n        eprintln!(\"A NULL argv[0] was passed through an exec system call.\");\n        std::process::abort();\n    }\n\n    let c_str = unsafe { std::ffi::CStr::from_ptr(argv0) };\n    let argv0_str = c_str.to_string_lossy();\n    \n    let slash = argv0_str.rfind('/').map(|index| &argv0_str[index + 1..]).unwrap_or(&argv0_str);\n    \n    if slash.len() >= 7 && &slash[slash.len() - 7..] == \"/.libs/\" {\n        let base = &slash[1..];\n        if base.starts_with(\"lt-\") {\n            unsafe {\n                program_invocation_short_name = base[3..].as_ptr() as *mut libc::c_char;\n            }\n        }\n        unsafe {\n            program_name = base.as_ptr() as *const libc::c_char;\n            program_invocation_name = base.as_ptr() as *mut libc::c_char;\n        }\n    } else {\n        unsafe {\n            program_name = argv0;\n            program_invocation_name = argv0 as *mut libc::c_char;\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\progname.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\propername_lite.rs"
    },
    {
      "chunk": "use std::option::Option;\nuse std::clone::Clone;\nuse std::convert::TryInto;\nuse std::ffi::CString;\nuse std::ffi::CStr;\nuse std::os::raw::c_char;\nuse ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nunsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub fn clone_quoting_options(o: Option<&quoting_options>) -> quoting_options {\n    let options_to_clone: &quoting_options = if let Some(ref opt) = o {\n        opt\n    } else {\n        unsafe { &default_quoting_options }\n    };\n    options_to_clone.clone()\n}\n#[no_mangle]\npub fn get_quoting_style(o: Option<&quoting_options>) -> quoting_style {\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &default_quoting_options },\n    };\n    options.style\n}\n#[no_mangle]\npub fn set_quoting_style(\n    o: Option<&mut quoting_options>,\n    s: quoting_style,\n) {\n    if let Some(options) = o {\n        options.style = s;\n    } else {\n        // Use a mutable reference to the static variable in a safe manner\n        let options = unsafe { &mut default_quoting_options };\n        options.style = s;\n    }\n}\n#[no_mangle]\npub fn set_char_quoting(\n    o: Option<&mut quoting_options>,\n    c: i8,\n    i: i32,\n) -> i32 {\n    let uc = c as u8;\n    let options = match o {\n        Some(opt) => opt,\n        None => unsafe { &mut default_quoting_options },\n    };\n    let index = (uc as usize) / (std::mem::size_of::<u32>() * 8);\n    let shift = (uc as usize) % (std::mem::size_of::<u32>() * 8);\n    \n    let p = &mut options.quote_these_too[index];\n    let r = (*p >> shift) & 1;\n    *p ^= ((i & 1 ^ r as i32) << shift) as u32;\n    \n    r as i32\n}\n#[no_mangle]\npub fn set_quoting_flags(\n    mut o: Option<&mut quoting_options>,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    let options = if let Some(ref mut opt) = o {\n        opt\n    } else {\n        unsafe { &mut default_quoting_options }\n    };\n    r = options.flags;\n    options.flags = i;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}\nfn quoting_options_from_style(style: quoting_style) -> quoting_options {\n    let mut o = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: std::ptr::null(),\n        right_quote: std::ptr::null(),\n    };\n\n    if style == custom_quoting_style {\n        panic!(\"Custom quoting style is not allowed\");\n    }\n\n    o.style = style;\n    o\n}\nunsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        let mut pending_shell_escape_end = false;\nlet mut current_block_48: u64;\n\nmatch quoting_style {\n    6 => {\n        quoting_style = c_quoting_style;\n        elide_outer_quotes = true;\n        current_block_48 = 1283995450065962895;\n    }\n    5 => {\n        current_block_48 = 1283995450065962895;\n    }\n    7 => {\n        backslash_escapes = true;\n        elide_outer_quotes = false;\n        current_block_48 = 2989495919056355252;\n    }\n    8 | 9 | 10 => {\n        if quoting_style != custom_quoting_style {\n            left_quote = gettext_quote(b\"`\\0\".as_ptr() as *const libc::c_char, quoting_style);\n            right_quote = gettext_quote(b\"'\\0\".as_ptr() as *const libc::c_char, quoting_style);\n        }\n        if !elide_outer_quotes {\n            let mut quote_string = left_quote;\n            while !quote_string.is_null() && *quote_string != 0 {\n                if len < buffersize {\n                    *buffer.offset(len as isize) = *quote_string;\n                }\n                len = len.wrapping_add(1);\n                quote_string = quote_string.offset(1);\n            }\n        }\n        backslash_escapes = true;\n        quote_string = right_quote;\n        quote_string_len = strlen(quote_string) as u64;\n        current_block_48 = 2989495919056355252;\n    }\n    3 => {\n        backslash_escapes = true;\n        current_block_48 = 2694013637280298776;\n    }\n    1 => {\n        current_block_48 = 2694013637280298776;\n    }\n    4 => {\n        current_block_48 = 2266290538919981374;\n    }\n    2 => {\n        current_block_48 = 14141891332124833771;\n    }\n    0 => {\n        elide_outer_quotes = false;\n        current_block_48 = 2989495919056355252;\n    }\n    _ => {\n        panic!(\"Invalid quoting style\");\n    }\n}\n\nmatch current_block_48 {\n    1283995450065962895 => {\n        if !elide_outer_quotes {\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\"' as i8;\n            }\n            len = len.wrapping_add(1);\n        }\n        backslash_escapes = true;\n        quote_string = b\"\\\"\\0\".as_ptr() as *const libc::c_char;\n        quote_string_len = 1;\n        current_block_48 = 2989495919056355252;\n    }\n    2694013637280298776 => {\n        elide_outer_quotes = true;\n        current_block_48 = 2266290538919981374;\n    }\n    _ => {}\n}\n\nmatch current_block_48 {\n    2266290538919981374 => {\n        if !elide_outer_quotes {\n            backslash_escapes = true;\n        }\n        current_block_48 = 14141891332124833771;\n    }\n    _ => {}\n}\n\nmatch current_block_48 {\n    14141891332124833771 => {\n        quoting_style = shell_always_quoting_style;\n        if !elide_outer_quotes {\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\'' as i8;\n            }\n            len = len.wrapping_add(1);\n        }\n        quote_string = b\"'\\0\".as_ptr() as *const libc::c_char;\n        quote_string_len = 1;\n    }\n    _ => {}\n}\n\nlet mut i = 0;\nwhile if argsize == u64::MAX {\n    *arg.offset(i as isize) == 0\n} else {\n    i == argsize\n} == false\n{\n     let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    escaping = true;\n    if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '$' as i8; }\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n        }\n        len += 1;\n        pending_shell_escape_end = true;\n    }\n    if len < buffersize {\n        unsafe { *buffer.offset(len as isize) = '\\\\' as i8; }\n    }\n    len += 1;\n    if quoting_style != shell_always_quoting_style\n        && i + 1 < argsize\n        && ('0' as i8 <= unsafe { *arg.offset((i + 1) as isize) } && unsafe { *arg.offset((i + 1) as isize) } <= '9' as i8)\n    {\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '0' as i8; }\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '0' as i8; }\n        }\n        len += 1;\n    }\n    c = '0' as u8;\n    current_block = 253337042034819032;\n} else if flags & QA_ELIDE_NULL_BYTES as i32 != 0 {\n    current_block = 13619784596304402172;\n} else {\n    current_block = 253337042034819032;\n}\n\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    current_block = 4476262310586904498;\n} else if backslash_escapes && elide_outer_quotes && quote_string_len != 0 {\n    current_block = 4476262310586904498;\n} else {\n    current_block = 9215498979640025612;\n}\n\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = true;\nc_and_shell_quote_compat = true;\n\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    if buffersize != 0 && orig_buffersize == 0 {\n        orig_buffersize = buffersize;\n        buffersize = 0;\n    }\n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\'' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    \n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\\\' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    \n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\'' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    \n    pending_shell_escape_end = false;\n    current_block = 253337042034819032;\n} else {\n    current_block = 253337042034819032;\n}\n\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if m > 1 || (backslash_escapes && !printable) {\n    let ilim = i.wrapping_add(m);\n    let buffer_slice = unsafe { std::slice::from_raw_parts_mut(buffer, buffersize as usize) };\n    loop {\n        if backslash_escapes && !printable {\n            if elide_outer_quotes {\n                current_block = 7928555609993211441;\n                break 's_25;\n            }\n            escaping = true;\n            if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n                if len < buffersize {\n                    buffer_slice[len as usize] = '\\'' as i8;\n                }\n                len = len.wrapping_add(1);\n                if len < buffersize {\n                    buffer_slice[len as usize] = '$' as i8;\n                }\n                len = len.wrapping_add(1);\n                if len < buffersize {\n                    buffer_slice[len as usize] = '\\'' as i8;\n                }\n                len = len.wrapping_add(1);\n                pending_shell_escape_end = true;\n            }\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\\\' as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as i32 + (c as i32 >> 6)) as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as i32 + ((c as i32 >> 3) & 7)) as i8;\n            }\n            len = len.wrapping_add(1);\n            c = ('0' as i32 + (c as i32 & 7)) as u8;\n        } else if is_right_quote {\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\\\' as i8;\n            }\n            len = len.wrapping_add(1);\n            is_right_quote = false;\n        }\n        if ilim <= i.wrapping_add(1) {\n            break;\n        }\n        if pending_shell_escape_end && !escaping {\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\'' as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\'' as i8;",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "            }\n            len = len.wrapping_add(1);\n            pending_shell_escape_end = false;\n        }\n        if len < buffersize {\n            buffer_slice[len as usize] = c as i8;\n        }\n        len = len.wrapping_add(1);\n        i = i.wrapping_add(1);\n        c = unsafe { *arg.offset(i as isize) } as u8;\n    }\n    current_block = 4476262310586904498;\n} else {\n    current_block = 253337042034819032;\n}\n\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n    \n}\n\nif len == 0 && quoting_style == shell_always_quoting_style && elide_outer_quotes {\n    current_block = 7928555609993211441;\n    break;\n}\nif !(quoting_style == shell_always_quoting_style && !elide_outer_quotes && encountered_single_quote) {\n    current_block = 6412618891452676311;\n    break;\n}\n/*\nThe variables live at this point are:\n(mut buffer: *mut i8, mut buffersize: u64, mut arg: *const i8, mut argsize: u64, mut quoting_style: u32, mut flags: i32, mut quote_these_too: *const u32, mut left_quote: *const i8, mut right_quote: *const i8, mut pending_shell_escape_end: bool, mut current_block: u64, mut i: u64, mut len: u64, mut orig_buffersize: u64, mut quote_string: *const i8, mut quote_string_len: u64, mut backslash_escapes: bool, mut unibyte_locale: bool, mut elide_outer_quotes: bool, mut encountered_single_quote: bool, mut all_c_and_shell_quote_compat: bool, mut current_block_48: u64)\n*/\n\n        if all_c_and_shell_quote_compat {\n    return quotearg_buffer_restyled(\n        buffer,\n        orig_buffersize,\n        arg,\n        argsize,\n        c_quoting_style,\n        flags,\n        quote_these_too,\n        left_quote,\n        right_quote,\n    );\n} else {\n    if !(buffersize == 0 && orig_buffersize != 0) {\n        current_block = 6412618891452676311;\n        break;\n    }\n    buffersize = orig_buffersize;\n    len = 0;\n}\n\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub fn quotearg_buffer(\n    buffer: &mut [c_char],\n    arg: &[c_char],\n    o: Option<&quoting_options>,\n) -> usize {\n    let p: &quoting_options;\n    if let Some(options) = o {\n        p = options;\n    } else {\n        p = unsafe { &default_quoting_options };\n    }\n    \n    let e = std::io::Error::last_os_error();\n    let r = unsafe {\n        quotearg_buffer_restyled(\n            buffer.as_mut_ptr(),\n            buffer.len().try_into().unwrap(),\n            arg.as_ptr(),\n            arg.len().try_into().unwrap(),\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        )\n    };\n    std::mem::forget(e); // Handle the error if necessary\n    r.try_into().unwrap()\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};\nstatic mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub fn quotearg_n(\n    n: i32,\n    arg: &CStr,\n) -> *mut libc::c_char {\n    unsafe {\n        quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            u64::MAX,\n            &default_quoting_options,\n        )\n    }\n}\n#[no_mangle]\npub fn quotearg_n_mem(\n    n: i32,\n    arg: &CStr,\n) -> *mut libc::c_char {\n    let argsize = arg.to_bytes().len() as u64;\n    unsafe {\n        quotearg_n_options(n, arg.as_ptr(), argsize, &default_quoting_options)\n    }\n}\n#[no_mangle]\npub fn quotearg(arg: &CStr) -> CString {\n    let result_ptr = quotearg_n(0, arg);\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let arg_cstr = CStr::from_ptr(arg);\nreturn quotearg_n_mem(0, arg_cstr);\n}\n#[no_mangle]\npub fn quotearg_n_style(\n    n: i32,\n    s: quoting_style,\n    arg: &CStr,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    unsafe {\n        quotearg_n_options(n, arg.as_ptr(), u64::MAX, &o)\n    }\n}\n#[no_mangle]\npub fn quotearg_n_style_mem(\n    n: i32,\n    s: quoting_style,\n    arg: &str,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    let argsize = arg.len() as size_t;\n    \n    unsafe {\n        quotearg_n_options(n, arg.as_ptr() as *const libc::c_char, argsize, &o)\n    }\n}\n#[no_mangle]\npub fn quotearg_style(\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let result_ptr = quotearg_n_style(0, s, arg);\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub fn quotearg_style_mem(\n    s: quoting_style,\n    arg: &CStr,\n) -> String {\n    let arg_str = arg.to_string_lossy();\n    let result_ptr = quotearg_n_style_mem(0, s, &arg_str);\n    unsafe { CStr::from_ptr(result_ptr).to_string_lossy().into_owned() }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    let result = set_char_quoting(Some(&mut options), ch as i8, 1);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub fn quotearg_char(arg: &CStr, ch: char) -> CString {\n    let ch_as_c_char = ch as libc::c_char;\n    let result_ptr = unsafe {\n        quotearg_char_mem(arg.as_ptr(), 18446744073709551615 as libc::c_ulong, ch_as_c_char)\n    };\n    unsafe { CStr::from_ptr(result_ptr).to_owned() }\n}\n#[no_mangle]\npub fn quotearg_colon(arg: &CStr) -> CString {\n    quotearg_char(arg, ':' as char)\n}\n#[no_mangle]\npub fn quotearg_colon_mem(arg: &CStr) -> String {\n    let argsize = arg.to_bytes().len() as u64;\n    let result_ptr: *mut libc::c_char = unsafe { quotearg_char_mem(arg.as_ptr(), argsize, ':' as i32 as c_char) };\n    unsafe { CStr::from_ptr(result_ptr).to_string_lossy().into_owned() }\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub fn quotearg_n_style_colon(\n    n: i32,\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: std::ptr::null(),\n        right_quote: std::ptr::null(),\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(Some(&mut options), ':' as i32 as i8, 1);\n    \n    let result_ptr: *mut libc::c_char;\n    unsafe {\n        result_ptr = quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            u64::MAX,\n            &mut options,\n        );\n    }\n    \n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub fn quotearg_custom(\n    left_quote: &str,\n    right_quote: &str,\n    arg: &str,\n) -> String {\n    let left_quote_c = std::ffi::CString::new(left_quote).unwrap();\n    let right_quote_c = std::ffi::CString::new(right_quote).unwrap();\n    let arg_c = std::ffi::CString::new(arg).unwrap();\n\n    let result = unsafe {\n        quotearg_n_custom(\n            0,\n            left_quote_c.as_ptr(),\n            right_quote_c.as_ptr(),\n            arg_c.as_ptr(),\n        )\n    };\n\n    unsafe { std::ffi::CStr::from_ptr(result).to_string_lossy().into_owned() }\n}\n#[no_mangle]\npub fn quotearg_custom_mem(\n    left_quote: &str,\n    right_quote: &str,\n    arg: &str,\n) -> String {\n    let argsize = arg.len() as u64; // Convert usize to u64\n    let result_ptr: *mut libc::c_char = unsafe {\n        quotearg_n_custom_mem(\n            0,\n            left_quote.as_ptr() as *const libc::c_char,\n            right_quote.as_ptr() as *const libc::c_char,\n            arg.as_ptr() as *const libc::c_char,\n            argsize,\n        )\n    };\n    unsafe { CStr::from_ptr(result_ptr).to_string_lossy().into_owned() } // Convert raw pointer to String\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub fn quote_n_mem(\n    n: i32,\n    arg: &CStr,\n) -> *const libc::c_char {\n    let argsize = arg.to_bytes().len() as u64;\n    unsafe {\n        quotearg_n_options(n, arg.as_ptr(), argsize, &quote_quoting_options)\n    }\n}\n#[no_mangle]\npub fn quote_mem(arg: &CStr) -> CString {\n    let quoted_ptr = quote_n_mem(0, arg);\n    unsafe { CStr::from_ptr(quoted_ptr) }.to_owned()\n}\n#[no_mangle]\npub fn quote_n(n: i32, arg: &CStr) -> *const libc::c_char {\n    quote_n_mem(n, arg)\n}\n#[no_mangle]\npub fn quote(arg: &CStr) -> *const libc::c_char {\n    quote_n(0, arg)\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn write(__fd: libc::c_int, __buf: *const libc::c_void, __n: size_t) -> ssize_t;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type ssize_t = __ssize_t;\npub type __ssize_t = libc::c_long;\npub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn safe_write(\n    mut fd: libc::c_int,\n    mut buf: *const libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = write(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\safe_write.rs"
    },
    {
      "chunk": "use ::libc;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn psame_inode(mut a: *const stat, mut b: *const stat) -> bool {\n    return (*a).st_dev ^ (*b).st_dev | (*a).st_ino ^ (*b).st_ino == 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\same_inode.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}\n#[no_mangle]\npub fn setlocale_null(category: libc::c_int) -> Option<String> {\n    unsafe {\n        let locale = setlocale_null_unlocked(category);\n        if locale.is_null() {\n            None\n        } else {\n            Some(CStr::from_ptr(locale).to_string_lossy().into_owned())\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\setlocale_null.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\setlocale_null_unlocked.rs"
    },
    {
      "chunk": "use std::ffi::CString;\nuse ::libc;\nextern \"C\" {\n    fn __libc_current_sigrtmin() -> libc::c_int;\n    fn __libc_current_sigrtmax() -> libc::c_int;\n    fn strtol(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n    ) -> libc::c_long;\n    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct numname {\n    pub num: libc::c_int,\n    pub name: [libc::c_char; 8],\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\sig2str.rs"
    },
    {
      "chunk": "static mut numname_table: [numname; 35] = unsafe {\n    [\n        {\n            let mut init = numname {\n                num: 1 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"HUP\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 2 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"INT\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 3 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"QUIT\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 4 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"ILL\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 5 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"TRAP\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 6 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"ABRT\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 8 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"FPE\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 9 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"KILL\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 11 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"SEGV\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 7 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"BUS\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 13 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"PIPE\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 14 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"ALRM\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 15 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"TERM\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 10 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"USR1\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 12 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"USR2\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 17 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"CHLD\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 23 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"URG\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 19 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"STOP\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 20 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"TSTP\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 18 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"CONT\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 21 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"TTIN\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 22 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"TTOU\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 31 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"SYS\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 29 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"POLL\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 26 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"VTALRM\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 27 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"PROF\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 24 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"XCPU\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 25 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"XFSZ\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 6 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"IOT\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 17 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"CLD\\0\\0\\0\\0\\0\"),\n            };",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\sig2str.rs"
    },
    {
      "chunk": "            init\n        },\n        {\n            let mut init = numname {\n                num: 30 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"PWR\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 28 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"WINCH\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 29 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"IO\\0\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 16 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"STKFLT\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 0 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"EXIT\\0\\0\\0\\0\"),\n            };\n            init\n        },\n    ]\n};\nunsafe extern \"C\" fn str2signum(mut signame: *const libc::c_char) -> libc::c_int {\n    if (*signame as libc::c_uint).wrapping_sub('0' as i32 as libc::c_uint)\n        <= 9 as libc::c_int as libc::c_uint\n    {\n        let mut endp: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut n: libc::c_long = strtol(signame, &mut endp, 10 as libc::c_int);\n        if *endp == 0\n            && n\n                <= (64 as libc::c_int + 1 as libc::c_int - 1 as libc::c_int)\n                    as libc::c_long\n        {\n            return n as libc::c_int;\n        }\n    } else {\n        let mut i: libc::c_uint = 0;\n        i = 0 as libc::c_int as libc::c_uint;\n        while (i as libc::c_ulong)\n            < (::core::mem::size_of::<[numname; 35]>() as libc::c_ulong)\n                .wrapping_div(::core::mem::size_of::<numname>() as libc::c_ulong)\n        {\n            if strcmp((numname_table[i as usize].name).as_ptr(), signame)\n                == 0 as libc::c_int\n            {\n                return numname_table[i as usize].num;\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        let mut endp_0: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut rtmin: libc::c_int = __libc_current_sigrtmin();\n        let mut rtmax: libc::c_int = __libc_current_sigrtmax();\n        if (0 as libc::c_int) < rtmin\n            && strncmp(\n                signame,\n                b\"RTMIN\\0\" as *const u8 as *const libc::c_char,\n                5 as libc::c_int as libc::c_ulong,\n            ) == 0 as libc::c_int\n        {\n            let mut n_0: libc::c_long = strtol(\n                signame.offset(5 as libc::c_int as isize),\n                &mut endp_0,\n                10 as libc::c_int,\n            );\n            if *endp_0 == 0 && 0 as libc::c_int as libc::c_long <= n_0\n                && n_0 <= (rtmax - rtmin) as libc::c_long\n            {\n                return (rtmin as libc::c_long + n_0) as libc::c_int;\n            }\n        } else if (0 as libc::c_int) < rtmax\n            && strncmp(\n                signame,\n                b\"RTMAX\\0\" as *const u8 as *const libc::c_char,\n                5 as libc::c_int as libc::c_ulong,\n            ) == 0 as libc::c_int\n        {\n            let mut n_1: libc::c_long = strtol(\n                signame.offset(5 as libc::c_int as isize),\n                &mut endp_0,\n                10 as libc::c_int,\n            );\n            if *endp_0 == 0 && (rtmin - rtmax) as libc::c_long <= n_1\n                && n_1 <= 0 as libc::c_int as libc::c_long\n            {\n                return (rtmax as libc::c_long + n_1) as libc::c_int;\n            }\n        }\n    }\n    return -(1 as libc::c_int);\n}\n#[no_mangle]\npub fn str2sig(signame: &str, signum: &mut i32) -> i32 {\n    let c_signame = std::ffi::CString::new(signame).unwrap();\n    unsafe {\n        *signum = str2signum(c_signame.as_ptr());\n    }\n    if *signum < 0 {\n        -1\n    } else {\n        0\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn sig2str(\n    mut signum: libc::c_int,\n    mut signame: *mut libc::c_char,\n) -> libc::c_int {\n    let mut i: libc::c_uint = 0;\n    i = 0 as libc::c_int as libc::c_uint;\n    while (i as libc::c_ulong)\n        < (::core::mem::size_of::<[numname; 35]>() as libc::c_ulong)\n            .wrapping_div(::core::mem::size_of::<numname>() as libc::c_ulong)\n    {\n        if numname_table[i as usize].num == signum {\n            strcpy(signame, (numname_table[i as usize].name).as_ptr());\n            return 0 as libc::c_int;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    let mut rtmin: libc::c_int = __libc_current_sigrtmin();\n    let mut rtmax: libc::c_int = __libc_current_sigrtmax();\n    let mut base: libc::c_int = 0;\n    let mut delta: libc::c_int = 0;\n    if !(rtmin <= signum && signum <= rtmax) {\n        return -(1 as libc::c_int);\n    }\n    if signum <= rtmin + (rtmax - rtmin) / 2 as libc::c_int {\n        strcpy(signame, b\"RTMIN\\0\" as *const u8 as *const libc::c_char);\n        base = rtmin;\n    } else {\n        strcpy(signame, b\"RTMAX\\0\" as *const u8 as *const libc::c_char);\n        base = rtmax;\n    }\n    delta = signum - base;\n    if delta != 0 as libc::c_int {\n        sprintf(\n            signame.offset(5 as libc::c_int as isize),\n            b\"%+d\\0\" as *const u8 as *const libc::c_char,\n            delta,\n        );\n    }\n    return 0 as libc::c_int;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\sig2str.rs"
    },
    {
      "chunk": "#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut, unused_imports)]\n#![feature(extern_types, label_break_value)]\nuse std::option::Option;\nuse std::ffi::CString;\nuse std::ptr;\nuse std::process;\nuse std::io::Read;\nuse std::ffi::CStr;\nuse std::io::Write;\nuse ::rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char) -> *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn fwrite_unlocked(\n        __ptr: *const libc::c_void,\n        __size: size_t,\n        __n: size_t,\n        __stream: *mut FILE,\n    ) -> size_t;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn fpurge(gl_stream: *mut FILE) -> libc::c_int;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    static mut optarg: *mut libc::c_char;\n    static mut optind: libc::c_int;\n    fn signal(__sig: libc::c_int, __handler: __sighandler_t) -> __sighandler_t;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;\n    fn pipe(__pipedes: *mut libc::c_int) -> libc::c_int;\n    fn dup2(__fd: libc::c_int, __fd2: libc::c_int) -> libc::c_int;\n    fn execl(\n        __path: *const libc::c_char,\n        __arg: *const libc::c_char,\n        _: ...\n    ) -> libc::c_int;\n    fn fork() -> __pid_t;\n    fn getpagesize() -> libc::c_int;\n    fn ftruncate(__fd: libc::c_int, __length: __off_t) -> libc::c_int;\n    fn waitpid(\n        __pid: __pid_t,\n        __stat_loc: *mut libc::c_int,\n        __options: libc::c_int,\n    ) -> __pid_t;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memmove(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memchr(\n        _: *const libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn rawmemchr(__s: *const libc::c_void, __c: libc::c_int) -> *mut libc::c_void;\n    fn memrchr(\n        __s: *const libc::c_void,\n        __c: libc::c_int,\n        __n: size_t,\n    ) -> *mut libc::c_void;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strspn(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_ulong;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn free(_: *mut libc::c_void);\n    fn __errno_location() -> *mut libc::c_int;\n    fn atexit(__func: Option::<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn exit(_: libc::c_int) -> !;\n    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;\n    fn setenv(\n        __name: *const libc::c_char,\n        __value: *const libc::c_char,\n        __replace: libc::c_int,\n    ) -> libc::c_int;\n    static mut Version: *const libc::c_char;\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn xalloc_die();\n    fn xmalloc(s: size_t) -> *mut libc::c_void;\n    fn xinmalloc(n: idx_t, s: idx_t) -> *mut libc::c_void;\n    fn xicalloc(n: idx_t, s: idx_t) -> *mut libc::c_void;\n    fn xirealloc(p: *mut libc::c_void, s: idx_t) -> *mut libc::c_void;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xstrdup(str: *const libc::c_char) -> *mut libc::c_char;\n    fn last_component(filename: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stdout();\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    static mut program_name: *const libc::c_char;\n    fn set_program_name(argv0: *const libc::c_char);\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn quotearg_n_style_colon(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn xalignalloc(_: idx_t, _: idx_t) -> *mut libc::c_void;\n    fn fdadvise(fd: libc::c_int, offset: off_t, len: off_t, advice: fadvice_t);\n    fn fd_reopen(\n        _: libc::c_int,\n        _: *const libc::c_char,\n        _: libc::c_int,\n        _: mode_t,\n    ) -> libc::c_int;\n    fn open_safer(_: *const libc::c_char, _: libc::c_int, _: ...) -> libc::c_int;\n    fn full_write(fd: libc::c_int, buf: *const libc::c_void, count: size_t) -> size_t;\n    fn quote_mem(arg: *const libc::c_char, argsize: size_t) -> *const libc::c_char;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn sig2str(_: libc::c_int, _: *mut libc::c_char) -> libc::c_int;\n    fn temp_stream(fp: *mut *mut FILE, file_name: *mut *mut libc::c_char) -> bool;\n    fn xdectoimax(\n        n_str: *const libc::c_char,\n        min: intmax_t,\n        max: intmax_t,\n        suffixes: *const libc::c_char,\n        err: *const libc::c_char,\n        err_exit: libc::c_int,\n    ) -> intmax_t;\n    fn xdectoumax(\n        n_str: *const libc::c_char,\n        min: uintmax_t,\n        max: uintmax_t,\n        suffixes: *const libc::c_char,\n        err: *const libc::c_char,\n        err_exit: libc::c_int,\n    ) -> uintmax_t;\n    fn xstrtoimax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut intmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n}\npub type __intmax_t = libc::c_long;\npub type __uintmax_t = libc::c_ulong;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __pid_t = libc::c_int;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __ssize_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISspace: C2RustUnnamed = 8192;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;\npub type size_t = libc::c_ulong;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type ssize_t = __ssize_t;\npub type ptrdiff_t = libc::c_long;\npub type mode_t = __mode_t;\npub type pid_t = __pid_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\npub type __sighandler_t = Option::<unsafe extern \"C\" fn(libc::c_int) -> ()>;\n#[derive(Copy, Clone)]\n#[repr(C)]",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "pub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\npub type intmax_t = __intmax_t;\npub type uintmax_t = __uintmax_t;\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed_0 = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed_0 = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type fadvice_t = libc::c_uint;\npub const FADVISE_RANDOM: fadvice_t = 1;\npub const FADVISE_WILLNEED: fadvice_t = 3;\npub const FADVISE_DONTNEED: fadvice_t = 4;\npub const FADVISE_NOREUSE: fadvice_t = 5;\npub const FADVISE_SEQUENTIAL: fadvice_t = 2;\npub const FADVISE_NORMAL: fadvice_t = 0;\npub type C2RustUnnamed_1 = libc::c_uint;\npub const IO_BUFSIZE: C2RustUnnamed_1 = 262144;\npub type C2RustUnnamed_2 = libc::c_uint;\npub const SYS_BUFSIZE_MAX: C2RustUnnamed_2 = 2146435072;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub type Split_type = libc::c_uint;\npub const type_rr: Split_type = 7;\npub const type_chunk_lines: Split_type = 6;\npub const type_chunk_bytes: Split_type = 5;\npub const type_digits: Split_type = 4;\npub const type_lines: Split_type = 3;\npub const type_byteslines: Split_type = 2;\npub const type_bytes: Split_type = 1;\npub const type_undef: Split_type = 0;\npub type C2RustUnnamed_3 = libc::c_uint;\npub const ADDITIONAL_SUFFIX_OPTION: C2RustUnnamed_3 = 259;\npub const IO_BLKSIZE_OPTION: C2RustUnnamed_3 = 258;\npub const FILTER_OPTION: C2RustUnnamed_3 = 257;\npub const VERBOSE_OPTION: C2RustUnnamed_3 = 256;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct of_info {\n    pub of_name: *mut libc::c_char,\n    pub ofd: libc::c_int,\n    pub ofile: *mut FILE,\n    pub opid: pid_t,\n}\npub type of_t = of_info;\npub type C2RustUnnamed_4 = libc::c_int;\npub const OFD_APPEND: C2RustUnnamed_4 = -2;\npub const OFD_NEW: C2RustUnnamed_4 = -1;\n#[inline]\nfn to_uchar(ch: i8) -> u8 {\n    ch as u8\n}\n#[inline]\nfn psame_inode(a: &stat, b: &stat) -> bool {\n    (*a).st_dev == (*b).st_dev && (*a).st_ino == (*b).st_ino\n}\n#[inline]\nfn emit_stdin_note() {\n    let message = \"\\nWith no FILE, or when FILE is -, read standard input.\\n\";\n    let translated_message = unsafe { gettext(message.as_ptr() as *const libc::c_char) };\n    let stdout_handle = std::io::stdout();\n    let mut handle = stdout_handle.lock();\n    let cstr = unsafe { CStr::from_ptr(translated_message) };\n    if let Err(e) = handle.write_all(cstr.to_bytes()) {\n        eprintln!(\"Error writing to stdout: {}\", e);\n    }\n}\n#[inline]\nfn emit_mandatory_arg_note() {\n    let message = \"\\nMandatory arguments to long options are mandatory for short options too.\\n\";\n    let stdout_handle = std::io::stdout();\n    let mut handle = stdout_handle.lock();\n    handle.write_all(message.as_bytes()).expect(\"Failed to write to stdout\");\n}\n#[inline]\nfn emit_size_note() {\n    let message = \"\\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\\nUnits are K,M,G,T,P,E,Z,Y,R,Q (powers of 1024) or KB,MB,... (powers of 1000).\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\";\n    let stdout_handle = std::io::stdout();\n    let mut handle = stdout_handle.lock();\n    let _ = handle.write_all(message.as_bytes());\n}\n#[inline]\nfn emit_ancillary_info(program: &CStr) {\n    let infomap_0: [(&CStr, &CStr); 7] = [\n        (CStr::from_bytes_with_nul(b\"[\\0\").unwrap(), CStr::from_bytes_with_nul(b\"test invocation\\0\").unwrap()),\n        (CStr::from_bytes_with_nul(b\"coreutils\\0\").unwrap(), CStr::from_bytes_with_nul(b\"Multi-call invocation\\0\").unwrap()),\n        (CStr::from_bytes_with_nul(b\"sha224sum\\0\").unwrap(), CStr::from_bytes_with_nul(b\"sha2 utilities\\0\").unwrap()),\n        (CStr::from_bytes_with_nul(b\"sha256sum\\0\").unwrap(), CStr::from_bytes_with_nul(b\"sha2 utilities\\0\").unwrap()),\n        (CStr::from_bytes_with_nul(b\"sha384sum\\0\").unwrap(), CStr::from_bytes_with_nul(b\"sha2 utilities\\0\").unwrap()),\n        (CStr::from_bytes_with_nul(b\"sha512sum\\0\").unwrap(), CStr::from_bytes_with_nul(b\"sha2 utilities\\0\").unwrap()),\n        (CStr::from_bytes_with_nul(b\"\\0\").unwrap(), CStr::from_bytes_with_nul(b\"\\0\").unwrap()),\n    ];\n    \n    let mut node = program.as_ptr();\n    let mut map_prog = infomap_0.iter();\n\n    while let Some(&(prog, ref n)) = map_prog.next() {\n        if prog.as_ptr().is_null() || program.as_ptr() == prog.as_ptr() {\n            node = n.as_ptr();\n            break;\n        }\n    }\n\n    let help_url = CStr::from_bytes_with_nul(b\"https://www.gnu.org/software/coreutils/\\0\").unwrap();\n    println!(\n        \"{} online help: <{}>\",\n        CStr::from_bytes_with_nul(b\"GNU coreutils\\0\").unwrap().to_str().unwrap(),\n        help_url.to_str().unwrap()\n    );\n\n    let lc_messages: *const libc::c_char;\n    unsafe {\n        lc_messages = setlocale(5, std::ptr::null());\n    }\n    \n    if !lc_messages.is_null() && unsafe { CStr::from_ptr(lc_messages).to_str().unwrap().starts_with(\"en_\") } {\n        writeln!(\n            std::io::stdout(),\n            \"{}\",\n            CStr::from_bytes_with_nul(b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\").unwrap().to_str().unwrap()\n        ).unwrap();\n    }\n\n    let url_program = if program.to_bytes() == b\"[\\0\" {\n        CStr::from_bytes_with_nul(b\"test\\0\").unwrap()\n    } else {\n        program\n    };\n\n    println!(\n        \"Full documentation <{}{}>\",\n        help_url.to_str().unwrap(),\n        url_program.to_str().unwrap()\n    );\n\n    println!(\n        \"or available locally via: info '(coreutils) {}{}'\",\n        unsafe { CStr::from_ptr(node).to_str().unwrap() },\n        if node == program.as_ptr() {\n            \" invocation\"\n        } else {\n            \"\"\n        }\n    );\n}\n#[inline]\nfn usable_st_size(sb: *const stat) -> bool {\n    let sb = unsafe { &*sb };\n    (sb.st_mode & 0o170000) == 0o100000\n        || (sb.st_mode & 0o170000) == 0o120000\n        || (sb.st_mode.wrapping_sub(sb.st_mode) != 0) || (0 != 0)\n}\n#[inline]\nfn write_error() {\n    let saved_errno = std::io::Error::last_os_error();\n    let _ = std::io::stdout().flush();\n    let _ = std::io::stdout().lock().flush();\n    \n    let error_message = std::ffi::CString::new(\"write error\").unwrap();\n    \n    if false {\n        unsafe {\n            error(\n                1,\n                saved_errno.raw_os_error().unwrap_or(0),\n                error_message.as_ptr(),\n            );\n        }\n        if true {\n            unreachable!();\n        }\n    } else {\n        {\n            let __errstatus = 1;\n            unsafe {\n                error(\n                    __errstatus,\n                    saved_errno.raw_os_error().unwrap_or(0),\n                    error_message.as_ptr(),\n                );\n            }\n            if __errstatus != 0 {\n                unreachable!();\n            }\n        }\n        {\n            let __errstatus = 1;\n            unsafe {\n                error(\n                    __errstatus,\n                    saved_errno.raw_os_error().unwrap_or(0),\n                    error_message.as_ptr(),\n                );\n            }\n            if __errstatus != 0 {\n                unreachable!();\n            }\n        }\n    }\n}\n#[inline]\nfn __gl_stdbit_clzll(n: u64) -> i32 {\n    if n != 0 {\n        n.leading_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u64>() as u32) as i32\n    }\n}\n#[inline]\nunsafe extern \"C\" fn stdc_leading_zeros_ull(mut n: libc::c_ulonglong) -> libc::c_uint {\n    let result: u32 = __gl_stdbit_clzll(n) as u32;\nreturn result;\n}\n#[inline]",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn io_blksize(mut st: *const stat) -> idx_t {\n    let mut blocksize: idx_t = (if (if (0 as libc::c_int) < (*st).st_blksize\n        && (*st).st_blksize as libc::c_ulong\n            <= (-(1 as libc::c_int) as size_t)\n                .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        (*st).st_blksize\n    } else {\n        512 as libc::c_int\n    }) <= 0 as libc::c_int\n    {\n        IO_BUFSIZE as libc::c_int\n    } else if (0 as libc::c_int) < (*st).st_blksize\n        && (*st).st_blksize as libc::c_ulong\n            <= (-(1 as libc::c_int) as size_t)\n                .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        (*st).st_blksize\n    } else {\n        512 as libc::c_int\n    }) as idx_t;\n    blocksize\n        += (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long\n            - (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long % blocksize;\n    if (*st).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        && blocksize & blocksize - 1 as libc::c_int as libc::c_long != 0\n    {\n        let mut leading_zeros: libc::c_int = stdc_leading_zeros_ull(\n            blocksize as libc::c_ulonglong,\n        ) as libc::c_int;\n        if (9223372036854775807 as libc::c_long as libc::c_ulonglong)\n            < (9223372036854775807 as libc::c_longlong as libc::c_ulonglong)\n                .wrapping_mul(2 as libc::c_ulonglong)\n                .wrapping_add(1 as libc::c_ulonglong) || leading_zeros != 0\n        {\n            let mut power: libc::c_ulonglong = (1 as libc::c_ulonglong)\n                << 64 as libc::c_int - leading_zeros;\n            if power <= 9223372036854775807 as libc::c_long as libc::c_ulonglong {\n                blocksize = power as idx_t;\n            }\n        }\n    }\n    return (if (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n        < 18446744073709551615 as libc::c_ulong\n    {\n        9223372036854775807 as libc::c_long as libc::c_ulong\n    } else {\n        18446744073709551615 as libc::c_ulong\n    })\n        .wrapping_div(2 as libc::c_int as libc::c_ulong)\n        .wrapping_add(1 as libc::c_int as libc::c_ulong) < blocksize as libc::c_ulong\n    {\n        (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        })\n            .wrapping_div(2 as libc::c_int as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    } else {\n        blocksize as libc::c_ulong\n    }) as idx_t;\n}\n#[inline]\nfn __gl_setmode(fd: i32, mode: i32) -> i32 {\n    return 0;\n}\n#[inline]\nfn set_binary_mode(fd: i32, mode: i32) -> i32 {\n    // Safety: We need to ensure that the file descriptor is valid and that the mode is appropriate.\n    // This is a direct call to a function that may have undefined behavior if misused.\n    unsafe { __gl_setmode(fd, mode) }\n}\n#[inline]\nunsafe extern \"C\" fn xset_binary_mode_error() {}\n#[inline]\nfn xset_binary_mode(fd: i32, mode: i32) {\n    if set_binary_mode(fd, mode) < 0 {\n        unsafe {\n            xset_binary_mode_error();\n        }\n    }\n}\nstatic mut filter_command: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut filter_pid: pid_t = 0;\nstatic mut open_pipes: *mut libc::c_int = 0 as *const libc::c_int as *mut libc::c_int;\nstatic mut open_pipes_alloc: idx_t = 0;\nstatic mut n_open_pipes: libc::c_int = 0;\nstatic mut default_SIGPIPE: bool = false;\nstatic mut outbase: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut outfile: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;\nstatic mut outfile_mid: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;\nstatic mut suffix_auto: bool = 1 as libc::c_int != 0;\nstatic mut suffix_length: idx_t = 0;\nstatic mut suffix_alphabet: *const libc::c_char = b\"abcdefghijklmnopqrstuvwxyz\\0\"\n    as *const u8 as *const libc::c_char;\nstatic mut numeric_suffix_start: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut additional_suffix: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut infile: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut in_stat_buf: stat = stat {\n    st_dev: 0,\n    st_ino: 0,\n    st_mode: 0,\n    st_nlink: 0,\n    st_uid: 0,\n    st_gid: 0,\n    st_rdev: 0,\n    __pad1: 0,\n    st_size: 0,\n    st_blksize: 0,\n    __pad2: 0,\n    st_blocks: 0,\n    st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n    st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n    st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n    __glibc_reserved: [0; 2],\n};\nstatic mut output_desc: libc::c_int = -(1 as libc::c_int);\nstatic mut verbose: bool = false;\nstatic mut elide_empty_files: bool = false;\nstatic mut unbuffered: bool = false;\nstatic mut eolchar: libc::c_int = -(1 as libc::c_int);\nstatic mut longopts: [option; 17] = [\n    {\n        let mut init = option {\n            name: b\"bytes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'b' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"lines\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'l' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"line-bytes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'C' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"number\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'n' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"elide-empty-files\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'e' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"unbuffered\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'u' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"suffix-length\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'a' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"additional-suffix\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: ADDITIONAL_SUFFIX_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"numeric-suffixes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 2 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'd' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"hex-suffixes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 2 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'x' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"filter\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: FILTER_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"verbose\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: VERBOSE_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"separator\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 't' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"-io-blksize\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: IO_BLKSIZE_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];\n#[inline]\nfn ignorable(err: i32) -> bool {\n    let command_ref = unsafe { filter_command.as_ref() };\n    err == 32 && command_ref.is_some()\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn set_suffix_length(\n    mut n_units: intmax_t,\n    mut split_type: Split_type,\n) {\n    let mut suffix_length_needed: libc::c_int = 0 as libc::c_int;\n    if !numeric_suffix_start.is_null() {\n        suffix_auto = 0 as libc::c_int != 0;\n    }\n    if split_type as libc::c_uint == type_chunk_bytes as libc::c_int as libc::c_uint\n        || split_type as libc::c_uint == type_chunk_lines as libc::c_int as libc::c_uint\n        || split_type as libc::c_uint == type_rr as libc::c_int as libc::c_uint\n    {\n        let mut n_units_end: intmax_t = n_units - 1 as libc::c_int as libc::c_long;\n        if !numeric_suffix_start.is_null() {\n            let mut n_start: intmax_t = 0;\n            let mut e: strtol_error = xstrtoimax(\n                numeric_suffix_start,\n                0 as *mut *mut libc::c_char,\n                10 as libc::c_int,\n                &mut n_start,\n                b\"\\0\" as *const u8 as *const libc::c_char,\n            );\n            if e as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint\n                && n_start < n_units\n            {\n                let (fresh0, fresh1) = n_units_end.overflowing_add(n_start);\n                *(&mut n_units_end as *mut intmax_t) = fresh0;\n                if fresh1 {\n                    n_units_end = 9223372036854775807 as libc::c_long;\n                }\n            }\n        }\n        let mut alphabet_len: idx_t = strlen(suffix_alphabet) as idx_t;\n        loop {\n            suffix_length_needed += 1;\n            suffix_length_needed;\n            n_units_end /= alphabet_len;\n            if !(n_units_end != 0) {\n                break;\n            }\n        }\n        suffix_auto = 0 as libc::c_int != 0;\n    }\n    if suffix_length != 0 {\n        if suffix_length < suffix_length_needed as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"the suffix length needs to be at least %d\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    suffix_length_needed,\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"the suffix length needs to be at least %d\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        suffix_length_needed,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"the suffix length needs to be at least %d\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        suffix_length_needed,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        suffix_auto = 0 as libc::c_int != 0;\n        return;\n    } else {\n        suffix_length = (if 2 as libc::c_int > suffix_length_needed {\n            2 as libc::c_int\n        } else {\n            suffix_length_needed\n        }) as idx_t;\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [FILE [PREFIX]]\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Output pieces of FILE to PREFIXaa, PREFIXab, ...;\\ndefault size is 1000 lines, and default PREFIX is 'x'.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_stdin_note();\n        emit_mandatory_arg_note();\n        fprintf(\n            stdout,\n            gettext(\n                b\"  -a, --suffix-length=N   generate suffixes of length N (default %d)\\n      --additional-suffix=SUFFIX  append an additional SUFFIX to file names\\n  -b, --bytes=SIZE        put SIZE bytes per output file\\n  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file\\n  -d                      use numeric suffixes starting at 0, not alphabetic\\n      --numeric-suffixes[=FROM]  same as -d, but allow setting the start value\\n  -x                      use hex suffixes starting at 0, not alphabetic\\n      --hex-suffixes[=FROM]  same as -x, but allow setting the start value\\n  -e, --elide-empty-files  do not generate empty output files with '-n'\\n      --filter=COMMAND    write to shell COMMAND; file name is $FILE\\n  -l, --lines=NUMBER      put NUMBER lines/records per output file\\n  -n, --number=CHUNKS     generate CHUNKS output files; see explanation below\\n  -t, --separator=SEP     use SEP instead of newline as the record separator;\\n                            '\\\\0' (zero) specifies the NUL character\\n  -u, --unbuffered        immediately copy input to output with '-n r/...'\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            2 as libc::c_int,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --verbose           print a diagnostic just before each\\n                            output file is opened\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_size_note();\n        fputs_unlocked(\n            gettext(\n                b\"\\nCHUNKS may be:\\n  N       split into N files based on size of input\\n  K/N     output Kth of N to stdout\\n  l/N     split into N files without splitting lines/records\\n  l/K/N   output Kth of N to stdout without splitting lines/records\\n  r/N     like 'l' but use round robin distribution\\n  r/K/N   likewise but only output Kth of N to stdout\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_ancillary_info(CStr::from_bytes_with_nul(b\"split\\0\").unwrap());\n    }\n    exit(status);\n}\nunsafe extern \"C\" fn copy_to_tmpfile(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n) -> off_t {\n    let mut tmp: *mut FILE = 0 as *mut FILE;\n    if !temp_stream(&mut tmp, 0 as *mut *mut libc::c_char) {\n        return -(1 as libc::c_int) as off_t;\n    }\n    let mut copied: off_t = 0 as libc::c_int as off_t;\n    let mut r: off_t = 0;\n    loop {\n        r = read(fd, buf as *mut libc::c_void, bufsize as size_t);\n        if !((0 as libc::c_int as libc::c_long) < r) {\n            break;\n        }\n        if fwrite_unlocked(\n            buf as *const libc::c_void,\n            1 as libc::c_int as size_t,\n            r as size_t,\n            tmp,\n        ) != r as libc::c_ulong\n        {\n            return -(1 as libc::c_int) as off_t;\n        }\n        let (fresh2, fresh3) = copied.overflowing_add(r);\n        *(&mut copied as *mut off_t) = fresh2;\n        if fresh3 {\n            *__errno_location() = 75 as libc::c_int;\n            return -(1 as libc::c_int) as off_t;\n        }\n    }\n    if r < 0 as libc::c_int as libc::c_long {\n        return r;\n    }\n    r = dup2(fileno(tmp), fd) as off_t;\n    if r < 0 as libc::c_int as libc::c_long {\n        return r;\n    }\n    if rpl_fclose(tmp) < 0 as libc::c_int {\n        return -(1 as libc::c_int) as off_t;\n    }\n    return copied;\n}\nunsafe extern \"C\" fn input_file_size(\n    mut fd: libc::c_int,\n    mut st: *const stat,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n) -> off_t {\n    let mut size: off_t = 0 as libc::c_int as off_t;\n    loop {\n        let mut n_read: ssize_t = read(\n            fd,\n            buf.offset(size as isize) as *mut libc::c_void,\n            (bufsize - size) as size_t,\n        );\n        if n_read <= 0 as libc::c_int as libc::c_long {\n            return if n_read < 0 as libc::c_int as libc::c_long { n_read } else { size };\n        }\n        size += n_read;\n        if !(size < bufsize) {\n            break;\n        }\n    }\n    let mut cur: off_t = 0;\n    let mut end: off_t = 0;\n    if usable_st_size(st) as libc::c_int != 0 && (*st).st_size < size\n        || {\n            cur = lseek(fd, 0 as libc::c_int as __off_t, 1 as libc::c_int);\n            cur < 0 as libc::c_int as libc::c_long\n        } || cur < size\n        || {\n            end = lseek(fd, 0 as libc::c_int as __off_t, 2 as libc::c_int);\n            end < 0 as libc::c_int as libc::c_long\n        }\n    {\n        let mut tmpbuf: *mut libc::c_char = xmalloc(bufsize as size_t)\n            as *mut libc::c_char;\n        end = copy_to_tmpfile(fd, tmpbuf, bufsize);\n        free(tmpbuf as *mut libc::c_void);\n        if end < 0 as libc::c_int as libc::c_long {\n            return end;\n        }\n        cur = 0 as libc::c_int as off_t;\n    }\n    if end\n        == (if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n            -(1 as libc::c_int) as off_t\n        } else {\n            (((1 as libc::c_int as off_t)\n                << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        })\n        || cur < end\n            && {\n                let (fresh4, fresh5) = size.overflowing_add(end - cur);\n                *(&mut size as *mut off_t) = fresh4;\n                fresh5 as libc::c_int != 0\n            }\n    {\n        *__errno_location() = 75 as libc::c_int;\n        return -(1 as libc::c_int) as off_t;\n    }\n    if cur < end {\n        let mut r: off_t = lseek(fd, cur, 0 as libc::c_int);\n        if r < 0 as libc::c_int as libc::c_long {\n            return r;\n        }\n    }\n    return size;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn next_file_name() {\n    static mut sufindex: *mut idx_t = 0 as *const idx_t as *mut idx_t;\n    static mut outbase_length: idx_t = 0;\n    static mut outfile_length: idx_t = 0;\n    static mut addsuf_length: idx_t = 0;\n    let mut overflow: bool = false;\n    let mut widen: bool = false;\n    let mut current_block_37: u64;\n    if outfile.is_null() {\n        overflow = false;\n        widen = false;\n        current_block_37 = 9769017674192345533;\n    } else {\n        let mut i_0: idx_t = suffix_length;\n        loop {\n            let fresh13 = i_0;\n            i_0 = i_0 - 1;\n            if !(fresh13 != 0 as libc::c_int as libc::c_long) {\n                current_block_37 = 14434620278749266018;\n                break;\n            }\n            let ref mut fresh14 = *sufindex.offset(i_0 as isize);\n            *fresh14 += 1;\n            let _ = *fresh14;\n            if suffix_auto as libc::c_int != 0 && i_0 == 0 as libc::c_int as libc::c_long\n                && *suffix_alphabet\n                    .offset(\n                        (*sufindex.offset(0 as libc::c_int as isize)\n                            + 1 as libc::c_int as libc::c_long) as isize,\n                    ) == 0\n            {\n                current_block_37 = 9769017674192345533;\n                break;\n            }\n            *outfile_mid\n                .offset(\n                    i_0 as isize,\n                ) = *suffix_alphabet.offset(*sufindex.offset(i_0 as isize) as isize);\n            if *outfile_mid.offset(i_0 as isize) != 0 {\n                return;\n            }\n            *sufindex.offset(i_0 as isize) = 0 as libc::c_int as idx_t;\n            *outfile_mid\n                .offset(\n                    i_0 as isize,\n                ) = *suffix_alphabet.offset(*sufindex.offset(i_0 as isize) as isize);\n        }\n        match current_block_37 {\n            9769017674192345533 => {}\n            _ => {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"output file suffixes exhausted\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"output file suffixes exhausted\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"output file suffixes exhausted\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                current_block_37 = 2873832966593178012;\n            }\n        }\n    }\n    match current_block_37 {\n        9769017674192345533 => {\n            widen = outfile_length != 0;\n            if !widen {\n                outbase_length = strlen(outbase) as idx_t;\n                addsuf_length = (if !additional_suffix.is_null() {\n                    strlen(additional_suffix)\n                } else {\n                    0 as libc::c_int as libc::c_ulong\n                }) as idx_t;\n                let (fresh6, fresh7) = (outbase_length + addsuf_length)\n                    .overflowing_add(suffix_length);\n                *(&mut outfile_length as *mut idx_t) = fresh6;\n                overflow = fresh7;\n            } else {\n                let (fresh8, fresh9) = outfile_length.overflowing_add((2 as libc::c_int).into());\n                *(&mut outfile_length as *mut idx_t) = fresh8;\n                overflow = fresh9;\n                suffix_length += 1;\n                suffix_length;\n            }\n            let mut outfile_size: idx_t = 0;\n            let (fresh10, fresh11) = outfile_length.overflowing_add((1 as libc::c_int).into());\n            *(&mut outfile_size as *mut idx_t) = fresh10;\n            overflow = (overflow as libc::c_int | fresh11 as libc::c_int) != 0;\n            if overflow {\n                xalloc_die();\n            }\n            outfile = xirealloc(outfile as *mut libc::c_void, outfile_size)\n                as *mut libc::c_char;\n            if !widen {\n                memcpy(\n                    outfile as *mut libc::c_void,\n                    outbase as *const libc::c_void,\n                    outbase_length as libc::c_ulong,\n                );\n            } else {\n                *outfile\n                    .offset(\n                        outbase_length as isize,\n                    ) = *suffix_alphabet\n                    .offset(*sufindex.offset(0 as libc::c_int as isize) as isize);\n                outbase_length += 1;\n                outbase_length;\n            }\n            outfile_mid = outfile.offset(outbase_length as isize);\n            memset(\n                outfile_mid as *mut libc::c_void,\n                *suffix_alphabet.offset(0 as libc::c_int as isize) as libc::c_int,\n                suffix_length as libc::c_ulong,\n            );\n            if !additional_suffix.is_null() {\n                memcpy(\n                    outfile_mid.offset(suffix_length as isize) as *mut libc::c_void,\n                    additional_suffix as *const libc::c_void,\n                    addsuf_length as libc::c_ulong,\n                );\n            }\n            *outfile.offset(outfile_length as isize) = 0 as libc::c_int as libc::c_char;\n            free(sufindex as *mut libc::c_void);\n            sufindex = xicalloc(\n                suffix_length,\n                ::core::mem::size_of::<idx_t>() as libc::c_ulong as idx_t,\n            ) as *mut idx_t;\n            if !numeric_suffix_start.is_null() {\n                if !widen {} else {\n                    __assert_fail(\n                        b\"! widen\\0\" as *const u8 as *const libc::c_char,\n                        b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                        423 as libc::c_int as libc::c_uint,\n                        (*::core::mem::transmute::<\n                            &[u8; 26],\n                            &[libc::c_char; 26],\n                        >(b\"void next_file_name(void)\\0\"))\n                            .as_ptr(),\n                    );\n                }\n                'c_9037: {\n                    if !widen {} else {\n                        __assert_fail(\n                            b\"! widen\\0\" as *const u8 as *const libc::c_char,\n                            b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                            423 as libc::c_int as libc::c_uint,\n                            (*::core::mem::transmute::<\n                                &[u8; 26],\n                                &[libc::c_char; 26],\n                            >(b\"void next_file_name(void)\\0\"))\n                                .as_ptr(),\n                        );\n                    }\n                };\n                let mut i: idx_t = strlen(numeric_suffix_start) as idx_t;\n                memcpy(\n                    outfile_mid.offset(suffix_length as isize).offset(-(i as isize))\n                        as *mut libc::c_void,\n                    numeric_suffix_start as *const libc::c_void,\n                    i as libc::c_ulong,\n                );\n                let mut sufindex_end: *mut idx_t = sufindex\n                    .offset(suffix_length as isize);\n                loop {\n                    let fresh12 = i;\n                    i = i - 1;\n                    if !(fresh12 != 0 as libc::c_int as libc::c_long) {\n                        break;\n                    }\n                    sufindex_end = sufindex_end.offset(-1);\n                    *sufindex_end = (*numeric_suffix_start.offset(i as isize)\n                        as libc::c_int - '0' as i32) as idx_t;\n                }\n            }\n        }\n        _ => {}\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn create(mut name: *const libc::c_char) -> libc::c_int {\n    if filter_command.is_null() {\n        if verbose {\n            fprintf(\n                stdout,\n                gettext(b\"creating file %s\\n\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, name),\n            );\n        }\n        let mut oflags: libc::c_int = 0o1 as libc::c_int | 0o100 as libc::c_int\n            | 0 as libc::c_int;\n        let mut fd: libc::c_int = open_safer(\n            name,\n            oflags | 0o200 as libc::c_int,\n            0o400 as libc::c_int | 0o200 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int,\n        );\n        if 0 as libc::c_int <= fd || *__errno_location() != 17 as libc::c_int {\n            return fd;\n        }\n        fd = open_safer(\n            name,\n            oflags,\n            0o400 as libc::c_int | 0o200 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int,\n        );\n        if fd < 0 as libc::c_int {\n            return fd;\n        }\n        let mut out_stat_buf: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        if fstat(fd, &mut out_stat_buf) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, name),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if psame_inode(&mut in_stat_buf, &mut out_stat_buf) {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s would overwrite input; aborting\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, name),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s would overwrite input; aborting\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s would overwrite input; aborting\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if ftruncate(fd, 0 as libc::c_int as __off_t) < 0 as libc::c_int\n            && (out_stat_buf.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint\n                || (out_stat_buf.st_mode).wrapping_sub(out_stat_buf.st_mode) != 0)\n        {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: error truncating\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: error truncating\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: error truncating\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        return fd;\n    } else {\n        let mut fd_pair: [libc::c_int; 2] = [0; 2];\n        let mut child_pid: pid_t = 0;\n        let mut shell_prog: *const libc::c_char = getenv(\n            b\"SHELL\\0\" as *const u8 as *const libc::c_char,\n        );\n        if shell_prog.is_null() {\n            shell_prog = b\"/bin/sh\\0\" as *const u8 as *const libc::c_char;\n        }\n        if setenv(b\"FILE\\0\" as *const u8 as *const libc::c_char, name, 1 as libc::c_int)\n            != 0 as libc::c_int\n        {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to set FILE environment variable\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to set FILE environment variable\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to set FILE environment variable\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if verbose {\n            fprintf(\n                stdout,\n                gettext(\n                    b\"executing with FILE=%s\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    name,\n                ),\n            );\n        }\n        if pipe(fd_pair.as_mut_ptr()) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to create pipe\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to create pipe\\0\" as *const u8\n                                as *const libc::c_char,",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to create pipe\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        child_pid = fork();\n        if child_pid == 0 as libc::c_int {\n            let mut j: libc::c_int = 0;\n            j = 0 as libc::c_int;\n            while j < n_open_pipes {\n                if close(*open_pipes.offset(j as isize)) != 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"closing prior pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"closing prior pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"closing prior pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                j += 1;\n                j;\n            }\n            if close(fd_pair[1 as libc::c_int as usize]) != 0 {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"closing output pipe\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"closing output pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"closing output pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            if fd_pair[0 as libc::c_int as usize] != 0 as libc::c_int {\n                if dup2(fd_pair[0 as libc::c_int as usize], 0 as libc::c_int)\n                    != 0 as libc::c_int\n                {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"moving input pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"moving input pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"moving input pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                if close(fd_pair[0 as libc::c_int as usize]) != 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"closing input pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"closing input pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"closing input pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n            }\n            if default_SIGPIPE {\n                signal(13 as libc::c_int, None);\n            }\n            execl(\n                shell_prog,\n                last_component(shell_prog),\n                b\"-c\\0\" as *const u8 as *const libc::c_char,\n                filter_command,\n                0 as *mut libc::c_void as *mut libc::c_char,\n            );\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to run command: \\\"%s -c %s\\\"\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    shell_prog,\n                    filter_command,\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to run command: \\\"%s -c %s\\\"\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        shell_prog,\n                        filter_command,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to run command: \\\"%s -c %s\\\"\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        shell_prog,\n                        filter_command,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if child_pid < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"fork system call failed\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"fork system call failed\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"fork system call failed\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if close(fd_pair[0 as libc::c_int as usize]) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to close input pipe\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to close input pipe\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to close input pipe\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        filter_pid = child_pid;\n        if n_open_pipes as libc::c_long == open_pipes_alloc {\n            open_pipes = xpalloc(\n                open_pipes as *mut libc::c_void,\n                &mut open_pipes_alloc,\n                1 as libc::c_int as idx_t,\n                if (2147483647 as libc::c_int as libc::c_long)\n                    < 9223372036854775807 as libc::c_long\n                {\n                    2147483647 as libc::c_int as libc::c_long\n                } else {\n                    9223372036854775807 as libc::c_long\n                },\n                ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as idx_t,\n            ) as *mut libc::c_int;\n        }\n        let fresh15 = n_open_pipes;\n        n_open_pipes = n_open_pipes + 1;\n        *open_pipes.offset(fresh15 as isize) = fd_pair[1 as libc::c_int as usize];\n        return fd_pair[1 as libc::c_int as usize];\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn closeout(\n    mut fp: *mut FILE,\n    mut fd: libc::c_int,\n    mut pid: pid_t,\n    mut name: *const libc::c_char,\n) {\n    if !fp.is_null() && rpl_fclose(fp) != 0 as libc::c_int\n        && !ignorable(*__errno_location())\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    name,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if fd >= 0 as libc::c_int {\n        if fp.is_null() && close(fd) < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        let mut j: libc::c_int = 0;\n        j = 0 as libc::c_int;\n        while j < n_open_pipes {\n            if *open_pipes.offset(j as isize) == fd {\n                n_open_pipes -= 1;\n                *open_pipes\n                    .offset(j as isize) = *open_pipes.offset(n_open_pipes as isize);\n                break;\n            } else {\n                j += 1;\n                j;\n            }\n        }\n    }\n    if pid > 0 as libc::c_int {\n        let mut wstatus: libc::c_int = 0;\n        if waitpid(pid, &mut wstatus, 0 as libc::c_int) < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"waiting for child process\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"waiting for child process\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"waiting for child process\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else if ((wstatus & 0x7f as libc::c_int) + 1 as libc::c_int) as libc::c_schar\n            as libc::c_int >> 1 as libc::c_int > 0 as libc::c_int\n        {\n            let mut sig: libc::c_int = wstatus & 0x7f as libc::c_int;\n            if sig != 13 as libc::c_int {\n                let mut signame: [libc::c_char; 19] = [0; 19];\n                if sig2str(sig, signame.as_mut_ptr()) != 0 as libc::c_int {\n                    sprintf(\n                        signame.as_mut_ptr(),\n                        b\"%d\\0\" as *const u8 as *const libc::c_char,\n                        sig,\n                    );\n                }\n                if 0 != 0 {\n                    error(\n                        sig + 128 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"with FILE=%s, signal %s from command: %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                        signame.as_mut_ptr(),\n                        filter_command,\n                    );\n                    if sig + 128 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = sig + 128 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"with FILE=%s, signal %s from command: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                name,\n                            ),\n                            signame.as_mut_ptr(),\n                            filter_command,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = sig + 128 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"with FILE=%s, signal %s from command: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                name,\n                            ),\n                            signame.as_mut_ptr(),\n                            filter_command,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        } else if wstatus & 0x7f as libc::c_int == 0 as libc::c_int {\n            let mut ex: libc::c_int = (wstatus & 0xff00 as libc::c_int)\n                >> 8 as libc::c_int;\n            if ex != 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        ex,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"with FILE=%s, exit %d from command: %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                        ex,\n                        filter_command,\n                    );\n                    if ex != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = ex;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"with FILE=%s, exit %d from command: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                name,\n                            ),\n                            ex,\n                            filter_command,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "                        let __errstatus: libc::c_int = ex;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"with FILE=%s, exit %d from command: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                name,\n                            ),\n                            ex,\n                            filter_command,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        } else {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"unknown status from command (0x%X)\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    (wstatus as libc::c_uint).wrapping_add(0 as libc::c_uint),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"unknown status from command (0x%X)\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        (wstatus as libc::c_uint).wrapping_add(0 as libc::c_uint),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"unknown status from command (0x%X)\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        (wstatus as libc::c_uint).wrapping_add(0 as libc::c_uint),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    }\n}\nunsafe extern \"C\" fn cwrite(\n    mut new_file_flag: bool,\n    mut bp: *const libc::c_char,\n    mut bytes: idx_t,\n) -> bool {\n    if new_file_flag {\n        if bp.is_null() && bytes == 0 as libc::c_int as libc::c_long\n            && elide_empty_files as libc::c_int != 0\n        {\n            return 1 as libc::c_int != 0;\n        }\n        closeout(0 as *mut FILE, output_desc, filter_pid, outfile);\n        next_file_name();\n        output_desc = create(outfile);\n        if output_desc < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        outfile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            outfile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            outfile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    }\n    if full_write(output_desc, bp as *const libc::c_void, bytes as size_t)\n        == bytes as libc::c_ulong\n    {\n        return 1 as libc::c_int != 0\n    } else {\n        if !ignorable(*__errno_location()) {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        outfile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            outfile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            outfile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        return 0 as libc::c_int != 0;\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn bytes_split(\n    mut n_bytes: intmax_t,\n    mut rem_bytes: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n    mut initial_read: ssize_t,\n    mut max_files: intmax_t,\n) {\n    let mut new_file_flag: bool = 1 as libc::c_int != 0;\n    let mut filter_ok: bool = 1 as libc::c_int != 0;\n    let mut opened: intmax_t = 0 as libc::c_int as intmax_t;\n    let mut to_write: intmax_t = n_bytes\n        + ((0 as libc::c_int as libc::c_long) < rem_bytes) as libc::c_int\n            as libc::c_long;\n    let mut eof: bool = to_write == 0;\n    while !eof {\n        let mut n_read: ssize_t = 0;\n        if 0 as libc::c_int as libc::c_long <= initial_read {\n            n_read = initial_read;\n            initial_read = -(1 as libc::c_int) as ssize_t;\n            eof = n_read < bufsize;\n        } else {\n            if !filter_ok\n                && 0 as libc::c_int as libc::c_long\n                    <= lseek(0 as libc::c_int, to_write, 1 as libc::c_int)\n            {\n                to_write = n_bytes\n                    + ((opened + 1 as libc::c_int as libc::c_long) < rem_bytes)\n                        as libc::c_int as libc::c_long;\n                new_file_flag = 1 as libc::c_int != 0;\n            }\n            n_read = read(0 as libc::c_int, buf as *mut libc::c_void, bufsize as size_t);\n            if n_read < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            eof = n_read == 0 as libc::c_int as libc::c_long;\n        }\n        let mut bp_out: *mut libc::c_char = buf;\n        while (0 as libc::c_int as libc::c_long) < to_write && to_write <= n_read {\n            if filter_ok as libc::c_int != 0 || new_file_flag as libc::c_int != 0 {\n                filter_ok = cwrite(new_file_flag, bp_out, to_write);\n            }\n            opened += new_file_flag as libc::c_long;\n            new_file_flag = max_files == 0 || opened < max_files;\n            if !filter_ok && !new_file_flag {\n                n_read = 0 as libc::c_int as ssize_t;\n                eof = 1 as libc::c_int != 0;\n                break;\n            } else {\n                bp_out = bp_out.offset(to_write as isize);\n                n_read -= to_write;\n                to_write = n_bytes + (opened < rem_bytes) as libc::c_int as libc::c_long;\n            }\n        }\n        if !((0 as libc::c_int as libc::c_long) < n_read) {\n            continue;\n        }\n        if filter_ok as libc::c_int != 0 || new_file_flag as libc::c_int != 0 {\n            filter_ok = cwrite(new_file_flag, bp_out, n_read);\n        }\n        opened += new_file_flag as libc::c_long;\n        new_file_flag = 0 as libc::c_int != 0;\n        if !filter_ok && opened == max_files {\n            break;\n        }\n        to_write -= n_read;\n    }\n    loop {\n        let fresh16 = opened;\n        opened = opened + 1;\n        if !(fresh16 < max_files) {\n            break;\n        }\n        cwrite(\n            1 as libc::c_int != 0,\n            0 as *const libc::c_char,\n            0 as libc::c_int as idx_t,\n        );\n    };\n}\nunsafe extern \"C\" fn lines_split(\n    mut n_lines: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n) {\n    let mut n_read: ssize_t = 0;\n    let mut bp: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut bp_out: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut eob: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut new_file_flag: bool = 1 as libc::c_int != 0;\n    let mut n: intmax_t = 0 as libc::c_int as intmax_t;\n    loop {\n        n_read = read(0 as libc::c_int, buf as *mut libc::c_void, bufsize as size_t);\n        if n_read < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        bp_out = buf;\n        bp = bp_out;\n        eob = bp.offset(n_read as isize);\n        *eob = eolchar as libc::c_char;\n        loop {\n            bp = rawmemchr(bp as *const libc::c_void, eolchar) as *mut libc::c_char;\n            if bp == eob {\n                if eob != bp_out {\n                    let mut len: idx_t = eob.offset_from(bp_out) as libc::c_long;\n                    cwrite(new_file_flag, bp_out, len);\n                    new_file_flag = 0 as libc::c_int != 0;\n                }\n                break;\n            } else {\n                bp = bp.offset(1);\n                bp;\n                n += 1;\n                if n >= n_lines {\n                    cwrite(\n                        new_file_flag,\n                        bp_out,\n                        bp.offset_from(bp_out) as libc::c_long,\n                    );\n                    bp_out = bp;\n                    new_file_flag = 1 as libc::c_int != 0;\n                    n = 0 as libc::c_int as intmax_t;\n                }\n            }\n        }\n        if !(n_read != 0) {\n            break;\n        }\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn line_bytes_split(\n    mut n_bytes: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n) {\n    let mut n_read: ssize_t = 0;\n    let mut n_out: intmax_t = 0 as libc::c_int as intmax_t;\n    let mut n_hold: idx_t = 0 as libc::c_int as idx_t;\n    let mut hold: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut hold_size: idx_t = 0 as libc::c_int as idx_t;\n    let mut split_line: bool = 0 as libc::c_int != 0;\n    loop {\n        n_read = read(0 as libc::c_int, buf as *mut libc::c_void, bufsize as size_t);\n        if n_read < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        let mut n_left: idx_t = n_read;\n        let mut sob: *mut libc::c_char = buf;\n        while n_left != 0 {\n            let mut split_rest: idx_t = 0 as libc::c_int as idx_t;\n            let mut eoc: *mut libc::c_char = 0 as *mut libc::c_char;\n            let mut eol: *mut libc::c_char = 0 as *mut libc::c_char;\n            if n_bytes - n_out - n_hold <= n_left {\n                split_rest = n_bytes - n_out - n_hold;\n                eoc = sob\n                    .offset(split_rest as isize)\n                    .offset(-(1 as libc::c_int as isize));\n                eol = memrchr(sob as *const libc::c_void, eolchar, split_rest as size_t)\n                    as *mut libc::c_char;\n            } else {\n                eol = memrchr(sob as *const libc::c_void, eolchar, n_left as size_t)\n                    as *mut libc::c_char;\n            }\n            if n_hold != 0 && !(eol.is_null() && n_out != 0) {\n                cwrite(n_out == 0 as libc::c_int as libc::c_long, hold, n_hold);\n                n_out += n_hold;\n                n_hold = 0 as libc::c_int as idx_t;\n            }\n            if !eol.is_null() {\n                split_line = 1 as libc::c_int != 0;\n                let mut n_write: idx_t = eol.offset_from(sob) as libc::c_long\n                    + 1 as libc::c_int as libc::c_long;\n                cwrite(n_out == 0 as libc::c_int as libc::c_long, sob, n_write);\n                n_out += n_write;\n                n_left -= n_write;\n                sob = sob.offset(n_write as isize);\n                if !eoc.is_null() {\n                    split_rest -= n_write;\n                }\n            }\n            if n_left != 0 && !split_line {\n                let mut n_write_0: idx_t = if !eoc.is_null() {\n                    split_rest\n                } else {\n                    n_left\n                };\n                cwrite(n_out == 0 as libc::c_int as libc::c_long, sob, n_write_0);\n                n_out += n_write_0;\n                n_left -= n_write_0;\n                sob = sob.offset(n_write_0 as isize);\n                if !eoc.is_null() {\n                    split_rest -= n_write_0;\n                }\n            }\n            if !eoc.is_null() && split_rest != 0 || eoc.is_null() && n_left != 0 {\n                let mut n_buf: idx_t = if !eoc.is_null() { split_rest } else { n_left };\n                if hold_size - n_hold < n_buf {\n                    hold = xpalloc(\n                        hold as *mut libc::c_void,\n                        &mut hold_size,\n                        n_buf - (hold_size - n_hold),\n                        -(1 as libc::c_int) as ptrdiff_t,\n                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong as idx_t,\n                    ) as *mut libc::c_char;\n                }\n                memcpy(\n                    hold.offset(n_hold as isize) as *mut libc::c_void,\n                    sob as *const libc::c_void,\n                    n_buf as libc::c_ulong,\n                );\n                n_hold += n_buf;\n                n_left -= n_buf;\n                sob = sob.offset(n_buf as isize);\n            }\n            if !eoc.is_null() {\n                n_out = 0 as libc::c_int as intmax_t;\n                split_line = 0 as libc::c_int != 0;\n            }\n        }\n        if !(n_read != 0) {\n            break;\n        }\n    }\n    if n_hold != 0 {\n        cwrite(n_out == 0 as libc::c_int as libc::c_long, hold, n_hold);\n    }\n    free(hold as *mut libc::c_void);\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn lines_chunk_split(\n    mut k: intmax_t,\n    mut n: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n    mut initial_read: ssize_t,\n    mut file_size: off_t,\n) {\n    if n != 0 && k <= n {\n    // Do nothing, condition is satisfied\n} else {\n    panic!(\"n && k <= n\");\n}\n\nlet rem_bytes: i64 = file_size % n;\nlet chunk_size: i64 = file_size / n;\nlet mut chunk_no: i64 = 1;\nlet mut chunk_end: i64 = chunk_size + if rem_bytes > 0 { 1 } else { 0 };\nlet mut n_written: i64 = 0;\nlet mut new_file_flag: bool = true;\nlet mut chunk_truncated: bool = false;\n\nif k > 1 && file_size > 0 {\n    let start: i64 = (k - 1) * chunk_size + if (k - 1) < rem_bytes { k - 1 } else { rem_bytes } - 1;\n\n    if start < initial_read {\n        let buf_slice = unsafe { std::slice::from_raw_parts_mut(buf, bufsize as usize) };\n        buf_slice.copy_within(start as usize..initial_read as usize, 0);\n        initial_read -= start;\n    } else {\n        if initial_read < start {\n            let seek_result = lseek(0, start - initial_read, 1);\n            if seek_result < 0 {\n                let err = unsafe { *libc::__errno_location() };\n                error(1, err, b\"Error seeking file: %s\\0\".as_ptr() as *const i8, quotearg_n_style_colon(0, shell_escape_quoting_style, infile));\n                unreachable!();\n            } else {\n                initial_read = -1;\n            }\n        }\n        n_written = start;\n        chunk_no = k - 1;\n        chunk_end = start + 1;\n    }\n}\n\nwhile n_written < file_size {\n     let mut bp: *mut libc::c_char = buf;\n        let mut eob: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut n_read: ssize_t = 0;\n        if 0 as libc::c_int as libc::c_long <= initial_read {\n            n_read = initial_read;\n            initial_read = -(1 as libc::c_int) as ssize_t;\n        } else {\n            n_read = read(\n                0 as libc::c_int,\n                buf as *mut libc::c_void,\n                (if bufsize < file_size - n_written {\n                    bufsize\n                } else {\n                    file_size - n_written\n                }) as size_t,\n            );\n            if n_read < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        }\n        if n_read == 0 as libc::c_int as libc::c_long {\n            break;\n        }\n        chunk_truncated = 0 as libc::c_int != 0;\n        eob = buf.offset(n_read as isize);\n        while bp != eob {\n            let mut to_write: idx_t = 0;\n            let mut next: bool = 0 as libc::c_int != 0;\n            let mut skip: off_t = if n_read\n                < (if 0 as libc::c_int as libc::c_long\n                    > chunk_end - 1 as libc::c_int as libc::c_long - n_written\n                {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    chunk_end - 1 as libc::c_int as libc::c_long - n_written\n                })\n            {\n                n_read\n            } else if 0 as libc::c_int as libc::c_long\n                > chunk_end - 1 as libc::c_int as libc::c_long - n_written\n            {\n                0 as libc::c_int as libc::c_long\n            } else {\n                chunk_end - 1 as libc::c_int as libc::c_long - n_written\n            };\n            let mut bp_out: *mut libc::c_char = memchr(\n                bp.offset(skip as isize) as *const libc::c_void,\n                eolchar,\n                (n_read - skip) as libc::c_ulong,\n            ) as *mut libc::c_char;\n            if !bp_out.is_null() {\n                bp_out = bp_out.offset(1);\n                bp_out;\n                next = 1 as libc::c_int != 0;\n            } else {\n                bp_out = eob;\n            }\n            to_write = bp_out.offset_from(bp) as libc::c_long;\n            if k == chunk_no {\n                if full_write(\n                    1 as libc::c_int,\n                    bp as *const libc::c_void,\n                    to_write as size_t,\n                ) != to_write as libc::c_ulong\n                {\n                    write_error();\n                }\n            } else if k == 0 {\n                cwrite(new_file_flag, bp, to_write);\n            }\n            n_written += to_write;\n            bp = bp.offset(to_write as isize);\n            n_read -= to_write;\n            new_file_flag = next;\n            while next as libc::c_int != 0 || chunk_end <= n_written {\n                if !next && bp == eob {\n                    chunk_truncated = 1 as libc::c_int != 0;\n                    break;\n                } else {\n                    if k == chunk_no {\n                        return;\n                    }\n                    chunk_end\n                        += chunk_size\n                            + (chunk_no < rem_bytes) as libc::c_int as libc::c_long;\n                    chunk_no += 1;\n                    chunk_no;\n                    if chunk_end <= n_written {\n                        if k == 0 {\n                            cwrite(\n                                1 as libc::c_int != 0,\n                                0 as *const libc::c_char,\n                                0 as libc::c_int as idx_t,\n                            );\n                        }\n                    } else {\n                        next = 0 as libc::c_int != 0;\n                    }\n                }\n            }\n        }\n\n}\n\nif chunk_truncated {\n    chunk_no += 1;\n}\n\nif k == 0 {\n    loop {\n        let fresh17 = chunk_no;\n        chunk_no += 1;\n        if fresh17 > n {\n            break;\n        }\n        cwrite(new_file_flag as i32 != 0, 0 as *const i8, 0);\n    }\n}\n\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn bytes_chunk_extract(\n    mut k: intmax_t,\n    mut n: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n    mut initial_read: ssize_t,\n    mut file_size: off_t,\n) {\n    let mut start: off_t = 0;\n    let mut end: off_t = 0;\n    if (0 as libc::c_int as libc::c_long) < k && k <= n {} else {\n        __assert_fail(\n            b\"0 < k && k <= n\\0\" as *const u8 as *const libc::c_char,\n            b\"split.c\\0\" as *const u8 as *const libc::c_char,\n            1009 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 76],\n                &[libc::c_char; 76],\n            >(\n                b\"void bytes_chunk_extract(intmax_t, intmax_t, char *, idx_t, ssize_t, off_t)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_14132: {\n        if (0 as libc::c_int as libc::c_long) < k && k <= n {} else {\n            __assert_fail(\n                b\"0 < k && k <= n\\0\" as *const u8 as *const libc::c_char,\n                b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                1009 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 76],\n                    &[libc::c_char; 76],\n                >(\n                    b\"void bytes_chunk_extract(intmax_t, intmax_t, char *, idx_t, ssize_t, off_t)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    start = (k - 1 as libc::c_int as libc::c_long) * (file_size / n)\n        + (if (k - 1 as libc::c_int as libc::c_long) < file_size % n {\n            k - 1 as libc::c_int as libc::c_long\n        } else {\n            file_size % n\n        });\n    end = if k == n {\n        file_size\n    } else {\n        k * (file_size / n) + (if k < file_size % n { k } else { file_size % n })\n    };\n    if start < initial_read {\n        memmove(\n            buf as *mut libc::c_void,\n            buf.offset(start as isize) as *const libc::c_void,\n            (initial_read - start) as libc::c_ulong,\n        );\n        initial_read -= start;\n    } else {\n        if initial_read < start\n            && lseek(0 as libc::c_int, start - initial_read, 1 as libc::c_int)\n                < 0 as libc::c_int as libc::c_long\n        {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        initial_read = -(1 as libc::c_int) as ssize_t;\n    }\n    while start < end {\n    let mut n_read: i64 = 0;\n    if initial_read >= 0 {\n        n_read = initial_read;\n        initial_read = -1;\n    } else {\n        let buffer = unsafe { std::slice::from_raw_parts_mut(buf as *mut u8, bufsize as usize) };\n        n_read = match std::io::stdin().read(&mut buffer[start as usize..end as usize]) {\n            Ok(bytes_read) => bytes_read as i64,\n            Err(e) => {\n                error(\n                    1,\n                    e.raw_os_error().unwrap_or(0),\n                    b\"%s\\0\" as *const u8 as *const i8,\n                    quotearg_n_style_colon(0, shell_escape_quoting_style, infile),\n                );\n                return; // Handle error appropriately\n            }\n        };\n    }\n\n    if n_read == 0 {\n        break;\n    }\n\n    n_read = n_read.min(end - start);\n    let buffer = unsafe { std::slice::from_raw_parts(buf as *mut u8, bufsize as usize) };\n    let written = std::io::stdout().write(&buffer[start as usize..(start + n_read) as usize] as &[u8]);\n    if written.is_err() {\n        error(\n            1,\n            written.err().unwrap().raw_os_error().unwrap_or(0),\n            b\"%s\\0\" as *const u8 as *const i8,\n            quotearg_n_style_colon(0, shell_escape_quoting_style, b\"-\\0\" as *const u8 as *const i8),\n        );\n        return; // Handle error appropriately\n    }\n\n    start += n_read;\n}\n\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn ofile_open(\n    mut files: *mut of_t,\n    mut i_check: idx_t,\n    mut nfiles: idx_t,\n) -> bool {\n    let mut file_limit: bool = 0 as libc::c_int != 0;\n    if (*files.offset(i_check as isize)).ofd <= OFD_NEW as libc::c_int {\n        let mut fd: libc::c_int = 0;\n        let mut i_reopen: idx_t = if i_check != 0 {\n            i_check - 1 as libc::c_int as libc::c_long\n        } else {\n            nfiles - 1 as libc::c_int as libc::c_long\n        };\n        loop {\n            if (*files.offset(i_check as isize)).ofd == OFD_NEW {\n    fd = create((*files.offset(i_check as isize)).of_name);\n} else {\n    fd = open_safer(\n        (*files.offset(i_check as isize)).of_name,\n        libc::O_RDONLY | libc::O_CREAT | libc::O_EXCL | libc::O_TRUNC,\n    );\n}\n\nif fd >= 0 {\n    break;\n}\n\nif !(*__errno_location() == 24 || *__errno_location() == 23) {\n    let errstatus = 1;\n    error(\n        errstatus,\n        *__errno_location(),\n        \"%s\\0\".as_ptr() as *const libc::c_char,\n        quotearg_n_style_colon(\n            0,\n            shell_escape_quoting_style,\n            (*files.offset(i_check as isize)).of_name,\n        ),\n    );\n    unreachable!();\n}\n\nfile_limit = true;\n\nwhile (*files.offset(i_reopen as isize)).ofd < 0 {\n    i_reopen = if i_reopen != 0 {\n        i_reopen - 1\n    } else {\n        nfiles - 1\n    };\n\n    if i_reopen == i_check {\n        let errstatus = 1;\n        error(\n            errstatus,\n            *__errno_location(),\n            \"%s\\0\".as_ptr() as *const libc::c_char,\n            quotearg_n_style_colon(\n                0,\n                shell_escape_quoting_style,\n                (*files.offset(i_check as isize)).of_name,\n            ),\n        );\n        unreachable!();\n    }\n}\n\n            if rpl_fclose((*files.offset(i_reopen as isize)).ofile) != 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            (*files.offset(i_reopen as isize)).of_name,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_reopen as isize)).of_name,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_reopen as isize)).of_name,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            let ref mut fresh18 = (*files.offset(i_reopen as isize)).ofile;\n            *fresh18 = 0 as *mut FILE;\n            (*files.offset(i_reopen as isize)).ofd = OFD_APPEND as libc::c_int;\n        }\n        (*files.offset(i_check as isize)).ofd = fd;\n        let mut ofile: *mut FILE = fdopen(\n            fd,\n            b\"a\\0\" as *const u8 as *const libc::c_char,\n        );\n        if ofile.is_null() {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        (*files.offset(i_check as isize)).of_name,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            (*files.offset(i_check as isize)).of_name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            (*files.offset(i_check as isize)).of_name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        let ref mut fresh19 = (*files.offset(i_check as isize)).ofile;\n        *fresh19 = ofile;\n        (*files.offset(i_check as isize)).opid = filter_pid;\n        filter_pid = 0 as libc::c_int;\n    }\n    return file_limit;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn lines_rr(\n    mut k: intmax_t,\n    mut n: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n    mut filesp: *mut *mut of_t,\n) {\n    let mut wrapped: bool = 0 as libc::c_int != 0;\n    let mut wrote: bool = 0 as libc::c_int != 0;\n    let mut file_limit: bool = false;\n    let mut i_file: idx_t = 0;\n    let mut files: *mut of_t = 0 as *mut of_t;\n    let mut line_no: intmax_t = 0;\n    if k != 0 {\n        line_no = 1 as libc::c_int as intmax_t;\n    } else {\n        if (9223372036854775807 as libc::c_long) < n {\n            xalloc_die();\n        }\n        *filesp = xinmalloc(n, ::core::mem::size_of::<of_t>() as libc::c_ulong as idx_t)\n            as *mut of_t;\n        files = *filesp;\n        i_file = 0 as libc::c_int as idx_t;\n        while i_file < n {\n            next_file_name();\n            let ref mut fresh20 = (*files.offset(i_file as isize)).of_name;\n            *fresh20 = xstrdup(outfile);\n            (*files.offset(i_file as isize)).ofd = OFD_NEW as libc::c_int;\n            let ref mut fresh21 = (*files.offset(i_file as isize)).ofile;\n            *fresh21 = 0 as *mut FILE;\n            (*files.offset(i_file as isize)).opid = 0 as libc::c_int;\n            i_file += 1;\n            i_file;\n        }\n        i_file = 0 as libc::c_int as idx_t;\n        file_limit = 0 as libc::c_int != 0;\n    }\n    's_76: loop {\n        let mut bp: *mut libc::c_char = buf;\n        let mut eob: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut n_read: ssize_t = read(\n            0 as libc::c_int,\n            buf as *mut libc::c_void,\n            bufsize as size_t,\n        );\n        if n_read < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else if n_read == 0 as libc::c_int as libc::c_long {\n            break;\n        }\n        eob = buf.offset(n_read as isize);\n        while bp != eob {\n            let mut to_write: idx_t = 0;\n            let mut next: bool = 0 as libc::c_int != 0;\n            let mut bp_out: *mut libc::c_char = memchr(\n                bp as *const libc::c_void,\n                eolchar,\n                eob.offset_from(bp) as libc::c_long as libc::c_ulong,\n            ) as *mut libc::c_char;\n            if !bp_out.is_null() {\n                bp_out = bp_out.offset(1);\n                bp_out;\n                next = 1 as libc::c_int != 0;\n            } else {\n                bp_out = eob;\n            }\n            to_write = bp_out.offset_from(bp) as libc::c_long;\n            if k != 0 {\n                if line_no == k && unbuffered as libc::c_int != 0 {\n                    if full_write(\n                        1 as libc::c_int,\n                        bp as *const libc::c_void,\n                        to_write as size_t,\n                    ) != to_write as libc::c_ulong\n                    {\n                        write_error();\n                    }\n                } else if line_no == k\n                    && fwrite_unlocked(\n                        bp as *const libc::c_void,\n                        to_write as size_t,\n                        1 as libc::c_int as size_t,\n                        stdout,\n                    ) != 1 as libc::c_int as libc::c_ulong\n                {\n                    write_error();\n                }\n                if next {\n                    line_no = if line_no == n {\n                        1 as libc::c_int as libc::c_long\n                    } else {\n                        line_no + 1 as libc::c_int as libc::c_long\n                    };\n                }\n            } else {\n                file_limit = (file_limit as libc::c_int\n                    | ofile_open(files, i_file, n) as libc::c_int) != 0;\n                if unbuffered {\n                    if full_write(\n                        (*files.offset(i_file as isize)).ofd,\n                        bp as *const libc::c_void,\n                        to_write as size_t,\n                    ) != to_write as libc::c_ulong && !ignorable(*__errno_location())\n                    {\n                        if 0 != 0 {\n                            error(\n                                1 as libc::c_int,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_file as isize)).of_name,\n                                ),\n                            );\n                            if 1 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        (*files.offset(i_file as isize)).of_name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        (*files.offset(i_file as isize)).of_name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    }\n                } else if fwrite_unlocked(\n                    bp as *const libc::c_void,\n                    to_write as size_t,\n                    1 as libc::c_int as size_t,\n                    (*files.offset(i_file as isize)).ofile,\n                ) != 1 as libc::c_int as libc::c_ulong && !ignorable(*__errno_location())\n                {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_file as isize)).of_name,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_file as isize)).of_name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_file as isize)).of_name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                if !ignorable(*__errno_location()) {\n                    wrote = 1 as libc::c_int != 0;\n                }\n                if file_limit {\n    if rpl_fclose((*files.offset(i_file as isize)).ofile) != 0 {\n        let errstatus = 1;\n        error(\n            errstatus,\n            std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n            b\"%s\\0\".as_ptr() as *const i8,\n            quotearg_n_style_colon(0, shell_escape_quoting_style, (*files.offset(i_file as isize)).of_name),\n        );\n        if errstatus != 0 {\n            unreachable!();\n        }\n    }\n    (*files.offset(i_file as isize)).ofile = std::ptr::null_mut();\n    (*files.offset(i_file as isize)).ofd = OFD_APPEND;\n}\n\nif next && {\n    i_file += 1;\n    i_file == n\n} {\n    wrapped = true;\n    if !wrote {\n        break 's_76;\n    }\n    wrote = false;\n    i_file = 0;\n}\n\n            }\n            bp = bp_out;\n        }\n    }\n    if k == 0 {\n        let mut ceiling: idx_t = if wrapped as libc::c_int != 0 { n } else { i_file };",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "        i_file = 0 as libc::c_int as idx_t;\n        while i_file < n {\n            if i_file >= ceiling && !elide_empty_files {\n                file_limit = (file_limit as libc::c_int\n                    | ofile_open(files, i_file, n) as libc::c_int) != 0;\n            }\n            if (*files.offset(i_file as isize)).ofd >= 0 as libc::c_int {\n                closeout(\n                    (*files.offset(i_file as isize)).ofile,\n                    (*files.offset(i_file as isize)).ofd,\n                    (*files.offset(i_file as isize)).opid,\n                    (*files.offset(i_file as isize)).of_name,\n                );\n            }\n            (*files.offset(i_file as isize)).ofd = OFD_APPEND as libc::c_int;\n            i_file += 1;\n            i_file;\n        }\n    }\n}\nfn strtoint_die(msgid: *const libc::c_char, arg: *const libc::c_char) {\n    let err_status = 1;\n    let errno = std::io::Error::last_os_error().raw_os_error().unwrap_or(0);\n    \n    let msgid_str = unsafe { std::ffi::CStr::from_ptr(msgid).to_string_lossy() };\n    let arg_str = unsafe { std::ffi::CStr::from_ptr(arg).to_string_lossy() };\n\n    unsafe {\n        error(\n            err_status,\n            if errno == 22 { 0 } else { errno },\n            b\"%s: %s\\0\".as_ptr() as *const libc::c_char,\n            msgid_str.as_ptr() as *const libc::c_char,\n            arg_str.as_ptr() as *const libc::c_char,\n        );\n    }\n\n    if err_status != 0 {\n        std::process::abort(); // Use abort instead of unreachable to avoid hanging\n    }\n}\nunsafe extern \"C\" fn parse_n_units(\n    mut arg: *const libc::c_char,\n    mut multipliers: *const libc::c_char,\n    mut msgid: *const libc::c_char,\n) -> intmax_t {\n    let mut n: intmax_t = 0;\n    if (LONGINT_OVERFLOW as libc::c_int as libc::c_uint)\n        < xstrtoimax(\n            arg,\n            0 as *mut *mut libc::c_char,\n            10 as libc::c_int,\n            &mut n,\n            multipliers,\n        ) as libc::c_uint || n < 1 as libc::c_int as libc::c_long\n    {\n        strtoint_die(msgid, arg);\n    }\n    return n;\n}\nunsafe extern \"C\" fn parse_chunk(\n    mut k_units: *mut intmax_t,\n    mut n_units: *mut intmax_t,\n    mut arg: *const libc::c_char,\n) {\n    let mut argend: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut e: strtol_error = xstrtoimax(\n        arg,\n        &mut argend,\n        10 as libc::c_int,\n        n_units,\n        b\"\\0\" as *const u8 as *const libc::c_char,\n    );\n    if e as libc::c_uint == LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint\n        && *argend as libc::c_int == '/' as i32\n    {\n        *k_units = *n_units;\n        *n_units = parse_n_units(\n            argend.offset(1 as libc::c_int as isize),\n            b\"\\0\" as *const u8 as *const libc::c_char,\n            b\"invalid number of chunks\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !((0 as libc::c_int as libc::c_long) < *k_units && *k_units <= *n_units) {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(\n                        b\"invalid chunk number\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_mem(arg, argend.offset_from(arg) as libc::c_long as size_t),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        gettext(\n                            b\"invalid chunk number\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quote_mem(arg, argend.offset_from(arg) as libc::c_long as size_t),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        gettext(\n                            b\"invalid chunk number\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quote_mem(arg, argend.offset_from(arg) as libc::c_long as size_t),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    } else if !(e as libc::c_uint <= LONGINT_OVERFLOW as libc::c_int as libc::c_uint\n        && (0 as libc::c_int as libc::c_long) < *n_units)\n    {\n        strtoint_die(\n    b\"invalid number of chunks\\0\" as *const u8 as *const libc::c_char,\n    arg,\n);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut split_type: Split_type = type_undef;\n    let mut in_blk_size: idx_t = 0 as libc::c_int as idx_t;\n    let mut page_size: idx_t = getpagesize() as idx_t;\n    let mut k_units: intmax_t = 0 as libc::c_int as intmax_t;\n    let mut n_units: intmax_t = 0 as libc::c_int as intmax_t;\n    static mut multipliers: [libc::c_char; 15] = unsafe {\n        *::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b\"bEGKkMmPQRTYZ0\\0\")\n    };\n    let mut c: libc::c_int = 0;\n    let mut digits_optind: libc::c_int = 0 as libc::c_int;\n    let mut file_size: off_t = if (0 as libc::c_int as off_t)\n        < -(1 as libc::c_int) as off_t\n    {\n        -(1 as libc::c_int) as off_t\n    } else {\n        (((1 as libc::c_int as off_t)\n            << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n            - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n            + 1 as libc::c_int as libc::c_long\n    };\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    infile = b\"-\\0\" as *const u8 as *const libc::c_char;\n    outbase = b\"x\\0\" as *const u8 as *const libc::c_char;\n    loop {\n        let this_optind: i32 = if optind != 0 {\n    optind\n} else {\n    1\n};\n\nc = getopt_long(\n    argc,\n    argv,\n    b\"0123456789C:a:b:del:n:t:ux\\0\" as *const u8 as *const i8,\n    longopts.as_ptr(),\n    std::ptr::null_mut(),\n);\n\nif c == -1 {\n    break;\n}\n\nmatch c {\n    97 => {\n         suffix_length = xdectoimax(\n                    optarg,\n                    0,\n                    i64::MAX,\n                    std::ptr::null(),\n                    gettext(std::ffi::CString::new(\"invalid suffix length\").unwrap().as_ptr()),\n                    0,\n                );\n\n\n    }\n    259 => {\n         let suffix_len = unsafe { CStr::from_ptr(optarg).to_bytes().len() as i32 };\nlet optarg_str = unsafe { CStr::from_ptr(optarg).to_str().unwrap() };\nif last_component(optarg) != optarg\n    || (suffix_len != 0 && optarg_str.ends_with('/')) {\n    let errstatus = 0;\n    error(\n        errstatus,\n        0,\n        gettext(b\"invalid suffix %s, contains directory separator\\0\".as_ptr() as *const libc::c_char),\n        quote(optarg),\n    );\n    usage(1);\n}\nadditional_suffix = optarg;\n\n\n    }\n    98 => {\n         if split_type != type_undef {\n    if false {\n        error(\n            0,\n            0,\n            unsafe { gettext(b\"cannot split in more than one way\\0\".as_ptr() as *const libc::c_char) },\n        );\n        if false {\n            unreachable!();\n        }\n    } else {\n        let errstatus = 0;\n        error(\n            errstatus,\n            0,\n            unsafe { gettext(b\"cannot split in more than one way\\0\".as_ptr() as *const libc::c_char) },\n        );\n        if errstatus != 0 {\n            unreachable!();\n        }\n\n        let errstatus = 0;\n        error(\n            errstatus,\n            0,\n            unsafe { gettext(b\"cannot split in more than one way\\0\".as_ptr() as *const libc::c_char) },\n        );\n        if errstatus != 0 {\n            unreachable!();\n        }\n    }\n    usage(1);\n}\nsplit_type = type_bytes;\nn_units = unsafe {\n    parse_n_units(\n        optarg,\n        multipliers.as_ptr(),\n        b\"invalid number of bytes\\0\".as_ptr() as *const libc::c_char,\n    )\n};\n\n\n    }\n    108 => {\n         if split_type != type_undef {\n    if false {\n        error(0, 0, gettext(b\"cannot split in more than one way\\0\".as_ptr() as *const libc::c_char));\n        unreachable!();\n    } else {\n        let errstatus = 0;\n        error(errstatus, 0, gettext(b\"cannot split in more than one way\\0\".as_ptr() as *const libc::c_char));\n        if errstatus != 0 {\n            unreachable!();\n        }\n        \n        let errstatus = 0;\n        error(errstatus, 0, gettext(b\"cannot split in more than one way\\0\".as_ptr() as *const libc::c_char));\n        if errstatus != 0 {\n            unreachable!();\n        }\n    }\n    usage(1);\n}\nsplit_type = type_lines;\nn_units = parse_n_units(\n    optarg,\n    b\"\\0\".as_ptr() as *const libc::c_char,\n    b\"invalid number of lines\\0\".as_ptr() as *const libc::c_char,\n);\n\n\n    }\n    67 => {\n         if split_type != type_undef {\n    if false {\n        error(\n            0,\n            0,\n            gettext(b\"cannot split in more than one way\\0\".as_ptr() as *const libc::c_char),\n        );\n        unreachable!();\n    } else {\n        let errstatus = 0;\n        error(\n            errstatus,\n            0,\n            gettext(b\"cannot split in more than one way\\0\".as_ptr() as *const libc::c_char),\n        );\n        if errstatus != 0 {\n            unreachable!();\n        }\n    }\n    usage(1);\n}\nsplit_type = type_byteslines;\nn_units = parse_n_units(\n    optarg,\n    multipliers.as_ptr(),\n    b\"invalid number of lines\\0\".as_ptr() as *const libc::c_char,\n);\n\n\n    }\n    110 => {\n         if split_type != type_undef {\n    if false {\n        error(0, 0, gettext(\"cannot split in more than one way\\0\".as_ptr() as *const libc::c_char));\n        unreachable!();\n    } else {\n        let errstatus = 0;\n        error(errstatus, 0, gettext(\"cannot split in more than one way\\0\".as_ptr() as *const libc::c_char));\n        if errstatus != 0 {\n            unreachable!();\n        }\n    }\n    usage(1);\n}\n\nlet mut local_optarg = unsafe { std::ffi::CStr::from_ptr(optarg).to_string_lossy() };\nlet mut trimmed_optarg = local_optarg.as_ref();\n\nwhile trimmed_optarg.chars().next().map_or(false, |c| c.is_whitespace()) {\n    trimmed_optarg = &trimmed_optarg[1..];\n}\n\nif trimmed_optarg.starts_with(\"r/\") {\n    split_type = type_rr;\n    trimmed_optarg = &trimmed_optarg[2..];\n} else if trimmed_optarg.starts_with(\"l/\") {\n    split_type = type_chunk_lines;\n    trimmed_optarg = &trimmed_optarg[2..];\n} else {\n    split_type = type_chunk_bytes;\n}\n\nparse_chunk(&mut k_units, &mut n_units, trimmed_optarg.as_ptr() as *const libc::c_char);\n\n\n    }\n    117 => {\n        unbuffered = true;\n    }\n    116 => {\n         let optarg_str = unsafe { std::ffi::CStr::from_ptr(optarg) }.to_string_lossy();\nlet mut neweol = optarg_str.chars().next().unwrap_or('\\0') as i8;\n\nif neweol == 0 {\n    let errstatus = 1;\n    error(\n        errstatus,\n        0,\n        gettext(\"empty record separator\\0\".as_ptr() as *const libc::c_char),\n    );\n    unreachable!();\n}\n\nif optarg_str.len() > 1 {\n    if optarg_str == \"\\\\0\" {\n        neweol = '\\0' as i32 as i8;\n    } else {\n        let errstatus = 1;\n        error(\n            errstatus,\n            0,\n            gettext(\"multi-character separator %s\\0\".as_ptr() as *const libc::c_char),\n            quote(optarg_str.as_ptr() as *const libc::c_char),\n        );\n        unreachable!();\n    }\n}\n\nif 0 <= eolchar && neweol as i32 != eolchar {\n    let errstatus = 1;\n    error(\n        errstatus,\n        0,\n        gettext(\"multiple separator characters specified\\0\".as_ptr() as *const libc::c_char),\n    );\n    unreachable!();\n}\n\neolchar = neweol as i32;\n\n\n    }\n    48..=57 => {\n         if split_type as libc::c_uint\n                    == type_undef as libc::c_int as libc::c_uint\n                {\n                    split_type = type_digits;\n                    n_units = 0 as libc::c_int as intmax_t;\n                }\n                if split_type as libc::c_uint\n                    != type_undef as libc::c_int as libc::c_uint\n                    && split_type as libc::c_uint\n                        != type_digits as libc::c_int as libc::c_uint\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"cannot split in more than one way\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n                if digits_optind != 0 as libc::c_int && digits_optind != this_optind {\n                    n_units = 0 as libc::c_int as intmax_t;\n                }\n                digits_optind = this_optind;\n                if (if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n_units\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        10 as libc::c_int\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    && (if (10 as libc::c_int) < 0 as libc::c_int {\n                        if n_units < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as intmax_t\n                                }) + 10 as libc::c_int as libc::c_long\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n_units\n                                    < -(1 as libc::c_int) as intmax_t\n                                        / 10 as libc::c_int as libc::c_long) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    10 as libc::c_int\n                                }) - 1 as libc::c_int) < 0 as libc::c_int\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) + 1 as libc::c_int)\n                                        << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) + 0 as libc::c_int\n                                }) < 0 as libc::c_int\n                                {\n                                    ((10 as libc::c_int)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) + 1 as libc::c_int)\n                                                << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) - 1 as libc::c_int\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int) < 10 as libc::c_int) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + -(1 as libc::c_int) as intmax_t\n                                        >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as intmax_t\n                                        / -(10 as libc::c_int) as libc::c_long\n                                }) <= -(1 as libc::c_int) as libc::c_long - n_units)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    10 as libc::c_int\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    10 as libc::c_int\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                                    as libc::c_int\n                            }) != 0 && 10 as libc::c_int == -(1 as libc::c_int)\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n_units\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n_units + 0 as libc::c_int as intmax_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n_units\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as intmax_t)\n                                            < n_units - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                ((0 as libc::c_int as intmax_t\n                                    / 10 as libc::c_int as libc::c_long) < n_units)\n                                    as libc::c_int\n                            }\n                        }\n                    } else {\n                        if 10 as libc::c_int == 0 as libc::c_int {\n                            0 as libc::c_int\n                        } else {\n                            if n_units < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n_units\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n_units\n                                        }) + 0 as libc::c_int as intmax_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n_units\n                                        }) + 0 as libc::c_int as intmax_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n_units\n                                    }) + 0 as libc::c_int as intmax_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n_units\n                                            }) + 0 as libc::c_int as intmax_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n_units\n                                                }) + 0 as libc::c_int as intmax_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n_units\n                                                }) + 0 as libc::c_int as intmax_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n_units\n                                        }) + 0 as libc::c_int as intmax_t) as libc::c_int\n                                }) != 0 && n_units == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < 10 as libc::c_int as libc::c_long\n                                                + 0 as libc::c_int as intmax_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as intmax_t)\n                                            < (10 as libc::c_int - 1 as libc::c_int) as libc::c_long)\n                                            as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as intmax_t / n_units\n                                        < 10 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                ((-(1 as libc::c_int) as intmax_t\n                                    / 10 as libc::c_int as libc::c_long) < n_units)\n                                    as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh27, _fresh28) = n_units.overflowing_mul((10 as libc::c_int).into());\n                    *(&mut n_units as *mut intmax_t) = fresh27;\n                    1 as libc::c_int\n                } else {\n                    let (fresh29, fresh30) = n_units.overflowing_mul((10 as libc::c_int).into());\n                    *(&mut n_units as *mut intmax_t) = fresh29;\n                    fresh30 as libc::c_int\n                }) != 0\n                    || {\n                        let (fresh31, fresh32) = n_units.overflowing_add((c - '0' as i32).into());\n                        *(&mut n_units as *mut intmax_t) = fresh31;\n                        fresh32 as libc::c_int != 0\n                    }\n                {\n                    n_units = 9223372036854775807 as libc::c_long;\n                }\n\n    }\n    100 | 120 => {\n         if c == 'd' as i32 {\n                    suffix_alphabet = b\"0123456789\\0\" as *const u8\n                        as *const libc::c_char;\n                } else {\n                    suffix_alphabet = b\"0123456789abcdef\\0\" as *const u8\n                        as *const libc::c_char;\n                }\n                if !optarg.is_null() {\n                    if strlen(optarg) != strspn(optarg, suffix_alphabet) {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                0 as libc::c_int,\n                                if c == 'd' as i32 {\n                                    gettext(\n                                        b\"%s: invalid start value for numerical suffix\\0\"\n                                            as *const u8 as *const libc::c_char,\n                                    )\n                                } else {\n                                    gettext(\n                                        b\"%s: invalid start value for hexadecimal suffix\\0\"\n                                            as *const u8 as *const libc::c_char,\n                                    )\n                                },\n                                quote(optarg),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    if c == 'd' as i32 {\n                                        gettext(\n                                            b\"%s: invalid start value for numerical suffix\\0\"\n                                                as *const u8 as *const libc::c_char,\n                                        )\n                                    } else {\n                                        gettext(\n                                            b\"%s: invalid start value for hexadecimal suffix\\0\"\n                                                as *const u8 as *const libc::c_char,\n                                        )\n                                    },\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    if c == 'd' as i32 {\n                                        gettext(\n                                            b\"%s: invalid start value for numerical suffix\\0\"\n                                                as *const u8 as *const libc::c_char,\n                                        )\n                                    } else {\n                                        gettext(\n                                            b\"%s: invalid start value for hexadecimal suffix\\0\"\n                                                as *const u8 as *const libc::c_char,\n                                        )\n                                    },\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                        usage(1 as libc::c_int);\n                    } else {\n                        while *optarg as libc::c_int == '0' as i32\n                            && *optarg.offset(1 as libc::c_int as isize) as libc::c_int\n                                != '\\0' as i32\n                        {\n                            optarg = optarg.offset(1);\n                            optarg;\n                        }\n                        numeric_suffix_start = optarg;\n                    }\n                }\n\n    }\n    101 => {\n        elide_empty_files = true;\n    }\n    257 => {\n        filter_command = optarg;\n    }\n    258 => {\n         in_blk_size = xdectoumax(\n                    optarg,\n                    1 as libc::c_int as uintmax_t,\n                    if (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong)\n                        < (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n                            < 18446744073709551615 as libc::c_ulong\n                        {\n                            9223372036854775807 as libc::c_long as libc::c_ulong\n                        } else {\n                            18446744073709551615 as libc::c_ulong\n                        })\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    {\n                        SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong\n                    } else {\n                        (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n                            < 18446744073709551615 as libc::c_ulong\n                        {\n                            9223372036854775807 as libc::c_long as libc::c_ulong\n                        } else {\n                            18446744073709551615 as libc::c_ulong\n                        })\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    },\n                    multipliers.as_ptr(),\n                    gettext(\n                        b\"invalid IO block size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as libc::c_int,\n                ) as idx_t;\n\n    }\n    256 => {\n        verbose = true;\n    }\n    -2 => {\n        usage(0);\n    }\n    -3 => {\n         version_etc(\n    unsafe { stdout },\n    b\"split\\0\".as_ptr() as *const libc::c_char,\n    b\"GNU coreutils\\0\".as_ptr() as *const libc::c_char,\n    Version,\n    proper_name_lite(\n        b\"Torbjorn Granlund\\0\".as_ptr() as *const libc::c_char,\n        b\"Torbj\\xF6rn Granlund\\0\".as_ptr() as *const libc::c_char,\n    ),\n    proper_name_lite(\n        b\"Richard M. Stallman\\0\".as_ptr() as *const libc::c_char,\n        b\"Richard M. Stallman\\0\".as_ptr() as *const libc::c_char,\n    ),\n    std::ptr::null_mut::<libc::c_char>(),\n);\nstd::process::exit(0);\n\n\n    }\n    _ => {\n        usage(1);\n    }\n}\n\n/*\nThe variables live at this point are:\n(mut argc: i32, mut argv: *mut *mut i8, mut split_type: u32, mut in_blk_size: i64, mut k_units: i64, mut n_units: i64, mut c: i32, mut digits_optind: i32, mut this_optind: i32)\n*/\n\n    }\n    if k_units != 0 as libc::c_int as libc::c_long && !filter_command.is_null() {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"--filter does not process a chunk extracted to stdout\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"--filter does not process a chunk extracted to stdout\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"--filter does not process a chunk extracted to stdout\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if split_type as libc::c_uint == type_undef as libc::c_int as libc::c_uint {\n        split_type = type_lines;\n        n_units = 1000 as libc::c_int as intmax_t;\n    }\n    if n_units == 0 as libc::c_int as libc::c_long {\n        if 0 != 0 {",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"invalid number of lines: %s\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote(b\"0\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"invalid number of lines: %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote(b\"0\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"invalid number of lines: %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote(b\"0\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if eolchar < 0 as libc::c_int {\n        eolchar = '\\n' as i32;\n    }\n    set_suffix_length(n_units, split_type);\n    if optind < argc {\n        let fresh33 = optind;\n        optind = optind + 1;\n        infile = *argv.offset(fresh33 as isize);\n    }\n    if optind < argc {\n        let fresh34 = optind;\n        optind = optind + 1;\n        outbase = *argv.offset(fresh34 as isize);\n    }\n    if optind < argc {\n    let extra_operand_error = format!(\"extra operand {}\", unsafe { CStr::from_ptr(*argv.offset(optind as isize)).to_string_lossy() });\n    error(0, 0, gettext(extra_operand_error.as_ptr() as *const libc::c_char));\n    usage(1);\n}\n\nif !numeric_suffix_start.is_null() && strlen(numeric_suffix_start) > suffix_length as libc::c_ulong {\n    let suffix_error = \"numerical suffix start value is too large for the suffix length\";\n    error(0, 0, gettext(suffix_error.as_ptr() as *const libc::c_char));\n    usage(1);\n}\n\nif unsafe { strcmp(infile, b\"-\\0\" as *const u8 as *const libc::c_char) } != 0 {\n    if fd_reopen(0, infile, 0, 0) < 0 {\n        let open_error = format!(\"cannot open {}\", unsafe { CStr::from_ptr(infile).to_string_lossy() });\n        error(1, *__errno_location(), gettext(open_error.as_ptr() as *const libc::c_char));\n    }\n}\n\nxset_binary_mode(0, 0);\n;\n    fdadvise(\n        0 as libc::c_int,\n        0 as libc::c_int as off_t,\n        0 as libc::c_int as off_t,\n        FADVISE_SEQUENTIAL,\n    );\n    if fstat(0 as libc::c_int, &mut in_stat_buf) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    infile,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if in_blk_size == 0 as libc::c_int as libc::c_long {\n        in_blk_size = io_blksize(&mut in_stat_buf);\n        if (SYS_BUFSIZE_MAX as libc::c_int as libc::c_long) < in_blk_size {\n            in_blk_size = SYS_BUFSIZE_MAX as libc::c_int as idx_t;\n        }\n    }\n    let mut buf: *mut libc::c_char = xalignalloc(\n        page_size,\n        in_blk_size + 1 as libc::c_int as libc::c_long,\n    ) as *mut libc::c_char;\n    let mut initial_read: ssize_t = -(1 as libc::c_int) as ssize_t;\n    if split_type as libc::c_uint == type_chunk_bytes as libc::c_int as libc::c_uint\n        || split_type as libc::c_uint == type_chunk_lines as libc::c_int as libc::c_uint\n    {\n        file_size = input_file_size(\n            0 as libc::c_int,\n            &mut in_stat_buf,\n            buf,\n            in_blk_size,\n        );\n        if file_size < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: cannot determine file size\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot determine file size\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot determine file size\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        initial_read = if file_size < in_blk_size { file_size } else { in_blk_size };\n    }\n    if !filter_command.is_null() {\n        default_SIGPIPE = (signal(\n            13 as libc::c_int,\n            ::core::mem::transmute::<\n                libc::intptr_t,\n                __sighandler_t,\n            >(1 as libc::c_int as libc::intptr_t),\n        ))\n            .is_none();\n    }\n    match split_type as libc::c_uint {\n        4 | 3 => {\n            lines_split(n_units, buf, in_blk_size);\n        }\n        1 => {\n            bytes_split(\n                n_units,\n                0 as libc::c_int as intmax_t,\n                buf,\n                in_blk_size,\n                -(1 as libc::c_int) as ssize_t,\n                0 as libc::c_int as intmax_t,\n            );\n        }\n        2 => {\n            line_bytes_split(n_units, buf, in_blk_size);\n        }\n        5 => {\n            if k_units == 0 as libc::c_int as libc::c_long {\n                bytes_split(\n                    file_size / n_units,\n                    file_size % n_units,\n                    buf,\n                    in_blk_size,\n                    initial_read,\n                    n_units,\n                );\n            } else {\n                bytes_chunk_extract(\n                    k_units,\n                    n_units,\n                    buf,\n                    in_blk_size,\n                    initial_read,\n                    file_size,\n                );\n            }\n        }\n        6 => {\n            lines_chunk_split(\n                k_units,\n                n_units,\n                buf,\n                in_blk_size,\n                initial_read,\n                file_size,\n            );\n        }\n        7 => {\n            let mut files: *mut of_t = 0 as *mut of_t;\n            lines_rr(k_units, n_units, buf, in_blk_size, &mut files);\n        }\n        _ => {\n            __assert_fail(\n                b\"0\\0\" as *const u8 as *const libc::c_char,\n                b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                1686 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 23],\n                    &[libc::c_char; 23],\n                >(b\"int main(int, char **)\\0\"))\n                    .as_ptr(),\n            );\n            'c_16295: {\n                __assert_fail(\n                    b\"0\\0\" as *const u8 as *const libc::c_char,\n                    b\"split.c\\0\" as *const u8 as *const libc::c_char,",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "                    1686 as libc::c_int as libc::c_uint,\n                    (*::core::mem::transmute::<\n                        &[u8; 23],\n                        &[libc::c_char; 23],\n                    >(b\"int main(int, char **)\\0\"))\n                        .as_ptr(),\n                );\n            };\n        }\n    }\n    if close(0 as libc::c_int) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    infile,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    closeout(0 as *mut FILE, output_desc, filter_pid, outfile);\n    exit(0 as libc::c_int);\n}\npub fn main() {\n    let args: Vec<CString> = ::std::env::args()\n        .map(|arg| CString::new(arg).expect(\"Failed to convert argument into CString.\"))\n        .collect();\n    \n    let mut argv: Vec<*mut libc::c_char> = args.iter()\n        .map(|arg| arg.as_ptr() as *mut libc::c_char)\n        .collect();\n    \n    argv.push(std::ptr::null_mut());\n\n    unsafe {\n        ::std::process::exit(main_0((argv.len() - 1) as libc::c_int, argv.as_mut_ptr()) as i32);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\split.rs"
    },
    {
      "chunk": "use std::u32;\nuse std::mem;\nuse ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn __gl_stdbit_clz(n: u32) -> i32 {\n    if n != 0 {\n        n.leading_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u32>() as i32)\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn __gl_stdbit_clzl(n: u64) -> i32 {\n    if n != 0 {\n        n.leading_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u64>() as u64) as i32\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn __gl_stdbit_ctz(n: u32) -> i32 {\n    if n != 0 {\n        n.trailing_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u32>() as i32)\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn __gl_stdbit_ctzl(n: u64) -> i32 {\n    if n != 0 {\n        n.trailing_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u64>() as u64) as i32\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_ctzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\stdbit.rs"
    },
    {
      "chunk": "use std::u32;\nuse std::mem;\nuse std::convert::TryInto;\nuse ::libc;\n#[inline]\nfn __gl_stdbit_clz(n: u32) -> i32 {\n    if n != 0 {\n        n.leading_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u32>() as i32)\n    }\n}\n#[inline]\nfn __gl_stdbit_clzl(n: u64) -> i32 {\n    if n != 0 {\n        n.leading_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u64>() as u32) as i32\n    }\n}\n#[inline]\nfn __gl_stdbit_clzll(n: u64) -> i32 {\n    if n != 0 {\n        n.leading_zeros() as i32\n    } else {\n        (8 * std::mem::size_of::<u64>() as u32) as i32\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn stdc_leading_zeros_ui(n: u32) -> u32 {\n    let leading_zeros = n.leading_zeros();\n    leading_zeros\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn stdc_leading_zeros_uc(n: u8) -> u32 {\n    let leading_zeros = stdc_leading_zeros_ui(n as u32);\n    let size_difference = (std::mem::size_of::<u32>() as u32).wrapping_sub(std::mem::size_of::<u8>() as u32);\n    (leading_zeros as u64).wrapping_sub((8u32 as u64).wrapping_mul(size_difference as u64)) as u32\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn stdc_leading_zeros_us(n: u16) -> u32 {\n    let leading_zeros = stdc_leading_zeros_ui(n as u32);\n    let size_diff = (std::mem::size_of::<u32>() - std::mem::size_of::<u16>()) * 8;\n    leading_zeros.wrapping_sub(size_diff as u32)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn stdc_leading_zeros_ul(n: u64) -> u32 {\n    return __gl_stdbit_clzl(n) as u32;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn stdc_leading_zeros_ull(n: u64) -> u32 {\n    n.leading_zeros()\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\stdc_leading_zeros.rs"
    },
    {
      "chunk": "use std::ffi;\nuse std::io;\nuse std::ffi::CStr;\nuse std::fs;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char) -> *mut FILE;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn free(_: *mut libc::c_void);\n    fn mkstemp_safer(_: *mut libc::c_char) -> libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn unlink(__name: *const libc::c_char) -> libc::c_int;\n    fn ftruncate(__fd: libc::c_int, __length: __off_t) -> libc::c_int;\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn __errno_location() -> *mut libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn path_search(\n        tmpl: *mut libc::c_char,\n        tmpl_len: size_t,\n        dir: *const libc::c_char,\n        pfx: *const libc::c_char,\n        try_tmpdir: bool,\n    ) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\nfn record_or_unlink_tempfile(fn_0: &str) {\n    std::fs::remove_file(fn_0).ok();\n}\n#[no_mangle]\npub unsafe extern \"C\" fn temp_stream(\n    mut fp: *mut *mut FILE,\n    mut file_name: *mut *mut libc::c_char,\n) -> bool {\n    use std::ffi::{CString, CStr};\nuse std::fs::File;\nuse std::io::{self, Write};\nuse std::os::unix::io::AsRawFd;\nuse std::ptr;\n\nstatic mut tempfile: *mut libc::c_char = ptr::null_mut();\nstatic mut tmp_fp: *mut FILE = ptr::null_mut();\n\nif tempfile.is_null() {\n    's_103: {\n         let mut tempbuf: Vec<i8> = vec![0; 128];\nlet mut tempbuf_len: usize = tempbuf.len();\nloop {\n    tempbuf.resize(tempbuf_len, 0);\n    if tempbuf.is_empty() {\n        error(\n            0,\n            *__errno_location(),\n            gettext(b\"failed to make temporary file name\\0\" as *const u8 as *const libc::c_char),\n        );\n        return false;\n    }\n    if path_search(\n        tempbuf.as_mut_ptr(),\n        tempbuf_len.try_into().unwrap(),\n        std::ptr::null(),\n        b\"cutmp\\0\" as *const u8 as *const libc::c_char,\n        true,\n    ) == 0\n    {\n        break;\n    }\n    if *__errno_location() != 22 || (4096 / 2) < tempbuf_len {\n        error(\n            0,\n            if *__errno_location() == 22 { 36 } else { *__errno_location() },\n            gettext(b\"failed to make temporary file name\\0\" as *const u8 as *const libc::c_char),\n        );\n        return false;\n    }\n    tempbuf_len *= 2;\n}\nlet tempfile_ptr = tempbuf.as_mut_ptr();\nlet fd: libc::c_int = mkstemp_safer(tempfile_ptr);\n\n            if fd < 0 {\n    if false {\n        error(\n            0,\n            std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n            gettext(\"failed to create temporary file %s\\0\".as_ptr() as *const libc::c_char),\n            quotearg_style(shell_escape_always_quoting_style, tempfile),\n        );\n        unreachable!();\n    } else {\n        let __errstatus: i32 = 0;\n        error(\n            __errstatus,\n            std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n            gettext(\"failed to create temporary file %s\\0\".as_ptr() as *const libc::c_char),\n            quotearg_style(shell_escape_always_quoting_style, tempfile),\n        );\n        if __errstatus != 0 {\n            unreachable!();\n        }\n\n        let __errstatus: i32 = 0;\n        error(\n            __errstatus,\n            std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n            gettext(\"failed to create temporary file %s\\0\".as_ptr() as *const libc::c_char),\n            quotearg_style(shell_escape_always_quoting_style, tempfile),\n        );\n        if __errstatus != 0 {\n            unreachable!();\n        }\n    }\n} else {\n    let mode = if false { \"w+b\\0\" } else { \"w+\\0\" };\n    let file_pointer = fdopen(fd, mode.as_ptr() as *const libc::c_char);\n    if file_pointer.is_null() {\n        if false {\n            error(\n                0,\n                std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                gettext(\"failed to open %s for writing\\0\".as_ptr() as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, tempfile),\n            );\n            unreachable!();\n        } else {\n            let __errstatus: i32 = 0;\n            error(\n                __errstatus,\n                std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                gettext(\"failed to open %s for writing\\0\".as_ptr() as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, tempfile),\n            );\n            if __errstatus != 0 {\n                unreachable!();\n            }\n\n            let __errstatus: i32 = 0;\n            error(\n                __errstatus,\n                std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n                gettext(\"failed to open %s for writing\\0\".as_ptr() as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, tempfile),\n            );\n            if __errstatus != 0 {\n                unreachable!();\n            }\n        }\n        close(fd);\n        unlink(tempfile);\n    } else {\n        record_or_unlink_tempfile(unsafe { std::ffi::CStr::from_ptr(tempfile).to_str().unwrap() });\n        break 's_103;\n    }\n}\nfree(tempfile as *mut libc::c_void);\ntempfile = std::ptr::null_mut();\nreturn false;\n\n        }\n} else {\n    clearerr_unlocked(tmp_fp);\n        if rpl_fseeko(tmp_fp, 0 as libc::c_int as off_t, 0 as libc::c_int)\n            < 0 as libc::c_int\n            || ftruncate(fileno(tmp_fp), 0 as libc::c_int as __off_t) < 0 as libc::c_int\n        {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to rewind stream for %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, tempfile),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to rewind stream for %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, tempfile),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to rewind stream for %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, tempfile),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n    \n}\n\n*fp = tmp_fp;\nif !file_name.is_null() {\n    *file_name = tempfile;\n}\nreturn 1 != 0;\n\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\temp_stream.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn secure_getenv(__name: *const libc::c_char) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn __errno_location() -> *mut libc::c_int;\n    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub type __syscall_slong_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blkcnt_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __off_t = libc::c_long;\npub type __dev_t = libc::c_ulong;\npub type __gid_t = libc::c_uint;\npub type __uid_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\nunsafe extern \"C\" fn direxists(mut dir: *const libc::c_char) -> bool {\n    let mut buf: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    return stat(dir, &mut buf) == 0 as libc::c_int\n        && buf.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o40000 as libc::c_int as libc::c_uint;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn path_search(\n    mut tmpl: *mut libc::c_char,\n    mut tmpl_len: size_t,\n    mut dir: *const libc::c_char,\n    mut pfx: *const libc::c_char,\n    mut try_tmpdir: bool,\n) -> libc::c_int {\n    let mut d: *const libc::c_char = 0 as *const libc::c_char;\n    let mut dlen: size_t = 0;\n    let mut plen: size_t = 0;\n    let mut add_slash: bool = false;\n    if pfx.is_null() || *pfx.offset(0 as libc::c_int as isize) == 0 {\n        pfx = b\"file\\0\" as *const u8 as *const libc::c_char;\n        plen = 4 as libc::c_int as size_t;\n    } else {\n        plen = strlen(pfx);\n        if plen > 5 as libc::c_int as libc::c_ulong {\n            plen = 5 as libc::c_int as size_t;\n        }\n    }\n    if try_tmpdir {\n        d = secure_getenv(b\"TMPDIR\\0\" as *const u8 as *const libc::c_char);\n        if !d.is_null() && direxists(d) as libc::c_int != 0 {\n            dir = d;\n        } else if !(!dir.is_null() && direxists(dir) as libc::c_int != 0) {\n            dir = 0 as *const libc::c_char;\n        }\n    }\n    if dir.is_null() {\n        if direxists(b\"/tmp\\0\" as *const u8 as *const libc::c_char) {\n            dir = b\"/tmp\\0\" as *const u8 as *const libc::c_char;\n        } else if strcmp(\n            b\"/tmp\\0\" as *const u8 as *const libc::c_char,\n            b\"/tmp\\0\" as *const u8 as *const libc::c_char,\n        ) != 0 as libc::c_int\n            && direxists(b\"/tmp\\0\" as *const u8 as *const libc::c_char) as libc::c_int\n                != 0\n        {\n            dir = b\"/tmp\\0\" as *const u8 as *const libc::c_char;\n        } else {\n            *__errno_location() = 2 as libc::c_int;\n            return -(1 as libc::c_int);\n        }\n    }\n    dlen = strlen(dir);\n    add_slash = dlen != 0 as libc::c_int as libc::c_ulong\n        && !(*dir.offset(dlen.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_int == '/' as i32);\n    if tmpl_len\n        < dlen\n            .wrapping_add(add_slash as libc::c_ulong)\n            .wrapping_add(plen)\n            .wrapping_add(6 as libc::c_int as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        *__errno_location() = 22 as libc::c_int;\n        return -(1 as libc::c_int);\n    }\n    memcpy(tmpl as *mut libc::c_void, dir as *const libc::c_void, dlen);\n    sprintf(\n        tmpl.offset(dlen as isize),\n        &*(b\"/%.*sXXXXXX\\0\" as *const u8 as *const libc::c_char)\n            .offset(!add_slash as libc::c_int as isize) as *const libc::c_char,\n        plen as libc::c_int,\n        pfx,\n    );\n    return 0 as libc::c_int;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\tmpdir.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\version.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\version_etc.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub fn emit_bug_reporting_address() {\n    println!();\n    let report_bugs = unsafe { CStr::from_ptr(gettext(b\"Report bugs to: %s\\n\\0\".as_ptr() as *const libc::c_char)) };\n    println!(\"{}\", report_bugs.to_string_lossy().replace(\"%s\", \"bug-coreutils@gnu.org\"));\n\n    let home_page = unsafe { CStr::from_ptr(gettext(b\"%s home page: <%s>\\n\\0\".as_ptr() as *const libc::c_char)) };\n    println!(\n        \"{} home page: <{}>\",\n        home_page.to_string_lossy().replace(\"%s\", \"GNU coreutils\"),\n        \"https://www.gnu.org/software/coreutils/\"\n    );\n\n    let help_message = unsafe { CStr::from_ptr(gettext(b\"General help using GNU software: <%s>\\n\\0\".as_ptr() as *const libc::c_char)) };\n    println!(\n        \"{}\",\n        help_message.to_string_lossy().replace(\"%s\", \"https://www.gnu.org/gethelp/\")\n    );\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\version_etc.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\version_etc_fsf.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn aligned_alloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn xalloc_die();\n}\npub type size_t = libc::c_ulong;\npub type ptrdiff_t = libc::c_long;\npub type idx_t = ptrdiff_t;\n#[inline]\nfn alignalloc(alignment: usize, size: usize) -> *mut libc::c_void {\n    let alignment = if alignment.is_power_of_two() && alignment > 0 { alignment } else { usize::MAX };\n    let size = if size > 0 { size } else { usize::MAX };\n\n    let ptr = unsafe { aligned_alloc(alignment.try_into().unwrap(), size.try_into().unwrap()) };\n    if ptr.is_null() {\n        std::ptr::null_mut()\n    } else {\n        ptr\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xalignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    let p: *mut libc::c_void = alignalloc(alignment.try_into().unwrap(), size.try_into().unwrap());\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xalignalloc.rs"
    },
    {
      "chunk": "use std::process;\nuse ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub fn xalloc_die() {\n    unsafe {\n        if 0 != 0 {\n            error(\n                exit_failure,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if exit_failure != 0 {\n                unreachable!();\n            }\n        } else {\n            let errstatus = exit_failure;\n            error(\n                errstatus,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if errstatus != 0 {\n                unreachable!();\n            }\n\n            let errstatus = exit_failure;\n            error(\n                errstatus,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if errstatus != 0 {\n                unreachable!();\n            }\n        }\n    }\n    std::process::abort();\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xalloc_die.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn xset_binary_mode(fd: libc::c_int, mode: libc::c_int) {\n    let result = unsafe { set_binary_mode(fd, mode) };\n    if result < 0 {\n        xset_binary_mode_error();\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn xset_binary_mode_error() {\n    // This function is intended to set the binary mode for standard input/output.\n    // We will use the libc crate to perform the necessary system calls.\n    use std::io::{self, Write};\n    use std::os::unix::io::AsRawFd;\n    use libc::{self, termios, TCSETA};\n\n    // Create a termios structure to set the terminal attributes\n    let mut tty = unsafe { std::mem::zeroed::<termios>() };\n    \n    // Get the current terminal attributes\n    let fd = std::io::stdin().as_raw_fd();\n    if unsafe { libc::tcgetattr(fd, &mut tty) } != 0 {\n        eprintln!(\"Failed to get terminal attributes: {}\", io::Error::last_os_error());\n        return;\n    }\n\n    // Modify the attributes to set binary mode\n    tty.c_iflag &= !(libc::ICRNL | libc::INPCK | libc::ISTRIP);\n    tty.c_oflag &= !libc::OPOST;\n    tty.c_lflag &= !(libc::ICANON | libc::ECHO | libc::ECHOE | libc::ECHOK | libc::ECHONL | libc::ISIG);\n\n    // Set the new terminal attributes\n    if unsafe { libc::tcsetattr(fd, 0, &tty) } != 0 { // Use 0 for TCSANOW to apply changes immediately\n        eprintln!(\"Failed to set terminal attributes: {}\", io::Error::last_os_error());\n    }\n}\n#[inline]\nunsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    let result = __gl_setmode(fd, mode);\nreturn result;\n}\n#[inline]\nfn __gl_setmode(fd: i32, mode: i32) -> i32 {\n    // Here we would typically set the terminal mode using the termios struct.\n    // Since we are converting to idiomatic Rust, we will assume that the\n    // actual implementation is handled elsewhere.\n    return 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xbinary_io.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn xstrtoimax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut intmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n}\npub type __intmax_t = libc::c_long;\npub type intmax_t = __intmax_t;\npub const LONGINT_OK: strtol_error = 0;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\n#[no_mangle]\npub unsafe extern \"C\" fn xnumtoimax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: intmax_t = 0;\n    s_err = xstrtoimax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_long {\n                *__errno_location() = 75 as libc::c_int;\n            } else if tnum\n                < ((-(2147483647 as libc::c_int) - 1 as libc::c_int) / 2 as libc::c_int)\n                    as libc::c_long\n            {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xdectoimax(\n    mut n_str: *const libc::c_char,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    return xnumtoimax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xdectoimax.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse std::io::Write;\nuse ::libc;\nextern \"C\" {\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn xstrtoumax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut uintmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n}\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\npub const LONGINT_OK: strtol_error = 0;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\n#[no_mangle]\npub unsafe extern \"C\" fn xdectoumax(\n    mut n_str: *const libc::c_char,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    let result = xnumtoumax(\n    std::ffi::CStr::from_ptr(n_str).to_str().unwrap(),\n    10,\n    min,\n    max,\n    suffixes.as_ref().map(|s| std::ffi::CStr::from_ptr(s).to_str().unwrap()),\n    std::ffi::CStr::from_ptr(err).to_str().unwrap(),\n    err_exit,\n);\nreturn result;\n}\n#[no_mangle]\npub fn xnumtoumax(\n    n_str: &str,\n    base: i32,\n    min: u64,\n    max: u64,\n    suffixes: Option<&str>,\n    err: &str,\n    err_exit: i32,\n) -> u64 {\n    let mut tnum: u64 = 0;\n    let mut end_ptr: *mut libc::c_char = std::ptr::null_mut();\n\n    // Call to unsafe function requires an unsafe block\n    let s_err = unsafe {\n        xstrtoumax(\n            n_str.as_ptr() as *const libc::c_char,\n            &mut end_ptr,\n            base,\n            &mut tnum,\n            suffixes.map_or(std::ptr::null(), |s| s.as_ptr() as *const libc::c_char),\n        )\n    };\n\n    match s_err {\n        LONGINT_OK => {\n            if tnum < min || tnum > max {\n                eprintln!(\"Value out of range\");\n                std::process::exit(err_exit);\n            }\n        }\n        LONGINT_OVERFLOW => {\n            eprintln!(\"Overflow occurred\");\n            std::process::exit(err_exit);\n        }\n        LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW => {\n            eprintln!(\"Invalid suffix character with overflow\");\n            std::process::exit(err_exit);\n        }\n        _ => {\n            eprintln!(\"Unknown error\");\n            std::process::exit(err_exit);\n        }\n    }\n\n    tnum\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xdectoumax.rs"
    },
    {
      "chunk": "use std::slice;\nuse std::mem;\nuse std::vec::Vec;\nuse std::vec;\nuse ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nunsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n    return _gl_alloc_nomem();\n};\n}\n#[inline]\nfn icalloc(n: i64, s: i64) -> *mut libc::c_void {\n    let n_usize: Option<usize> = n.try_into().ok();\n    let s_usize: Option<usize> = s.try_into().ok();\n\n    if n_usize.is_none() || n_usize.unwrap() > usize::MAX {\n        if s != 0 {\n            return _gl_alloc_nomem();\n        }\n        return std::ptr::null_mut();\n    }\n    if s_usize.is_none() || s_usize.unwrap() > usize::MAX {\n        if n != 0 {\n            return _gl_alloc_nomem();\n        }\n        return std::ptr::null_mut();\n    }\n    \n    let total_size: usize = n_usize.unwrap() * s_usize.unwrap();\n    let vec = vec![0u8; total_size];\n    let boxed_slice = vec.into_boxed_slice();\n    Box::into_raw(boxed_slice) as *mut libc::c_void\n}\n#[inline]\nfn ireallocarray(\n    p: *mut libc::c_void,\n    n: usize,\n    s: usize,\n) -> *mut libc::c_void {\n    if n <= usize::MAX && s <= usize::MAX {\n        let mut nx = n;\n        let mut sx = s;\n        if n == 0 || s == 0 {\n            sx = 1;\n            nx = sx;\n        }\n        let new_size = nx.checked_mul(sx).unwrap_or(0);\n        if new_size == 0 {\n            return std::ptr::null_mut();\n        }\n        let new_ptr = unsafe { libc::reallocarray(p, nx, sx) };\n        if new_ptr.is_null() {\n            return std::ptr::null_mut();\n        }\n        new_ptr\n    } else {\n        unsafe { _gl_alloc_nomem() }\n    }\n}\n#[cold]\n#[inline]\nfn _gl_alloc_nomem() -> *mut libc::c_void {\n    unsafe {\n        *__errno_location() = 12; // Set errno to ENOMEM\n    }\n    std::ptr::null_mut() // Return a null pointer\n}\n#[inline]\nfn imalloc(s: usize) -> *mut libc::c_void {\n    if s <= usize::MAX {\n        let layout = std::alloc::Layout::from_size_align(s, 1).unwrap();\n        let ptr = unsafe { std::alloc::alloc(layout) };\n        if ptr.is_null() {\n            std::ptr::null_mut()\n        } else {\n            ptr as *mut libc::c_void\n        }\n    } else {\n        std::ptr::null_mut()\n    }\n}\nfn check_nonnull(p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        unsafe { xalloc_die() };\n    }\n    p\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    let ptr = malloc(s);\nreturn check_nonnull(ptr);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    let ptr = imalloc(s.try_into().expect(\"Size conversion failed\"));\nreturn check_nonnull(ptr);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let ptr = irealloc(p, s);\nreturn check_nonnull(ptr);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let ptr = ireallocarray(p, n as usize, s as usize);\nreturn check_nonnull(ptr);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub fn xinmalloc(n: usize, s: usize) -> Option<Box<[u8]>> {\n    let total_size = n.checked_mul(s)?;\n    let buffer = vec![0u8; total_size].into_boxed_slice();\n    Some(buffer)\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub fn xzalloc(s: usize) -> Vec<u8> {\n    let size = s * std::mem::size_of::<u8>();\n    vec![0; size]\n}\n#[no_mangle]\npub fn xizalloc(s: usize) -> Vec<u8> {\n    let vec = vec![0u8; s];\n    vec\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    let ptr = calloc(n, s);\nreturn check_nonnull(ptr);\n}\n#[no_mangle]\npub fn xicalloc(n: usize, s: usize) -> *mut libc::c_void {\n    let total_size = n.checked_mul(s).expect(\"Overflow in allocation size\");\n    let mut allocation = vec![0u8; total_size];\n    let ptr = allocation.as_mut_ptr() as *mut libc::c_void;\n    std::mem::forget(allocation); // Prevent deallocation of the vector\n    ptr\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}\n#[no_mangle]\npub fn ximemdup(p: &[u8]) -> Vec<u8> {\n    let s = p.len();\n    let mut new_vec = vec![0u8; s];\n    new_vec.copy_from_slice(p);\n    new_vec\n}\n#[no_mangle]\npub fn ximemdup0(p: &[u8]) -> Vec<u8> {\n    let s = p.len();\n    let mut result = vec![0; s + 1]; // Allocate space for the data plus a null terminator\n    result[..s].copy_from_slice(p); // Copy the data\n    result[s] = 0; // Null terminate the result\n    result\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtoimax(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __base: libc::c_int,\n    ) -> intmax_t;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n}\npub type __intmax_t = libc::c_long;\npub type intmax_t = __intmax_t;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub const _ISspace: C2RustUnnamed = 8192;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xstrtoimax.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn bkm_scale(\n    mut x: *mut intmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: intmax_t = 0;\n    if if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { *x })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as intmax_t\n                    }) + scale_factor as libc::c_long\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (*x < -(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + -(1 as libc::c_int) as intmax_t\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as intmax_t / -scale_factor as libc::c_long\n                    }) <= -(1 as libc::c_int) as libc::c_long - *x) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n                        as libc::c_long + 0 as libc::c_int as intmax_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        *x\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < *x + 0 as libc::c_int as intmax_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < *x\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < *x - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as intmax_t / scale_factor as libc::c_long) < *x)\n                        as libc::c_int\n                }\n            }\n        } else {\n            if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    *x\n                                }) + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < scale_factor as libc::c_long\n                                    + 0 as libc::c_int as intmax_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_long)",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xstrtoimax.rs"
    },
    {
      "chunk": "                                as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as intmax_t / *x\n                            < scale_factor as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        < *x) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_long {\n            !if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n                -(1 as libc::c_int) as intmax_t\n            } else {\n                (((1 as libc::c_int as intmax_t)\n                    << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            }\n        } else if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n            -(1 as libc::c_int) as intmax_t\n        } else {\n            (((1 as libc::c_int as intmax_t)\n                << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}\nfn bkm_scale_by_power(\n    x: &mut i64, // Assuming intmax_t is equivalent to i64 in Rust\n    base: i32,\n    mut power: i32,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    while power > 0 {\n        power -= 1;\n        unsafe {\n            err |= bkm_scale(x, base);\n        }\n    }\n    err\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrtoimax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut intmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: intmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 78],\n                &[libc::c_char; 78],\n            >(\n                b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2247: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 78],\n                    &[libc::c_char; 78],\n                >(\n                    b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoimax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as intmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if !(*p).is_null() && **p != 0 {\n    let mut base: i32 = 1024;\n    let mut suffixes: i32 = 1;\n    let mut overflow: strtol_error = LONGINT_OK;\n\n    let valid_suffixes_str = unsafe { std::ffi::CStr::from_ptr(valid_suffixes).to_string_lossy() };\n    if !valid_suffixes_str.contains(**p as u8 as char) {\n        *val = tmp;\n        return (err | LONGINT_INVALID_SUFFIX_CHAR) as strtol_error;\n    }\n\n    match **p as u8 {\n        b'E' | b'G' | b'g' | b'k' | b'K' | b'M' | b'm' | b'P' | b'Q' | b'R' | b'T' | b't' | b'Y' | b'Z' => {\n            if valid_suffixes_str.contains('0') {\n                match unsafe { *(*p).offset(1) } as u8 {\n                    b'i' => {\n                        if unsafe { *(*p).offset(2) } as u8 == b'B' {\n                            suffixes += 2;\n                        }\n                    }\n                    b'B' | b'D' => {\n                        base = 1000;\n                        suffixes += 1;\n                    }\n                    _ => {}\n                }\n            }\n        }\n        _ => {}\n    }\n\n    match **p as u8 {\n        b'b' => {\n            overflow = bkm_scale(&mut tmp, 512);\n        }\n        b'B' => {\n            overflow = bkm_scale(&mut tmp, 1024);\n        }\n        b'c' => {\n            overflow = LONGINT_OK;\n        }\n        b'E' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 6);\n        }\n        b'G' | b'g' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 3);\n        }\n        b'k' | b'K' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 1);\n        }\n        b'M' | b'm' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 2);\n        }\n        b'P' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 5);\n        }\n        b'Q' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 10);\n        }\n        b'R' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 9);\n        }\n        b'T' | b't' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 4);\n        }\n        b'w' => {\n            overflow = bkm_scale(&mut tmp, 2);\n        }\n        b'Y' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 8);\n        }\n        b'Z' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 7);\n        }\n        _ => {\n            *val = tmp;\n            return (err | LONGINT_INVALID_SUFFIX_CHAR) as strtol_error;\n        }\n    }\n\n    err |= overflow as u32;\n    *p = unsafe { (*p).offset(suffixes as isize) };\n    if **p != 0 {\n        err |= LONGINT_INVALID_SUFFIX_CHAR as u32;\n    }\n}\n*val = tmp;\nreturn err;\n\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xstrtoimax.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtoumax(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __base: libc::c_int,\n    ) -> uintmax_t;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n}\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub const _ISspace: C2RustUnnamed = 8192;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xstrtoumax.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn bkm_scale(\n    mut x: *mut uintmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: uintmax_t = 0;\n    if if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t\n        && (if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_ulong } else { *x })\n            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n            < 0 as libc::c_int as libc::c_ulong\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_ulong {\n                if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        -(1 as libc::c_int) as uintmax_t\n                    })\n                        .wrapping_add(scale_factor as libc::c_ulong)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    (*x\n                        < (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(scale_factor as libc::c_ulong)) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(-(1 as libc::c_int) as uintmax_t)\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(-scale_factor as libc::c_ulong)\n                    }) <= (-(1 as libc::c_int) as libc::c_ulong).wrapping_sub(*x))\n                        as libc::c_int\n                }\n            } else {\n                let scale_factor_value = if scale_factor != 0 { scale_factor } else { 0 };\nlet x_value = *x;\n\nlet condition1 = (scale_factor_value as u64).wrapping_sub(1) < 0;\nlet condition2 = if condition1 {\n    !(scale_factor_value as u64)\n        .wrapping_add(1)\n        << ((std::mem::size_of::<u64>() * 8) as u64 - 2)\n        .wrapping_sub(1)\n        .wrapping_mul(2)\n        .wrapping_add(1)\n} else {\n    scale_factor_value as u64\n};\n\nlet result = if condition1 {\n    if (scale_factor_value as u64).wrapping_add(1) < 0 {\n        ((scale_factor_value as u64).wrapping_add(1)\n            << ((std::mem::size_of::<u64>() * 8) as u64 - 2))\n            .wrapping_sub(1)\n            .wrapping_mul(2)\n            .wrapping_add(1)\n    } else {\n        scale_factor_value as u64 - 1\n    }\n    .wrapping_neg() as i32\n} else {\n    (0u64 < scale_factor_value as u64) as i32\n};\n\nif result != 0 && scale_factor == -1 {\n    if x_value.wrapping_sub(1) < 0 {\n        (0u64 < x_value) as i32\n    } else {\n        (0u64 < x_value && (u64::MAX - 1) < x_value.wrapping_sub(1)) as i32\n    }\n} else {\n    (0u64.wrapping_div(scale_factor as u64) < x_value) as i32\n}\n\n            }\n        } else {\n            if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_ulong {\n                    if (if (if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        !((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                    }) < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                            < (if (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    *x\n                                })\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                < 0 as libc::c_int as libc::c_ulong\n                            {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                    << (::core::mem::size_of::<libc::c_ulong>()\n                                        as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            })\n                                .wrapping_neg()) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_ulong\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_ulong)\n                                < (scale_factor as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_ulong)\n                                as libc::c_int\n                        }\n                    } else {\n                        ((0 as libc::c_int as uintmax_t).wrapping_div(*x)\n                            < scale_factor as libc::c_ulong) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_ulong {\n            !if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n                -(1 as libc::c_int) as uintmax_t\n            } else {\n                ((1 as libc::c_int as uintmax_t)\n                    << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            }\n        } else if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n            -(1 as libc::c_int) as uintmax_t\n        } else {\n            ((1 as libc::c_int as uintmax_t)\n                << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xstrtoumax.rs"
    },
    {
      "chunk": "                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}\nfn bkm_scale_by_power(\n    x: &mut u64,\n    base: i32,\n    mut power: i32,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    while power > 0 {\n        power -= 1;\n        // Call to bkm_scale is unsafe, so we need to wrap it in an unsafe block\n        err = {\n            unsafe {\n                (err as u32 | bkm_scale(x, base) as u32) as strtol_error\n            }\n        };\n    }\n    err\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrtoumax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut uintmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: uintmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 79],\n                &[libc::c_char; 79],\n            >(\n                b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2256: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 79],\n                    &[libc::c_char; 79],\n                >(\n                    b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoumax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as uintmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if !(*p).is_null() && **p != 0 {\n    let mut base: i32 = 1024;\n    let mut suffixes: i32 = 1;\n    let mut overflow: strtol_error = LONGINT_OK;\n\n    let valid_suffixes_slice = std::ffi::CStr::from_ptr(valid_suffixes).to_str().unwrap();\n    if !valid_suffixes_slice.contains(&(**p as u8 as char).to_string()) {\n        *val = tmp;\n        return (err as u32 | LONGINT_INVALID_SUFFIX_CHAR) as strtol_error;\n    }\n\n    match **p as i32 {\n        69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n            if valid_suffixes_slice.contains('0') {\n                match *(*p).offset(1) as i32 {\n                    105 => {\n                        if *(*p).offset(2) as i32 == 'B' as i32 {\n                            suffixes += 2;\n                        }\n                    }\n                    66 | 68 => {\n                        base = 1000;\n                        suffixes += 1;\n                    }\n                    _ => {}\n                }\n            }\n        }\n        _ => {}\n    }\n\n    match **p as i32 {\n        98 => {\n            overflow = bkm_scale(&mut tmp, 512);\n        }\n        66 => {\n            overflow = bkm_scale(&mut tmp, 1024);\n        }\n        99 => {\n            overflow = LONGINT_OK;\n        }\n        69 => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 6);\n        }\n        71 | 103 => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 3);\n        }\n        107 | 75 => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 1);\n        }\n        77 | 109 => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 2);\n        }\n        80 => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 5);\n        }\n        81 => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 10);\n        }\n        82 => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 9);\n        }\n        84 | 116 => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 4);\n        }\n        119 => {\n            overflow = bkm_scale(&mut tmp, 2);\n        }\n        89 => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 8);\n        }\n        90 => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 7);\n        }\n        _ => {\n            *val = tmp;\n            return (err as u32 | LONGINT_INVALID_SUFFIX_CHAR) as strtol_error;\n        }\n    }\n\n    err = (err as u32 | overflow as u32) as strtol_error;\n    *p = (*p).offset(suffixes as isize);\n    if **p != 0 {\n        err = (err as u32 | LONGINT_INVALID_SUFFIX_CHAR) as strtol_error;\n    }\n}\n*val = tmp;\nreturn err;\n\n}",
      "file_name": "c2saferrust/coreutils/src\\split\\rust_WIP\\src\\xstrtoumax.rs"
    }
  ],
  "tail": [
    {
      "chunk": "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\build.rs"
    },
    {
      "chunk": "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(label_break_value)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod argmatch;\npub mod basename_lgpl;\npub mod binary_io;\npub mod bitrotate;\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod c_strtod;\npub mod cl_strtod;\npub mod close_stream;\npub mod closeout;\npub mod dirname_lgpl;\npub mod dtotimespec;\npub mod dup_safer;\npub mod exitfail;\npub mod fclose;\npub mod fcntl;\npub mod fd_safer;\npub mod fflush;\npub mod fpurge;\npub mod fseeko;\npub mod hard_locale;\npub mod hash;\npub mod ialloc;\npub mod iopoll;\npub mod isapipe;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod nanosleep;\npub mod offtostr;\npub mod open_safer;\npub mod posixver;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod safe_read;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod stat_time;\npub mod timespec;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalloc_die;\npub mod xbinary_io;\npub mod xdectoumax;\npub mod xmalloc;\npub mod xnanosleep;\npub mod xstrtod;\npub mod xstrtoumax;\n}\n// mod src",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\lib.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse std::os::raw::c_char;\nuse std::convert::TryInto;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stderr: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn putc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn quote_n(n: libc::c_int, arg: *const libc::c_char) -> *const libc::c_char;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn quotearg_n_style(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn usage(_e: libc::c_int);\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type argmatch_exit_fn = Option::<unsafe extern \"C\" fn() -> ()>\n;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\nunsafe extern \"C\" fn __argmatch_die() {\n    usage(1 as libc::c_int);\n}\n#[no_mangle]\npub static mut argmatch_die: argmatch_exit_fn = unsafe {\n    Some(__argmatch_die as unsafe extern \"C\" fn() -> ())\n};\n#[no_mangle]\npub fn argmatch(\n    arg: &str,\n    arglist: &[&str],\n    vallist: Option<&[u8]>,\n    valsize: usize,\n) -> isize {\n    let arglen = arg.len();\n    let mut matchind: isize = -1;\n    let mut ambiguous = false;\n\n    for (i, &arg_item) in arglist.iter().enumerate() {\n        if arg_item.starts_with(arg) {\n            if arg_item.len() == arglen {\n                return i as isize;\n            } else if matchind == -1 {\n                matchind = i as isize;\n            } else if let Some(vallist) = vallist {\n                if valsize * matchind as usize >= vallist.len() || valsize * i >= vallist.len() {\n                    ambiguous = true;\n                    break;\n                }\n                if &vallist[valsize * matchind as usize..valsize * matchind as usize + valsize] != \n                   &vallist[valsize * i..valsize * i + valsize] {\n                    ambiguous = true;\n                }\n            } else {\n                ambiguous = true;\n            }\n        }\n    }\n    if ambiguous {\n        -2\n    } else {\n        matchind\n    }\n}\n#[no_mangle]\npub fn argmatch_exact(\n    arg: &CStr,\n    arglist: &[&CStr],\n) -> isize {\n    for (i, item) in arglist.iter().enumerate() {\n        if item.to_bytes() == arg.to_bytes() {\n            return i as isize;\n        }\n    }\n    return -1;\n}\n#[no_mangle]\npub fn argmatch_invalid(\n    context: &str,\n    value: &str,\n    problem: isize,\n) {\n    let format = if problem == -1 {\n        unsafe { CStr::from_ptr(gettext(b\"invalid argument %s for %s\\0\".as_ptr() as *const c_char)).to_string_lossy().into_owned() }\n    } else {\n        unsafe { CStr::from_ptr(gettext(b\"ambiguous argument %s for %s\\0\".as_ptr() as *const c_char)).to_string_lossy().into_owned() }\n    };\n\n    let quoted_value = unsafe { quotearg_n_style(0, locale_quoting_style, value.as_ptr() as *const c_char) };\n    let quoted_context = unsafe { quote_n(1, context.as_ptr() as *const c_char) };\n\n    let errstatus: i32 = 0;\n    unsafe {\n        error(\n            errstatus,\n            0,\n            format.as_ptr() as *const c_char,\n            quoted_value,\n            quoted_context,\n        );\n    }\n\n    if errstatus != 0 {\n        unreachable!();\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch_valid(\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) {\n    let mut i: size_t = 0;\n    let mut last_val: *const libc::c_char = 0 as *const libc::c_char;\n    fputs_unlocked(\n        gettext(b\"Valid arguments are:\\0\" as *const u8 as *const libc::c_char),\n        stderr,\n    );\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if i == 0 as libc::c_int as libc::c_ulong\n            || memcmp(\n                last_val as *const libc::c_void,\n                (vallist as *const libc::c_char).offset(valsize.wrapping_mul(i) as isize)\n                    as *const libc::c_void,\n                valsize,\n            ) != 0\n        {\n            fprintf(\n                stderr,\n                b\"\\n  - %s\\0\" as *const u8 as *const libc::c_char,\n                quote(*arglist.offset(i as isize)),\n            );\n            last_val = (vallist as *const libc::c_char)\n                .offset(valsize.wrapping_mul(i) as isize);\n        } else {\n            fprintf(\n                stderr,\n                b\", %s\\0\" as *const u8 as *const libc::c_char,\n                quote(*arglist.offset(i as isize)),\n            );\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    putc_unlocked('\\n' as i32, stderr);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn __xargmatch_internal(\n    mut context: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n    mut exit_fn: argmatch_exit_fn,\n    mut allow_abbreviation: bool,\n) -> ptrdiff_t {\n    let mut res: ptrdiff_t = 0;\n    if allow_abbreviation {\n        let arg_str = unsafe { std::ffi::CStr::from_ptr(arg).to_string_lossy().into_owned() };\nlet arglist_slice: Vec<&str> = unsafe {\n    let mut vec = Vec::new();\n    let mut i = 0;\n    while !(*arglist.offset(i as isize)).is_null() {\n        vec.push(std::ffi::CStr::from_ptr(*arglist.offset(i as isize)).to_str().unwrap());\n        i += 1;\n    }\n    vec\n};\nlet res = argmatch(\n    &arg_str,\n    &arglist_slice,\n    if vallist.is_null() { None } else { Some(std::slice::from_raw_parts(vallist as *const u8, valsize as usize)) },\n    valsize as usize\n);\n    } else {\n        let arg_cstr = unsafe { CStr::from_ptr(arg) };\nlet arglist_slice: Vec<&CStr> = unsafe {\n    let mut vec = Vec::new();\n    let mut i = 0;\n    while !(*arglist.offset(i as isize)).is_null() {\n        vec.push(CStr::from_ptr(*arglist.offset(i as isize)));\n        i += 1;\n    }\n    vec\n};\nlet res = argmatch_exact(arg_cstr, &arglist_slice);\n    }\n    if res >= 0 as libc::c_int as libc::c_long {\n        return res;\n    }\n    let context_str = unsafe { CStr::from_ptr(context).to_string_lossy().into_owned() };\nlet arg_str = unsafe { CStr::from_ptr(arg).to_string_lossy().into_owned() };\nargmatch_invalid(&context_str, &arg_str, res.try_into().unwrap());\n    argmatch_valid(arglist, vallist, valsize);\n    (Some(exit_fn.expect(\"non-null function pointer\")))\n        .expect(\"non-null function pointer\")();\n    return -(1 as libc::c_int) as ptrdiff_t;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch_to_argument(\n    mut value: *const libc::c_void,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) -> *const libc::c_char {\n    let mut i: size_t = 0;\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if memcmp(\n            value,\n            (vallist as *const libc::c_char).offset(valsize.wrapping_mul(i) as isize)\n                as *const libc::c_void,\n            valsize,\n        ) == 0\n        {\n            return *arglist.offset(i as isize);\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as *const libc::c_char;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\argmatch.rs"
    },
    {
      "chunk": "use std::str;\nuse ::libc;\nextern \"C\" {\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn last_component(name: &str) -> &str {\n    let mut base = name.trim_start_matches('/');\n    let mut last_was_slash = false;\n\n    for (i, c) in base.char_indices() {\n        if c == '/' {\n            last_was_slash = true;\n        } else if last_was_slash {\n            base = &base[i..];\n            last_was_slash = false;\n        }\n    }\n\n    base\n}\n#[no_mangle]\npub fn base_len(name: &str, prefix_len: usize) -> usize {\n    let mut len = name.len();\n    \n    while len > 0 && name.as_bytes()[len - 1] == b'/' {\n        len -= 1;\n    }\n    \n    if len == 1 && name.as_bytes()[0] == b'/' && name.as_bytes().get(1) == Some(&b'/') && name.as_bytes().get(2).is_none() {\n        return 2;\n    }\n    \n    if len == prefix_len && name.as_bytes().get(prefix_len) == Some(&b'/') {\n        return prefix_len + 1;\n    }\n    \n    len\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\basename_lgpl.rs"
    },
    {
      "chunk": "use std::os::unix::io::AsRawFd;\nuse ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn set_binary_mode(fd: i32, mode: i32) -> i32 {\n    __gl_setmode(fd, mode)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn __gl_setmode(fd: i32, mode: i32) -> i32 {\n    0\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\binary_io.rs"
    },
    {
      "chunk": "use std::usize;\nuse std::num::Wrapping;\nuse std::convert::TryInto;\nuse ::libc;\npub type __uint8_t = libc::c_uchar;\npub type __uint16_t = libc::c_ushort;\npub type __uint32_t = libc::c_uint;\npub type __uint64_t = libc::c_ulong;\npub type uint8_t = __uint8_t;\npub type uint16_t = __uint16_t;\npub type uint32_t = __uint32_t;\npub type uint64_t = __uint64_t;\npub type size_t = libc::c_ulong;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn rotr8(x: u8, n: i32) -> u8 {\n    let n = n % 8; // Ensure n is within the range of 0-7\n    (x >> n) | (x << (8 - n))\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn rotl8(x: u8, n: i32) -> u8 {\n    let n = n % 8; // Ensure n is within the range of 0-7\n    (x << n | x >> (8 - n)) & 0xFF\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn rotr16(x: u16, n: i32) -> u16 {\n    let n = n % 16; // Ensure n is within the range of 0-15\n    (x >> n) | (x << (16 - n))\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn rotl16(x: u16, n: i32) -> u16 {\n    let n = n % 16; // Ensure n is within the range of 0-15\n    (x << n | x >> (16 - n)) & 0xFFFF\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn rotr_sz(x: usize, n: i32) -> usize {\n    let size_bits = 8 * std::mem::size_of::<usize>() as u32;\n    let n = n as u32 % size_bits; // Ensure n is within the bounds of size_bits\n    (x >> n) | (x << (size_bits - n))\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn rotl_sz(x: usize, n: i32) -> usize {\n    let bits = (usize::BITS as usize) - n as usize;\n    (x << n) | (x >> bits)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn rotr32(x: u32, n: i32) -> u32 {\n    let n = n as u32 % 32; // Ensure n is within the range of 0-31\n    (x >> n) | (x << (32 - n))\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn rotl32(x: u32, n: i32) -> u32 {\n    let n = n % 32; // Ensure n is within the range of 0-31\n    (x << n) | (x >> (32 - n))\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn rotr64(x: u64, n: i32) -> u64 {\n    let n = n % 64; // Ensure n is within the range of 0-63\n    (x >> n) | (x << (64 - n))\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn rotl64(x: u64, n: i32) -> u64 {\n    let n = n as u64 % 64; // Ensure n is within the range of 0-63\n    (x << n) | (x >> (64 - n))\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\bitrotate.rs"
    },
    {
      "chunk": "use std::ffi::CString;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub fn close_stdout_set_file_name(file: &str) {\n    let c_string = CString::new(file).unwrap();\n    unsafe {\n        file_name = c_string.into_raw();\n    }\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\npub fn close_stdout_set_ignore_EPIPE(ignore: bool) {\n    unsafe {\n        ignore_EPIPE = ignore;\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\closeout.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\close_stream.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn c_strtod(\n        nptr: *const libc::c_char,\n        endptr: *mut *mut libc::c_char,\n    ) -> libc::c_double;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn cl_strtod(\n    mut nptr: *const libc::c_char,\n    mut endptr: *mut *mut libc::c_char,\n) -> libc::c_double {\n    let mut end: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut d: libc::c_double = strtod(nptr, &mut end);\n    if *end != 0 {\n        let mut strtod_errno: libc::c_int = *__errno_location();\n        let mut c_end: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut c: libc::c_double = c_strtod(nptr, &mut c_end);\n        if end < c_end {\n            d = c;\n            end = c_end;\n        } else {\n            *__errno_location() = strtod_errno;\n        }\n    }\n    if !endptr.is_null() {\n        *endptr = end;\n    }\n    return d;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\cl_strtod.rs"
    },
    {
      "chunk": "use std::convert::TryFrom;\nuse std::char;\nuse std::ops::RangeInclusive;\nuse ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalnum(c: i32) -> bool {\n    match c {\n        48..=57 | 65..=90 | 97..=122 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalpha(c: i32) -> bool {\n    matches!(c, 97..=122 | 65..=90)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isascii(c: i32) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isblank(c: char) -> bool {\n    c == ' ' || c == '\\t'\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_iscntrl(c: i32) -> bool {\n    matches!(c, 0..=31 | 127)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isdigit(c: i32) -> bool {\n    matches!(c, 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isgraph(c: i32) -> bool {\n    matches!(c, \n        48..=57 | 97..=122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 |\n        58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | \n        65..=90\n    )\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_islower(c: char) -> bool {\n    c.is_lowercase()\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isprint(c: i32) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_ispunct(c: i32) -> bool {\n    match c as u8 {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isspace(c: i32) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isupper(c: i32) -> bool {\n    matches!(c, 65..=90)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isxdigit(c: i32) -> bool {\n    matches!(c, 48..=57 | 97..=102 | 65..=70)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_tolower(c: i32) -> i32 {\n    if (65..=90).contains(&c) {\n        return c - ('A' as i32 - 'a' as i32);\n    }\n    c\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_toupper(c: i32) -> i32 {\n    if let Some(ch) = char::from_u32(c as u32) {\n        if ch.is_ascii_lowercase() {\n            return ch.to_ascii_uppercase() as i32;\n        }\n    }\n    c\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\c_ctype.rs"
    },
    {
      "chunk": "use std::char;\nuse ::libc;\n#[inline]\nfn c_tolower(c: i32) -> i32 {\n    match c {\n        65..=90 => c - 'A' as i32 + 'a' as i32,\n        _ => c,\n    }\n}\n#[no_mangle]\npub fn c_strcasecmp(s1: &str, s2: &str) -> libc::c_int {\n    let c1 = s1.chars().map(|c| c_tolower(c as i32) as u8);\n    let c2 = s2.chars().map(|c| c_tolower(c as i32) as u8);\n    \n    for (ch1, ch2) in c1.zip(c2) {\n        if ch1 != ch2 {\n            return ch1 as libc::c_int - ch2 as libc::c_int;\n        }\n    }\n    \n    // If one string is a prefix of the other, we need to compare their lengths\n    if s1.len() != s2.len() {\n        return s1.len() as libc::c_int - s2.len() as libc::c_int;\n    }\n    \n    0\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\c_strcasecmp.rs"
    },
    {
      "chunk": "use std::ffi::{CString, CStr};\nuse ::libc;\nextern \"C\" {\n    pub type __locale_data;\n    fn newlocale(\n        __category_mask: libc::c_int,\n        __locale: *const libc::c_char,\n        __base: locale_t,\n    ) -> locale_t;\n    fn strtod_l(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __loc: locale_t,\n    ) -> libc::c_double;\n}\npub type locale_t = __locale_t;\npub type __locale_t = *mut __locale_struct;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __locale_struct {\n    pub __locales: [*mut __locale_data; 13],\n    pub __ctype_b: *const libc::c_ushort,\n    pub __ctype_tolower: *const libc::c_int,\n    pub __ctype_toupper: *const libc::c_int,\n    pub __names: [*const libc::c_char; 13],\n}\nstatic mut c_locale_cache: locale_t = 0 as *const __locale_struct\n    as *mut __locale_struct;\nfn c_locale() -> locale_t {\n    use std::sync::{Once, Mutex};\n\n    static INIT: Once = Once::new();\n    static mut c_locale_cache: Option<locale_t> = None;\n    static CACHE_LOCK: Mutex<()> = Mutex::new(());\n\n    INIT.call_once(|| {\n        let _lock = CACHE_LOCK.lock().unwrap();\n        unsafe {\n            c_locale_cache = Some(newlocale(\n                (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 7) | (1 << 8) | (1 << 9) | (1 << 10) | (1 << 11),\n                b\"C\\0\".as_ptr() as *const libc::c_char,\n                0 as locale_t,\n            ));\n        }\n    });\n\n    let _lock = CACHE_LOCK.lock().unwrap();\n    unsafe { c_locale_cache.unwrap() }\n}\n#[no_mangle]\npub fn c_strtod<'a>(\n    nptr: &'a str,\n    endptr: &mut Option<&'a str>,\n) -> f64 {\n    let locale = c_locale();\n    if locale.is_null() {\n        *endptr = Some(nptr);\n        return 0.0;\n    }\n    \n    let c_str = std::ffi::CString::new(nptr).unwrap();\n    let mut end: *mut libc::c_char = std::ptr::null_mut();\n    let r = unsafe { strtod_l(c_str.as_ptr(), &mut end, locale) };\n    \n    if endptr.is_some() {\n        *endptr = unsafe { Some(std::ffi::CStr::from_ptr(end).to_str().unwrap()) };\n    }\n    \n    r\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\c_strtod.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn last_component(filename: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn dir_len(mut file: *const libc::c_char) -> size_t {\n    let mut prefix_length: size_t = 0 as libc::c_int as size_t;\n    let mut length: size_t = 0;\n    prefix_length = (prefix_length as libc::c_ulong)\n        .wrapping_add(\n            (if prefix_length != 0 as libc::c_int as libc::c_ulong {\n                (0 as libc::c_int != 0\n                    && *file.offset(prefix_length as isize) as libc::c_int == '/' as i32)\n                    as libc::c_int\n            } else if *file.offset(0 as libc::c_int as isize) as libc::c_int\n                == '/' as i32\n            {\n                if 0 as libc::c_int != 0\n                    && *file.offset(1 as libc::c_int as isize) as libc::c_int\n                        == '/' as i32\n                    && !(*file.offset(2 as libc::c_int as isize) as libc::c_int\n                        == '/' as i32)\n                {\n                    2 as libc::c_int\n                } else {\n                    1 as libc::c_int\n                }\n            } else {\n                0 as libc::c_int\n            }) as libc::c_ulong,\n        ) as size_t as size_t;\n    length = (last_component(file)).offset_from(file) as libc::c_long as size_t;\n    while prefix_length < length {\n        if !(*file\n            .offset(length.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_int == '/' as i32)\n        {\n            break;\n        }\n        length = length.wrapping_sub(1);\n        length;\n    }\n    return length;\n}\n#[no_mangle]\npub fn mdir_name(file: *const libc::c_char) -> Option<String> {\n    unsafe {\n        let length = dir_len(file) as usize;\n        let append_dot = length == 0 || (length == 0 && *file.offset(2) != 0 && *file.offset(2) != b'/' as i8);\n\n        let mut dir = String::with_capacity(length + if append_dot { 1 } else { 0 } + 1);\n        dir.push_str(std::ffi::CStr::from_ptr(file).to_str().unwrap());\n        \n        if append_dot {\n            dir.push('.');\n        }\n        \n        dir.push('\\0'); // This is just to mimic the C-style string termination, but in Rust, it's not necessary.\n        \n        Some(dir)\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\dirname_lgpl.rs"
    },
    {
      "chunk": "use ::libc;\npub type __time_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\npub type time_t = __time_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub type C2RustUnnamed = libc::c_uint;\npub const TIMESPEC_HZ: C2RustUnnamed = 1000000000;\n#[inline]\nunsafe extern \"C\" fn make_timespec(mut s: time_t, mut ns: libc::c_long) -> timespec {\n    return {\n        let mut init = timespec { tv_sec: s, tv_nsec: ns };\n        init\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn dtotimespec(mut sec: libc::c_double) -> timespec {\n    if !((!(if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n        -(1 as libc::c_int) as time_t\n    } else {\n        (((1 as libc::c_int as time_t)\n            << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n            - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n            + 1 as libc::c_int as libc::c_long\n    }) as libc::c_double) < sec)\n    {\n        return make_timespec(\n            !if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n                -(1 as libc::c_int) as time_t\n            } else {\n                (((1 as libc::c_int as time_t)\n                    << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            },\n            0 as libc::c_int as libc::c_long,\n        )\n    } else if !(sec\n        < 1.0f64\n            + (if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n                -(1 as libc::c_int) as time_t\n            } else {\n                (((1 as libc::c_int as time_t)\n                    << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            }) as libc::c_double)\n    {\n        return make_timespec(\n            if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n                -(1 as libc::c_int) as time_t\n            } else {\n                (((1 as libc::c_int as time_t)\n                    << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            },\n            (TIMESPEC_HZ as libc::c_int - 1 as libc::c_int) as libc::c_long,\n        )\n    } else {\n        let mut s: time_t = sec as time_t;\n        let mut frac: libc::c_double = TIMESPEC_HZ as libc::c_int as libc::c_double\n            * (sec - s as libc::c_double);\n        let mut ns: libc::c_long = frac as libc::c_long;\n        ns += ((ns as libc::c_double) < frac) as libc::c_int as libc::c_long;\n        s += ns / TIMESPEC_HZ as libc::c_int as libc::c_long;\n        ns %= TIMESPEC_HZ as libc::c_int as libc::c_long;\n        if ns < 0 as libc::c_int as libc::c_long {\n            s -= 1;\n            s;\n            ns += TIMESPEC_HZ as libc::c_int as libc::c_long;\n        }\n        return make_timespec(s, ns);\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\dtotimespec.rs"
    },
    {
      "chunk": "use std::os::unix::io::FromRawFd;\nuse ::libc;\nextern \"C\" {\n    fn rpl_fcntl(fd: libc::c_int, action: libc::c_int, _: ...) -> libc::c_int;\n}\n#[no_mangle]\npub fn dup_safer(fd: i32) -> i32 {\n    use std::os::unix::io::AsRawFd;\n    use std::os::unix::net::UnixStream;\n\n    let stream = unsafe { UnixStream::from_raw_fd(fd) };\n    let new_fd = stream.as_raw_fd();\n    std::mem::forget(stream); // Prevent the stream from closing the fd\n    return new_fd;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\dup_safer.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\exitfail.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn rpl_fclose(fp: &mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0;\n    \n    // Unsafe block for operations that require raw pointers or FFI\n    let fd = unsafe { fileno(fp) };\n    \n    if fd < 0 {\n        return unsafe { fclose(fp) };\n    }\n    \n    let is_reading = unsafe { __freading(fp) != 0 };\n    let seek_result = unsafe { lseek(fd, 0, libc::SEEK_CUR) };\n    \n    if (!is_reading || seek_result == -1) && unsafe { rpl_fflush(fp) } != 0 {\n        saved_errno = unsafe { *__errno_location() };\n    }\n    \n    let result = unsafe { fclose(fp) };\n    \n    if saved_errno != 0 {\n        unsafe { *__errno_location() = saved_errno };\n        return -1;\n    }\n    \n    result\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\fclose.rs"
    },
    {
      "chunk": "use std::ffi::VaList;\nuse ::libc;\nextern \"C\" {\n    fn fcntl(__fd: libc::c_int, __cmd: libc::c_int, _: ...) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\n#[no_mangle]\npub fn rpl_fcntl(\n    fd: libc::c_int,\n    action: libc::c_int,\n    args: &mut std::ffi::VaList,\n) -> libc::c_int {\n    let mut result: libc::c_int = -1;\n\n    match action {\n        0 => {\n            let target: libc::c_int = unsafe { args.arg::<libc::c_int>() };\n            result = rpl_fcntl_DUPFD(fd, target);\n        }\n        1030 => {\n            let target: libc::c_int = unsafe { args.arg::<libc::c_int>() };\n            result = rpl_fcntl_DUPFD_CLOEXEC(fd, target);\n        }\n        _ => {\n            match action {\n                1 | 3 => {\n                    result = unsafe { fcntl(fd, action) };\n                }\n                1025 => {\n                    let p: *mut libc::c_void = unsafe { args.arg::<*mut libc::c_void>() };\n                    result = unsafe { fcntl(fd, action, p) };\n                }\n                9 | 1032 | 1034 | 11 | 1033 => {\n                    result = unsafe { fcntl(fd, action) };\n                }\n                1026 | 2 | 4 | 8 | 1031 | 1024 | 10 => {\n                    let x: libc::c_int = unsafe { args.arg::<libc::c_int>() };\n                    result = unsafe { fcntl(fd, action, x) };\n                }\n                _ => {\n                    result = unsafe { fcntl(fd, action) };\n                }\n            }\n        }\n    }\n    result\n}\nfn rpl_fcntl_DUPFD(fd: i32, target: i32) -> i32 {\n    unsafe {\n        fcntl(fd, libc::F_DUPFD, target)\n    }\n}\nstatic mut have_dupfd_cloexec: libc::c_int = 0;\nfn rpl_fcntl_DUPFD_CLOEXEC(fd: libc::c_int, target: libc::c_int) -> libc::c_int {\n    static mut HAVE_DUPFD_CLOEXEC: libc::c_int = 0;\n    let mut result: libc::c_int;\n\n    unsafe {\n        if HAVE_DUPFD_CLOEXEC <= 0 {\n            result = fcntl(fd, 1030, target);\n            if result >= 0 || *libc::__errno_location() != 22 {\n                HAVE_DUPFD_CLOEXEC = 1;\n            } else {\n                result = rpl_fcntl_DUPFD(fd, target);\n                if result >= 0 {\n                    HAVE_DUPFD_CLOEXEC = -1;\n                }\n            }\n        } else {\n            result = rpl_fcntl_DUPFD(fd, target);\n        }\n\n        if result >= 0 && HAVE_DUPFD_CLOEXEC == -1 {\n            let flags = fcntl(result, 1);\n            if flags < 0 || fcntl(result, 2, flags | 1) == -1 {\n                let saved_errno = *libc::__errno_location();\n                close(result);\n                *libc::__errno_location() = saved_errno;\n                result = -1;\n            }\n        }\n    }\n    result\n}\nunsafe extern \"C\" fn run_static_initializers() {\n    have_dupfd_cloexec = if 0 != 0 {\n        -(1)\n    } else {\n        0\n    };\n}\n#[used]\n#[cfg_attr(target_os = \"linux\", link_section = \".init_array\")]\n#[cfg_attr(target_os = \"windows\", link_section = \".CRT$XIB\")]\n#[cfg_attr(target_os = \"macos\", link_section = \"__DATA,__mod_init_func\")]\nstatic INIT_ARRAY: [unsafe extern \"C\" fn(); 1] = [run_static_initializers];",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\fcntl.rs"
    },
    {
      "chunk": "use libc::c_int;\nuse ::libc;\nextern \"C\" {\n    fn dup_safer(_: libc::c_int) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n}\n#[no_mangle]\npub fn fd_safer(fd: i32) -> i32 {\n    if (0..=2).contains(&fd) {\n        let f = unsafe { dup_safer(fd) };\n        unsafe { close(fd) };\n        return f;\n    }\n    fd\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\fd_safer.rs"
    },
    {
      "chunk": "use std::ptr;\nuse std::option::Option;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nfn clear_ungetc_buffer_preserving_position(fp: *mut FILE) {\n    unsafe {\n        if (*fp)._flags & 0x100 != 0 {\n            rpl_fseeko(fp, 0, 1);\n        }\n    }\n}\n#[no_mangle]\npub fn rpl_fflush(stream: Option<&mut FILE>) -> libc::c_int {\n    if let Some(s) = stream {\n        if unsafe { __freading(s) != 0 } {\n            unsafe { clear_ungetc_buffer_preserving_position(s) };\n        }\n        return unsafe { fflush(s) };\n    }\n    unsafe { fflush(std::ptr::null_mut()) }\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\fflush.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __fpurge(__fp: *mut FILE);\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn fpurge(fp: *mut _IO_FILE) -> libc::c_int {\n    unsafe {\n        __fpurge(fp);\n    }\n    0\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\fpurge.rs"
    },
    {
      "chunk": "use std::os::raw::c_int;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub fn rpl_fseeko(\n    fp: &mut FILE,\n    offset: off_t,\n    whence: libc::c_int,\n) -> libc::c_int {\n    if fp._IO_read_end == fp._IO_read_ptr\n        && fp._IO_write_ptr == fp._IO_write_base && fp._IO_save_base.is_null()\n    {\n        let pos: off_t;\n        unsafe {\n            pos = lseek(fileno(fp), offset, whence);\n        }\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        fp._flags &= !(0x10 as libc::c_int);\n        fp._offset = pos;\n        return 0 as libc::c_int;\n    }\n    unsafe {\n        return fseeko(fp, offset, whence);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\fseeko.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn hard_locale(category: libc::c_int) -> bool {\n    let mut locale = [0; 257];\n    \n    unsafe {\n        let result = setlocale_null_r(category, locale.as_mut_ptr(), locale.len() as u64);\n        \n        if result != 0 {\n            return false;\n        }\n\n        let locale_str = std::ffi::CStr::from_ptr(locale.as_ptr()).to_string_lossy().into_owned();\n        \n        if locale_str == \"C\" || locale_str == \"POSIX\" {\n            return false;\n        }\n    }\n    \n    true\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\hard_locale.rs"
    },
    {
      "chunk": "use std::sync::atomic::{AtomicPtr, Ordering};\nuse std::option::Option;\nuse std::str;\nuse std::boxed::Box;\nuse std::ptr;\nuse std::process;\nuse std::mem;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct hash_tuning {\n    pub shrink_threshold: libc::c_float,\n    pub shrink_factor: libc::c_float,\n    pub growth_threshold: libc::c_float,\n    pub growth_factor: libc::c_float,\n    pub is_n_buckets: bool,\n}\npub type Hash_tuning = hash_tuning;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct hash_table {\n    pub bucket: *mut hash_entry,\n    pub bucket_limit: *const hash_entry,\n    pub n_buckets: size_t,\n    pub n_buckets_used: size_t,\n    pub n_entries: size_t,\n    pub tuning: *const Hash_tuning,\n    pub hasher: Hash_hasher,\n    pub comparator: Hash_comparator,\n    pub data_freer: Hash_data_freer,\n    pub free_entry_list: *mut hash_entry,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct hash_entry {\n    pub data: *mut libc::c_void,\n    pub next: *mut hash_entry,\n}\npub type Hash_data_freer = Option::<unsafe extern \"C\" fn(*mut libc::c_void) -> ()>\n;\npub type Hash_comparator = Option::<\n    unsafe extern \"C\" fn(*const libc::c_void, *const libc::c_void) -> bool,\n>\n;\npub type Hash_hasher = Option::<\n    unsafe extern \"C\" fn(*const libc::c_void, size_t) -> size_t,\n>\n;\npub type Hash_table = hash_table;\npub type Hash_processor = Option::<\n    unsafe extern \"C\" fn(*mut libc::c_void, *mut libc::c_void) -> bool,\n>;\n#[inline]\nfn rotr_sz(x: u64, n: i32) -> u64 {\n    let size_bits = (std::mem::size_of::<u64>() * 8) as u32;\n    let n = n as u32 % size_bits; // Ensure n is within the bounds of size_bits\n    (x >> n) | (x << (size_bits - n))\n}\nstatic mut default_tuning: Hash_tuning = {\n    let mut init = hash_tuning {\n        shrink_threshold: 0.0f32,\n        shrink_factor: 1.0f32,\n        growth_threshold: 0.8f32,\n        growth_factor: 1.414f32,\n        is_n_buckets: 0 as libc::c_int != 0,\n    };\n    init\n};\n#[no_mangle]\npub fn hash_get_n_buckets(table: &Hash_table) -> usize {\n    table.n_buckets as usize\n}\n#[no_mangle]\nuse std::convert::TryInto;\npub fn hash_get_n_buckets_used(table: &Hash_table) -> usize {\n    table.n_buckets_used.try_into().unwrap()\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_get_n_entries(mut table: *const Hash_table) -> size_t {\n    return (*table).n_entries;\n}\n#[no_mangle]\npub fn hash_get_max_bucket_length(table: &Hash_table) -> usize {\n    let mut max_bucket_length: usize = 0;\n    let bucket_limit = table.bucket_limit as usize;\n    let buckets = unsafe { std::slice::from_raw_parts(table.bucket, bucket_limit) };\n    \n    for bucket in buckets {\n        if !bucket.data.is_null() {\n            let mut cursor: *const hash_entry = bucket;\n            let mut bucket_length: usize = 1;\n            loop {\n                cursor = unsafe { (*cursor).next };\n                if cursor.is_null() {\n                    break;\n                }\n                bucket_length += 1;\n            }\n            if bucket_length > max_bucket_length {\n                max_bucket_length = bucket_length;\n            }\n        }\n    }\n    max_bucket_length\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_table_ok(mut table: *const Hash_table) -> bool {\n    let mut bucket: *const hash_entry = 0 as *const hash_entry;\n    let mut n_buckets_used: size_t = 0 as libc::c_int as size_t;\n    let mut n_entries: size_t = 0 as libc::c_int as size_t;\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit {\n        if !((*bucket).data).is_null() {\n            let mut cursor: *const hash_entry = bucket;\n            n_buckets_used = n_buckets_used.wrapping_add(1);\n            n_buckets_used;\n            n_entries = n_entries.wrapping_add(1);\n            n_entries;\n            loop {\n                cursor = (*cursor).next;\n                if cursor.is_null() {\n                    break;\n                }\n                n_entries = n_entries.wrapping_add(1);\n                n_entries;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    if n_buckets_used == (*table).n_buckets_used && n_entries == (*table).n_entries {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}\n#[no_mangle]\npub fn hash_print_statistics(\n    table: &Hash_table,\n    stream: &mut dyn std::io::Write,\n) {\n    let n_entries: usize = unsafe { hash_get_n_entries(table) }.try_into().unwrap();\n    let n_buckets: usize = unsafe { hash_get_n_buckets(table) }.try_into().unwrap();\n    let n_buckets_used: usize = unsafe { hash_get_n_buckets_used(table) }.try_into().unwrap();\n    let max_bucket_length: usize = unsafe { hash_get_max_bucket_length(table) }.try_into().unwrap();\n    \n    writeln!(stream, \"# entries:         {}\", n_entries).unwrap();\n    writeln!(stream, \"# buckets:         {}\", n_buckets).unwrap();\n    writeln!(stream, \"# buckets used:    {} ( {:.2}%)\", n_buckets_used, 100.0 * n_buckets_used as f64 / n_buckets as f64).unwrap();\n    writeln!(stream, \"max bucket length: {}\", max_bucket_length).unwrap();\n}\nunsafe extern \"C\" fn safe_hasher(\n    mut table: *const Hash_table,\n    mut key: *const libc::c_void,\n) -> *mut hash_entry {\n    let mut n: size_t = ((*table).hasher)\n        .expect(\"non-null function pointer\")(key, (*table).n_buckets);\n    if !(n < (*table).n_buckets) {\n        abort();\n    }\n    return ((*table).bucket).offset(n as isize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_lookup(\n    mut table: *const Hash_table,\n    mut entry: *const libc::c_void,\n) -> *mut libc::c_void {\n    let mut bucket: *const hash_entry = safe_hasher(table, entry);\n    let mut cursor: *const hash_entry = 0 as *const hash_entry;\n    if ((*bucket).data).is_null() {\n        return 0 as *mut libc::c_void;\n    }\n    cursor = bucket;\n    while !cursor.is_null() {\n        if entry == (*cursor).data as *const libc::c_void\n            || ((*table).comparator)\n                .expect(\"non-null function pointer\")(entry, (*cursor).data)\n                as libc::c_int != 0\n        {\n            return (*cursor).data;\n        }\n        cursor = (*cursor).next;\n    }\n    return 0 as *mut libc::c_void;\n}\n#[no_mangle]\npub fn hash_get_first(table: &Hash_table) -> Option<&libc::c_void> {\n    if table.n_entries == 0 {\n        return None;\n    }\n    \n    let mut bucket = table.bucket as *const hash_entry;\n    while bucket < table.bucket_limit as *const hash_entry {\n        if let Some(data) = unsafe { (*bucket).data.as_ref() } {\n            return Some(data);\n        }\n        unsafe {\n            bucket = bucket.add(1);\n        }\n    }\n    \n    None\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_get_next(\n    mut table: *const Hash_table,\n    mut entry: *const libc::c_void,\n) -> *mut libc::c_void {\n    let mut bucket: *const hash_entry = safe_hasher(table, entry);\n    let mut cursor: *const hash_entry = 0 as *const hash_entry;\n    cursor = bucket;\n    loop {\n        if (*cursor).data == entry as *mut libc::c_void && !((*cursor).next).is_null() {\n            return (*(*cursor).next).data;\n        }\n        cursor = (*cursor).next;\n        if cursor.is_null() {\n            break;\n        }\n    }\n    loop {\n        bucket = bucket.offset(1);\n        if !(bucket < (*table).bucket_limit) {\n            break;\n        }\n        if !((*bucket).data).is_null() {\n            return (*bucket).data;\n        }\n    }\n    return 0 as *mut libc::c_void;\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\hash.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn hash_get_entries(\n    mut table: *const Hash_table,\n    mut buffer: *mut *mut libc::c_void,\n    mut buffer_size: size_t,\n) -> size_t {\n    let mut counter: size_t = 0 as libc::c_int as size_t;\n    let mut bucket: *const hash_entry = 0 as *const hash_entry;\n    let mut cursor: *const hash_entry = 0 as *const hash_entry;\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit {\n        if !((*bucket).data).is_null() {\n            cursor = bucket;\n            while !cursor.is_null() {\n                if counter >= buffer_size {\n                    return counter;\n                }\n                let fresh0 = counter;\n                counter = counter.wrapping_add(1);\n                let ref mut fresh1 = *buffer.offset(fresh0 as isize);\n                *fresh1 = (*cursor).data;\n                cursor = (*cursor).next;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    return counter;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_do_for_each(\n    mut table: *const Hash_table,\n    mut processor: Hash_processor,\n    mut processor_data: *mut libc::c_void,\n) -> size_t {\n    let mut counter: size_t = 0 as libc::c_int as size_t;\n    let mut bucket: *const hash_entry = 0 as *const hash_entry;\n    let mut cursor: *const hash_entry = 0 as *const hash_entry;\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit {\n        if !((*bucket).data).is_null() {\n            cursor = bucket;\n            while !cursor.is_null() {\n                if !processor\n                    .expect(\"non-null function pointer\")((*cursor).data, processor_data)\n                {\n                    return counter;\n                }\n                counter = counter.wrapping_add(1);\n                counter;\n                cursor = (*cursor).next;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    return counter;\n}\n#[no_mangle]\npub fn hash_string(string: &str, n_buckets: usize) -> usize {\n    let mut value: usize = 0;\n    for ch in string.chars() {\n        value = value\n            .wrapping_mul(31)\n            .wrapping_add(ch as usize)\n            .wrapping_rem(n_buckets);\n    }\n    value\n}\nfn is_prime(mut candidate: u64) -> bool {\n    if candidate < 2 {\n        return false;\n    }\n    if candidate == 2 {\n        return true;\n    }\n    if candidate % 2 == 0 {\n        return false;\n    }\n\n    let mut divisor: u64 = 3;\n    while divisor * divisor <= candidate {\n        if candidate % divisor == 0 {\n            return false;\n        }\n        divisor += 2; // Only check odd divisors\n    }\n    true\n}\nfn next_prime(mut candidate: u64) -> u64 {\n    if candidate < 10 {\n        candidate = 10;\n    }\n    candidate |= 1; // Ensure candidate is odd\n    while candidate != u64::MAX && !unsafe { is_prime(candidate) } {\n        candidate += 2; // Increment by 2 to check the next odd number\n    }\n    candidate\n}\n#[no_mangle]\npub fn hash_reset_tuning(tuning: &mut Hash_tuning) {\n    *tuning = unsafe { default_tuning };\n}\nunsafe extern \"C\" fn raw_hasher(mut data: *const libc::c_void, mut n: size_t) -> size_t {\n    let val: u64 = rotr_sz(data as u64, 3);\n    return val.wrapping_rem(n);\n}\nunsafe extern \"C\" fn raw_comparator(\n    a: *const libc::c_void,\n    b: *const libc::c_void,\n) -> bool {\n    a == b\n}\nunsafe extern \"C\" fn check_tuning(mut table: *mut Hash_table) -> bool {\n    let mut tuning: *const Hash_tuning = (*table).tuning;\n    let mut epsilon: libc::c_float = 0.;\n    if tuning == &default_tuning as *const Hash_tuning {\n        return 1 as libc::c_int != 0;\n    }\n    epsilon = 0.1f32;\n    if epsilon < (*tuning).growth_threshold\n        && (*tuning).growth_threshold < 1 as libc::c_int as libc::c_float - epsilon\n        && 1 as libc::c_int as libc::c_float + epsilon < (*tuning).growth_factor\n        && 0 as libc::c_int as libc::c_float <= (*tuning).shrink_threshold\n        && (*tuning).shrink_threshold + epsilon < (*tuning).shrink_factor\n        && (*tuning).shrink_factor <= 1 as libc::c_int as libc::c_float\n        && (*tuning).shrink_threshold + epsilon < (*tuning).growth_threshold\n    {\n        return 1 as libc::c_int != 0;\n    }\n    (*table).tuning = &default_tuning;\n    return 0 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn compute_bucket_size(\n    mut candidate: size_t,\n    mut tuning: *const Hash_tuning,\n) -> size_t {\n    let mut current_block: u64;\n    if !(*tuning).is_n_buckets {\n        let mut new_candidate: libc::c_float = candidate as libc::c_float\n            / (*tuning).growth_threshold;\n        if 18446744073709551615 as libc::c_ulong as libc::c_float <= new_candidate {\n            current_block = 8933918830699217881;\n        } else {\n            candidate = new_candidate as size_t;\n            current_block = 12675440807659640239;\n        }\n    } else {\n        current_block = 12675440807659640239;\n    }\n    match current_block {\n        12675440807659640239 => {\n            candidate = next_prime(candidate.try_into().unwrap());\n            if !(::core::mem::size_of::<*mut hash_entry>() as libc::c_ulong\n                != 0 as libc::c_int as libc::c_ulong\n                && (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n                    < 18446744073709551615 as libc::c_ulong\n                {\n                    9223372036854775807 as libc::c_long as libc::c_ulong\n                } else {\n                    (18446744073709551615 as libc::c_ulong)\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                })\n                    .wrapping_div(\n                        ::core::mem::size_of::<*mut hash_entry>() as libc::c_ulong,\n                    ) < candidate)\n            {\n                return candidate;\n            }\n        }\n        _ => {}\n    }\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as libc::c_int as size_t;\n}\n#[no_mangle]\npub fn hash_initialize(\n    candidate: usize,\n    tuning: Option<&Hash_tuning>,\n    hasher: Option<Hash_hasher>,\n    comparator: Option<Hash_comparator>,\n    data_freer: Hash_data_freer,\n) -> Option<Box<Hash_table>> {\n    let mut table = Box::new(Hash_table {\n        tuning: tuning.unwrap_or_else(|| unsafe { &default_tuning }),\n        n_buckets: 0,\n        bucket: std::ptr::null_mut(),\n        bucket_limit: std::ptr::null_mut(),\n        n_buckets_used: 0,\n        n_entries: 0,\n        hasher: hasher.unwrap_or(Some(raw_hasher)),\n        comparator: comparator.unwrap_or(Some(raw_comparator)),\n        data_freer,\n        free_entry_list: std::ptr::null_mut(),\n    });\n\n    if !unsafe { check_tuning(&mut *table) } {\n        std::process::exit(22);\n    }\n\n    table.n_buckets = unsafe { compute_bucket_size(candidate.try_into().unwrap(), table.tuning) };\n    if table.n_buckets == 0 {\n        return None;\n    }\n\n    let bucket_size = table.n_buckets.try_into().unwrap();\n    table.bucket = unsafe {\n        libc::calloc(bucket_size, std::mem::size_of::<hash_entry>()) as *mut hash_entry\n    };\n\n    if table.bucket.is_null() {\n        return None;\n    }\n\n    table.bucket_limit = unsafe { table.bucket.add(bucket_size) };\n\n    Some(table)\n}\n#[no_mangle]\npub fn hash_clear(table: &mut Hash_table) {\n    let bucket_limit = table.bucket_limit as usize;\n    for i in 0..bucket_limit {\n        let bucket = unsafe { &mut *table.bucket.add(i) };\n        if !bucket.data.is_null() {\n            if let Some(data_freer) = table.data_freer {\n                unsafe {\n                    data_freer(bucket.data);\n                }\n            }\n            let mut cursor = unsafe { bucket.next };\n            while !cursor.is_null() {\n                let next_cursor = unsafe { &mut *cursor };\n                if let Some(data_freer) = table.data_freer {\n                    unsafe {\n                        data_freer(next_cursor.data);\n                    }\n                }\n                cursor = next_cursor.next;\n                next_cursor.next = table.free_entry_list;\n                table.free_entry_list = next_cursor as *mut _;\n            }\n            if let Some(data_freer) = table.data_freer {\n                unsafe {\n                    data_freer(bucket.data);\n                }\n            }\n            bucket.data = std::ptr::null_mut();\n            bucket.next = std::ptr::null_mut();\n        }\n    }\n    table.n_buckets_used = 0;\n    table.n_entries = 0;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_free(mut table: *mut Hash_table) {\n    let mut bucket: *mut hash_entry = 0 as *mut hash_entry;\n    let mut cursor: *mut hash_entry = 0 as *mut hash_entry;\n    let mut next: *mut hash_entry = 0 as *mut hash_entry;\n    let mut err: libc::c_int = *__errno_location();\n    if ((*table).data_freer).is_some() && (*table).n_entries != 0 {\n        bucket = (*table).bucket;\n        while bucket < (*table).bucket_limit as *mut hash_entry {\n            if !((*bucket).data).is_null() {\n                cursor = bucket;\n                while !cursor.is_null() {\n                    ((*table).data_freer)\n                        .expect(\"non-null function pointer\")((*cursor).data);\n                    cursor = (*cursor).next;\n                }\n            }\n            bucket = bucket.offset(1);\n            bucket;\n        }\n    }\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit as *mut hash_entry {\n        cursor = (*bucket).next;\n        while !cursor.is_null() {\n            next = (*cursor).next;\n            free(cursor as *mut libc::c_void);\n            cursor = next;\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    cursor = (*table).free_entry_list;\n    while !cursor.is_null() {\n        next = (*cursor).next;\n        free(cursor as *mut libc::c_void);\n        cursor = next;\n    }\n    free((*table).bucket as *mut libc::c_void);\n    free(table as *mut libc::c_void);\n    *__errno_location() = err;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\hash.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn allocate_entry(mut table: *mut Hash_table) -> *mut hash_entry {\n    let mut new: *mut hash_entry = 0 as *mut hash_entry;\n    if !((*table).free_entry_list).is_null() {\n        new = (*table).free_entry_list;\n        (*table).free_entry_list = (*new).next;\n    } else {\n        new = malloc(::core::mem::size_of::<hash_entry>() as libc::c_ulong)\n            as *mut hash_entry;\n    }\n    return new;\n}\nunsafe extern \"C\" fn free_entry(mut table: *mut Hash_table, mut entry: *mut hash_entry) {\n    (*entry).data = 0 as *mut libc::c_void;\n    (*entry).next = (*table).free_entry_list;\n    (*table).free_entry_list = entry;\n}\nunsafe extern \"C\" fn hash_find_entry(\n    mut table: *mut Hash_table,\n    mut entry: *const libc::c_void,\n    mut bucket_head: *mut *mut hash_entry,\n    mut delete: bool,\n) -> *mut libc::c_void {\n    let mut bucket: *mut hash_entry = safe_hasher(table, entry);\n    let mut cursor: *mut hash_entry = 0 as *mut hash_entry;\n    *bucket_head = bucket;\n    if ((*bucket).data).is_null() {\n        return 0 as *mut libc::c_void;\n    }\n    if entry == (*bucket).data as *const libc::c_void\n        || ((*table).comparator)\n            .expect(\"non-null function pointer\")(entry, (*bucket).data) as libc::c_int\n            != 0\n    {\n        let mut data: *mut libc::c_void = (*bucket).data;\n        if delete {\n            if !((*bucket).next).is_null() {\n                let mut next: *mut hash_entry = (*bucket).next;\n                *bucket = *next;\n                free_entry(table, next);\n            } else {\n                (*bucket).data = 0 as *mut libc::c_void;\n            }\n        }\n        return data;\n    }\n    cursor = bucket;\n    while !((*cursor).next).is_null() {\n        if entry == (*(*cursor).next).data as *const libc::c_void\n            || ((*table).comparator)\n                .expect(\"non-null function pointer\")(entry, (*(*cursor).next).data)\n                as libc::c_int != 0\n        {\n            let mut data_0: *mut libc::c_void = (*(*cursor).next).data;\n            if delete {\n                let mut next_0: *mut hash_entry = (*cursor).next;\n                (*cursor).next = (*next_0).next;\n                free_entry(table, next_0);\n            }\n            return data_0;\n        }\n        cursor = (*cursor).next;\n    }\n    return 0 as *mut libc::c_void;\n}\nunsafe extern \"C\" fn transfer_entries(\n    mut dst: *mut Hash_table,\n    mut src: *mut Hash_table,\n    mut safe: bool,\n) -> bool {\n    let mut bucket: *mut hash_entry = 0 as *mut hash_entry;\n    let mut cursor: *mut hash_entry = 0 as *mut hash_entry;\n    let mut next: *mut hash_entry = 0 as *mut hash_entry;\n    bucket = (*src).bucket;\n    while bucket < (*src).bucket_limit as *mut hash_entry {\n        if !((*bucket).data).is_null() {\n            let mut data: *mut libc::c_void = 0 as *mut libc::c_void;\n            let mut new_bucket: *mut hash_entry = 0 as *mut hash_entry;\n            cursor = (*bucket).next;\n            while !cursor.is_null() {\n                data = (*cursor).data;\n                new_bucket = safe_hasher(dst, data);\n                next = (*cursor).next;\n                if !((*new_bucket).data).is_null() {\n                    (*cursor).next = (*new_bucket).next;\n                    (*new_bucket).next = cursor;\n                } else {\n                    (*new_bucket).data = data;\n                    (*dst).n_buckets_used = ((*dst).n_buckets_used).wrapping_add(1);\n                    (*dst).n_buckets_used;\n                    free_entry(dst, cursor);\n                }\n                cursor = next;\n            }\n            data = (*bucket).data;\n            (*bucket).next = 0 as *mut hash_entry;\n            if !safe {\n                new_bucket = safe_hasher(dst, data);\n                if !((*new_bucket).data).is_null() {\n                    let mut new_entry: *mut hash_entry = allocate_entry(dst);\n                    if new_entry.is_null() {\n                        return 0 as libc::c_int != 0;\n                    }\n                    (*new_entry).data = data;\n                    (*new_entry).next = (*new_bucket).next;\n                    (*new_bucket).next = new_entry;\n                } else {\n                    (*new_bucket).data = data;\n                    (*dst).n_buckets_used = ((*dst).n_buckets_used).wrapping_add(1);\n                    (*dst).n_buckets_used;\n                }\n                (*bucket).data = 0 as *mut libc::c_void;\n                (*src).n_buckets_used = ((*src).n_buckets_used).wrapping_sub(1);\n                (*src).n_buckets_used;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    return 1 as libc::c_int != 0;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_rehash(\n    mut table: *mut Hash_table,\n    mut candidate: size_t,\n) -> bool {\n    let mut storage: Hash_table = Hash_table {\n        bucket: 0 as *mut hash_entry,\n        bucket_limit: 0 as *const hash_entry,\n        n_buckets: 0,\n        n_buckets_used: 0,\n        n_entries: 0,\n        tuning: 0 as *const Hash_tuning,\n        hasher: None,\n        comparator: None,\n        data_freer: None,\n        free_entry_list: 0 as *mut hash_entry,\n    };\n    let mut new_table: *mut Hash_table = 0 as *mut Hash_table;\n    let mut new_size: size_t = compute_bucket_size(candidate, (*table).tuning);\n    if new_size == 0 {\n        return 0 as libc::c_int != 0;\n    }\n    if new_size == (*table).n_buckets {\n        return 1 as libc::c_int != 0;\n    }\n    new_table = &mut storage;\n    (*new_table)\n        .bucket = calloc(new_size, ::core::mem::size_of::<hash_entry>() as libc::c_ulong)\n        as *mut hash_entry;\n    if ((*new_table).bucket).is_null() {\n        return 0 as libc::c_int != 0;\n    }\n    (*new_table).n_buckets = new_size;\n    (*new_table).bucket_limit = ((*new_table).bucket).offset(new_size as isize);\n    (*new_table).n_buckets_used = 0 as libc::c_int as size_t;\n    (*new_table).n_entries = 0 as libc::c_int as size_t;\n    (*new_table).tuning = (*table).tuning;\n    (*new_table).hasher = (*table).hasher;\n    (*new_table).comparator = (*table).comparator;\n    (*new_table).data_freer = (*table).data_freer;\n    (*new_table).free_entry_list = (*table).free_entry_list;\n    if transfer_entries(new_table, table, 0 as libc::c_int != 0) {\n        free((*table).bucket as *mut libc::c_void);\n        (*table).bucket = (*new_table).bucket;\n        (*table).bucket_limit = (*new_table).bucket_limit;\n        (*table).n_buckets = (*new_table).n_buckets;\n        (*table).n_buckets_used = (*new_table).n_buckets_used;\n        (*table).free_entry_list = (*new_table).free_entry_list;\n        return 1 as libc::c_int != 0;\n    }\n    let mut err: libc::c_int = *__errno_location();\n    (*table).free_entry_list = (*new_table).free_entry_list;\n    if !(transfer_entries(table, new_table, 1 as libc::c_int != 0) as libc::c_int != 0\n        && transfer_entries(table, new_table, 0 as libc::c_int != 0) as libc::c_int != 0)\n    {\n        abort();\n    }\n    free((*new_table).bucket as *mut libc::c_void);\n    *__errno_location() = err;\n    return 0 as libc::c_int != 0;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_insert_if_absent(\n    mut table: *mut Hash_table,\n    mut entry: *const libc::c_void,\n    mut matched_ent: *mut *const libc::c_void,\n) -> libc::c_int {\n    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;\n    let mut bucket: *mut hash_entry = 0 as *mut hash_entry;\n    if entry.is_null() {\n        abort();\n    }\n    data = hash_find_entry(table, entry, &mut bucket, 0 as libc::c_int != 0);\n    if !data.is_null() {\n        if !matched_ent.is_null() {\n            *matched_ent = data;\n        }\n        return 0 as libc::c_int;\n    }\n    if (*table).n_buckets_used as libc::c_float\n        > (*(*table).tuning).growth_threshold * (*table).n_buckets as libc::c_float\n    {\n        check_tuning(table);\n        if (*table).n_buckets_used as libc::c_float\n            > (*(*table).tuning).growth_threshold * (*table).n_buckets as libc::c_float\n        {\n            let mut tuning: *const Hash_tuning = (*table).tuning;\n            let mut candidate: libc::c_float = if (*tuning).is_n_buckets as libc::c_int\n                != 0\n            {\n                (*table).n_buckets as libc::c_float * (*tuning).growth_factor\n            } else {\n                (*table).n_buckets as libc::c_float * (*tuning).growth_factor\n                    * (*tuning).growth_threshold\n            };\n            if 18446744073709551615 as libc::c_ulong as libc::c_float <= candidate {\n                *__errno_location() = 12 as libc::c_int;\n                return -(1 as libc::c_int);\n            }\n            if !hash_rehash(table, candidate as size_t) {\n                return -(1 as libc::c_int);\n            }\n            if !(hash_find_entry(table, entry, &mut bucket, 0 as libc::c_int != 0))\n                .is_null()\n            {\n                abort();\n            }\n        }\n    }\n    if !((*bucket).data).is_null() {\n        let mut new_entry: *mut hash_entry = allocate_entry(table);\n        if new_entry.is_null() {\n            return -(1 as libc::c_int);\n        }\n        (*new_entry).data = entry as *mut libc::c_void;\n        (*new_entry).next = (*bucket).next;\n        (*bucket).next = new_entry;\n        (*table).n_entries = ((*table).n_entries).wrapping_add(1);\n        (*table).n_entries;\n        return 1 as libc::c_int;\n    }\n    (*bucket).data = entry as *mut libc::c_void;\n    (*table).n_entries = ((*table).n_entries).wrapping_add(1);\n    (*table).n_entries;\n    (*table).n_buckets_used = ((*table).n_buckets_used).wrapping_add(1);\n    (*table).n_buckets_used;\n    return 1 as libc::c_int;\n}\n#[no_mangle]\npub fn hash_insert(\n    table: &mut Hash_table,\n    entry: &libc::c_void,\n) -> Option<*const libc::c_void> {\n    let mut matched_ent: *const libc::c_void = std::ptr::null();\n    \n    unsafe {\n        let err = hash_insert_if_absent(table, entry, &mut matched_ent);\n        \n        if err == -1 {\n            None\n        } else {\n            Some(if err == 0 { matched_ent } else { entry })\n        }\n    }\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\hash.rs"
    },
    {
      "chunk": "pub fn hash_remove(\n    table: &mut Hash_table,\n    entry: *const libc::c_void,\n) -> *mut libc::c_void {\n    let mut data: *mut libc::c_void;\n    let mut bucket: *mut hash_entry = std::ptr::null_mut();\n\n    unsafe {\n        data = hash_find_entry(table, entry, &mut bucket, true);\n        if data.is_null() {\n            return std::ptr::null_mut();\n        }\n\n        table.n_entries = table.n_entries.wrapping_sub(1);\n        \n        if (*bucket).data.is_null() {\n            table.n_buckets_used = table.n_buckets_used.wrapping_sub(1);\n            \n            if (table.n_buckets_used as f32) < (unsafe { (*table.tuning).shrink_threshold } * table.n_buckets as f32) {\n                check_tuning(table);\n                if (table.n_buckets_used as f32) < (unsafe { (*table.tuning).shrink_threshold } * table.n_buckets as f32) {\n                    let tuning = unsafe { &*table.tuning };\n                    let candidate: usize = if tuning.is_n_buckets {\n                        (table.n_buckets as f32 * tuning.shrink_factor) as usize\n                    } else {\n                        (table.n_buckets as f32 * tuning.shrink_factor * tuning.growth_threshold) as usize\n                    };\n                    \n                    if !hash_rehash(table, candidate.try_into().unwrap()) {\n                        let mut cursor = table.free_entry_list;\n                        while !cursor.is_null() {\n                            let next = unsafe { (*cursor).next };\n                            free(cursor as *mut libc::c_void);\n                            cursor = next;\n                        }\n                        table.free_entry_list = std::ptr::null_mut();\n                    }\n                }\n            }\n        }\n    }\n    data\n}\n#[no_mangle]\npub fn hash_delete(\n    table: &mut Hash_table,\n    entry: &libc::c_void,\n) -> *mut libc::c_void {\n    hash_remove(table, entry)\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\hash.rs"
    },
    {
      "chunk": "use std::alloc::Layout;\nuse std::option::Option;\nuse std::vec::Vec;\nuse ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn icalloc(n: usize, s: usize) -> Option<Vec<u8>> {\n    if n > usize::MAX / s {\n        if s != 0 {\n            return None; // Equivalent to _gl_alloc_nomem()\n        }\n        return Some(Vec::new()); // Return an empty Vec\n    }\n    if s > usize::MAX / n {\n        if n != 0 {\n            return None; // Equivalent to _gl_alloc_nomem()\n        }\n        return Some(Vec::new()); // Return an empty Vec\n    }\n    let total_size = n * s;\n    Some(vec![0u8; total_size]) // Allocate and initialize the Vec with zeroes\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn irealloc(p: Option<&mut [u8]>, s: usize) -> Option<Vec<u8>> {\n    if s <= usize::MAX {\n        let new_size = if s == 0 { 0 } else { s };\n        let mut vec = p.map(|slice| Vec::from(slice)).unwrap_or_else(Vec::new);\n        vec.resize(new_size, 0);\n        Some(vec)\n    } else {\n        None\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn imalloc(s: idx_t) -> Option<Vec<u8>> {\n    if s as usize <= usize::MAX {\n        let vec = Vec::with_capacity(s as usize);\n        Some(vec)\n    } else {\n        None\n    }\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\ialloc.rs"
    },
    {
      "chunk": "use std::os::unix::io::AsRawFd;\nuse std::os::unix::io::RawFd;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n    fn poll(__fds: *mut pollfd, __nfds: nfds_t, __timeout: libc::c_int) -> libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn fwrite_unlocked(\n        __ptr: *const libc::c_void,\n        __size: size_t,\n        __n: size_t,\n        __stream: *mut FILE,\n    ) -> size_t;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn isapipe(fd: libc::c_int) -> libc::c_int;\n}\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __ssize_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub type nfds_t = libc::c_ulong;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct pollfd {\n    pub fd: libc::c_int,\n    pub events: libc::c_short,\n    pub revents: libc::c_short,\n}\npub type ssize_t = __ssize_t;\npub type size_t = libc::c_ulong;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\nfn iopoll_internal(\n    fdin: i32,\n    fdout: i32,\n    block: bool,\n    broken_output: bool,\n) -> i32 {\n    assert!(fdin != -1 || fdout != -1, \"fdin != -1 || fdout != -1\");\n\n    let mut pfds: [libc::pollfd; 2] = [\n        libc::pollfd {\n            fd: fdin,\n            events: (libc::POLLIN | libc::POLLOUT) as libc::c_short,\n            revents: 0,\n        },\n        libc::pollfd {\n            fd: fdout,\n            events: libc::POLLOUT as libc::c_short,\n            revents: 0,\n        },\n    ];\n\n    let mut check_out_events = libc::POLLERR | libc::POLLHUP | libc::POLLNVAL;\n    let mut ret: i32;\n\n    if !broken_output {\n        pfds[1].events = libc::POLLERR as libc::c_short;\n        pfds[0].events = pfds[1].events;\n        check_out_events = libc::POLLERR;\n    }\n\n    loop {\n        ret = unsafe {\n            libc::poll(\n                pfds.as_mut_ptr(),\n                pfds.len() as libc::c_ulong,\n                if block { -1 } else { 0 },\n            )\n        };\n\n        if ret < 0 {\n            continue;\n        }\n        if ret == 0 && !block {\n            return 0;\n        }\n        assert!(ret > 0, \"0 < ret\");\n\n        if pfds[0].revents != 0 {\n            return 0;\n        }\n        if (pfds[1].revents as i32) & (check_out_events as i32) != 0 {\n            return if broken_output { -2 } else { 0 };\n        }\n    }\n}\n#[no_mangle]\npub fn iopoll(\n    fdin: i32,\n    fdout: i32,\n    block: bool,\n) -> i32 {\n    iopoll_internal(fdin, fdout, block, true)\n}\n#[no_mangle]\npub fn iopoll_input_ok(fdin: libc::c_int) -> bool {\n    let mut st: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n\n    // Use an unsafe block to call the unsafe function\n    let always_ready = unsafe {\n        fstat(fdin, &mut st) == 0 && \n        (st.st_mode & 0o170000 as libc::c_int as libc::c_uint == 0o100000 as libc::c_int as libc::c_uint ||\n         st.st_mode & 0o170000 as libc::c_int as libc::c_uint == 0o60000 as libc::c_int as libc::c_uint)\n    };\n\n    !always_ready\n}\n#[no_mangle]\npub fn iopoll_output_ok(fdout: RawFd) -> bool {\n    unsafe { isapipe(fdout) > 0 }\n}\nfn fwait_for_nonblocking_write(f: *mut FILE) -> bool {\n    unsafe {\n        if !(*__errno_location() == 11 || *__errno_location() == 11) {\n            return false;\n        }\n        let fd: libc::c_int = fileno(f);\n        if fd != -1 {\n            if iopoll_internal(-1, fd, true, false) == 0 {\n                clearerr_unlocked(f);\n                return true;\n            }\n        }\n        *__errno_location() = 11;\n        return false;\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn fclose_wait(mut f: *mut FILE) -> bool {\n    while !(fflush_unlocked(f) == 0 as libc::c_int) {\n        if !fwait_for_nonblocking_write(f) {\n            break;\n        }\n    }\n    return rpl_fclose(f) == 0 as libc::c_int;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn fwrite_wait(\n    mut buf: *const libc::c_char,\n    mut size: ssize_t,\n    mut f: *mut FILE,\n) -> bool {\n    loop {\n        let written: size_t = fwrite_unlocked(\n            buf as *const libc::c_void,\n            1 as libc::c_int as size_t,\n            size as size_t,\n            f,\n        );\n        size = (size as libc::c_ulong).wrapping_sub(written) as ssize_t as ssize_t;\n        if size >= 0 as libc::c_int as libc::c_long {} else {\n            __assert_fail(\n                b\"size >= 0\\0\" as *const u8 as *const libc::c_char,\n                b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n                230 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 49],\n                    &[libc::c_char; 49],\n                >(b\"_Bool fwrite_wait(const char *, ssize_t, FILE *)\\0\"))\n                    .as_ptr(),\n            );\n        }\n        'c_7276: {\n            if size >= 0 as libc::c_int as libc::c_long {} else {\n                __assert_fail(\n                    b\"size >= 0\\0\" as *const u8 as *const libc::c_char,\n                    b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n                    230 as libc::c_int as libc::c_uint,\n                    (*::core::mem::transmute::<\n                        &[u8; 49],\n                        &[libc::c_char; 49],\n                    >(b\"_Bool fwrite_wait(const char *, ssize_t, FILE *)\\0\"))\n                        .as_ptr(),\n                );\n            }\n        };\n        if size <= 0 as libc::c_int as libc::c_long {\n            return 1 as libc::c_int != 0;\n        }\n        if !fwait_for_nonblocking_write(f) {\n            return 0 as libc::c_int != 0;\n        }\n        buf = buf.offset(written as isize);\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\iopoll.rs"
    },
    {
      "chunk": "use std::mem;\nuse ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn pipe(__pipedes: *mut libc::c_int) -> libc::c_int;\n}\npub type __mode_t = libc::c_uint;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub type __syscall_slong_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blkcnt_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __off_t = libc::c_long;\npub type __dev_t = libc::c_ulong;\npub type __gid_t = libc::c_uint;\npub type __uid_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type nlink_t = __nlink_t;\n#[no_mangle]\npub fn isapipe(fd: libc::c_int) -> libc::c_int {\n    let mut pipe_link_count_max: nlink_t = 1;\n    let mut check_for_fifo: bool = true;\n    let mut st: stat = unsafe { std::mem::zeroed() }; // Using zeroed to initialize stat\n\n    let fstat_result = unsafe { fstat(fd, &mut st) };\n    if fstat_result != 0 {\n        return fstat_result;\n    }\n\n    if !((true || true) && 1u32 != !0) \n        && (st.st_mode & 0o170000 == 0o10000 || st.st_mode & 0o170000 == 0o14000) {\n        \n        let mut fd_pair: [libc::c_int; 2] = [0; 2];\n        let pipe_result = unsafe { pipe(fd_pair.as_mut_ptr()) };\n        if pipe_result != 0 {\n            return pipe_result;\n        }\n\n        let mut pipe_st: stat = unsafe { std::mem::zeroed() };\n        let fstat_pipe_result = unsafe { fstat(fd_pair[0], &mut pipe_st) };\n        let fstat_pipe_errno = unsafe { *__errno_location() };\n        unsafe {\n            close(fd_pair[0]);\n            close(fd_pair[1]);\n        }\n\n        if fstat_pipe_result != 0 {\n            unsafe {\n                *__errno_location() = fstat_pipe_errno;\n            }\n            return fstat_pipe_result;\n        }\n\n        check_for_fifo = (pipe_st.st_mode & 0o170000 == 0o10000);\n        pipe_link_count_max = pipe_st.st_nlink;\n    }\n\n    return (st.st_nlink <= pipe_link_count_max\n        && if check_for_fifo {\n            st.st_mode & 0o170000 == 0o10000\n        } else {\n            st.st_mode & 0o170000 == 0o14000\n        }) as libc::c_int;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\isapipe.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;\npub const _NL_WAM_STR: C2RustUnnamed = 131162;",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "pub const _NL_WMON_12: C2RustUnnamed = 131161;\npub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub fn locale_charset() -> String {\n    let codeset_ptr: *const libc::c_char = unsafe { nl_langinfo(CODESET as libc::c_int) };\n    let codeset = unsafe { CStr::from_ptr(codeset_ptr) };\n    \n    if codeset.to_bytes().is_empty() {\n        return \"ASCII\".to_string();\n    }\n    \n    codeset.to_string_lossy().into_owned()\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nfn mbszero(ps: &mut mbstate_t) {\n    let size = std::mem::size_of::<mbstate_t>();\n    let bytes: &mut [u8] = unsafe { std::slice::from_raw_parts_mut(ps as *mut _ as *mut u8, size) };\n    bytes.fill(0);\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(&mut *ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\mbrtoc32.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\mbszero.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn nanosleep(\n        __requested_time: *const timespec,\n        __remaining: *mut timespec,\n    ) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type __time_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\npub type time_t = __time_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub const BILLION: C2RustUnnamed = 1000000000;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_nanosleep(\n    mut requested_delay: *const timespec,\n    mut remaining_delay: *mut timespec,\n) -> libc::c_int {\n    if (*requested_delay).tv_nsec < 0 as libc::c_int as libc::c_long\n        || BILLION as libc::c_int as libc::c_long <= (*requested_delay).tv_nsec\n    {\n        *__errno_location() = 22 as libc::c_int;\n        return -(1 as libc::c_int);\n    }\n    let limit: time_t = (24 as libc::c_int * 24 as libc::c_int * 60 as libc::c_int\n        * 60 as libc::c_int) as time_t;\n    let mut seconds: time_t = (*requested_delay).tv_sec;\n    let mut intermediate: timespec = *requested_delay;\n    while limit < seconds {\n        let mut result: libc::c_int = 0;\n        intermediate.tv_sec = limit;\n        result = nanosleep(&mut intermediate, remaining_delay);\n        seconds -= limit;\n        if result != 0 {\n            if !remaining_delay.is_null() {\n                (*remaining_delay).tv_sec += seconds;\n            }\n            return result;\n        }\n        intermediate.tv_nsec = 0 as libc::c_int as __syscall_slong_t;\n    }\n    intermediate.tv_sec = seconds;\n    return nanosleep(&mut intermediate, remaining_delay);\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\nanosleep.rs"
    },
    {
      "chunk": "use std::os::raw::c_char;\nuse ::libc;\npub type __off_t = libc::c_long;\npub type off_t = __off_t;\n#[no_mangle]\npub fn offtostr(i: off_t, buf: &mut [libc::c_char]) -> &mut [libc::c_char] {\n    let mut p = buf.len() as isize - 1;\n    buf[p as usize] = 0;\n\n    let mut num = i;\n    if num < 0 {\n        num = -num;\n        loop {\n            p -= 1;\n            buf[p as usize] = ('0' as i32 - (num % 10) as i32) as libc::c_char;\n            num /= 10;\n            if num == 0 {\n                break;\n            }\n        }\n        p -= 1;\n        buf[p as usize] = '-' as libc::c_char;\n    } else {\n        loop {\n            p -= 1;\n            buf[p as usize] = ('0' as i32 + (num % 10) as i32) as libc::c_char;\n            num /= 10;\n            if num == 0 {\n                break;\n            }\n        }\n    }\n    &mut buf[p as usize..]\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\offtostr.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn fd_safer(_: libc::c_int) -> libc::c_int;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type __mode_t = libc::c_uint;\npub type mode_t = __mode_t;\npub type va_list = __builtin_va_list;\n#[no_mangle]\npub unsafe extern \"C\" fn open_safer(\n    mut file: *const libc::c_char,\n    mut flags: libc::c_int,\n    mut args: ...\n) -> libc::c_int {\n    let mut mode: mode_t = 0 as libc::c_int as mode_t;\n    if flags & 0o100 as libc::c_int != 0 {\n        let mut ap: ::core::ffi::VaListImpl;\n        ap = args.clone();\n        mode = ap.arg::<mode_t>();\n    }\n    return fd_safer(open(file, flags, mode));\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\open_safer.rs"
    },
    {
      "chunk": "use std::env;\nuse ::libc;\nextern \"C\" {\n    fn strtol(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n    ) -> libc::c_long;\n    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub fn posix2_version() -> libc::c_int {\n    let mut v: libc::c_long = 200809;\n    if let Ok(s) = std::env::var(\"_POSIX2_VERSION\") {\n        if let Ok(i) = s.parse::<libc::c_long>() {\n            v = i;\n        }\n    }\n    return (if v < (-(2147483647) - 1) {\n        (-(2147483647) - 1) as libc::c_long\n    } else if v < 2147483647 {\n        v\n    } else {\n        2147483647\n    }) as libc::c_int;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\posixver.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse std::process;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub fn set_program_name(argv0: *const libc::c_char) {\n    if argv0.is_null() {\n        eprintln!(\"A NULL argv[0] was passed through an exec system call.\");\n        std::process::abort();\n    }\n\n    let c_str = unsafe { std::ffi::CStr::from_ptr(argv0) };\n    let argv0_str = c_str.to_string_lossy();\n    \n    let slash = argv0_str.rfind('/').map(|index| &argv0_str[index + 1..]).unwrap_or(&argv0_str);\n    \n    if slash.len() >= 7 && &slash[slash.len() - 7..] == \"/.libs/\" {\n        let base = &slash[1..];\n        if base.starts_with(\"lt-\") {\n            unsafe {\n                program_invocation_short_name = base[3..].as_ptr() as *mut libc::c_char;\n            }\n        }\n        unsafe {\n            program_name = base.as_ptr() as *const libc::c_char;\n            program_invocation_name = base.as_ptr() as *mut libc::c_char;\n        }\n    } else {\n        unsafe {\n            program_name = argv0;\n            program_invocation_name = argv0 as *mut libc::c_char;\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\progname.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\propername_lite.rs"
    },
    {
      "chunk": "use std::clone::Clone;\nuse std::os::raw::c_int;\nuse std::option::Option;\nuse std::convert::TryInto;\nuse std::ffi::CStr;\nuse std::ffi::CString;\nuse std::os::raw::c_char;\nuse ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nfn c32isprint(wc: wint_t) -> libc::c_int {\n    unsafe { iswprint(wc) }\n}\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub fn clone_quoting_options(o: Option<&quoting_options>) -> Option<Box<quoting_options>> {\n    let options = match o {\n        Some(ref opt) => opt,\n        None => unsafe { &default_quoting_options },\n    };\n    let cloned_options = options.clone();\n    Some(Box::new(cloned_options))\n}\n#[no_mangle]\npub fn get_quoting_style(o: Option<&quoting_options>) -> quoting_style {\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &default_quoting_options },\n    };\n    options.style\n}\n#[no_mangle]\npub fn set_quoting_style(\n    o: Option<&mut quoting_options>,\n    s: quoting_style,\n) {\n    if let Some(options) = o {\n        options.style = s;\n    } else {\n        // Safe access to the mutable static\n        unsafe {\n            default_quoting_options.style = s;\n        }\n    }\n}\n#[no_mangle]\npub fn set_char_quoting(\n    o: Option<&mut quoting_options>,\n    c: char,\n    i: i32,\n) -> i32 {\n    let uc: u8 = c as u8;\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &mut default_quoting_options },\n    };\n    let index = (uc as usize) / (std::mem::size_of::<u32>() * 8);\n    let shift = (uc as usize) % (std::mem::size_of::<u32>() * 8);\n    \n    let p = &mut options.quote_these_too[index];\n    let r = (*p >> shift) & 1;\n    *p ^= ((i & 1 ^ r as i32) << shift) as u32;\n    \n    r as i32\n}\n#[no_mangle]\npub fn set_quoting_flags(\n    o: Option<&mut quoting_options>,\n    i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    let options: &mut quoting_options;\n\n    if let Some(opt) = o {\n        options = opt;\n    } else {\n        unsafe {\n            options = &mut default_quoting_options;\n        }\n    }\n\n    r = options.flags;\n    options.flags = i;\n    r\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}\nfn quoting_options_from_style(style: quoting_style) -> quoting_options {\n    let mut o = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: std::ptr::null(),\n        right_quote: std::ptr::null(),\n    };\n\n    if style == custom_quoting_style {\n        panic!(\"Custom quoting style is not allowed\");\n    }\n\n    o.style = style;\n    o\n}\nfn gettext_quote(msgid: &str, s: quoting_style) -> String {\n    let translation = unsafe { std::ffi::CStr::from_ptr(gettext(msgid.as_ptr() as *const libc::c_char)) }\n        .to_string_lossy()\n        .into_owned();\n    let locale_code = unsafe { std::ffi::CStr::from_ptr(locale_charset()) }\n        .to_string_lossy()\n        .into_owned();\n    \n    if translation != msgid {\n        return translation;\n    }\n    \n    unsafe {\n        if c_strcasecmp(locale_code.as_ptr() as *const libc::c_char, b\"UTF-8\\0\".as_ptr() as *const libc::c_char) == 0 {\n            return if msgid.chars().next() == Some('`') {\n                \"\\u{2018}\".to_string() // Left single quotation mark\n            } else {\n                \"\\u{2019}\".to_string() // Right single quotation mark\n            };\n        }\n        \n        if c_strcasecmp(locale_code.as_ptr() as *const libc::c_char, b\"GB18030\\0\".as_ptr() as *const libc::c_char) == 0 {\n            return if msgid.chars().next() == Some('`') {\n                \"\\u{A1E7}\".to_string() // Specific character for GB18030\n            } else {\n                \"\\u{A1AF}\".to_string() // Specific character for GB18030\n            };\n        }\n    }\n    \n    if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        return \"\\\"\".to_string();\n    } else {\n        return \"'\".to_string();\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    let left_quote = gettext_quote(\"`\", quoting_style);\n                    let right_quote = gettext_quote(\"'\", quoting_style);\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: u8 = 0;\nlet mut esc: u8 = 0;\nlet mut is_right_quote: bool = false;\nlet mut escaping: bool = false;\nlet mut c_and_shell_quote_compat: bool = false;\n\nlet arg_slice = unsafe { std::slice::from_raw_parts(arg as *const u8, argsize as usize) };\n\nif backslash_escapes\n    && quoting_style != shell_always_quoting_style\n    && quote_string_len != 0\n    && i + quote_string_len <= if argsize == u64::MAX && 1 < quote_string_len {\n        argsize = arg_slice.len() as u64;\n        argsize\n    } else {\n        argsize\n    }\n    && &arg_slice[i as usize..(i + quote_string_len) as usize] == unsafe { std::slice::from_raw_parts(quote_string as *const u8, quote_string_len as usize) }\n{\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    is_right_quote = true;\n}\n\nc = arg_slice[i as usize];\n\nmatch c {\n    0 => {\n         if backslash_escapes {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    escaping = true;\n    if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '$' as i8; }\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n        }\n        len += 1;\n        pending_shell_escape_end = true;\n    }\n    if len < buffersize {\n        unsafe { *buffer.offset(len as isize) = '\\\\' as i8; }\n    }\n    len += 1;\n    if quoting_style != shell_always_quoting_style\n        && i + 1 < argsize\n        && ('0' as i8 <= unsafe { *arg.offset((i + 1) as isize) } && unsafe { *arg.offset((i + 1) as isize) } <= '9' as i8)\n    {\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '0' as i8; }\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '0' as i8; }\n        }\n        len += 1;\n    }\n    c = '0' as u8;\n    current_block = 253337042034819032;\n} else if flags & QA_ELIDE_NULL_BYTES as i32 != 0 {\n    current_block = 13619784596304402172;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n    63 => {\n         match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n\n    }\n    7 => {\n        esc = 'a' as u8;\n        current_block = 1190876092451756080;\n    }\n    8 => {\n        esc = 'b' as u8;\n        current_block = 1190876092451756080;\n    }\n    12 => {\n        esc = 'f' as u8;\n        current_block = 1190876092451756080;\n    }\n    10 => {\n        esc = 'n' as u8;\n        current_block = 9215498979640025612;\n    }\n    13 => {\n        esc = 'r' as u8;\n        current_block = 9215498979640025612;\n    }\n    9 => {\n        esc = 't' as u8;\n        current_block = 9215498979640025612;\n    }\n    11 => {\n        esc = 'v' as u8;\n        current_block = 1190876092451756080;\n    }\n    92 => {\n         esc = c;\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    current_block = 4476262310586904498;\n} else if backslash_escapes && elide_outer_quotes && quote_string_len != 0 {\n    current_block = 4476262310586904498;\n} else {\n    current_block = 9215498979640025612;\n}\n\n\n    }\n    123 | 125 => {\n         let arg_slice = unsafe { std::slice::from_raw_parts(arg as *const i8, argsize as usize) };\nlet is_null_terminated = arg_slice.get(1).map_or(false, |&c| c == 0);\n\nif (argsize == u64::MAX && is_null_terminated) || (argsize == 1) {\n    current_block = 16442922512115311366;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n    35 | 126 => {\n        current_block = 16442922512115311366;\n    }\n    32 => {\n        current_block = 4634307283396172174;\n    }\n    33 => {\n        current_block = 7549413860336125482;\n    }\n    34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n        current_block = 13059411171234995867;\n    }\n    62 | 91 | 94 => {\n        current_block = 16620298045565028098;\n    }\n    96 | 124 => {\n        current_block = 15155215915847730705;\n    }\n    39 => {\n         encountered_single_quote = true;\nc_and_shell_quote_compat = true;\n\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    if buffersize != 0 && orig_buffersize == 0 {\n        orig_buffersize = buffersize;\n        buffersize = 0;\n    }\n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\'' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\\\' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\'' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    pending_shell_escape_end = false;\n    current_block = 253337042034819032;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n    37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n    | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n    | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n    | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n    | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n    | 120 | 121 | 122 => {\n        c_and_shell_quote_compat = true;\n        current_block = 253337042034819032;\n    }\n    _ => {\n         let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n\n         if m > 1 || (backslash_escapes && !printable) {\n    let ilim = i.wrapping_add(m);\n    let buffer_slice = unsafe { std::slice::from_raw_parts_mut(buffer, buffersize as usize) };\n    loop {\n        if backslash_escapes && !printable {\n            if elide_outer_quotes {\n                current_block = 7928555609993211441;\n                break 's_25;\n            }\n            escaping = true;\n            if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n                if len < buffersize {\n                    buffer_slice[len as usize] = '\\'' as i8;\n                }\n                len = len.wrapping_add(1);\n                if len < buffersize {\n                    buffer_slice[len as usize] = '$' as i8;\n                }\n                len = len.wrapping_add(1);\n                if len < buffersize {\n                    buffer_slice[len as usize] = '\\'' as i8;\n                }\n                len = len.wrapping_add(1);\n                pending_shell_escape_end = true;\n            }\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\\\' as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as i32 + (c as i32 >> 6)) as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as i32 + ((c as i32 >> 3) & 7)) as i8;\n            }\n            len = len.wrapping_add(1);\n            c = ('0' as i32 + (c as i32 & 7)) as u8;\n        } else if is_right_quote {\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\\\' as i8;\n            }\n            len = len.wrapping_add(1);\n            is_right_quote = false;\n        }\n        if ilim <= i.wrapping_add(1) {\n            break;\n        }\n        if pending_shell_escape_end && !escaping {\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\'' as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\'' as i8;\n            }",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "            len = len.wrapping_add(1);\n            pending_shell_escape_end = false;\n        }\n        if len < buffersize {\n            buffer_slice[len as usize] = c as i8;\n        }\n        len = len.wrapping_add(1);\n        i = i.wrapping_add(1);\n        c = unsafe { *arg.offset(i as isize) } as u8;\n    }\n    current_block = 4476262310586904498;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n}\n\nmatch current_block {\n    16442922512115311366 => {\n        if i != 0 {\n            current_block = 253337042034819032;\n        } else {\n            current_block = 4634307283396172174;\n        }\n    }\n    9215498979640025612 => {\n        if quoting_style == shell_always_quoting_style && elide_outer_quotes {\n            current_block = 7928555609993211441;\n            break 's_25;\n        }\n        current_block = 1190876092451756080;\n    }\n    _ => {}\n}\n\nmatch current_block {\n    1190876092451756080 => {\n        if backslash_escapes {\n            c = esc;\n            current_block = 3173013908131212616;\n        } else {\n            current_block = 253337042034819032;\n        }\n    }\n    4634307283396172174 => {\n        c_and_shell_quote_compat = true;\n        current_block = 7549413860336125482;\n    }\n    _ => {}\n}\n\nmatch current_block {\n    7549413860336125482 => {\n        current_block = 13059411171234995867;\n    }\n    _ => {}\n}\n\nmatch current_block {\n    13059411171234995867 => {\n        current_block = 16620298045565028098;\n    }\n    _ => {}\n}\n\n            let mut current_block = match current_block {\n    16620298045565028098 => {\n        15155215915847730705\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    15155215915847730705 => {\n        if quoting_style == shell_always_quoting_style && elide_outer_quotes {\n            break 's_25;\n        }\n        253337042034819032\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    253337042034819032 => {\n        if !((backslash_escapes && quoting_style != shell_always_quoting_style) || elide_outer_quotes) \n            && !quote_these_too.is_null() \n            && (unsafe { *quote_these_too.offset(c as isize / (std::mem::size_of::<libc::c_int>() * 8) as isize) } >> (c as usize % (std::mem::size_of::<libc::c_int>() * 8)) & 1) != 0 \n            && !is_right_quote {\n            4476262310586904498\n        } else {\n            3173013908131212616\n        }\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    3173013908131212616 => {\n        if elide_outer_quotes {\n            break 's_25;\n        }\n        escaping = true;\n        if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '$' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            pending_shell_escape_end = true;\n        }\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '\\\\' as i8; }\n        }\n        len += 1;\n        4476262310586904498\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    4476262310586904498 => {\n        if pending_shell_escape_end && !escaping {\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            pending_shell_escape_end = false;\n        }\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = c as i8; }\n        }\n        len += 1;\n        if !c_and_shell_quote_compat {\n            all_c_and_shell_quote_compat = false;\n        }\n        current_block\n    }\n    _ => current_block,\n};\n\ni += 1;\n\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n    return quotearg_buffer_restyled(\n        buffer,\n        orig_buffersize,\n        arg,\n        argsize,\n        c_quoting_style,\n        flags,\n        quote_these_too,\n        left_quote,\n        right_quote,\n    );\n} else {\n    if !(buffersize == 0 && orig_buffersize != 0) {\n        current_block = 6412618891452676311;\n        break;\n    }\n    buffersize = orig_buffersize;\n    len = 0;\n}\n\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub fn quotearg_buffer(\n    buffer: &mut [c_char],\n    arg: &[c_char],\n    o: Option<&quoting_options>,\n) -> usize {\n    let p = o.unwrap_or(unsafe { &default_quoting_options });\n    let e = std::io::Error::last_os_error();\n    let r = unsafe {\n        quotearg_buffer_restyled(\n            buffer.as_mut_ptr(),\n            buffer.len().try_into().unwrap(),\n            arg.as_ptr(),\n            arg.len().try_into().unwrap(),\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        )\n    };\n    std::mem::forget(e); // Handle the error if necessary\n    r.try_into().unwrap()\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};\nstatic mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}\n#[no_mangle]\npub fn quotearg(arg: &CStr) -> CString {\n    let result_ptr = unsafe { quotearg_n(0, arg.as_ptr()) };\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub fn quotearg_mem(arg: &str) -> String {\n    let argsize = arg.len() as u64;\n    let c_string = CString::new(arg).expect(\"CString::new failed\");\n    let result_ptr;\n    unsafe {\n        result_ptr = quotearg_n_mem(0, c_string.as_ptr(), argsize);\n    }\n    unsafe { CString::from_raw(result_ptr).into_string().expect(\"Failed to convert to String\") }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}\n#[no_mangle]\npub fn quotearg_style(\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    unsafe {\n        let result_ptr = quotearg_n_style(0, s, arg.as_ptr());\n        CString::from_raw(result_ptr)\n    }\n}\n#[no_mangle]\npub fn quotearg_style_mem(\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let argsize = arg.to_bytes().len() as u64;\n    let result_ptr = unsafe { quotearg_n_style_mem(0, s, arg.as_ptr(), argsize) };\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(Some(&mut options), ch as u8 as char, 1);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}\n#[no_mangle]\npub fn quotearg_colon(arg: &str) -> String {\n    let ch: i8 = b':' as i8;\n    let c_string = CString::new(arg).expect(\"CString::new failed\");\n    \n    let result = unsafe {\n        let result_ptr = quotearg_char(c_string.as_ptr(), ch);\n        CString::from_raw(result_ptr).into_string().expect(\"Failed to convert to String\")\n    };\n    \n    result\n}\n#[no_mangle]\npub fn quotearg_colon_mem(arg: &CStr) -> CString {\n    let argsize = arg.to_bytes().len() as u64;\n    let result_ptr: *mut libc::c_char = unsafe { quotearg_char_mem(arg.as_ptr(), argsize, ':' as i32 as c_char) };\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(Some(&mut options), ':' as u8 as char, 1);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub fn quotearg_custom(\n    left_quote: &str,\n    right_quote: &str,\n    arg: &str,\n) -> String {\n    let left_quote_c = std::ffi::CString::new(left_quote).unwrap();\n    let right_quote_c = std::ffi::CString::new(right_quote).unwrap();\n    let arg_c = std::ffi::CString::new(arg).unwrap();\n    \n    let result_ptr;\n    unsafe {\n        result_ptr = quotearg_n_custom(0, left_quote_c.as_ptr(), right_quote_c.as_ptr(), arg_c.as_ptr());\n    }\n    \n    unsafe {\n        std::ffi::CStr::from_ptr(result_ptr).to_string_lossy().into_owned()\n    }\n}\n#[no_mangle]\npub fn quotearg_custom_mem(\n    left_quote: &CStr,\n    right_quote: &CStr,\n    arg: &CStr,\n) -> CString {\n    let argsize = arg.to_bytes().len() as u64;\n    let result_ptr: *mut libc::c_char = unsafe {\n        quotearg_n_custom_mem(\n            0,\n            left_quote.as_ptr(),\n            right_quote.as_ptr(),\n            arg.as_ptr(),\n            argsize,\n        )\n    };\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}\n#[no_mangle]\npub fn quote_mem(arg: &CStr) -> CString {\n    let argsize = arg.to_bytes().len();\n    let quoted = unsafe { quote_n_mem(0, arg.as_ptr(), argsize.try_into().unwrap()) };\n    unsafe { CString::from_raw(quoted as *mut libc::c_char) }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}\n#[no_mangle]\npub fn quote(arg: &CStr) -> *const libc::c_char {\n    unsafe { quote_n(0, arg.as_ptr()) }\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type ssize_t = __ssize_t;\npub type __ssize_t = libc::c_long;\npub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn safe_read(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = read(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\safe_read.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse std::slice;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn setlocale_null_r(\n    category: libc::c_int,\n    buf: &mut [libc::c_char],\n) -> libc::c_int {\n    let bufsize = buf.len() as size_t;\n    unsafe {\n        return setlocale_null_r_unlocked(category, buf.as_mut_ptr(), bufsize);\n    }\n}\n#[no_mangle]\npub fn setlocale_null(category: libc::c_int) -> Option<String> {\n    unsafe {\n        let result = setlocale_null_unlocked(category);\n        if result.is_null() {\n            None\n        } else {\n            // Convert the C string to a Rust String\n            let c_str = std::ffi::CStr::from_ptr(result);\n            c_str.to_str().ok().map(|s| s.to_owned())\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\setlocale_null.rs"
    },
    {
      "chunk": "use std::slice;\nuse ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub fn setlocale_null_r_unlocked(\n    category: libc::c_int,\n    buf: &mut Vec<u8>,\n) -> libc::c_int {\n    let result: *const libc::c_char;\n    unsafe {\n        result = setlocale_null_unlocked(category);\n    }\n    \n    if result.is_null() {\n        if !buf.is_empty() {\n            buf[0] = 0; // Set the first byte to null terminator\n        }\n        return 22;\n    } else {\n        let length: usize = unsafe { strlen(result) } as usize; // Cast to usize\n        if length < buf.len() {\n            buf[..length].copy_from_slice(unsafe { std::slice::from_raw_parts(result as *const u8, length) });\n            buf[length] = 0; // Null terminate\n            return 0;\n        } else {\n            let copy_length = buf.len() - 1;\n            if !buf.is_empty() {\n                let slice = unsafe { std::slice::from_raw_parts(result as *const u8, copy_length) };\n                buf[..copy_length].copy_from_slice(slice);\n                buf[copy_length] = 0; // Null terminate\n            }\n            return 34;\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\setlocale_null_unlocked.rs"
    },
    {
      "chunk": "use std::fs::Metadata;\nuse libc::time_t;\nuse libc::c_long;\nuse std::os::unix::fs::MetadataExt;\nuse ::libc;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn stat_time_normalize(result: i32, _st: &std::fs::Metadata) -> i32 {\n    result\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn get_stat_birthtime(st: &libc::stat) -> libc::timespec {\n    libc::timespec {\n        tv_sec: -(1 as libc::c_int) as libc::time_t,\n        tv_nsec: -(1 as libc::c_int) as libc::c_long,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn get_stat_mtime(st: &Metadata) -> libc::timespec {\n    let mtime = st.mtime();\n    libc::timespec {\n        tv_sec: mtime as libc::time_t,\n        tv_nsec: 0, // Assuming nanoseconds are not available, set to 0\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn get_stat_ctime(st: &Metadata) -> libc::timespec {\n    let ctime = st.ctime();\n    libc::timespec {\n        tv_sec: ctime as libc::time_t,\n        tv_nsec: 0, // Assuming nanoseconds are not needed, set to 0\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn get_stat_atime(st: &Metadata) -> libc::timespec {\n    let atime = st.atime();\n    libc::timespec {\n        tv_sec: atime as libc::time_t,\n        tv_nsec: 0, // Assuming nanoseconds are not needed, set to 0\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn get_stat_birthtime_ns(st: &Metadata) -> libc::c_long {\n    st.ctime() as libc::c_long // Assuming ctime is the intended method for birthtime\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn get_stat_mtime_ns(st: &Metadata) -> libc::c_long {\n    return st.modified().unwrap().duration_since(std::time::UNIX_EPOCH).unwrap().as_nanos() as libc::c_long;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn get_stat_ctime_ns(st: &stat) -> libc::c_long {\n    st.st_ctim.tv_nsec\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn get_stat_atime_ns(st: &Metadata) -> libc::c_long {\n    return st.atime_nsec();\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\stat_time.rs"
    },
    {
      "chunk": "#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut, unused_imports)]\n#![feature(extern_types, label_break_value)]\nuse std::cmp::Ordering;\nuse std::convert::TryInto;\nuse std::slice;\nuse std::os::unix::io::AsRawFd;\nuse std::os::raw::c_int;\nuse std::ptr;\nuse std::process;\nuse std::ptr::null_mut;\nuse std::ffi::CString;\nuse std::os::raw::c_void;\nuse std::io;\nuse std::ffi::CStr;\nuse std::io::Write;\nuse ::rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    pub type hash_table;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn fwrite_unlocked(\n        __ptr: *const libc::c_void,\n        __size: size_t,\n        __n: size_t,\n        __stream: *mut FILE,\n    ) -> size_t;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn fpurge(gl_stream: *mut FILE) -> libc::c_int;\n    fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;\n    static mut optarg: *mut libc::c_char;\n    static mut optind: libc::c_int;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    fn kill(__pid: __pid_t, __sig: libc::c_int) -> libc::c_int;\n    fn raise(__sig: libc::c_int) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn isatty(__fd: libc::c_int) -> libc::c_int;\n    fn getpagesize() -> libc::c_int;\n    fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn lstat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memchr(\n        _: *const libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn rawmemchr(__s: *const libc::c_void, __c: libc::c_int) -> *mut libc::c_void;\n    fn memrchr(\n        __s: *const libc::c_void,\n        __c: libc::c_int,\n        __n: size_t,\n    ) -> *mut libc::c_void;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn free(_: *mut libc::c_void);\n    fn __errno_location() -> *mut libc::c_int;\n    fn atexit(__func: Option::<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn exit(_: libc::c_int) -> !;\n    static mut Version: *const libc::c_char;\n    fn rpl_fcntl(fd: libc::c_int, action: libc::c_int, _: ...) -> libc::c_int;\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn xalloc_die();\n    fn xmalloc(s: size_t) -> *mut libc::c_void;\n    fn xrealloc(p: *mut libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn last_component(filename: *const libc::c_char) -> *mut libc::c_char;\n    fn dir_len(file: *const libc::c_char) -> size_t;\n    fn close_stdout();\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    static mut program_name: *const libc::c_char;\n    fn set_program_name(argv0: *const libc::c_char);\n    fn offtostr(_: off_t, _: *mut libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn quotearg_n_style_colon(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn xnmalloc(n: size_t, s: size_t) -> *mut libc::c_void;\n    static mut argmatch_die: argmatch_exit_fn;\n    fn __xargmatch_internal(\n        context: *const libc::c_char,\n        arg: *const libc::c_char,\n        arglist: *const *const libc::c_char,\n        vallist: *const libc::c_void,\n        valsize: size_t,\n        exit_fn: argmatch_exit_fn,\n        allow_abbreviation: bool,\n    ) -> ptrdiff_t;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn cl_strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;\n    fn open_safer(_: *const libc::c_char, _: libc::c_int, _: ...) -> libc::c_int;\n    fn iopoll(fdin: libc::c_int, fdout: libc::c_int, block: bool) -> libc::c_int;\n    fn isapipe(fd: libc::c_int) -> libc::c_int;\n    fn posix2_version() -> libc::c_int;\n    fn safe_read(fd: libc::c_int, buf: *mut libc::c_void, count: size_t) -> size_t;\n    fn xdectoumax(\n        n_str: *const libc::c_char,\n        min: uintmax_t,\n        max: uintmax_t,\n        suffixes: *const libc::c_char,\n        err: *const libc::c_char,\n        err_exit: libc::c_int,\n    ) -> uintmax_t;\n    fn xnanosleep(_: libc::c_double) -> libc::c_int;\n    fn xstrtoumax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut uintmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n    fn xstrtod(\n        str: *const libc::c_char,\n        ptr: *mut *const libc::c_char,\n        result: *mut libc::c_double,\n        convert: Option::<\n            unsafe extern \"C\" fn(\n                *const libc::c_char,\n                *mut *mut libc::c_char,\n            ) -> libc::c_double,\n        >,\n    ) -> bool;\n    fn hash_get_n_entries(table: *const Hash_table) -> size_t;\n    fn hash_lookup(\n        table: *const Hash_table,\n        entry: *const libc::c_void,\n    ) -> *mut libc::c_void;\n    fn hash_free(table: *mut Hash_table);\n    fn hash_initialize(\n        candidate: size_t,\n        tuning: *const Hash_tuning,\n        hasher: Hash_hasher,\n        comparator: Hash_comparator,\n        data_freer: Hash_data_freer,\n    ) -> *mut Hash_table;\n    fn hash_insert(\n        table: *mut Hash_table,\n        entry: *const libc::c_void,\n    ) -> *mut libc::c_void;\n    fn hash_remove(\n        table: *mut Hash_table,\n        entry: *const libc::c_void,\n    ) -> *mut libc::c_void;\n    fn poll(__fds: *mut pollfd, __nfds: nfds_t, __timeout: libc::c_int) -> libc::c_int;\n    fn inotify_init() -> libc::c_int;\n    fn inotify_add_watch(\n        __fd: libc::c_int,\n        __name: *const libc::c_char,\n        __mask: uint32_t,\n    ) -> libc::c_int;\n    fn inotify_rm_watch(__fd: libc::c_int, __wd: libc::c_int) -> libc::c_int;\n    fn fstatfs(__fildes: libc::c_int, __buf: *mut statfs) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uintmax_t = libc::c_ulong;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __pid_t = libc::c_int;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __fsid_t {\n    pub __val: [libc::c_int; 2],\n}\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __fsblkcnt_t = libc::c_ulong;\npub type __fsfilcnt_t = libc::c_ulong;\npub type __fsword_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type ptrdiff_t = libc::c_long;\npub type ino_t = __ino_t;\npub type dev_t = __dev_t;\npub type mode_t = __mode_t;\npub type pid_t = __pid_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub type blksize_t = __blksize_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "pub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\npub type uint32_t = __uint32_t;\npub type uintmax_t = __uintmax_t;\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type argmatch_exit_fn = Option::<unsafe extern \"C\" fn() -> ()>\n;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct hash_tuning {\n    pub shrink_threshold: libc::c_float,\n    pub shrink_factor: libc::c_float,\n    pub growth_threshold: libc::c_float,\n    pub growth_factor: libc::c_float,\n    pub is_n_buckets: bool,\n}\npub type Hash_tuning = hash_tuning;\npub type Hash_table = hash_table;\npub type Hash_hasher = Option::<\n    unsafe extern \"C\" fn(*const libc::c_void, size_t) -> size_t,\n>\n;\npub type Hash_comparator = Option::<\n    unsafe extern \"C\" fn(*const libc::c_void, *const libc::c_void) -> bool,\n>\n;\npub type Hash_data_freer = Option::<unsafe extern \"C\" fn(*mut libc::c_void) -> ()>\n;\npub type nfds_t = libc::c_ulong;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct pollfd {\n    pub fd: libc::c_int,\n    pub events: libc::c_short,\n    pub revents: libc::c_short,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct inotify_event {\n    pub wd: libc::c_int,\n    pub mask: uint32_t,\n    pub cookie: uint32_t,\n    pub len: uint32_t,\n    pub name: [libc::c_char; 0],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct statfs {\n    pub f_type: __fsword_t,\n    pub f_bsize: __fsword_t,\n    pub f_blocks: __fsblkcnt_t,\n    pub f_bfree: __fsblkcnt_t,\n    pub f_bavail: __fsblkcnt_t,\n    pub f_files: __fsfilcnt_t,\n    pub f_ffree: __fsfilcnt_t,\n    pub f_fsid: __fsid_t,\n    pub f_namelen: __fsword_t,\n    pub f_frsize: __fsword_t,\n    pub f_flags: __fsword_t,\n    pub f_spare: [__fsword_t; 4],\n}\npub type Follow_mode = libc::c_uint;\npub const Follow_descriptor: Follow_mode = 2;\npub const Follow_name: Follow_mode = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct File_spec {\n    pub name: *mut libc::c_char,\n    pub size: off_t,\n    pub mtime: timespec,\n    pub dev: dev_t,\n    pub ino: ino_t,\n    pub mode: mode_t,\n    pub ignore: bool,\n    pub remote: bool,\n    pub tailable: bool,\n    pub fd: libc::c_int,\n    pub errnum: libc::c_int,\n    pub blocking: libc::c_int,\n    pub wd: libc::c_int,\n    pub parent_wd: libc::c_int,\n    pub basename_start: size_t,\n    pub n_unchanged_stats: uintmax_t,\n}\npub type header_mode = libc::c_uint;\npub const never: header_mode = 2;\npub const always: header_mode = 1;\npub const multiple_files: header_mode = 0;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const DISABLE_INOTIFY_OPTION: C2RustUnnamed_0 = 261;\npub const LONG_FOLLOW_OPTION: C2RustUnnamed_0 = 260;\npub const PRESUME_INPUT_PIPE_OPTION: C2RustUnnamed_0 = 259;\npub const PID_OPTION: C2RustUnnamed_0 = 258;\npub const MAX_UNCHANGED_STATS_OPTION: C2RustUnnamed_0 = 257;\npub const RETRY_OPTION: C2RustUnnamed_0 = 256;\npub type LBUFFER = linebuffer;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct linebuffer {\n    pub buffer: [libc::c_char; 8192],\n    pub nbytes: size_t,\n    pub nlines: size_t,\n    pub next: *mut linebuffer,\n}\npub type CBUFFER = charbuffer;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct charbuffer {\n    pub buffer: [libc::c_char; 8192],\n    pub nbytes: size_t,\n    pub next: *mut charbuffer,\n}\n#[inline]\nfn timespec_cmp(a: timespec, b: timespec) -> i32 {\n    let sec_cmp = a.tv_sec.cmp(&b.tv_sec);\n    if sec_cmp != std::cmp::Ordering::Equal {\n        return match sec_cmp {\n            std::cmp::Ordering::Greater => 1,\n            std::cmp::Ordering::Less => -1,\n            _ => unreachable!(),\n        };\n    }\n    let nsec_cmp = a.tv_nsec.cmp(&b.tv_nsec);\n    match nsec_cmp {\n        std::cmp::Ordering::Greater => 1,\n        std::cmp::Ordering::Less => -1,\n        std::cmp::Ordering::Equal => 0,\n    }\n}\n#[inline]\nfn emit_stdin_note() {\n    let message = \"\\nWith no FILE, or when FILE is -, read standard input.\\n\";\n    let stdout_handle = std::io::stdout();\n    let mut handle = stdout_handle.lock();\n    handle.write_all(message.as_bytes()).expect(\"Failed to write to stdout\");\n}\n#[inline]\nfn emit_mandatory_arg_note() {\n    let message = \"\\nMandatory arguments to long options are mandatory for short options too.\\n\";\n    let stdout_handle = std::io::stdout();\n    let mut handle = stdout_handle.lock();\n    handle.write_all(message.as_bytes()).expect(\"Failed to write to stdout\");\n}\n#[inline]\nfn emit_ancillary_info(program: &str) {\n    let infomap_0: [( &str, &str); 7] = [\n        ( \"[\", \"test invocation\" ),\n        ( \"coreutils\", \"Multi-call invocation\" ),\n        ( \"sha224sum\", \"sha2 utilities\" ),\n        ( \"sha256sum\", \"sha2 utilities\" ),\n        ( \"sha384sum\", \"sha2 utilities\" ),\n        ( \"sha512sum\", \"sha2 utilities\" ),\n        ( \"\", \"\" ),\n    ];\n\n    let mut node = program;\n    let mut map_prog = infomap_0.iter();\n\n    while let Some(&(prog, n)) = map_prog.next() {\n        if prog.is_empty() || program == prog {\n            node = n;\n            break;\n        }\n    }\n\n    println!(\n        \"{} online help: <{}>\",\n        \"GNU coreutils\",\n        \"https://www.gnu.org/software/coreutils/\"\n    );\n\n    let lc_messages = unsafe { setlocale(5, std::ptr::null()) };\n    if !lc_messages.is_null() {\n        let lc_messages_str = unsafe { std::ffi::CStr::from_ptr(lc_messages) };\n        if !lc_messages_str.to_string_lossy().starts_with(\"en_\") {\n            eprint!(\n                \"{}\",\n                \"Report any translation bugs to <https://translationproject.org/team/>\"\n            );\n        }\n    }\n\n    let url_program = if program == \"[\" { \"test\" } else { program };\n\n    println!(\n        \"Full documentation <{}{}>\",\n        \"https://www.gnu.org/software/coreutils/\",\n        url_program\n    );\n\n    println!(\n        \"or available locally via: info '(coreutils) {}{}'\",\n        node,\n        if node == program { \" invocation\" } else { \"\" }\n    );\n}\n#[inline]\nunsafe extern \"C\" fn usable_st_size(mut sb: *const stat) -> bool {\n    return (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        || (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o120000 as libc::c_int as libc::c_uint\n        || ((*sb).st_mode).wrapping_sub((*sb).st_mode) != 0 || 0 as libc::c_int != 0;\n}\n#[inline]\nfn write_error() {\n    let saved_errno = std::io::Error::last_os_error();\n    let _ = std::io::stdout().flush();\n    \n    if false {\n        unsafe {\n            error(\n                1,\n                saved_errno.raw_os_error().unwrap_or(0),\n                gettext(b\"write error\\0\".as_ptr() as *const libc::c_char),\n            );\n        }\n        if true {\n            unreachable!();\n        }\n    } else {\n        {\n            let __errstatus = 1;\n            unsafe {\n                error(\n                    __errstatus,\n                    saved_errno.raw_os_error().unwrap_or(0),\n                    gettext(b\"write error\\0\".as_ptr() as *const libc::c_char),\n                );\n            }\n            if __errstatus != 0 {\n                unreachable!();\n            }\n        }\n        {\n            let __errstatus = 1;\n            unsafe {\n                error(\n                    __errstatus,\n                    saved_errno.raw_os_error().unwrap_or(0),\n                    gettext(b\"write error\\0\".as_ptr() as *const libc::c_char),\n                );\n            }\n            if __errstatus != 0 {\n                unreachable!();\n            }\n        }\n    }\n}\n#[inline]\nfn get_stat_mtime(st: &stat) -> timespec {\n    st.st_mtim\n}\n#[inline]",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "fn xset_binary_mode_error() {\n    // Implement the functionality that was previously unsafe or C API related.\n    // For example, if this function was meant to set binary mode for a stream,\n    // we can use Rust's standard library features to achieve that.\n    \n    // Assuming we want to set binary mode for standard output:\n    let stdout_handle = std::io::stdout();\n    let mut handle = stdout_handle.lock();\n    \n    // Set the output to binary mode if necessary.\n    // This is a placeholder for the actual implementation.\n    // In Rust, we typically don't have a direct equivalent to binary mode,\n    // but we can ensure that we write bytes directly.\n    handle.write_all(b\"\"); // Example operation, replace with actual logic as needed.\n}\n#[inline]\nfn xset_binary_mode(fd: i32, mode: i32) {\n    unsafe {\n        if set_binary_mode(fd, mode) < 0 {\n            xset_binary_mode_error();\n        }\n    }\n}\n#[inline]\nfn __gl_setmode(fd: i32, mode: i32) -> i32 {\n    0\n}\n#[inline]\nfn set_binary_mode(fd: libc::c_int, mode: libc::c_int) -> libc::c_int {\n    __gl_setmode(fd, mode)\n}\n#[inline]\nfn is_local_fs_type(magic: u64) -> i32 {\n    match magic {\n        1513908720 => 1,\n        1633904243 => 0,\n        44533 => 1,\n        44543 => 1,\n        1397113167 => 0,\n        151263540 => 1,\n        1635083891 => 0,\n        391 => 1,\n        325456742 => 1,\n        3393526350 => 1,\n        1111905073 => 1,\n        1650746742 => 1,\n        464386766 => 1,\n        1819242352 => 1,\n        3405662737 => 1,\n        1112100429 => 1,\n        2435016766 => 1,\n        1936880249 => 1,\n        12805120 => 0,\n        2613483 => 1,\n        1667723888 => 1,\n        4283649346 => 0,\n        1937076805 => 0,\n        19920823 => 1,\n        1650812272 => 1,\n        684539205 => 1,\n        1161678120 => 1,\n        1684300152 => 1,\n        1684170528 => 1,\n        4979 => 1,\n        1162691661 => 1,\n        7377 => 1,\n        1145913666 => 1,\n        61791 => 1,\n        3730735588 => 1,\n        4278867 => 1,\n        3774210530 => 1,\n        538032816 => 1,\n        1163413075 => 1,\n        24053 => 1,\n        4989 => 1,\n        61267 => 1,\n        61265 => 1,\n        4076150800 => 1,\n        16390 => 1,\n        428016422 => 0,\n        1702057286 => 0,\n        1702057283 => 0,\n        195894762 => 1,\n        18225520 => 0,\n        1196443219 => 0,\n        16964 => 1,\n        18475 => 1,\n        18520 => 1,\n        12648430 => 1,\n        4187351113 => 1,\n        2508478710 => 1,\n        288389204 => 1,\n        19993000 => 0,\n        732765674 => 1,\n        38496 => 1,\n        16388 => 1,\n        16384 => 1,\n        1984 => 1,\n        29366 => 1,\n        827541066 => 1,\n        1799439955 => 0,\n        3380511080 => 1,\n        198183888 => 0,\n        1397109069 => 1,\n        4991 => 1,\n        5007 => 1,\n        9320 => 1,\n        9336 => 1,\n        19802 => 1,\n        427819522 => 1,\n        19780 => 1,\n        22092 => 0,\n        26985 => 0,\n        1852207972 => 0,\n        13364 => 1,\n        1853056627 => 1,\n        1397118030 => 1,\n        40865 => 1,\n        1952539503 => 0,\n        2035054128 => 0,\n        2866260714 => 0,\n        1346978886 => 1,\n        1346981957 => 0,\n        3344373136 => 1,\n        2088527475 => 0,\n        40864 => 1,\n        1634035564 => 1,\n        47 => 1,\n        1746473250 => 1,\n        2240043254 => 1,\n        124082209 => 1,\n        1382369651 => 1,\n        29301 => 1,\n        1733912937 => 1,\n        1573531125 => 1,\n        1397048141 => 1,\n        1935894131 => 1,\n        4185718668 => 1,\n        1128357203 => 1,\n        20859 => 0,\n        4266872130 => 0,\n        3203391149 => 0,\n        1397703499 => 1,\n        1936814952 => 1,\n        1650812274 => 1,\n        19920822 => 1,\n        19920821 => 1,\n        16914836 => 1,\n        1953653091 => 1,\n        604313861 => 1,\n        352400198 => 1,\n        72020 => 1,\n        1410924800 => 1,\n        40866 => 1,\n        16914839 => 1,\n        2020557398 => 0,\n        3133910204 => 0,\n        2768370933 => 0,\n        1448756819 => 1,\n        1397114950 => 1,\n        2881100148 => 1,\n        19920820 => 1,\n        1481003842 => 1,\n        19911021 => 1,\n        51 => 1,\n        801189825 => 1,\n        1515144787 => 1,\n        1479104553 => 1,\n        _ => -1,\n    }\n}\nstatic mut follow_mode_string: [*const libc::c_char; 3] = [\n    b\"descriptor\\0\" as *const u8 as *const libc::c_char,\n    b\"name\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\nstatic mut follow_mode_map: [Follow_mode; 2] = [Follow_descriptor, Follow_name];\nstatic mut reopen_inaccessible_files: bool = false;\nstatic mut count_lines: bool = false;\nstatic mut follow_mode: Follow_mode = Follow_descriptor;\nstatic mut forever: bool = false;\nstatic mut monitor_output: bool = false;\nstatic mut from_start: bool = false;\nstatic mut print_headers: bool = false;\nstatic mut line_end: libc::c_char = 0;\nstatic mut max_n_unchanged_stats_between_opens: uintmax_t = 5 as libc::c_int\n    as uintmax_t;\nstatic mut nbpids: libc::c_int = 0 as libc::c_int;\nstatic mut pids: *mut pid_t = 0 as *const pid_t as *mut pid_t;\nstatic mut pids_alloc: idx_t = 0;\nstatic mut page_size: idx_t = 0;\nstatic mut have_read_stdin: bool = false;\nstatic mut presume_input_pipe: bool = false;\nstatic mut disable_inotify: bool = false;",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "static mut long_options: [option; 16] = [\n    {\n        let mut init = option {\n            name: b\"bytes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'c' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"follow\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 2 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: LONG_FOLLOW_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"lines\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'n' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"max-unchanged-stats\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: MAX_UNCHANGED_STATS_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"-disable-inotify\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: DISABLE_INOTIFY_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"pid\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: PID_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"-presume-input-pipe\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: PRESUME_INPUT_PIPE_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"quiet\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'q' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"retry\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: RETRY_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"silent\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'q' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"sleep-interval\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 's' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"verbose\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'v' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"zero-terminated\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'z' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];\n#[no_mangle]\npub fn usage(status: i32) {\n    if status != 0 {\n        eprintln!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(format!(\"Try '{} --help' for more information.\\n\", unsafe { std::ffi::CStr::from_ptr(program_name).to_string_lossy() }).as_ptr() as *const i8)).to_string_lossy() }\n        );\n    } else {\n        println!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(format!(\"Usage: {} [OPTION]... [FILE]...\\n\", unsafe { std::ffi::CStr::from_ptr(program_name).to_string_lossy() }).as_ptr() as *const i8)).to_string_lossy() }\n        );\n        println!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(format!(\"Print the last {} lines of each FILE to standard output.\\nWith more than one FILE, precede each with a header giving the file name.\\n\", 10).as_ptr() as *const i8)).to_string_lossy() }\n        );\n        emit_stdin_note();\n        emit_mandatory_arg_note();\n        print!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"  -c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\\n                             output starting with byte NUM of each file\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        print!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"  -f, --follow[={name|descriptor}]\\n                           output appended data as the file grows;\\n                             an absent option argument means 'descriptor'\\n  -F                       same as --follow=name --retry\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        println!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(format!(\"  -n, --lines=[+]NUM       output the last NUM lines, instead of the last {};\\n                             or use -n +NUM to skip NUM-1 lines at the start\\n\", 10).as_ptr() as *const i8)).to_string_lossy() }\n        );\n        println!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(format!(\"      --max-unchanged-stats=N\\n                           with --follow=name, reopen a FILE which has not\\n                             changed size after N (default {}) iterations\\n                             to see if it has been unlinked or renamed\\n                             (this is the usual case of rotated log files);\\n                             with inotify, this option is rarely useful\\n\", 5).as_ptr() as *const i8)).to_string_lossy() }\n        );\n        print!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"      --pid=PID            with -f, terminate after process ID, PID dies;\\n                             can be repeated to watch multiple processes\\n  -q, --quiet, --silent    never output headers giving file names\\n      --retry              keep trying to open a file if it is inaccessible\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        print!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\\n                             (default 1.0) between iterations;\\n                             with inotify and --pid=P, check process P at\\n                             least once every N seconds\\n  -v, --verbose            always output headers giving file names\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        print!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"  -z, --zero-terminated    line delimiter is NUL, not newline\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        print!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"      --help        display this help and exit\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        print!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"      --version     output version information and exit\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        print!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"\\nNUM may have a multiplier suffix:\\nb 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\\nGB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        print!(\n            \"{}\",\n            unsafe { std::ffi::CStr::from_ptr(gettext(\"With --follow (-f), tail defaults to following the file descriptor, which\\nmeans that even if a tail'ed file is renamed, tail will continue to track\\nits end.  This default behavior is not desirable when you really want to\\ntrack the actual name of the file, not the file descriptor (e.g., log\\nrotation).  Use --follow=name in that case.  That causes tail to track the\\nnamed file in a way that accommodates renaming, removal and creation.\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        emit_ancillary_info(\"tail\");\n    }\n    std::process::exit(status);\n}\nfn die_pipe() {\n    std::process::exit(1);\n}\nfn check_output_alive() {\n    if !unsafe { monitor_output } {\n        return;\n    }\n    let result = unsafe { iopoll(-1, 1, false) };\n    if result == -2 {\n        die_pipe();\n    }\n}\nunsafe extern \"C\" fn valid_file_spec(mut f: *const File_spec) -> bool {\n    return ((*f).fd == -(1 as libc::c_int)) as libc::c_int\n        ^ ((*f).errnum == 0 as libc::c_int) as libc::c_int != 0;\n}\nunsafe extern \"C\" fn pretty_name(mut f: *const File_spec) -> *const libc::c_char {\n    return if strcmp((*f).name, b\"-\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        gettext(b\"standard input\\0\" as *const u8 as *const libc::c_char)\n    } else {\n        (*f).name\n    };\n}\nfn record_open_fd(\n    f: &mut File_spec,\n    fd: libc::c_int,\n    size: off_t,\n    st: &stat,\n    blocking: libc::c_int,\n) {\n    f.fd = fd;\n    f.size = size;\n    f.mtime = get_stat_mtime(st);\n    f.dev = st.st_dev;\n    f.ino = st.st_ino;\n    f.mode = st.st_mode;\n    f.blocking = blocking;\n    f.n_unchanged_stats = 0;\n    f.ignore = false;\n}\nunsafe extern \"C\" fn close_fd(mut fd: libc::c_int, mut filename: *const libc::c_char) {\n    if fd != -(1 as libc::c_int) && fd != 0 as libc::c_int && close(fd) != 0 {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"closing %s (fd=%d)\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, filename),\n                fd,\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"closing %s (fd=%d)\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                    fd,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"closing %s (fd=%d)\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                    fd,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn write_header(mut pretty_filename: *const libc::c_char) {\n    static mut first_file: bool = 1 as libc::c_int != 0;\n    printf(\n        b\"%s==> %s <==\\n\\0\" as *const u8 as *const libc::c_char,\n        if first_file as libc::c_int != 0 {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\n\\0\" as *const u8 as *const libc::c_char\n        },\n        pretty_filename,\n    );\n    first_file = 0 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn xwrite_stdout(\n    mut buffer: *const libc::c_char,\n    mut n_bytes: size_t,\n) {\n    if n_bytes > 0 as libc::c_int as libc::c_ulong\n        && fwrite_unlocked(\n            buffer as *const libc::c_void,\n            1 as libc::c_int as size_t,\n            n_bytes,\n            stdout,\n        ) < n_bytes\n    {\n        clearerr_unlocked(stdout);\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n}\nunsafe extern \"C\" fn dump_remainder(\n    mut want_header: bool,\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n) -> uintmax_t {\n    let mut n_written: uintmax_t = 0;\n    let mut n_remaining: uintmax_t = n_bytes;\n    n_written = 0 as libc::c_int as uintmax_t;\n    loop {\n        let mut buffer: [libc::c_char; 8192] = [0; 8192];\n        let mut n: size_t = if n_remaining < 8192 as libc::c_int as libc::c_ulong {\n            n_remaining\n        } else {\n            8192 as libc::c_int as libc::c_ulong\n        };\n        let mut bytes_read: size_t = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            n,\n        );\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if *__errno_location() != 11 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_filename,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_filename,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            break;\n        } else {\n            if bytes_read == 0 as libc::c_int as libc::c_ulong {\n                break;\n            }\n            if want_header {\n                write_header(pretty_filename);\n                want_header = 0 as libc::c_int != 0;\n            }\n            xwrite_stdout(buffer.as_mut_ptr(), bytes_read);\n            n_written = (n_written as libc::c_ulong).wrapping_add(bytes_read)\n                as uintmax_t as uintmax_t;\n            if !(n_bytes != 18446744073709551615 as libc::c_ulong) {\n                continue;\n            }\n            n_remaining = (n_remaining as libc::c_ulong).wrapping_sub(bytes_read)\n                as uintmax_t as uintmax_t;\n            if n_remaining == 0 as libc::c_int as libc::c_ulong\n                || n_bytes\n                    == (18446744073709551615 as libc::c_ulong)\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n            {\n                break;\n            }\n        }\n    }\n    return n_written;\n}\nunsafe extern \"C\" fn xlseek(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n    mut filename: *const libc::c_char,\n) -> off_t {\n    let mut new_offset: off_t = lseek(fd, offset, whence);\n    let mut buf: [libc::c_char; 21] = [0; 21];\n    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;\n    if 0 as libc::c_int as libc::c_long <= new_offset {\n        return new_offset;\n    }\n    s = offtostr(offset, buf.as_mut_ptr());\n    match whence {\n        0 => {\n            if false {\n    error(\n        1,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        gettext(b\"%s: cannot seek to offset %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_n_style_colon(0, shell_escape_quoting_style, filename),\n        s,\n    );\n    unreachable!();\n} else {\n    let __errstatus: i32 = 1;\n    error(\n        __errstatus,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        gettext(b\"%s: cannot seek to offset %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_n_style_colon(0, shell_escape_quoting_style, filename),\n        s,\n    );\n    unreachable!();\n    \n    let __errstatus: i32 = 1;\n    error(\n        __errstatus,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        gettext(b\"%s: cannot seek to offset %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_n_style_colon(0, shell_escape_quoting_style, filename),\n        s,\n    );\n    unreachable!();\n}\n\n        }\n        1 => {\n            if false {\n    error(\n        1,\n        *__errno_location(),\n        gettext(b\"%s: cannot seek to relative offset %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_n_style_colon(0, shell_escape_quoting_style, filename),\n        s,\n    );\n    unreachable!();\n} else {\n    let __errstatus: i32 = 1;\n    error(\n        __errstatus,\n        *__errno_location(),\n        gettext(b\"%s: cannot seek to relative offset %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_n_style_colon(0, shell_escape_quoting_style, filename),\n        s,\n    );\n    unreachable!();\n    \n    let __errstatus: i32 = 1;\n    error(\n        __errstatus,\n        *__errno_location(),\n        gettext(b\"%s: cannot seek to relative offset %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_n_style_colon(0, shell_escape_quoting_style, filename),\n        s,\n    );\n    unreachable!();\n}\n\n        }\n        2 => {\n            if false {\n    error(\n        1,\n        *__errno_location(),\n        gettext(b\"%s: cannot seek to end-relative offset %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_n_style_colon(0, shell_escape_quoting_style, filename),\n        s,\n    );\n    unreachable!();\n} else {\n    let errstatus: i32 = 1;\n    error(\n        errstatus,\n        *__errno_location(),\n        gettext(b\"%s: cannot seek to end-relative offset %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_n_style_colon(0, shell_escape_quoting_style, filename),\n        s,\n    );\n    unreachable!();\n    \n    let errstatus: i32 = 1;\n    error(\n        errstatus,\n        *__errno_location(),\n        gettext(b\"%s: cannot seek to end-relative offset %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_n_style_colon(0, shell_escape_quoting_style, filename),\n        s,\n    );\n    unreachable!();\n}\n\n        }\n        _ => {\n            unreachable!();\n        }\n    }\n    panic!(\"Reached end of non-void function without returning\");\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn file_lines(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut sb: *const stat,\n    mut n_lines: uintmax_t,\n    mut start_pos: off_t,\n    mut end_pos: off_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    let mut buffer: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut bytes_read: size_t = 0;\n    let mut bufsize: blksize_t = 8192 as libc::c_int;\n    let mut pos: off_t = end_pos;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    if n_lines == 0 as libc::c_int as libc::c_ulong {\n        return 1 as libc::c_int != 0;\n    }\n    if (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n    {} else {\n        __assert_fail(\n            b\"((((sb->st_mode)) & 0170000) == (0100000))\\0\" as *const u8\n                as *const libc::c_char,\n            b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n            543 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 95],\n                &[libc::c_char; 95],\n            >(\n                b\"_Bool file_lines(const char *, int, const struct stat *, uintmax_t, off_t, off_t, uintmax_t *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_10359: {\n        if (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o100000 as libc::c_int as libc::c_uint\n        {} else {\n            __assert_fail(\n                b\"((((sb->st_mode)) & 0170000) == (0100000))\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                543 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 95],\n                    &[libc::c_char; 95],\n                >(\n                    b\"_Bool file_lines(const char *, int, const struct stat *, uintmax_t, off_t, off_t, uintmax_t *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    if (*sb).st_size % page_size == 0 as libc::c_int as libc::c_long {\n        bufsize = (if 8192 as libc::c_int as libc::c_long > page_size {\n            8192 as libc::c_int as libc::c_long\n        } else {\n            page_size\n        }) as blksize_t;\n    }\n    buffer = xmalloc(bufsize as size_t) as *mut libc::c_char;\n    bytes_read = ((pos - start_pos) % bufsize as libc::c_long) as size_t;\n    if bytes_read == 0 as libc::c_int as libc::c_ulong {\n        bytes_read = bufsize as size_t;\n    }\n    pos = (pos as libc::c_ulong).wrapping_sub(bytes_read) as off_t as off_t;\n    xlseek(fd, pos, 0 as libc::c_int, pretty_filename);\n    bytes_read = safe_read(fd, buffer as *mut libc::c_void, bytes_read);\n    if bytes_read == -(1 as libc::c_int) as size_t {\n        if false {\n    error(\n        0,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        gettext(b\"error reading %s\\0\".as_ptr() as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n    );\n    if false {\n        unreachable!();\n    }\n} else {\n    let __errstatus: i32 = 0;\n    error(\n        __errstatus,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        gettext(b\"error reading %s\\0\".as_ptr() as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n    );\n    if __errstatus != 0 {\n        unreachable!();\n    }\n\n    let __errstatus: i32 = 0;\n    error(\n        __errstatus,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        gettext(b\"error reading %s\\0\".as_ptr() as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n    );\n    if __errstatus != 0 {\n        unreachable!();\n    }\n}\nok = false;\n\n    } else {\n        *read_pos = (pos as libc::c_ulong).wrapping_add(bytes_read);\n        if bytes_read != 0\n            && *buffer\n                .offset(\n                    bytes_read.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                ) as libc::c_int != line_end as libc::c_int\n        {\n            n_lines = n_lines.wrapping_sub(1);\n            n_lines;\n        }\n        's_79: loop {\n            let mut n: size_t = bytes_read;\n            while n != 0 {\n                let mut nl: *const libc::c_char = 0 as *const libc::c_char;\n                nl = memrchr(buffer as *const libc::c_void, line_end as libc::c_int, n)\n                    as *const libc::c_char;\n                if nl.is_null() {\n                    break;\n                }\n                n = nl.offset_from(buffer) as libc::c_long as size_t;\n                let fresh0 = n_lines;\n                n_lines = n_lines.wrapping_sub(1);\n                if !(fresh0 == 0 as libc::c_int as libc::c_ulong) {\n                    continue;\n                }\n                xwrite_stdout(\n                    nl.offset(1 as libc::c_int as isize),\n                    bytes_read\n                        .wrapping_sub(n.wrapping_add(1 as libc::c_int as libc::c_ulong)),\n                );\n                *read_pos = (*read_pos as libc::c_ulong)\n                    .wrapping_add(\n                        dump_remainder(\n                            0 as libc::c_int != 0,\n                            pretty_filename,\n                            fd,\n                            (end_pos as libc::c_ulong)\n                                .wrapping_sub(\n                                    (pos as libc::c_ulong).wrapping_add(bytes_read),\n                                ),\n                        ),\n                    ) as uintmax_t as uintmax_t;\n                break 's_79;\n            }\n            if pos == start_pos {\n                xlseek(fd, start_pos, 0 as libc::c_int, pretty_filename);\n                *read_pos = (start_pos as libc::c_ulong)\n                    .wrapping_add(\n                        dump_remainder(\n                            0 as libc::c_int != 0,\n                            pretty_filename,\n                            fd,\n                            end_pos as uintmax_t,\n                        ),\n                    );\n                break;\n            } else {\n                pos -= bufsize as libc::c_long;\n                xlseek(fd, pos, 0 as libc::c_int, pretty_filename);\n                bytes_read = safe_read(\n                    fd,\n                    buffer as *mut libc::c_void,\n                    bufsize as size_t,\n                );\n                if bytes_read == -(1 as libc::c_int) as size_t {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_filename,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    pretty_filename,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    pretty_filename,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                    break;\n                } else {\n                    *read_pos = (pos as libc::c_ulong).wrapping_add(bytes_read);\n                    if !(bytes_read > 0 as libc::c_int as libc::c_ulong) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    free(buffer as *mut libc::c_void);\n    return ok;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "fn pipe_lines(\n    pretty_filename: *const libc::c_char,\n    fd: i32,\n    n_lines: u64,\n    read_pos: *mut u64,\n) -> bool {\n    unsafe {\n        // Convert pretty_filename to a C-compatible string\n        let c_filename = std::ffi::CStr::from_ptr(pretty_filename);\n\n         let mut first: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut last: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut tmp: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut total_lines: size_t = 0 as libc::c_int as size_t;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut n_read: size_t = 0;\n    last = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong) as *mut LBUFFER;\n    first = last;\n    (*first).nlines = 0 as libc::c_int as size_t;\n    (*first).nbytes = (*first).nlines;\n    (*first).next = 0 as *mut linebuffer;\n    tmp = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong) as *mut LBUFFER;\n    loop {\n        n_read = safe_read(\n            fd,\n            ((*tmp).buffer).as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if n_read == 0 as libc::c_int as libc::c_ulong\n            || n_read == -(1 as libc::c_int) as size_t\n        {\n            break;\n        }\n        (*tmp).nbytes = n_read;\n        *read_pos = (*read_pos as libc::c_ulong).wrapping_add(n_read) as uintmax_t\n            as uintmax_t;\n        (*tmp).nlines = 0 as libc::c_int as size_t;\n        (*tmp).next = 0 as *mut linebuffer;\n        let mut buffer_end: *const libc::c_char = ((*tmp).buffer)\n            .as_mut_ptr()\n            .offset(n_read as isize);\n        let mut p: *const libc::c_char = ((*tmp).buffer).as_mut_ptr();\n        loop {\n            p = memchr(\n                p as *const libc::c_void,\n                line_end as libc::c_int,\n                buffer_end.offset_from(p) as libc::c_long as libc::c_ulong,\n            ) as *const libc::c_char;\n            if p.is_null() {\n                break;\n            }\n            p = p.offset(1);\n            p;\n            (*tmp).nlines = ((*tmp).nlines).wrapping_add(1);\n            (*tmp).nlines;\n        }\n        total_lines = (total_lines as libc::c_ulong).wrapping_add((*tmp).nlines)\n            as size_t as size_t;\n        if ((*tmp).nbytes).wrapping_add((*last).nbytes)\n            < 8192 as libc::c_int as libc::c_ulong\n        {\n            memcpy(\n                &mut *((*last).buffer).as_mut_ptr().offset((*last).nbytes as isize)\n                    as *mut libc::c_char as *mut libc::c_void,\n                ((*tmp).buffer).as_mut_ptr() as *const libc::c_void,\n                (*tmp).nbytes,\n            );\n            (*last)\n                .nbytes = ((*last).nbytes as libc::c_ulong).wrapping_add((*tmp).nbytes)\n                as size_t as size_t;\n            (*last)\n                .nlines = ((*last).nlines as libc::c_ulong).wrapping_add((*tmp).nlines)\n                as size_t as size_t;\n        } else {\n            (*last).next = tmp;\n            last = (*last).next;\n            if total_lines.wrapping_sub((*first).nlines) > n_lines {\n                tmp = first;\n                total_lines = (total_lines as libc::c_ulong)\n                    .wrapping_sub((*first).nlines) as size_t as size_t;\n                first = (*first).next;\n            } else {\n                tmp = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong)\n                    as *mut LBUFFER;\n            }\n        }\n    }\n    free(tmp as *mut libc::c_void);\n   \n         if n_read == -(1 as libc::c_int) as size_t {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        ok = 0 as libc::c_int != 0;\n    } else if !((*last).nbytes == 0 as libc::c_int as libc::c_ulong) {\n        if !(n_lines == 0 as libc::c_int as libc::c_ulong) {\n            if (*last)\n                .buffer[((*last).nbytes).wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                as usize] as libc::c_int != line_end as libc::c_int\n            {\n                (*last).nlines = ((*last).nlines).wrapping_add(1);\n                (*last).nlines;\n                total_lines = total_lines.wrapping_add(1);\n                total_lines;\n            }\n            tmp = first;\n            while total_lines.wrapping_sub((*tmp).nlines) > n_lines {\n                total_lines = (total_lines as libc::c_ulong).wrapping_sub((*tmp).nlines)\n                    as size_t as size_t;\n                tmp = (*tmp).next;\n            }\n            let mut beg: *const libc::c_char = ((*tmp).buffer).as_mut_ptr();\n            let mut buffer_end_0: *const libc::c_char = ((*tmp).buffer)\n                .as_mut_ptr()\n                .offset((*tmp).nbytes as isize);\n            if total_lines > n_lines {\n                let mut j: size_t = 0;\n                j = total_lines.wrapping_sub(n_lines);\n                while j != 0 {\n                    beg = rawmemchr(beg as *const libc::c_void, line_end as libc::c_int)\n                        as *const libc::c_char;\n                    beg = beg.offset(1);\n                    beg;\n                    j = j.wrapping_sub(1);\n                    j;\n                }\n            }\n            xwrite_stdout(beg, buffer_end_0.offset_from(beg) as libc::c_long as size_t);\n            tmp = (*tmp).next;\n            while !tmp.is_null() {\n                xwrite_stdout(((*tmp).buffer).as_mut_ptr(), (*tmp).nbytes);\n                tmp = (*tmp).next;\n            }\n        }\n    }\n    while !first.is_null() {\n        tmp = (*first).next;\n        free(first as *mut libc::c_void);\n        first = tmp;\n    }\n    return ok;\n\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn pipe_bytes(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    let mut first: *mut CBUFFER = 0 as *mut CBUFFER;\n    let mut last: *mut CBUFFER = 0 as *mut CBUFFER;\n    let mut tmp: *mut CBUFFER = 0 as *mut CBUFFER;\n    let mut i: size_t = 0;\n    let mut total_bytes: size_t = 0 as libc::c_int as size_t;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut n_read: size_t = 0;\n    last = xmalloc(::core::mem::size_of::<CBUFFER>() as libc::c_ulong) as *mut CBUFFER;\n    first = last;\n    (*first).nbytes = 0 as libc::c_int as size_t;\n    (*first).next = 0 as *mut charbuffer;\n    tmp = xmalloc(::core::mem::size_of::<CBUFFER>() as libc::c_ulong) as *mut CBUFFER;\n    loop {\n        n_read = safe_read(\n            fd,\n            ((*tmp).buffer).as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if n_read == 0 as libc::c_int as libc::c_ulong\n            || n_read == -(1 as libc::c_int) as size_t\n        {\n            break;\n        }\n        *read_pos = (*read_pos as libc::c_ulong).wrapping_add(n_read) as uintmax_t\n            as uintmax_t;\n        (*tmp).nbytes = n_read;\n        (*tmp).next = 0 as *mut charbuffer;\n        total_bytes = (total_bytes as libc::c_ulong).wrapping_add((*tmp).nbytes)\n            as size_t as size_t;\n        if ((*tmp).nbytes).wrapping_add((*last).nbytes)\n            < 8192 as libc::c_int as libc::c_ulong\n        {\n            memcpy(\n                &mut *((*last).buffer).as_mut_ptr().offset((*last).nbytes as isize)\n                    as *mut libc::c_char as *mut libc::c_void,\n                ((*tmp).buffer).as_mut_ptr() as *const libc::c_void,\n                (*tmp).nbytes,\n            );\n            (*last)\n                .nbytes = ((*last).nbytes as libc::c_ulong).wrapping_add((*tmp).nbytes)\n                as size_t as size_t;\n        } else {\n            (*last).next = tmp;\n            last = (*last).next;\n            if total_bytes.wrapping_sub((*first).nbytes) > n_bytes {\n                tmp = first;\n                total_bytes = (total_bytes as libc::c_ulong)\n                    .wrapping_sub((*first).nbytes) as size_t as size_t;\n                first = (*first).next;\n            } else {\n                tmp = xmalloc(::core::mem::size_of::<CBUFFER>() as libc::c_ulong)\n                    as *mut CBUFFER;\n            }\n        }\n    }\n    free(tmp as *mut libc::c_void);\n    if n_read == -(1 as libc::c_int) as size_t {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        ok = 0 as libc::c_int != 0;\n    } else {\n        tmp = first;\n        while total_bytes.wrapping_sub((*tmp).nbytes) > n_bytes {\n            total_bytes = (total_bytes as libc::c_ulong).wrapping_sub((*tmp).nbytes)\n                as size_t as size_t;\n            tmp = (*tmp).next;\n        }\n        if total_bytes > n_bytes {\n            i = total_bytes.wrapping_sub(n_bytes);\n        } else {\n            i = 0 as libc::c_int as size_t;\n        }\n        xwrite_stdout(\n            &mut *((*tmp).buffer).as_mut_ptr().offset(i as isize),\n            ((*tmp).nbytes).wrapping_sub(i),\n        );\n        tmp = (*tmp).next;\n        while !tmp.is_null() {\n            xwrite_stdout(((*tmp).buffer).as_mut_ptr(), (*tmp).nbytes);\n            tmp = (*tmp).next;\n        }\n    }\n    while !first.is_null() {\n        tmp = (*first).next;\n        free(first as *mut libc::c_void);\n        first = tmp;\n    }\n    return ok;\n}\nunsafe extern \"C\" fn start_bytes(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> libc::c_int {\n    let mut buffer: [libc::c_char; 8192] = [0; 8192];\n    while (0 as libc::c_int as libc::c_ulong) < n_bytes {\n        let mut bytes_read: size_t = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if bytes_read == 0 as libc::c_int as libc::c_ulong {\n            return -(1 as libc::c_int);\n        }\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 1 as libc::c_int;\n        }\n        *read_pos = (*read_pos as libc::c_ulong).wrapping_add(bytes_read) as uintmax_t\n            as uintmax_t;\n        if bytes_read <= n_bytes {\n            n_bytes = (n_bytes as libc::c_ulong).wrapping_sub(bytes_read) as uintmax_t\n                as uintmax_t;\n        } else {\n            let mut n_remaining: size_t = bytes_read.wrapping_sub(n_bytes);\n            xwrite_stdout(\n                &mut *buffer.as_mut_ptr().offset(n_bytes as isize),\n                n_remaining,\n            );\n            break;\n        }\n    }\n    return 0 as libc::c_int;\n}\nfn start_lines(\n    pretty_filename: *const libc::c_char,\n    fd: libc::c_int,\n    mut n_lines: u64,\n    read_pos: *mut u64,\n) -> libc::c_int {\n    if n_lines == 0 {\n        return 0;\n    }\n    \n    let mut buffer = vec![0; 8192];\n    \n    loop {\n        let bytes_read = unsafe { safe_read(fd, buffer.as_mut_ptr() as *mut libc::c_void, buffer.len() as u64) };\n        \n        if bytes_read == 0 {\n            return -1;\n        }\n        \n        if bytes_read == u64::MAX {\n            unsafe {\n                error(\n                    0,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n            }\n            return 1;\n        }\n        \n        let buffer_end = bytes_read as usize;\n        unsafe {\n            *read_pos += bytes_read;\n        }\n        \n        let mut p = 0;\n        while p < buffer_end {\n            if unsafe { buffer[p] } == unsafe { line_end } {\n                p += 1;\n                n_lines = n_lines.wrapping_sub(1);\n                if n_lines == 0 {\n                    if p < buffer_end {\n                        let remaining = &buffer[p..buffer_end];\n                        let remaining_u8: &[u8] = unsafe { std::slice::from_raw_parts(remaining.as_ptr() as *const u8, remaining.len()) };\n                        std::io::stdout().write_all(remaining_u8).unwrap();\n                    }\n                    return 0;\n                }\n            } else {\n                p += 1;\n            }\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn fremote(\n    mut fd: libc::c_int,\n    mut name: *const libc::c_char,\n) -> bool {\n    let mut remote: bool = 1 as libc::c_int != 0;\n    let mut buf: statfs = statfs {\n        f_type: 0,\n        f_bsize: 0,\n        f_blocks: 0,\n        f_bfree: 0,\n        f_bavail: 0,\n        f_files: 0,\n        f_ffree: 0,\n        f_fsid: __fsid_t { __val: [0; 2] },\n        f_namelen: 0,\n        f_frsize: 0,\n        f_flags: 0,\n        f_spare: [0; 4],\n    };\n    let mut err: libc::c_int = fstatfs(fd, &mut buf);\n    if err != 0 as libc::c_int {\n        if *__errno_location() != 38 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot determine location of %s. reverting to polling\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, name),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot determine location of %s. reverting to polling\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot determine location of %s. reverting to polling\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    } else {\n        let remote = is_local_fs_type(buf.f_type as u64) <= 0;\n    }\n    return remote;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn recheck(mut f: *mut File_spec, mut blocking: bool) {\n    let mut new_stats: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut is_stdin: bool = strcmp(\n        (*f).name,\n        b\"-\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int;\n    let mut was_tailable: bool = (*f).tailable;\n    let mut prev_errnum: libc::c_int = (*f).errnum;\n    let mut new_file: bool = false;\n    let mut fd: libc::c_int = if is_stdin as libc::c_int != 0 {\n        0 as libc::c_int\n    } else {\n        open_safer(\n            (*f).name,\n            0 as libc::c_int\n                | (if blocking as libc::c_int != 0 {\n                    0 as libc::c_int\n                } else {\n                    0o4000 as libc::c_int\n                }),\n        )\n    };\n    if valid_file_spec(f) {} else {\n        __assert_fail(\n            b\"valid_file_spec (f)\\0\" as *const u8 as *const libc::c_char,\n            b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n            987 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 40],\n                &[libc::c_char; 40],\n            >(b\"void recheck(struct File_spec *, _Bool)\\0\"))\n                .as_ptr(),\n        );\n    }\n    'c_13353: {\n        if valid_file_spec(f) {} else {\n            __assert_fail(\n                b\"valid_file_spec (f)\\0\" as *const u8 as *const libc::c_char,\n                b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                987 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 40],\n                    &[libc::c_char; 40],\n                >(b\"void recheck(struct File_spec *, _Bool)\\0\"))\n                    .as_ptr(),\n            );\n        }\n    };\n    (*f)\n        .tailable = !(reopen_inaccessible_files as libc::c_int != 0\n        && fd == -(1 as libc::c_int));\n    if !disable_inotify && lstat((*f).name, &mut new_stats) == 0\n        && new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o120000 as libc::c_int as libc::c_uint\n    {\n        let mut ok = false;\n(*f).errnum = -1;\n(*f).ignore = true;\n\nif false {\n    error(\n        0,\n        0,\n        gettext(b\"%s has been replaced with an untailable symbolic link\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    unreachable!();\n} else {\n    let __errstatus = 0;\n    error(\n        __errstatus,\n        0,\n        gettext(b\"%s has been replaced with an untailable symbolic link\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if __errstatus != 0 {\n        unreachable!();\n    }\n\n    let __errstatus = 0;\n    error(\n        __errstatus,\n        0,\n        gettext(b\"%s has been replaced with an untailable symbolic link\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if __errstatus != 0 {\n        unreachable!();\n    }\n}\n\n    } else if fd == -(1 as libc::c_int) || fstat(fd, &mut new_stats) < 0 as libc::c_int {\n        let ok = false; // Assuming this is the intended logic since 0 as libc::c_int != 0 is always false\nlet errnum = std::io::Error::last_os_error().raw_os_error().unwrap_or(0);\nlet f_ref = unsafe { &mut *f }; // Dereference the raw pointer\n\nf_ref.errnum = errnum;\n\nif !f_ref.tailable {\n    if was_tailable {\n        if false { // This condition is always false\n            error(\n                0,\n                f_ref.errnum,\n                gettext(b\"%s has become inaccessible\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            unreachable!();\n        } else {\n            let __errstatus = 0;\n            error(\n                __errstatus,\n                f_ref.errnum,\n                gettext(b\"%s has become inaccessible\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            if __errstatus != 0 {\n                unreachable!();\n            }\n\n            let __errstatus = 0;\n            error(\n                __errstatus,\n                f_ref.errnum,\n                gettext(b\"%s has become inaccessible\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            if __errstatus != 0 {\n                unreachable!();\n            }\n        }\n    }\n} else if prev_errnum != errnum {\n    if false { // This condition is always false\n        error(\n            0,\n            errnum,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            quotearg_n_style_colon(0, shell_escape_quoting_style, pretty_name(f)),\n        );\n        unreachable!();\n    } else {\n        let __errstatus = 0;\n        error(\n            __errstatus,\n            errnum,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            quotearg_n_style_colon(0, shell_escape_quoting_style, pretty_name(f)),\n        );\n        if __errstatus != 0 {\n            unreachable!();\n        }\n\n        let __errstatus = 0;\n        error(\n            __errstatus,\n            errnum,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            quotearg_n_style_colon(0, shell_escape_quoting_style, pretty_name(f)),\n        );\n        if __errstatus != 0 {\n            unreachable!();\n        }\n    }\n}\n\n    } else if !(new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        || new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o10000 as libc::c_int as libc::c_uint\n        || new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o140000 as libc::c_int as libc::c_uint\n        || new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o20000 as libc::c_int as libc::c_uint)\n    {\n        ok = 0 as libc::c_int != 0;\n        (*f).errnum = -(1 as libc::c_int);\n        (*f).tailable = 0 as libc::c_int != 0;\n        (*f)\n            .ignore = !(reopen_inaccessible_files as libc::c_int != 0\n            && follow_mode as libc::c_uint\n                == Follow_name as libc::c_int as libc::c_uint);\n        if was_tailable as libc::c_int != 0 || prev_errnum != (*f).errnum {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced with an untailable file%s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    if (*f).ignore as libc::c_int != 0 {\n                        gettext(\n                            b\"; giving up on this name\\0\" as *const u8\n                                as *const libc::c_char,\n                        ) as *const libc::c_char\n                    } else {\n                        b\"\\0\" as *const u8 as *const libc::c_char\n                    },\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has been replaced with an untailable file%s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_name(f),\n                        ),\n                        if (*f).ignore as libc::c_int != 0 {\n                            gettext(\n                                b\"; giving up on this name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ) as *const libc::c_char\n                        } else {\n                            b\"\\0\" as *const u8 as *const libc::c_char\n                        },\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has been replaced with an untailable file%s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_name(f),\n                        ),\n                        if (*f).ignore as libc::c_int != 0 {\n                            gettext(\n                                b\"; giving up on this name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ) as *const libc::c_char\n                        } else {\n                            b\"\\0\" as *const u8 as *const libc::c_char\n                        },\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    } else {\n        let remote = fremote(fd, pretty_name(f));\nif remote && !disable_inotify {\n    ok = false;\n    (*f).errnum = -1;\n    error(\n        0,\n        0,\n        gettext(\n            b\"%s has been replaced with an untailable remote file\\0\" as *const u8 as *const libc::c_char,\n        ),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if false {\n        unreachable!();\n    }\n    (*f).ignore = true;\n    (*f).remote = true;\n} else {\n    (*f).errnum = 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "\n    }\n    new_file = 0 as libc::c_int != 0;\n    if !ok {\n        close_fd(fd, pretty_name(f));\n        close_fd((*f).fd, pretty_name(f));\n        (*f).fd = -(1 as libc::c_int);\n    } else if prev_errnum != 0 && prev_errnum != 2 as libc::c_int {\n        new_file = 1 as libc::c_int != 0;\n        if (*f).fd == -(1 as libc::c_int) {} else {\n            __assert_fail(\n                b\"f->fd == -1\\0\" as *const u8 as *const libc::c_char,\n                b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                1064 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 40],\n                    &[libc::c_char; 40],\n                >(b\"void recheck(struct File_spec *, _Bool)\\0\"))\n                    .as_ptr(),\n            );\n        }\n        'c_12481: {\n            if (*f).fd == -(1 as libc::c_int) {} else {\n                __assert_fail(\n                    b\"f->fd == -1\\0\" as *const u8 as *const libc::c_char,\n                    b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                    1064 as libc::c_int as libc::c_uint,\n                    (*::core::mem::transmute::<\n                        &[u8; 40],\n                        &[libc::c_char; 40],\n                    >(b\"void recheck(struct File_spec *, _Bool)\\0\"))\n                        .as_ptr(),\n                );\n            }\n        };\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s has become accessible\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has become accessible\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has become accessible\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    } else if (*f).fd == -(1 as libc::c_int) {\n        let new_file = true;\n\nif false {\n    error(\n        0,\n        0,\n        gettext(b\"%s has appeared;  following new file\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    unreachable!();\n} else {\n    let errstatus = 0;\n    error(\n        errstatus,\n        0,\n        gettext(b\"%s has appeared;  following new file\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if errstatus != 0 {\n        unreachable!();\n    }\n\n    let errstatus = 0;\n    error(\n        errstatus,\n        0,\n        gettext(b\"%s has appeared;  following new file\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if errstatus != 0 {\n        unreachable!();\n    }\n}\n\n    } else if (*f).ino != new_stats.st_ino || (*f).dev != new_stats.st_dev {\n        let new_file = true;\n\nif false {\n    error(\n        0,\n        0,\n        gettext(b\"%s has been replaced; following new file\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if false {\n        unreachable!();\n    }\n} else {\n    let errstatus = 0;\n    error(\n        errstatus,\n        0,\n        gettext(b\"%s has been replaced; following new file\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if errstatus != 0 {\n        unreachable!();\n    }\n\n    let errstatus = 0;\n    error(\n        errstatus,\n        0,\n        gettext(b\"%s has been replaced; following new file\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if errstatus != 0 {\n        unreachable!();\n    }\n}\n\nclose_fd(unsafe { (*f).fd }, pretty_name(f));\n\n    } else {\n        close_fd(fd, pretty_name(f));\n    }\n    if new_file {\n        let blocking_value = if is_stdin as libc::c_int != 0 {\n    -(1 as libc::c_int)\n} else {\n    blocking as libc::c_int\n};\nrecord_open_fd(\n    &mut *f,\n    fd,\n    0,\n    &new_stats,\n    blocking_value,\n);\n        if new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o100000 as libc::c_int as libc::c_uint\n        {\n            xlseek(fd, 0 as libc::c_int as off_t, 0 as libc::c_int, pretty_name(f));\n        }\n    }\n}\nunsafe extern \"C\" fn any_live_files(\n    mut f: *const File_spec,\n    mut n_files: size_t,\n) -> bool {\n    if reopen_inaccessible_files as libc::c_int != 0\n        && follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n    {\n        return 1 as libc::c_int != 0;\n    }\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if 0 as libc::c_int <= (*f.offset(i as isize)).fd {\n            return 1 as libc::c_int != 0\n        } else if !(*f.offset(i as isize)).ignore\n            && reopen_inaccessible_files as libc::c_int != 0\n        {\n            return 1 as libc::c_int != 0\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}\nfn writers_are_dead() -> bool {\n    unsafe {\n        if nbpids == 0 {\n            return false;\n        }\n        for i in 0..nbpids {\n            let pid = *pids.offset(i as isize); // Accessing the raw pointer safely\n            if std::process::Command::new(\"kill\").arg(\"-0\").arg(pid.to_string()).status().is_err() {\n                return false;\n            }\n        }\n    }\n    true\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn tail_forever(\n    mut f: *mut File_spec,\n    mut n_files: size_t,\n    mut sleep_interval: libc::c_double,\n) {\n    let blocking: bool = nbpids == 0\n    && follow_mode == Follow_descriptor\n    && n_files == 1\n    && unsafe { (*f).fd } != -1\n    && (unsafe { (*f).mode & 0o170000 } != 0o100000);\n\nlet mut last: u64 = n_files.wrapping_sub(1);\nlet mut writers_dead: bool = false;\n\nloop {\n     /*\nThe variables live at this point are:\n(mut f: *mut File_spec, mut n_files: u64, mut sleep_interval: f64, mut blocking: bool, mut last: u64, mut writers_dead: bool)\n*/\nlet mut i: u64 = 0;\nlet mut any_input: bool = false;\nlet mut current_block_47: u64;\ni = 0;\nwhile i < n_files {\n     let mut fd: i32 = 0;\nlet mut name: *const libc::c_char = std::ptr::null();\nlet mut mode: u32 = 0;\nlet mut stats: stat = unsafe { std::mem::zeroed() }; // Initialize to zero\nlet mut bytes_read: u64 = 0;\n\nif !unsafe { (*f.offset(i as isize)).ignore } {\n    if unsafe { (*f.offset(i as isize)).fd } < 0 {\n        recheck(&mut *f.offset(i as isize), blocking);\n    } else {\n         fd = (*f.offset(i as isize)).fd;\n                    name = pretty_name(&mut *f.offset(i as isize));\n                    mode = (*f.offset(i as isize)).mode;\n                    if (*f.offset(i as isize)).blocking != blocking as libc::c_int {\n                        let mut old_flags: libc::c_int = rpl_fcntl(fd, 3 as libc::c_int);\n                        let mut new_flags: libc::c_int = old_flags\n                            | (if blocking as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                0o4000 as libc::c_int\n                            });\n                        if old_flags < 0 as libc::c_int\n                            || new_flags != old_flags\n                                && rpl_fcntl(fd, 4 as libc::c_int, new_flags)\n                                    == -(1 as libc::c_int)\n                        {\n                            if !((*f.offset(i as isize)).mode\n                                & 0o170000 as libc::c_int as libc::c_uint\n                                == 0o100000 as libc::c_int as libc::c_uint\n                                && *__errno_location() == 1 as libc::c_int)\n                            {\n                                if 0 != 0 {\n                                    error(\n                                        1 as libc::c_int,\n                                        *__errno_location(),\n                                        gettext(\n                                            b\"%s: cannot change nonblocking mode\\0\" as *const u8\n                                                as *const libc::c_char,\n                                        ),\n                                        quotearg_n_style_colon(\n                                            0 as libc::c_int,\n                                            shell_escape_quoting_style,\n                                            name,\n                                        ),\n                                    );\n                                    if 1 as libc::c_int != 0 as libc::c_int {\n                                        unreachable!();\n                                    } else {};\n                                } else {\n                                    ({\n                                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                                        error(\n                                            __errstatus,\n                                            *__errno_location(),\n                                            gettext(\n                                                b\"%s: cannot change nonblocking mode\\0\" as *const u8\n                                                    as *const libc::c_char,\n                                            ),\n                                            quotearg_n_style_colon(\n                                                0 as libc::c_int,\n                                                shell_escape_quoting_style,\n                                                name,\n                                            ),\n                                        );\n                                        if __errstatus != 0 as libc::c_int {\n                                            unreachable!();\n                                        } else {};\n                                        \n                                    });\n                                    ({\n                                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                                        error(\n                                            __errstatus,\n                                            *__errno_location(),\n                                            gettext(\n                                                b\"%s: cannot change nonblocking mode\\0\" as *const u8\n                                                    as *const libc::c_char,\n                                            ),\n                                            quotearg_n_style_colon(\n                                                0 as libc::c_int,\n                                                shell_escape_quoting_style,\n                                                name,\n                                            ),\n                                        );\n                                        if __errstatus != 0 as libc::c_int {\n                                            unreachable!();\n                                        } else {};\n                                        \n                                    });\n                                };\n                            }\n                        } else {\n                            (*f.offset(i as isize)).blocking = blocking as libc::c_int;\n                        }\n                    }\n                    let mut read_unchanged: bool = 0 as libc::c_int != 0;\n                    if (*f.offset(i as isize)).blocking == 0 {\n                        if fstat(fd, &mut stats) != 0 as libc::c_int {\n                            let file_spec = &mut *f.offset(i as isize);\nfile_spec.fd = -1;\nfile_spec.errnum = std::io::Error::last_os_error().raw_os_error().unwrap_or(0);\n\nif false {\n    error(\n        0,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        b\"%s\\0\".as_ptr() as *const i8,\n        quotearg_n_style_colon(0, shell_escape_quoting_style, name),\n    );\n    if false {\n        unreachable!();\n    }\n} else {\n    let errstatus = 0;\n    error(\n        errstatus,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        b\"%s\\0\".as_ptr() as *const i8,\n        quotearg_n_style_colon(0, shell_escape_quoting_style, name),\n    );\n    if errstatus != 0 {\n        unreachable!();\n    }\n\n    let errstatus = 0;\n    error(\n        errstatus,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        b\"%s\\0\".as_ptr() as *const i8,\n        quotearg_n_style_colon(0, shell_escape_quoting_style, name),\n    );\n    if errstatus != 0 {\n        unreachable!();\n    }\n}\n\nclose(fd);\ncurrent_block_47 = 17778012151635330486;\n\n                        } else {\n                            let file_spec = unsafe { &mut *f.offset(i as isize) };\nif file_spec.mode == stats.st_mode\n    && (!(stats.st_mode & 0o170000 == 0o100000)\n        || file_spec.size == stats.st_size)\n    && timespec_cmp(file_spec.mtime, get_stat_mtime(&stats)) == 0\n{\n    let fresh1 = &mut file_spec.n_unchanged_stats;\n    let fresh2 = *fresh1;\n    *fresh1 = fresh1.wrapping_add(1);\n    \n    if max_n_unchanged_stats_between_opens <= fresh2\n        && follow_mode == Follow_name\n    {\n        recheck(file_spec, file_spec.blocking != 0);\n        file_spec.n_unchanged_stats = 0;\n    }\n    \n    if fd != file_spec.fd\n        || stats.st_mode & 0o170000 == 0o100000\n        || 1 < n_files\n    {\n        current_block_47 = 17778012151635330486;\n    } else {\n        read_unchanged = true;\n        current_block_47 = 8693738493027456495;\n    }\n} else {\n    current_block_47 = 8693738493027456495;\n}\n\n                            match current_block_47 {\n    17778012151635330486 => {}\n    _ => {\n        let file = &mut *f.offset(i as isize);\n        if fd != file.fd {\n            panic!(\"fd == f[i].fd\");\n        }\n\n        file.mtime = get_stat_mtime(&mut stats);\n        file.mode = stats.st_mode;\n\n        if !read_unchanged {\n            file.n_unchanged_stats = 0;\n        }\n\n        if (mode & 0o170000) == 0o100000 && stats.st_size < file.size {\n            error(\n                0,\n                0,\n                gettext(b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char),\n                quotearg_n_style_colon(0, shell_escape_quoting_style, name),\n            );\n\n            xlseek(fd, 0, 0, name);\n            file.size = 0;\n        }\n\n        if i != last {\n            if print_headers {\n                write_header(name);\n            }\n            last = i;\n        }\n        current_block_47 = 3222590281903869779;\n    }\n}\n\n                        }\n                    } else {\n                        current_block_47 = 3222590281903869779;\n                    }\n                    match current_block_47 {\n                        17778012151635330486 => {}\n                        _ => {\n                            let mut bytes_to_read: uintmax_t = 0;\n                            if (*f.offset(i as isize)).blocking != 0 {\n                                bytes_to_read = (18446744073709551615 as libc::c_ulong)\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong);\n                            } else if mode & 0o170000 as libc::c_int as libc::c_uint\n                                == 0o100000 as libc::c_int as libc::c_uint\n                                && (*f.offset(i as isize)).remote as libc::c_int != 0\n                            {\n                                bytes_to_read = (stats.st_size\n                                    - (*f.offset(i as isize)).size) as uintmax_t;\n                            } else {\n                                bytes_to_read = 18446744073709551615 as libc::c_ulong;\n                            }\n                            bytes_read = dump_remainder(\n                                0 as libc::c_int != 0,\n                                name,\n                                fd,\n                                bytes_to_read,\n                            );\n                            if read_unchanged as libc::c_int != 0 && bytes_read != 0 {\n                                (*f.offset(i as isize))\n                                    .n_unchanged_stats = 0 as libc::c_int as uintmax_t;\n                            }\n                            any_input = (any_input as libc::c_int\n                                | (bytes_read != 0 as libc::c_int as libc::c_ulong)\n                                    as libc::c_int) != 0;\n                            let ref mut fresh3 = (*f.offset(i as isize)).size;\n                            *fresh3 = (*fresh3 as libc::c_ulong).wrapping_add(bytes_read)\n                                as off_t as off_t;\n                        }\n                    }\n\n    }\n}\ni = i.wrapping_add(1);\ni;\n\n\n}\nif !any_live_files(f, n_files) {\n    let errstatus: libc::c_int = 0;\n    error(\n        errstatus,\n        0,\n        gettext(b\"no files remaining\\0\" as *const u8 as *const libc::c_char),\n    );\n    if errstatus != 0 {\n        unreachable!();\n    }\n    break;\n} else {\n    if (!any_input || blocking) && fflush_unlocked(stdout) != 0 {\n        write_error();\n    }\n    check_output_alive();\n    if any_input {\n        continue;\n    }\n    if writers_dead {\n        break;\n    }\n    writers_dead = writers_are_dead();",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "    if !writers_dead && xnanosleep(sleep_interval) != 0 {\n        let errstatus: libc::c_int = 1;\n        error(\n            errstatus,\n            *__errno_location(),\n            gettext(b\"cannot read realtime clock\\0\" as *const u8 as *const libc::c_char),\n        );\n        if errstatus != 0 {\n            unreachable!();\n        }\n    }\n}\n/*\nThe variables live at this point are:\n(mut f: *mut File_spec, mut n_files: u64, mut sleep_interval: f64, mut blocking: bool, mut last: u64, mut writers_dead: bool, mut i: u64, mut any_input: bool, mut current_block_47: u64, writers_dead: bool)\n*/\n\n\n};\n/*\nThe variables live at this point are:\n(mut f: *mut File_spec, mut n_files: u64, mut sleep_interval: f64)\n*/\n\n}\nfn any_remote_file(f: *const File_spec, n_files: u64) -> bool {\n    let n_files_usize: usize = n_files.try_into().expect(\"Conversion to usize failed\");\n    let slice = unsafe { std::slice::from_raw_parts(f, n_files_usize) };\n    for file in slice.iter() {\n        if file.fd >= 0 && file.remote {\n            return true;\n        }\n    }\n    false\n}\nfn any_non_remote_file(f: *const File_spec, n_files: u64) -> bool {\n    let slice = unsafe { std::slice::from_raw_parts(f, n_files as usize) };\n    for file in slice.iter() {\n        if file.fd >= 0 && !file.remote {\n            return true;\n        }\n    }\n    false\n}\nunsafe extern \"C\" fn any_symlinks(mut f: *const File_spec, mut n_files: size_t) -> bool {\n    let mut st: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if lstat((*f.offset(i as isize)).name, &mut st) == 0 as libc::c_int\n            && st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o120000 as libc::c_int as libc::c_uint\n        {\n            return 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}\nfn any_non_regular_fifo(f: *const File_spec, n_files: u64) -> bool {\n    let n_files_usize: usize = n_files.try_into().unwrap();\n    let slice = unsafe { std::slice::from_raw_parts(f, n_files_usize) };\n    for file in slice.iter() {\n        if file.fd >= 0\n            && !(file.mode & 0o170000 == 0o100000)\n            && !(file.mode & 0o170000 == 0o10000)\n        {\n            return true;\n        }\n    }\n    false\n}\nunsafe extern \"C\" fn tailable_stdin(\n    mut f: *const File_spec,\n    mut n_files: size_t,\n) -> bool {\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if !(*f.offset(i as isize)).ignore\n            && strcmp(\n                (*f.offset(i as isize)).name,\n                b\"-\\0\" as *const u8 as *const libc::c_char,\n            ) == 0 as libc::c_int\n        {\n            return 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn wd_hasher(\n    mut entry: *const libc::c_void,\n    mut tabsize: size_t,\n) -> size_t {\n    let mut spec: *const File_spec = entry as *const File_spec;\n    return ((*spec).wd as libc::c_ulong).wrapping_rem(tabsize);\n}\nunsafe extern \"C\" fn wd_comparator(\n    e1: *const libc::c_void,\n    e2: *const libc::c_void,\n) -> bool {\n    let spec1 = &*(e1 as *const File_spec);\n    let spec2 = &*(e2 as *const File_spec);\n    spec1.wd == spec2.wd\n}\nunsafe extern \"C\" fn check_fspec(\n    mut fspec: *mut File_spec,\n    mut prev_fspec: *mut *mut File_spec,\n) {\n    let mut stats: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut name: *const libc::c_char = 0 as *const libc::c_char;\n    if (*fspec).fd == -(1 as libc::c_int) {\n        return;\n    }\n    name = pretty_name(fspec);\n    if fstat((*fspec).fd, &mut stats) != 0 as libc::c_int {\n        (*fspec).errnum = *__errno_location();\n        close_fd((*fspec).fd, name);\n        (*fspec).fd = -(1 as libc::c_int);\n        return;\n    }\n    if (*fspec).mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint && stats.st_size < (*fspec).size\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char),\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    name,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        xlseek((*fspec).fd, 0 as libc::c_int as off_t, 0 as libc::c_int, name);\n        (*fspec).size = 0 as libc::c_int as off_t;\n    } else if (*fspec).mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint && stats.st_size == (*fspec).size\n        && timespec_cmp((*fspec).mtime, get_stat_mtime(&mut stats)) == 0 as libc::c_int\n    {\n        return\n    }\n    let mut want_header: bool = print_headers as libc::c_int != 0\n        && fspec != *prev_fspec;\n    let mut bytes_read: uintmax_t = dump_remainder(\n        want_header,\n        name,\n        (*fspec).fd,\n        18446744073709551615 as libc::c_ulong,\n    );\n    (*fspec)\n        .size = ((*fspec).size as libc::c_ulong).wrapping_add(bytes_read) as off_t\n        as off_t;\n    if bytes_read != 0 {\n        *prev_fspec = fspec;\n        if fflush_unlocked(stdout) != 0 as libc::c_int {\n            write_error();\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn tail_forever_inotify(\n    mut wd: libc::c_int,\n    mut f: *mut File_spec,\n    mut n_files: size_t,\n    mut sleep_interval: libc::c_double,\n    mut wd_to_namep: *mut *mut Hash_table,\n) {\n    let mut max_realloc: libc::c_uint = 3 as libc::c_int as libc::c_uint;\n    let mut wd_to_name: *mut Hash_table = 0 as *mut Hash_table;\n    let mut found_watchable_file: bool = 0 as libc::c_int != 0;\n    let mut tailed_but_unwatchable: bool = 0 as libc::c_int != 0;\n    let mut found_unwatchable_dir: bool = 0 as libc::c_int != 0;\n    let mut no_inotify_resources: bool = 0 as libc::c_int != 0;\n    let mut writers_dead: bool = 0 as libc::c_int != 0;\n    let mut prev_fspec: *mut File_spec = 0 as *mut File_spec;\n    let mut evlen: size_t = 0 as libc::c_int as size_t;\n    let mut evbuf: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut evbuf_off: size_t = 0 as libc::c_int as size_t;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    wd_to_name = hash_initialize(\n        n_files,\n        0 as *const Hash_tuning,\n        Some(wd_hasher as unsafe extern \"C\" fn(*const libc::c_void, size_t) -> size_t),\n        Some(\n            wd_comparator\n                as unsafe extern \"C\" fn(*const libc::c_void, *const libc::c_void) -> bool,\n        ),\n        None,\n    );\n    if wd_to_name.is_null() {\n        xalloc_die();\n    }\n    *wd_to_namep = wd_to_name;\n    let mut inotify_wd_mask: uint32_t = 0x2 as libc::c_int as uint32_t;\n    if follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint {\n        inotify_wd_mask\n            |= (0x4 as libc::c_int | 0x400 as libc::c_int | 0x800 as libc::c_int)\n                as libc::c_uint;\n    }\n    let mut i: size_t = 0;\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if !(*f.offset(i as isize)).ignore {\n            let fnlen: usize = unsafe { CStr::from_ptr((*f.offset(i as isize)).name).to_bytes().len() };\nif evlen < fnlen as u64 {\n    evlen = fnlen as u64;\n}\nunsafe { (*f.offset(i as isize)).wd = -1 };\nif follow_mode == Follow_name {\n    let name_ptr = unsafe { (*f.offset(i as isize)).name };\n    let dirlen: usize = dir_len(name_ptr).try_into().unwrap();\n    let prev: i8 = unsafe { *name_ptr.offset(dirlen as isize) };\n    unsafe {\n        (*f.offset(i as isize)).basename_start = last_component(name_ptr)\n            .offset_from(name_ptr) as u64;\n        *name_ptr.offset(dirlen as isize) = 0;\n    }\n    unsafe {\n        (*f.offset(i as isize)).parent_wd = inotify_add_watch(\n            wd,\n            if dirlen != 0 {\n                name_ptr\n            } else {\n                b\".\\0\" as *const u8 as *const libc::c_char\n            },\n            (0x100 | 0x200 | 0x80 | 0x4 | 0x400) as u32,\n        );\n        *name_ptr.offset(dirlen as isize) = prev;\n    }\n    if unsafe { (*f.offset(i as isize)).parent_wd } < 0 {\n        if *__errno_location() != 28 {\n            error(\n                0,\n                *__errno_location(),\n                gettext(b\"cannot watch parent directory of %s\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 0 != 0 {\n                unreachable!();\n            }\n        } else {\n            error(\n                0,\n                0,\n                gettext(b\"inotify resources exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 0 != 0 {\n                unreachable!();\n            }\n        }\n        found_unwatchable_dir = true;\n        break;\n    }\n}\nunsafe {\n    (*f.offset(i as isize)).wd = inotify_add_watch(\n        wd,\n        (*f.offset(i as isize)).name,\n        inotify_wd_mask,\n    );\n}\n\n            if unsafe { (*f.offset(i as isize)).wd } < 0 {\n    if unsafe { (*f.offset(i as isize)).fd } != -1 {\n        tailed_but_unwatchable = true;\n    }\n    let errno = std::io::Error::last_os_error().raw_os_error().unwrap_or(0);\n    if errno == 28 || errno == 12 {\n        no_inotify_resources = true;\n        error(\n            0,\n            0,\n            gettext(b\"inotify resources exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        break;\n    } else if errno != unsafe { (*f.offset(i as isize)).errnum } {\n        error(\n            0,\n            errno,\n            gettext(b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char),\n            quotearg_style(shell_escape_always_quoting_style, unsafe { (*f.offset(i as isize)).name }),\n        );\n    }\n} else {\n    if hash_insert(wd_to_name, unsafe { &*f.offset(i as isize) as *const File_spec as *const libc::c_void }).is_null() {\n        xalloc_die();\n    }\n    found_watchable_file = true;\n}\n\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    if no_inotify_resources as libc::c_int != 0\n        || found_unwatchable_dir as libc::c_int != 0\n        || follow_mode as libc::c_uint\n            == Follow_descriptor as libc::c_int as libc::c_uint\n            && tailed_but_unwatchable as libc::c_int != 0\n    {\n        return;\n    }\n    if follow_mode as libc::c_uint == Follow_descriptor as libc::c_int as libc::c_uint\n        && !found_watchable_file\n    {\n        exit(1 as libc::c_int);\n    }\n    prev_fspec = &mut *f\n        .offset(n_files.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n        as *mut File_spec;\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if !(*f.offset(i as isize)).ignore {\n            if follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n            {\n                recheck(&mut *f.offset(i as isize), 0 as libc::c_int != 0);\n            } else if (*f.offset(i as isize)).fd != -(1 as libc::c_int) {\n                let mut stats: stat = stat {\n                    st_dev: 0,\n                    st_ino: 0,\n                    st_mode: 0,\n                    st_nlink: 0,\n                    st_uid: 0,\n                    st_gid: 0,\n                    st_rdev: 0,\n                    __pad1: 0,\n                    st_size: 0,\n                    st_blksize: 0,\n                    __pad2: 0,\n                    st_blocks: 0,\n                    st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    __glibc_reserved: [0; 2],\n                };\n                if stat((*f.offset(i as isize)).name, &mut stats) == 0 as libc::c_int\n                    && ((*f.offset(i as isize)).dev != stats.st_dev\n                        || (*f.offset(i as isize)).ino != stats.st_ino)\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"%s was replaced\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(&mut *f.offset(i as isize)),\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"%s was replaced\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    pretty_name(&mut *f.offset(i as isize)),\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"%s was replaced\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    pretty_name(&mut *f.offset(i as isize)),\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    return;\n                }\n            }\n            check_fspec(&mut *f.offset(i as isize), &mut prev_fspec);\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    evlen = (evlen as libc::c_ulong)\n        .wrapping_add(\n            (::core::mem::size_of::<inotify_event>() as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong),\n        ) as size_t as size_t;\n    evbuf = xmalloc(evlen) as *mut libc::c_char;\n    loop {\n        let mut fspec: *mut File_spec = std::ptr::null_mut();\nlet mut ev: *mut inotify_event = std::ptr::null_mut();\n\nif follow_mode == Follow_name && !reopen_inaccessible_files && hash_get_n_entries(wd_to_name) == 0 {\n    if false {\n        error(1, 0, gettext(b\"no files remaining\\0\" as *const u8 as *const libc::c_char));\n        unreachable!();\n    } else {\n        let __errstatus: i32 = 1;\n        error(__errstatus, 0, gettext(b\"no files remaining\\0\" as *const u8 as *const libc::c_char));\n        if __errstatus != 0 {\n            unreachable!();\n        }\n    }\n}\n\nif len <= evbuf_off {\n     let mut file_change: libc::c_int = 0;\n            let mut pfd: [pollfd; 2] = [pollfd {\n                fd: 0,\n                events: 0,\n                revents: 0,\n            }; 2];\n            loop {\n                let mut delay: libc::c_int = -(1 as libc::c_int);\n                if nbpids != 0 {\n                    if writers_dead {\n                        exit(0 as libc::c_int);\n                    }\n                    let writers_dead = writers_are_dead();\n                    if writers_dead as libc::c_int != 0\n                        || sleep_interval <= 0 as libc::c_int as libc::c_double\n                    {\n                        delay = 0 as libc::c_int;\n                    } else if sleep_interval\n                        < (2147483647 as libc::c_int / 1000 as libc::c_int\n                            - 1 as libc::c_int) as libc::c_double\n                    {\n                        let mut ddelay: libc::c_double = sleep_interval\n                            * 1000 as libc::c_int as libc::c_double;\n                        delay = ddelay as libc::c_int;\n                        delay += ((delay as libc::c_double) < ddelay) as libc::c_int;\n                    }\n                }\n                pfd[0 as libc::c_int as usize].fd = wd;\n                pfd[0 as libc::c_int as usize]\n                    .events = 0x1 as libc::c_int as libc::c_short;\n                pfd[1 as libc::c_int as usize].fd = 1 as libc::c_int;\n                pfd[1 as libc::c_int as usize]\n                    .revents = 0 as libc::c_int as libc::c_short;\n                pfd[1 as libc::c_int as usize]\n                    .events = pfd[1 as libc::c_int as usize].revents;\n                file_change = poll(\n                    pfd.as_mut_ptr(),",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "                    (monitor_output as libc::c_int + 1 as libc::c_int) as nfds_t,\n                    delay,\n                );\n                if !(file_change == 0 as libc::c_int) {\n                    break;\n                }\n            }\n            if file_change < 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"error waiting for inotify and output events\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error waiting for inotify and output events\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error waiting for inotify and output events\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            if pfd[1 as libc::c_int as usize].revents != 0 {\n                die_pipe();\n            }\n            len = safe_read(wd, evbuf as *mut libc::c_void, evlen);\n            evbuf_off = 0 as libc::c_int as size_t;\n\n    \n     if (len == 0 || len == u64::MAX && std::io::Error::last_os_error().raw_os_error() == Some(22)) && {\n    let fresh4 = max_realloc;\n    max_realloc = max_realloc.wrapping_sub(1);\n    fresh4 != 0\n} {\n    len = 0;\n    evlen = evlen.wrapping_mul(2);\n    evbuf = xrealloc(evbuf as *mut libc::c_void, evlen) as *mut i8;\n    continue;\n} else if len == 0 || len == u64::MAX {\n    let __errstatus: i32 = 1;\n    error(__errstatus, std::io::Error::last_os_error().raw_os_error().unwrap_or(0), CString::new(\"error reading inotify event\").unwrap().as_ptr());\n    if __errstatus != 0 {\n        unreachable!();\n    }\n    \n    error(__errstatus, std::io::Error::last_os_error().raw_os_error().unwrap_or(0), CString::new(\"error reading inotify event\").unwrap().as_ptr());\n    if __errstatus != 0 {\n        unreachable!();\n    }\n}\n\n\n}\n\nlet void_ev = unsafe { evbuf.add(evbuf_off as usize) } as *mut libc::c_void;\nev = void_ev as *mut inotify_event;\nevbuf_off += (std::mem::size_of::<inotify_event>() as u64 + (*ev).len as u64);\n\nif (*ev).mask & 0x400 != 0 && (*ev).len == 0 {\n    let mut i: usize = 0;\n    while i < n_files as usize {\n        if (*ev).wd == unsafe { (*f.offset(i as isize)).parent_wd } {\n            if false {\n                error(0, 0, gettext(b\"directory containing watched file was removed\\0\" as *const u8 as *const libc::c_char));\n                unreachable!();\n            } else {\n                let __errstatus: i32 = 0;\n                error(__errstatus, 0, gettext(b\"directory containing watched file was removed\\0\" as *const u8 as *const libc::c_char));\n                if __errstatus != 0 {\n                    unreachable!();\n                }\n            }\n            return;\n        }\n        i += 1;\n    }\n}\n\nif (*ev).len != 0 {\n     let mut j: size_t = 0;\n            j = 0 as libc::c_int as size_t;\n            while j < n_files {\n                if (*f.offset(j as isize)).parent_wd == (*ev).wd\n                    && strcmp(\n                        ((*ev).name).as_mut_ptr(),\n                        ((*f.offset(j as isize)).name)\n                            .offset((*f.offset(j as isize)).basename_start as isize),\n                    ) == 0 as libc::c_int\n                {\n                    break;\n                }\n                j = j.wrapping_add(1);\n                j;\n            }\n            if j == n_files {\n                continue;\n            }\n            fspec = &mut *f.offset(j as isize) as *mut File_spec;\n            let mut new_wd: libc::c_int = -(1 as libc::c_int);\n            let mut deleting: bool = (*ev).mask & 0x200 as libc::c_int as libc::c_uint\n                != 0;\n            if !deleting {\n                new_wd = inotify_add_watch(\n                    wd,\n                    (*f.offset(j as isize)).name,\n                    inotify_wd_mask,\n                );\n            }\n            if !deleting && new_wd < 0 as libc::c_int {\n                if *__errno_location() == 28 as libc::c_int\n                    || *__errno_location() == 12 as libc::c_int\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"inotify resources exhausted\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"inotify resources exhausted\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"inotify resources exhausted\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    return;\n                } else {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                (*f.offset(j as isize)).name,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    (*f.offset(j as isize)).name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    (*f.offset(j as isize)).name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n            }\n            let mut new_watch: bool = false;\n            new_watch = !deleting\n                && ((*fspec).wd < 0 as libc::c_int || new_wd != (*fspec).wd);\n\n    \n     if new_watch {\n    if unsafe { (*fspec).wd } >= 0 {\n        inotify_rm_watch(wd, unsafe { (*fspec).wd });\n        hash_remove(wd_to_name, fspec as *const libc::c_void);\n    }\n    unsafe { (*fspec).wd = new_wd };\n    if new_wd == -1 {\n        continue;\n    }\n    let prev = hash_remove(wd_to_name, fspec as *const libc::c_void) as *mut File_spec;\n    if !prev.is_null() && prev != fspec {\n        if follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint {\n            recheck(prev, false);\n        }\n        unsafe {\n            (*prev).wd = -1;\n            close_fd((*prev).fd, pretty_name(prev));\n        }\n    }\n    if hash_insert(wd_to_name, fspec as *const libc::c_void).is_null() {\n        xalloc_die();\n    }\n}\nif follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint {\n    recheck(fspec, false);\n}\n\n\n} else {\n     let mut key = File_spec {\n    name: std::ptr::null_mut(),\n    size: 0,\n    mtime: timespec { tv_sec: 0, tv_nsec: 0 },\n    dev: 0,\n    ino: 0,\n    mode: 0,\n    ignore: false,\n    remote: false,\n    tailable: false,\n    fd: 0,\n    errnum: 0,\n    blocking: 0,\n    wd: 0,\n    parent_wd: 0,\n    basename_start: 0,\n    n_unchanged_stats: 0,\n};\n\nkey.wd = unsafe { (*ev).wd };\n\nfspec = hash_lookup(wd_to_name, &key as *const File_spec as *const libc::c_void) as *mut File_spec;",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "\n\n}\n\nif fspec.is_null() {\n    continue;\n}\n\nif (*ev).mask & (0x4 | 0x200 | 0x400 | 0x800) != 0 {\n    if (*ev).mask & 0x400 != 0 {\n        inotify_rm_watch(wd, (*fspec).wd);\n        hash_remove(wd_to_name, fspec as *const libc::c_void);\n    }\n    recheck(fspec, false);\n} else {\n    check_fspec(fspec, &mut prev_fspec);\n}\n\n/*\nThe variables live at this point are:\n(mut wd: i32, mut f: *mut File_spec, mut n_files: u64, mut sleep_interval: f64, mut max_realloc: u32, mut wd_to_name: *mut hash_table, mut writers_dead: bool, mut prev_fspec: *mut File_spec, mut evlen: u64, mut evbuf: *mut i8, mut evbuf_off: u64, mut len: u64, mut inotify_wd_mask: u32, mut i: u64, mut fspec: *mut File_spec, mut ev: *mut inotify_event, mut void_ev: *mut libc::c_void)\n*/\n\n    };\n}\nunsafe extern \"C\" fn tail_bytes(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    use std::fs::File;\nuse std::os::unix::fs::MetadataExt;\nuse std::io;\n\nlet mut stats: stat = unsafe { std::mem::zeroed() }; // Create a zeroed stat struct\n\nif unsafe { fstat(fd, &mut stats as *mut _ as *mut stat) } != 0 {\n    let err_code = unsafe { *__errno_location() };\n    error(\n        0,\n        err_code,\n        gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n    );\n    return false; // Return false instead of 0\n}\n\n/*\nThe variables live at this point are:\n(pretty_filename: *const i8, fd: i32, stats: stat)\n*/\n\n    if from_start {\n        if !presume_input_pipe\n            && n_bytes\n                <= (if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                    -(1 as libc::c_int) as off_t\n                } else {\n                    (((1 as libc::c_int as off_t)\n                        << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long\n                }) as libc::c_ulong\n            && (stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint\n                && xlseek(fd, n_bytes as off_t, 1 as libc::c_int, pretty_filename)\n                    >= 0 as libc::c_int as libc::c_long\n                || lseek(fd, n_bytes as __off_t, 1 as libc::c_int)\n                    != -(1 as libc::c_int) as libc::c_long)\n        {\n            *read_pos = (*read_pos as libc::c_ulong).wrapping_add(n_bytes) as uintmax_t\n                as uintmax_t;\n        } else {\n            let mut t: libc::c_int = start_bytes(pretty_filename, fd, n_bytes, read_pos);\n            if t != 0 {\n                return t < 0 as libc::c_int;\n            }\n        }\n        n_bytes = 18446744073709551615 as libc::c_ulong;\n    } else {\n        let mut end_pos: off_t = -(1 as libc::c_int) as off_t;\n        let mut current_pos: off_t = -(1 as libc::c_int) as off_t;\n        let mut copy_from_current_pos: bool = 0 as libc::c_int != 0;\n        if !presume_input_pipe\n            && n_bytes\n                <= (if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                    -(1 as libc::c_int) as off_t\n                } else {\n                    (((1 as libc::c_int as off_t)\n                        << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long\n                }) as libc::c_ulong\n        {\n            if usable_st_size(&mut stats) {\n                end_pos = stats.st_size;\n                let mut smallish_size: off_t = (if (0 as libc::c_int) < stats.st_blksize\n                    && stats.st_blksize as libc::c_ulong\n                        <= (-(1 as libc::c_int) as size_t)\n                            .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                {\n                    stats.st_blksize\n                } else {\n                    512 as libc::c_int\n                }) as off_t;\n                copy_from_current_pos = smallish_size < end_pos;\n            } else {\n                current_pos = lseek(\n                    fd,\n                    n_bytes.wrapping_neg() as __off_t,\n                    2 as libc::c_int,\n                );\n                copy_from_current_pos = current_pos\n                    != -(1 as libc::c_int) as libc::c_long;\n                if copy_from_current_pos {\n                    end_pos = (current_pos as libc::c_ulong).wrapping_add(n_bytes)\n                        as off_t;\n                }\n            }\n        }\n        if !copy_from_current_pos {\n            return pipe_bytes(pretty_filename, fd, n_bytes, read_pos);\n        }\n        if current_pos == -(1 as libc::c_int) as libc::c_long {\n            current_pos = xlseek(\n                fd,\n                0 as libc::c_int as off_t,\n                1 as libc::c_int,\n                pretty_filename,\n            );\n        }\n        if current_pos < end_pos {\n            let mut bytes_remaining: off_t = end_pos - current_pos;\n            if n_bytes < bytes_remaining as libc::c_ulong {\n                current_pos = (end_pos as libc::c_ulong).wrapping_sub(n_bytes) as off_t;\n                xlseek(fd, current_pos, 0 as libc::c_int, pretty_filename);\n            }\n        }\n        *read_pos = current_pos as uintmax_t;\n    }\n    *read_pos = (*read_pos as libc::c_ulong)\n        .wrapping_add(\n            dump_remainder(0 as libc::c_int != 0, pretty_filename, fd, n_bytes),\n        ) as uintmax_t as uintmax_t;\n    return 1 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn tail_lines(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_lines: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    let mut stats: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    if fstat(fd, &mut stats) != 0 {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    if from_start {\n        let mut t: libc::c_int = start_lines(pretty_filename, fd, n_lines.try_into().unwrap(), read_pos);\n        if t != 0 {\n            return t < 0 as libc::c_int;\n        }\n        *read_pos = (*read_pos as libc::c_ulong)\n            .wrapping_add(\n                dump_remainder(\n                    0 as libc::c_int != 0,\n                    pretty_filename,\n                    fd,\n                    18446744073709551615 as libc::c_ulong,\n                ),\n            ) as uintmax_t as uintmax_t;\n    } else {\n        let mut start_pos: off_t = -(1 as libc::c_int) as off_t;\n        let mut end_pos: off_t = 0;\n        if !presume_input_pipe\n            && stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint\n            && {\n                start_pos = lseek(fd, 0 as libc::c_int as __off_t, 1 as libc::c_int);\n                start_pos != -(1 as libc::c_int) as libc::c_long\n            }\n            && {\n                end_pos = lseek(fd, 0 as libc::c_int as __off_t, 2 as libc::c_int);\n                start_pos < end_pos\n            }\n        {\n            *read_pos = end_pos as uintmax_t;\n            if end_pos != 0 as libc::c_int as libc::c_long\n                && !file_lines(\n                    pretty_filename,\n                    fd,\n                    &mut stats,\n                    n_lines,\n                    start_pos,\n                    end_pos,\n                    read_pos,\n                )\n            {\n                return 0 as libc::c_int != 0;\n            }\n        } else {\n            if start_pos != -(1 as libc::c_int) as libc::c_long {\n                xlseek(fd, start_pos, 0 as libc::c_int, pretty_filename);\n            }\n            let result = pipe_lines(pretty_filename, fd, n_lines, read_pos);\nreturn result;\n        }\n    }\n    return 1 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn tail(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_units: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    *read_pos = 0 as libc::c_int as uintmax_t;\n    if count_lines {\n        return tail_lines(filename, fd, n_units, read_pos)\n    } else {\n        return tail_bytes(filename, fd, n_units, read_pos)\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn tail_file(mut f: *mut File_spec, mut n_units: uintmax_t) -> bool {\n    let mut fd: i32 = 0;\nlet mut ok: bool = false;\nlet is_stdin = unsafe { CStr::from_ptr((*f).name) } == CStr::from_bytes_with_nul(b\"-\\0\").unwrap();\nif is_stdin {\n    have_read_stdin = true;\n    fd = 0;\n    xset_binary_mode(0, 0);\n} else {\n    fd = open_safer(unsafe { CStr::from_ptr((*f).name).as_ptr() }, 0);\n}\n(*f).tailable = !(reopen_inaccessible_files && fd == -1);\nif fd == -1 {\n     if forever {\n    unsafe {\n        (*f).fd = -1;\n        (*f).errnum = std::io::Error::last_os_error().raw_os_error().unwrap_or(0);\n        (*f).ignore = !reopen_inaccessible_files;\n        (*f).ino = 0;\n        (*f).dev = 0;\n    }\n}\n\nif false {\n    error(\n        0,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        gettext(b\"cannot open %s for reading\\0\".as_ptr() as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if false {\n        unreachable!();\n    }\n} else {\n    let __errstatus: i32 = 0;\n    error(\n        __errstatus,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        gettext(b\"cannot open %s for reading\\0\".as_ptr() as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if __errstatus != 0 {\n        unreachable!();\n    }\n\n    let __errstatus: i32 = 0;\n    error(\n        __errstatus,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        gettext(b\"cannot open %s for reading\\0\".as_ptr() as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if __errstatus != 0 {\n        unreachable!();\n    }\n}\n\nok = false;\n\n    \n} else {\n    let mut read_pos: u64 = 0;\n    if print_headers {\n        write_header(pretty_name(f));\n    }\n    ok = tail(pretty_name(f), fd, n_units, &mut read_pos);\n    if forever {\n         let mut stats = stat {\n    st_dev: 0,\n    st_ino: 0,\n    st_mode: 0,\n    st_nlink: 0,\n    st_uid: 0,\n    st_gid: 0,\n    st_rdev: 0,\n    __pad1: 0,\n    st_size: 0,\n    st_blksize: 0,\n    __pad2: 0,\n    st_blocks: 0,\n    st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n    st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n    st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n    __glibc_reserved: [0; 2],\n};\n\nif let Some(file_spec) = unsafe { f.as_mut() } {\n    file_spec.errnum = if ok { 0 } else { -1 };\n}\n\n        \n         if fstat(fd, &mut stats) < 0 as libc::c_int {\n                ok = 0 as libc::c_int != 0;\n                (*f).errnum = *__errno_location();\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(f),\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(f),\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            } else if !(stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint\n                || stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                    == 0o10000 as libc::c_int as libc::c_uint\n                || stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                    == 0o140000 as libc::c_int as libc::c_uint\n                || stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                    == 0o20000 as libc::c_int as libc::c_uint)\n            {\n                ok = 0 as libc::c_int != 0;\n                (*f).errnum = -(1 as libc::c_int);\n                (*f).tailable = 0 as libc::c_int != 0;\n                (*f).ignore = !reopen_inaccessible_files;\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s: cannot follow end of this type of file%s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            pretty_name(f),\n                        ),\n                        if (*f).ignore as libc::c_int != 0 {\n                            gettext(\n                                b\"; giving up on this name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ) as *const libc::c_char\n                        } else {\n                            b\"\\0\" as *const u8 as *const libc::c_char\n                        },\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s: cannot follow end of this type of file%s\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                pretty_name(f),\n                            ),\n                            if (*f).ignore as libc::c_int != 0 {\n                                gettext(\n                                    b\"; giving up on this name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ) as *const libc::c_char\n                            } else {\n                                b\"\\0\" as *const u8 as *const libc::c_char\n                            },\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s: cannot follow end of this type of file%s\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                pretty_name(f),\n                            ),\n                            if (*f).ignore as libc::c_int != 0 {\n                                gettext(\n                                    b\"; giving up on this name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ) as *const libc::c_char\n                            } else {\n                                b\"\\0\" as *const u8 as *const libc::c_char\n                            },\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        \n         if !ok {\n    (*f).ignore = !reopen_inaccessible_files;\n    close_fd(fd, pretty_name(f));\n    (*f).fd = -1;\n} else {\n    record_open_fd(\n        &mut *f,\n        fd,\n        read_pos as i64,\n        &mut stats,\n        if is_stdin { -1 } else { 1 },\n    );\n    (*f).remote = fremote(fd, pretty_name(f));\n}\n\n        \n    } else if !is_stdin && close(fd) != 0 {\n         if false {\n    error(\n        0,\n        *__errno_location(),\n        gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if false {\n        unreachable!();\n    }\n} else {\n    let __errstatus: i32 = 0;\n    error(\n        __errstatus,\n        *__errno_location(),\n        gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if __errstatus != 0 {\n        unreachable!();\n    }\n\n    let __errstatus: i32 = 0;\n    error(\n        __errstatus,\n        *__errno_location(),\n        gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );\n    if __errstatus != 0 {\n        unreachable!();\n    }\n}\nok = false;\n\n        \n    }\n}\nok\n\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn parse_obsolete_option(\n    mut argc: libc::c_int,\n    mut argv: *const *mut libc::c_char,\n    mut n_units: *mut uintmax_t,\n) -> bool {\n    let mut p: *const libc::c_char = 0 as *const libc::c_char;\n    let mut n_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut n_string_end: *const libc::c_char = 0 as *const libc::c_char;\n    let mut default_count: libc::c_int = 10 as libc::c_int;\n    let mut t_from_start: bool = false;\n    let mut t_count_lines: bool = 1 as libc::c_int != 0;\n    let mut t_forever: bool = 0 as libc::c_int != 0;\n    if !(argc == 2 as libc::c_int\n        || argc == 3 as libc::c_int\n            && !(*(*argv.offset(2 as libc::c_int as isize))\n                .offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32\n                && *(*argv.offset(2 as libc::c_int as isize))\n                    .offset(1 as libc::c_int as isize) as libc::c_int != 0)\n        || 3 as libc::c_int <= argc && argc <= 4 as libc::c_int\n            && strcmp(\n                *argv.offset(2 as libc::c_int as isize),\n                b\"--\\0\" as *const u8 as *const libc::c_char,\n            ) == 0 as libc::c_int)\n    {\n        return 0 as libc::c_int != 0;\n    }\n    let mut posix_ver: libc::c_int = posix2_version();\n    let mut obsolete_usage: bool = posix_ver < 200112 as libc::c_int;\n    let mut traditional_usage: bool = obsolete_usage as libc::c_int != 0\n        || 200809 as libc::c_int <= posix_ver;\n    p = *argv.offset(1 as libc::c_int as isize);\n    let fresh5 = p;\n    p = p.offset(1);\n    match *fresh5 as libc::c_int {\n        43 => {\n            if !traditional_usage {\n                return 0 as libc::c_int != 0;\n            }\n            t_from_start = 1 as libc::c_int != 0;\n        }\n        45 => {\n            if !obsolete_usage\n                && *p\n                    .offset(\n                        (*p.offset(0 as libc::c_int as isize) as libc::c_int\n                            == 'c' as i32) as libc::c_int as isize,\n                    ) == 0\n            {\n                return 0 as libc::c_int != 0;\n            }\n            t_from_start = 0 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    }\n    n_string = p;\n    while (*p as libc::c_uint).wrapping_sub('0' as i32 as libc::c_uint)\n        <= 9 as libc::c_int as libc::c_uint\n    {\n        p = p.offset(1);\n        p;\n    }\n    n_string_end = p;\n    let mut current_block_19: u64;\n    match *p as libc::c_int {\n        98 => {\n            default_count *= 512 as libc::c_int;\n            current_block_19 = 12856559154846489347;\n        }\n        99 => {\n            current_block_19 = 12856559154846489347;\n        }\n        108 => {\n            current_block_19 = 7044594549367080378;\n        }\n        _ => {\n            current_block_19 = 5783071609795492627;\n        }\n    }\n    match current_block_19 {\n        12856559154846489347 => {\n            t_count_lines = 0 as libc::c_int != 0;\n            current_block_19 = 7044594549367080378;\n        }\n        _ => {}\n    }\n    match current_block_19 {\n        7044594549367080378 => {\n            p = p.offset(1);\n            p;\n        }\n        _ => {}\n    }\n    if *p as libc::c_int == 'f' as i32 {\n        t_forever = 1 as libc::c_int != 0;\n        p = p.offset(1);\n        p;\n    }\n    if *p != 0 {\n        return 0 as libc::c_int != 0;\n    }\n    if n_string == n_string_end {\n        *n_units = default_count as uintmax_t;\n    } else if xstrtoumax(\n        n_string,\n        0 as *mut *mut libc::c_char,\n        10 as libc::c_int,\n        n_units,\n        b\"b\\0\" as *const u8 as *const libc::c_char,\n    ) as libc::c_uint & !(LONGINT_INVALID_SUFFIX_CHAR as libc::c_int) as libc::c_uint\n        != LONGINT_OK as libc::c_int as libc::c_uint\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"invalid number\\0\" as *const u8 as *const libc::c_char),\n                quote(*argv.offset(1 as libc::c_int as isize)),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(b\"invalid number\\0\" as *const u8 as *const libc::c_char),\n                    quote(*argv.offset(1 as libc::c_int as isize)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(b\"invalid number\\0\" as *const u8 as *const libc::c_char),\n                    quote(*argv.offset(1 as libc::c_int as isize)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    from_start = t_from_start;\n    count_lines = t_count_lines;\n    forever = t_forever;\n    return 1 as libc::c_int != 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn parse_options(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n    mut n_units: *mut uintmax_t,\n    mut header_mode: *mut header_mode,\n    mut sleep_interval: *mut libc::c_double,\n) {\n    /*\nThe variables live at this point are:\n(mut argc: i32, mut argv: *mut *mut i8, mut n_units: *mut u64, mut header_mode: *mut u32, mut sleep_interval: *mut f64)\n*/\nlet mut c: i32 = 0;\nloop {\n     use std::ffi::CString;\nuse std::os::raw::c_char;\n\nlet mut c: i32;\n\nc = getopt_long(\n    argc,\n    argv,\n    CString::new(\"c:n:fFqs:vz0123456789\").unwrap().as_ptr() as *const c_char,\n    long_options.as_ptr(),\n    std::ptr::null_mut(),\n);\n\nif c == -1 {\n    break;\n}\n\nlet mut current_block_33: u64;\nmatch c {\n    70 => {\n        forever = true;\n        follow_mode = Follow_name; // Assuming Follow_name is defined elsewhere\n        reopen_inaccessible_files = true;\n        current_block_33 = 4567019141635105728;\n    }\n    99 | 110 => {\n         let is_count_lines = c == 'n' as i32;\nlet optarg_str = unsafe { std::ffi::CStr::from_ptr(optarg) }.to_string_lossy();\n\nlet is_from_start = match optarg_str.chars().next() {\n    Some('+') => true,\n    Some('-') => {\n        optarg = optarg_str[1..].as_ptr() as *mut i8; // Move the pointer forward by one character\n        false\n    },\n    _ => false,\n};\n\n*n_units = xdectoumax(\n    optarg_str.as_ptr() as *const i8,\n    0,\n    u64::MAX,\n    b\"bkKmMGTPEZYRQ0\\0\" as *const u8 as *const libc::c_char,\n    if is_count_lines {\n        gettext(b\"invalid number of lines\\0\" as *const u8 as *const libc::c_char)\n    } else {\n        gettext(b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char)\n    },\n    0,\n);\ncurrent_block_33 = 4567019141635105728;\n\n\n    }\n    102 | 260 => {\n         let is_forever = true;\nif optarg.is_null() {\n    follow_mode = Follow_descriptor;\n} else {\n    follow_mode = follow_mode_map[__xargmatch_internal(\n        b\"--follow\\0\".as_ptr() as *const libc::c_char,\n        optarg,\n        follow_mode_string.as_ptr(),\n        follow_mode_map.as_ptr() as *const libc::c_void,\n        std::mem::size_of::<Follow_mode>() as libc::c_ulong,\n        argmatch_die,\n        true,\n    ) as usize];\n}\ncurrent_block_33 = 4567019141635105728;\n\n\n    }\n    256 => {\n        reopen_inaccessible_files = true;\n        current_block_33 = 4567019141635105728;\n    }\n    257 => {\n         max_n_unchanged_stats_between_opens = xdectoumax(\n    optarg,\n    0u64,\n    u64::MAX,\n    std::ptr::null(),\n    gettext(std::ffi::CString::new(\"invalid maximum number of unchanged stats between opens\").unwrap().as_ptr()),\n    0,\n);\ncurrent_block_33 = 4567019141635105728;\n\n\n    }\n    261 => {\n        disable_inotify = true;\n        current_block_33 = 4567019141635105728;\n    }\n    258 => {\n         if nbpids as libc::c_long == pids_alloc {\n                    pids = xpalloc(\n                        pids as *mut libc::c_void,\n                        &mut pids_alloc,\n                        1 as libc::c_int as idx_t,\n                        if (2147483647 as libc::c_int as libc::c_long)\n                            < 9223372036854775807 as libc::c_long\n                        {\n                            2147483647 as libc::c_int as libc::c_long\n                        } else {\n                            9223372036854775807 as libc::c_long\n                        },\n                        ::core::mem::size_of::<pid_t>() as libc::c_ulong as idx_t,\n                    ) as *mut pid_t;\n                }\n                let fresh6 = nbpids;\n                nbpids = nbpids + 1;\n                *pids\n                    .offset(\n                        fresh6 as isize,\n                    ) = xdectoumax(\n                    optarg,\n                    0 as libc::c_int as uintmax_t,\n                    (if (0 as libc::c_int) < -(1 as libc::c_int) {\n                        -(1 as libc::c_int)\n                    } else {\n                        (((1 as libc::c_int)\n                            << (::core::mem::size_of::<pid_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                    }) as uintmax_t,\n                    b\"\\0\" as *const u8 as *const libc::c_char,\n                    gettext(b\"invalid PID\\0\" as *const u8 as *const libc::c_char),\n                    0 as libc::c_int,\n                ) as pid_t;\n                current_block_33 = 4567019141635105728;\n\n    }\n    259 => {\n        presume_input_pipe = true;\n        current_block_33 = 4567019141635105728;\n    }\n    113 => {\n        *header_mode = never; // Assuming never is defined elsewhere\n        current_block_33 = 4567019141635105728;\n    }\n    115 => {\n         let mut s: libc::c_double = 0.;\n                if !(xstrtod(\n                    optarg,\n                    0 as *mut *const libc::c_char,\n                    &mut s,\n                    Some(\n                        cl_strtod\n                            as unsafe extern \"C\" fn(\n                                *const libc::c_char,\n                                *mut *mut libc::c_char,\n                            ) -> libc::c_double,\n                    ),\n                ) as libc::c_int != 0 && 0 as libc::c_int as libc::c_double <= s)\n                {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"invalid number of seconds: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quote(optarg),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid number of seconds: %s\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid number of seconds: %s\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                *sleep_interval = s;\n                current_block_33 = 4567019141635105728;\n\n    }\n    118 => {\n        *header_mode = always; // Assuming always is defined elsewhere\n        current_block_33 = 4567019141635105728;\n    }\n    122 => {\n        line_end = '\\0' as libc::c_char;\n        current_block_33 = 4567019141635105728;\n    }\n    -2 => {\n        usage(0); // Assuming usage is defined elsewhere\n        current_block_33 = 4567019141635105728;\n    }\n    -3 => {\n         version_etc(\n    stdout,\n    \"tail\\0\".as_ptr() as *const libc::c_char,\n    \"GNU coreutils\\0\".as_ptr() as *const libc::c_char,\n    Version,\n    proper_name_lite(\n        \"Paul Rubin\\0\".as_ptr() as *const libc::c_char,\n        \"Paul Rubin\\0\".as_ptr() as *const libc::c_char,\n    ),\n    proper_name_lite(\n        \"David MacKenzie\\0\".as_ptr() as *const libc::c_char,\n        \"David MacKenzie\\0\".as_ptr() as *const libc::c_char,\n    ),\n    proper_name_lite(\n        \"Ian Lance Taylor\\0\".as_ptr() as *const libc::c_char,\n        \"Ian Lance Taylor\\0\".as_ptr() as *const libc::c_char,\n    ),\n    proper_name_lite(\n        \"Jim Meyering\\0\".as_ptr() as *const libc::c_char,\n        \"Jim Meyering\\0\".as_ptr() as *const libc::c_char,\n    ),\n    std::ptr::null_mut::<libc::c_char>(),\n);\nstd::process::exit(0);\n\n\n    }\n    48..=57 => {\n         if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"option used in invalid context -- %c\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        c,\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"option used in invalid context -- %c\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            c,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"option used in invalid context -- %c\\0\" as *const u8",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "                                    as *const libc::c_char,\n                            ),\n                            c,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                current_block_33 = 17156019370052222107;\n\n    }\n    _ => {\n        current_block_33 = 17156019370052222107;\n    }\n}\n\nmatch current_block_33 {\n    17156019370052222107 => {\n        usage(1); // Assuming usage is defined elsewhere\n    }\n    _ => {}\n}\n\n/*\nThe variables live at this point are:\n(mut argc: i32, mut argv: *mut *mut i8, mut n_units: *mut u64, mut header_mode: *mut u32, mut sleep_interval: *mut f64, mut c: i32, mut current_block_33: u64)\n*/\n\n    \n}\nif reopen_inaccessible_files {\n    if !forever {\n        reopen_inaccessible_files = false;\n        if false {\n            error(\n                0,\n                0,\n                gettext(\n                    b\"warning: --retry ignored; --retry is useful only when following\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if false {\n                unreachable!();\n            }\n        } else {\n            let __errstatus: i32 = 0;\n            error(\n                __errstatus,\n                0,\n                gettext(\n                    b\"warning: --retry ignored; --retry is useful only when following\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if __errstatus != 0 {\n                unreachable!();\n            }\n            let __errstatus: i32 = 0;\n            error(\n                __errstatus,\n                0,\n                gettext(\n                    b\"warning: --retry ignored; --retry is useful only when following\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if __errstatus != 0 {\n                unreachable!();\n            }\n        }\n    } else if follow_mode == Follow_descriptor {\n        if false {\n            error(\n                0,\n                0,\n                gettext(\n                    b\"warning: --retry only effective for the initial open\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if false {\n                unreachable!();\n            }\n        } else {\n            let __errstatus: i32 = 0;\n            error(\n                __errstatus,\n                0,\n                gettext(\n                    b\"warning: --retry only effective for the initial open\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if __errstatus != 0 {\n                unreachable!();\n            }\n            let __errstatus: i32 = 0;\n            error(\n                __errstatus,\n                0,\n                gettext(\n                    b\"warning: --retry only effective for the initial open\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if __errstatus != 0 {\n                unreachable!();\n            }\n        }\n    }\n}\n/*\nThe variables live at this point are:\n(mut argc: i32, mut argv: *mut *mut i8, mut n_units: *mut u64, mut header_mode: *mut u32, mut sleep_interval: *mut f64, mut c: i32)\n*/\n\n    if nbpids != 0 && !forever {\n    if 0 != 0 {\n        error(\n            0,\n            0,\n            gettext(b\"warning: PID ignored; --pid=PID is useful only when following\\0\" as *const u8 as *const libc::c_char),\n        );\n        if 0 != 0 {\n            unreachable!();\n        }\n    } else {\n        let __errstatus: i32 = 0;\n        error(\n            __errstatus,\n            0,\n            gettext(b\"warning: PID ignored; --pid=PID is useful only when following\\0\" as *const u8 as *const libc::c_char),\n        );\n        if __errstatus != 0 {\n            unreachable!();\n        }\n\n        let __errstatus: i32 = 0;\n        error(\n            __errstatus,\n            0,\n            gettext(b\"warning: PID ignored; --pid=PID is useful only when following\\0\" as *const u8 as *const libc::c_char),\n        );\n        if __errstatus != 0 {\n            unreachable!();\n        }\n    }\n} else if nbpids != 0 && kill(*pids.offset(0), 0) != 0 && *__errno_location() == 38 {\n    if 0 != 0 {\n        error(\n            0,\n            0,\n            gettext(b\"warning: --pid=PID is not supported on this system\\0\" as *const u8 as *const libc::c_char),\n        );\n        if 0 != 0 {\n            unreachable!();\n        }\n    } else {\n        let __errstatus: i32 = 0;\n        error(\n            __errstatus,\n            0,\n            gettext(b\"warning: --pid=PID is not supported on this system\\0\" as *const u8 as *const libc::c_char),\n        );\n        if __errstatus != 0 {\n            unreachable!();\n        }\n\n        let __errstatus: i32 = 0;\n        error(\n            __errstatus,\n            0,\n            gettext(b\"warning: --pid=PID is not supported on this system\\0\" as *const u8 as *const libc::c_char),\n        );\n        if __errstatus != 0 {\n            unreachable!();\n        }\n    }\n    nbpids = 0;\n    unsafe { free(pids as *mut libc::c_void) }; // Assuming pids is a raw pointer, replace with appropriate freeing logic if needed\n}\n\n}\nunsafe extern \"C\" fn ignore_fifo_and_pipe(\n    mut f: *mut File_spec,\n    mut n_files: size_t,\n) -> size_t {\n    let mut n_viable: size_t = 0 as libc::c_int as size_t;\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        let mut is_a_fifo_or_pipe: bool = strcmp(\n            (*f.offset(i as isize)).name,\n            b\"-\\0\" as *const u8 as *const libc::c_char,\n        ) == 0 as libc::c_int && !(*f.offset(i as isize)).ignore\n            && 0 as libc::c_int <= (*f.offset(i as isize)).fd\n            && ((*f.offset(i as isize)).mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o10000 as libc::c_int as libc::c_uint\n                || 1 as libc::c_int != 1 as libc::c_int\n                    && isapipe((*f.offset(i as isize)).fd) != 0);\n        if is_a_fifo_or_pipe {\n            (*f.offset(i as isize)).fd = -(1 as libc::c_int);\n            (*f.offset(i as isize)).ignore = 1 as libc::c_int != 0;\n        } else {\n            n_viable = n_viable.wrapping_add(1);\n            n_viable;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return n_viable;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut header_mode: header_mode = multiple_files;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut n_units: uintmax_t = 10 as libc::c_int as uintmax_t;\n    let mut n_files: size_t = 0;\n    let mut file: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut F: *mut File_spec = 0 as *mut File_spec;\n    let mut i: size_t = 0;\n    let mut obsolete_option: bool = false;\n    let mut sleep_interval: libc::c_double = 1.0f64;\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    page_size = getpagesize() as idx_t;\n    have_read_stdin = 0 as libc::c_int != 0;\n    count_lines = 1 as libc::c_int != 0;\n    print_headers = 0 as libc::c_int != 0;\n    from_start = print_headers;\n    forever = from_start;\n    line_end = '\\n' as i32 as libc::c_char;\n    obsolete_option = parse_obsolete_option(argc, argv, &mut n_units);\n    argc -= obsolete_option as libc::c_int;\n    argv = argv.offset(obsolete_option as libc::c_int as isize);\n    parse_options(argc, argv, &mut n_units, &mut header_mode, &mut sleep_interval);\n    if from_start {\n        if n_units != 0 {\n            n_units = n_units.wrapping_sub(1);\n            n_units;\n        }\n    }\n    if optind < argc {\n        n_files = (argc - optind) as size_t;\n        file = argv.offset(optind as isize);\n    } else {\n        static mut dummy_stdin: *mut libc::c_char = b\"-\\0\" as *const u8\n            as *const libc::c_char as *mut libc::c_char;\n        n_files = 1 as libc::c_int as size_t;\n        file = &mut dummy_stdin;\n    }\n    let mut found_hyphen: bool = 0 as libc::c_int != 0;\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if strcmp(*file.offset(i as isize), b\"-\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int\n        {\n            found_hyphen = 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    if found_hyphen as libc::c_int != 0\n        && follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"cannot follow %s by name\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"cannot follow %s by name\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"-\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"cannot follow %s by name\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"-\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if forever as libc::c_int != 0 && found_hyphen as libc::c_int != 0 {\n        let mut in_stat: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        let mut blocking_stdin: bool = false;\n        blocking_stdin = nbpids == 0\n            && follow_mode as libc::c_uint\n                == Follow_descriptor as libc::c_int as libc::c_uint\n            && n_files == 1 as libc::c_int as libc::c_ulong\n            && fstat(0 as libc::c_int, &mut in_stat) == 0\n            && !(in_stat.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint);\n        if !blocking_stdin && isatty(0 as libc::c_int) != 0 {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: following standard input indefinitely is ineffective\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: following standard input indefinitely is ineffective\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: following standard input indefinitely is ineffective\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    }\n    if n_units == 0 && !forever && !from_start {\n        return 0 as libc::c_int;\n    }\n    F = xnmalloc(n_files, ::core::mem::size_of::<File_spec>() as libc::c_ulong)\n        as *mut File_spec;\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        let ref mut fresh7 = (*F.offset(i as isize)).name;\n        *fresh7 = *file.offset(i as isize);\n        i = i.wrapping_add(1);\n        i;\n    }\n    if header_mode as libc::c_uint == always as libc::c_int as libc::c_uint\n        || header_mode as libc::c_uint == multiple_files as libc::c_int as libc::c_uint\n            && n_files > 1 as libc::c_int as libc::c_ulong\n    {\n        print_headers = 1 as libc::c_int != 0;\n    }\n    let fd1: i32 = 1;\nlet mode1: i32 = 0;\nxset_binary_mode(fd1, mode1);\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        ok = (ok as libc::c_int\n            & tail_file(&mut *F.offset(i as isize), n_units) as libc::c_int) != 0;\n        i = i.wrapping_add(1);\n        i;\n    }\n    if forever as libc::c_int != 0 && ignore_fifo_and_pipe(F, n_files) != 0 {\n        let mut out_stat: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        if fstat(1 as libc::c_int, &mut out_stat) < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        monitor_output = out_stat.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o10000 as libc::c_int as libc::c_uint\n            || 1 as libc::c_int != 1 as libc::c_int && isapipe(1 as libc::c_int) != 0;\n        if !disable_inotify\n            && (tailable_stdin(F, n_files) as libc::c_int != 0\n                || any_remote_file(F, n_files) as libc::c_int != 0\n                || !any_non_remote_file(F, n_files)\n                || any_symlinks(F, n_files) as libc::c_int != 0\n                || any_non_regular_fifo(F, n_files) as libc::c_int != 0\n                || !ok\n                    && follow_mode as libc::c_uint\n                        == Follow_descriptor as libc::c_int as libc::c_uint)\n        {\n            disable_inotify = 1 as libc::c_int != 0;\n        }\n        if !disable_inotify {\n            let mut wd: libc::c_int = inotify_init();\n            if 0 as libc::c_int <= wd {\n                if fflush_unlocked(stdout) != 0 as libc::c_int {\n                    write_error();\n                }\n                let mut ht: *mut Hash_table = 0 as *mut Hash_table;\n                tail_forever_inotify(wd, F, n_files, sleep_interval, &mut ht);\n                hash_free(ht);\n                close(wd);\n                *__errno_location() = 0 as libc::c_int;\n            }",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"inotify cannot be used, reverting to polling\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"inotify cannot be used, reverting to polling\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"inotify cannot be used, reverting to polling\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        disable_inotify = 1 as libc::c_int != 0;\n        tail_forever(F, n_files, sleep_interval);\n    }\n    if have_read_stdin as libc::c_int != 0 && close(0 as libc::c_int) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"-\\0\" as *const u8 as *const libc::c_char,\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    exit(if ok as libc::c_int != 0 { 0 as libc::c_int } else { 1 as libc::c_int });\n}\npub fn main() {\n    let args: Vec<String> = ::std::env::args().collect();\n    let argc = args.len() as libc::c_int;\n    let argv: Vec<CString> = args.iter()\n        .map(|arg| CString::new(arg.clone()).expect(\"Failed to convert argument into CString.\"))\n        .collect();\n    \n    let mut argv_ptr: Vec<*mut libc::c_char> = argv.iter()\n        .map(|cstr| cstr.as_ptr() as *mut libc::c_char)\n        .collect();\n    argv_ptr.push(std::ptr::null_mut());\n\n    let exit_code = unsafe {\n        main_0(argc, argv_ptr.as_mut_ptr()) as i32\n    };\n    ::std::process::exit(exit_code);\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\tail.rs"
    },
    {
      "chunk": "use std::time::Duration;\nuse std::time::SystemTime;\nuse std::time;\nuse ::libc;\npub type __time_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\npub type time_t = __time_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn make_timespec(s: i64, ns: i64) -> std::time::SystemTime {\n    let duration = std::time::Duration::new(s as u64, ns as u32);\n    std::time::UNIX_EPOCH + duration\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn timespec_cmp(a: timespec, b: timespec) -> i32 {\n    if a.tv_sec > b.tv_sec {\n        1\n    } else if a.tv_sec < b.tv_sec {\n        -1\n    } else {\n        if a.tv_nsec > b.tv_nsec {\n            1\n        } else if a.tv_nsec < b.tv_nsec {\n            -1\n        } else {\n            0\n        }\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn timespec_sign(a: timespec) -> i32 {\n    if a.tv_sec > 0 {\n        1\n    } else if a.tv_sec < 0 {\n        -1\n    } else {\n        if a.tv_nsec != 0 {\n            1\n        } else {\n            0\n        }\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn timespectod(a: std::time::SystemTime) -> f64 {\n    let duration = a.duration_since(std::time::UNIX_EPOCH).expect(\"Time went backwards\");\n    duration.as_secs() as f64 + duration.subsec_nanos() as f64 / 1e9\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\timespec.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\version.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse std::os::raw::c_char;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n    0 => {}\n    1 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n            );\n        }\n    }\n    2 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n            );\n        }\n    }\n    3 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n            );\n        }\n    }\n    4 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n            );\n        }\n    }\n    5 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n                *authors.offset(4),\n            );\n        }\n    }\n    6 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n                *authors.offset(4),\n                *authors.offset(5),\n            );\n        }\n    }\n    7 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, %s, %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n                *authors.offset(4),\n                *authors.offset(5),\n                *authors.offset(6),\n            );\n        }\n    }\n    8 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, %s, %s, %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n                *authors.offset(4),\n                *authors.offset(5),\n                *authors.offset(6),\n                *authors.offset(7),\n            );\n        }\n    }\n    9 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, %s, %s, %s, %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n                *authors.offset(4),\n                *authors.offset(5),\n                *authors.offset(6),\n                *authors.offset(7),\n                *authors.offset(8),\n            );\n        }\n    }\n    _ => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, %s, %s, %s, %s, %s, and others.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n                *authors.offset(4),\n                *authors.offset(5),\n                *authors.offset(6),\n                *authors.offset(7),\n                *authors.offset(8),\n            );\n        }\n    }\n};\n\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\version_etc.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub fn emit_bug_reporting_address() {\n    println!();\n    println!(\n        \"Report bugs to: {}\",\n        unsafe { CStr::from_ptr(gettext(b\"bug-coreutils@gnu.org\\0\".as_ptr() as *const c_char)).to_string_lossy() }\n    );\n    println!(\n        \"{} home page: <{}>\",\n        unsafe { CStr::from_ptr(gettext(b\"GNU coreutils\\0\".as_ptr() as *const c_char)).to_string_lossy() },\n        \"https://www.gnu.org/software/coreutils/\"\n    );\n    println!(\n        \"General help using GNU software: <{}>\",\n        \"https://www.gnu.org/gethelp/\"\n    );\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\version_etc.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\version_etc_fsf.rs"
    },
    {
      "chunk": "use std::process;\nuse ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub fn xalloc_die() {\n    if 0 != 0 {\n        unsafe {\n            error(\n                exit_failure,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n        }\n        if unsafe { exit_failure } != 0 {\n            unreachable!();\n        }\n    } else {\n        let errstatus = unsafe { exit_failure };\n        unsafe {\n            error(\n                errstatus,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n        }\n        if errstatus != 0 {\n            unreachable!();\n        }\n\n        let errstatus = unsafe { exit_failure };\n        unsafe {\n            error(\n                errstatus,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n        }\n        if errstatus != 0 {\n            unreachable!();\n        }\n    }\n    std::process::abort();\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\xalloc_die.rs"
    },
    {
      "chunk": "use std::os::unix::io::AsRawFd;\nuse ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn xset_binary_mode(fd: i32, mode: i32) {\n    if set_binary_mode(fd, mode) < 0 {\n        xset_binary_mode_error();\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn xset_binary_mode_error() {\n    // Implement the functionality here in a safe manner.\n    // Since the original function does not perform any operations,\n    // we can leave it empty or add a comment indicating its purpose.\n}\n#[inline]\nfn set_binary_mode(fd: i32, mode: i32) -> i32 {\n    __gl_setmode(fd, mode)\n}\n#[inline]\nfn __gl_setmode(fd: i32, mode: i32) -> i32 {\n    return 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\xbinary_io.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn xstrtoumax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut uintmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n}\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\npub const LONGINT_OK: strtol_error = 0;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\n#[no_mangle]\npub unsafe extern \"C\" fn xdectoumax(\n    mut n_str: *const libc::c_char,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    let result = xnumtoumax(\n    std::ffi::CStr::from_ptr(n_str).to_str().unwrap(),\n    10,\n    min,\n    max,\n    if suffixes.is_null() { None } else { Some(std::ffi::CStr::from_ptr(suffixes).to_str().unwrap()) },\n    std::ffi::CStr::from_ptr(err).to_str().unwrap(),\n    err_exit,\n);\nreturn result;\n}\n#[no_mangle]\npub fn xnumtoumax(\n    n_str: &str,\n    base: i32,\n    min: u64,\n    max: u64,\n    suffixes: Option<&str>,\n    err: &str,\n    err_exit: i32,\n) -> u64 {\n    let mut tnum: u64 = 0;\n    let mut end_ptr: *mut libc::c_char = std::ptr::null_mut();\n    let suffix_ptr = suffixes.map_or(std::ptr::null(), |s| s.as_ptr() as *const libc::c_char);\n\n    unsafe {\n        let s_err = xstrtoumax(n_str.as_ptr() as *const libc::c_char, &mut end_ptr, base, &mut tnum, suffix_ptr);\n\n        if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n            if tnum < min || tnum > max {\n                let overflow_code = if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_ulong {\n                    75\n                } else {\n                    34\n                };\n                *__errno_location() = overflow_code;\n                panic!(\"Value out of range: {}\", tnum);\n            }\n        } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n            *__errno_location() = 75;\n        } else if s_err as libc::c_uint == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint {\n            *__errno_location() = 0;\n        }\n\n        if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n            let exit_code = if err_exit != 0 { err_exit } else { 1 };\n            let errno_value = *__errno_location();\n            error(exit_code, if errno_value == 22 { 0 } else { errno_value }, b\"%s: %s\\0\" as *const u8 as *const libc::c_char, err.as_ptr() as *const libc::c_char, quote(n_str.as_ptr() as *const libc::c_char));\n            if exit_code != 0 {\n                unreachable!();\n            }\n        }\n    }\n\n    tnum\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\xdectoumax.rs"
    },
    {
      "chunk": "use std::option::Option;\nuse std::slice;\nuse std::vec::Vec;\nuse std::convert::TryInto;\nuse ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nfn irealloc(s: i64) -> *mut libc::c_void {\n    if s >= 0 && s <= usize::MAX as i64 {\n        let new_size = if s == 0 { 1 } else { s as usize };\n        let p = vec![0u8; new_size].into_boxed_slice();\n        Box::into_raw(p) as *mut libc::c_void\n    } else {\n        unsafe { _gl_alloc_nomem() }\n    }\n}\n#[inline]\nfn icalloc(n: i64, s: i64) -> *mut libc::c_void {\n    let n_usize = n.try_into().unwrap_or(0);\n    let s_usize = s.try_into().unwrap_or(0);\n\n    if n_usize > usize::MAX / s_usize {\n        if s_usize != 0 {\n            return unsafe { _gl_alloc_nomem() };\n        }\n        return std::ptr::null_mut();\n    }\n    if s_usize > usize::MAX / n_usize {\n        if n_usize != 0 {\n            return unsafe { _gl_alloc_nomem() };\n        }\n        return std::ptr::null_mut();\n    }\n    let total_size = n_usize * s_usize;\n    let vec = vec![0u8; total_size];\n    let boxed_slice = vec.into_boxed_slice();\n    Box::into_raw(boxed_slice) as *mut libc::c_void\n}\n#[inline]\nfn ireallocarray(n: i64, s: i64) -> *mut libc::c_void {\n    unsafe {\n        if n as u64 <= usize::MAX as u64 && s as u64 <= usize::MAX as u64 {\n            let mut nx: usize = n.try_into().unwrap_or(0);\n            let mut sx: usize = s.try_into().unwrap_or(0);\n            if n == 0 || s == 0 {\n                sx = 1;\n                nx = sx;\n            }\n            let p = reallocarray(std::ptr::null_mut(), nx as u64, sx as u64);\n            return p;\n        } else {\n            return _gl_alloc_nomem();\n        }\n    }\n}\n#[cold]\n#[inline]\nunsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}\n#[inline]\nfn imalloc(s: usize) -> *mut libc::c_void {\n    if s <= usize::MAX {\n        let layout = std::alloc::Layout::from_size_align(s, 1).unwrap();\n        let ptr = unsafe { std::alloc::alloc(layout) };\n        if ptr.is_null() {\n            std::ptr::null_mut()\n        } else {\n            ptr as *mut libc::c_void\n        }\n    } else {\n        std::ptr::null_mut()\n    }\n}\nfn check_nonnull(p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        panic!(\"Pointer is null\");\n    }\n    p\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    let allocated_memory = imalloc(s.try_into().unwrap());\nif allocated_memory.is_null() {\n    // handle allocation failure\n    std::alloc::handle_alloc_error(std::alloc::Layout::from_size_align(s.try_into().unwrap(), 1).unwrap());\n}\ncheck_nonnull(allocated_memory)\n}\n#[no_mangle]\npub fn xcharalloc(n: usize) -> Vec<libc::c_char> {\n    if std::mem::size_of::<libc::c_char>() == 1 {\n        unsafe {\n            let ptr = xmalloc(n.try_into().unwrap()); // Convert usize to u64\n            Vec::from_raw_parts(ptr as *mut libc::c_char, n, n) // Assuming xmalloc returns a pointer\n        }\n    } else {\n        unsafe {\n            let ptr = xnmalloc(n.try_into().unwrap(), std::mem::size_of::<libc::c_char>().try_into().unwrap()); // Convert usize to u64\n            Vec::from_raw_parts(ptr as *mut libc::c_char, n, n) // Assuming xnmalloc returns a pointer\n        }\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub fn xirealloc(p: Option<&mut [u8]>, s: usize) -> Option<Vec<u8>> {\n    match p {\n        Some(slice) => {\n            let mut vec = Vec::from(slice);\n            vec.resize(s, 0);\n            Some(vec)\n        },\n        None => {\n            let mut vec = Vec::with_capacity(s);\n            vec.resize(s, 0);\n            Some(vec)\n        }\n    }\n}\n#[no_mangle]\npub fn xreallocarray(vec: &mut Vec<u8>, n: usize, s: usize) {\n    let new_size = n.checked_mul(s).expect(\"Overflow in size calculation\");\n    vec.resize(new_size, 0);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let result = ireallocarray(n, s);\nlet p = check_nonnull(result);\nreturn p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    let mut vec = Vec::with_capacity((n * s) as usize);\nxreallocarray(&mut vec, n as usize, s as usize);\nreturn vec.as_mut_ptr() as *mut libc::c_void;\n}\n#[no_mangle]\npub fn xinmalloc(n: usize, s: usize) -> Option<Vec<u8>> {\n    let total_size = n.checked_mul(s)?;\n    let result = vec![0u8; total_size];\n    Some(result)\n}\n#[no_mangle]\npub fn x2realloc(\n    p: Option<&mut [u8]>,\n    ps: &mut usize,\n) -> Option<Vec<u8>> {\n    let new_size = 1; // Assuming the size to be allocated is 1 byte\n    let mut vec = match p {\n        Some(slice) => {\n            let current_size = slice.len();\n            let mut new_vec = Vec::with_capacity(new_size);\n            new_vec.extend_from_slice(slice);\n            new_vec\n        },\n        None => Vec::with_capacity(new_size),\n    };\n    *ps = new_size;\n    Some(vec)\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    let mut vec = Vec::from_raw_parts(p as *mut u8, (n * s) as usize, (n * s) as usize);\nxreallocarray(&mut vec, n as usize, s as usize);\np = vec.as_mut_ptr() as *mut libc::c_void;\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub fn xzalloc(s: usize) -> Vec<u8> {\n    let size: usize = s.try_into().unwrap_or(0);\n    Vec::with_capacity(size)\n}\n#[no_mangle]\npub fn xizalloc(s: usize) -> Vec<u8> {\n    Vec::with_capacity(s)\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    let result = icalloc(n, s);\nlet nonnull_ptr = check_nonnull(result);\nreturn nonnull_ptr;\n}\n#[no_mangle]\npub fn xmemdup(p: &[u8]) -> Vec<u8> {\n    let mut result = vec![0; p.len()];\n    result.copy_from_slice(p);\n    result\n}\n#[no_mangle]\npub fn ximemdup(p: &[u8]) -> Vec<u8> {\n    let s = p.len();\n    let mut new_vec = Vec::with_capacity(s);\n    new_vec.copy_from_slice(p);\n    new_vec\n}\n#[no_mangle]\npub fn ximemdup0(p: &[u8]) -> Vec<u8> {\n    let s = p.len();\n    let mut result = vec![0; s + 1]; // Allocate space for the data plus a null terminator\n    result[..s].copy_from_slice(p); // Copy the data\n    result[s] = 0; // Null-terminate the string\n    result\n}\n#[no_mangle]\npub fn xstrdup(string: &str) -> String {\n    string.to_owned()\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "use std::mem;\nuse ::libc;\nextern \"C\" {\n    fn dtotimespec(_: libc::c_double) -> timespec;\n    fn rpl_nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn pause() -> libc::c_int;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub type __syscall_slong_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type time_t = __time_t;\n#[no_mangle]\npub fn xnanosleep(seconds: f64) -> i32 {\n    if 1.0 + (if (0 as i32 as time_t) < -(1 as i32) as time_t {\n        -(1 as i32) as f64\n    } else {\n        (((1 as i32 as time_t)\n            << (std::mem::size_of::<time_t>() as usize * 8 - 2) - 1) * 2 + 1) as f64\n    }) <= seconds {\n        loop {\n            unsafe { pause() };\n            if unsafe { *__errno_location() } != 4 {\n                break;\n            }\n        }\n    }\n    let mut ts_sleep: timespec;\n    unsafe {\n        ts_sleep = dtotimespec(seconds);\n    }\n    loop {\n        unsafe { *__errno_location() = 0 };\n        if unsafe { rpl_nanosleep(&ts_sleep as *const timespec, &mut ts_sleep) } == 0 {\n            break;\n        }\n        if unsafe { *__errno_location() } != 4 && unsafe { *__errno_location() } != 0 {\n            return -1;\n        }\n    }\n    return 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\xnanosleep.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrtod(\n    mut str: *const libc::c_char,\n    mut ptr: *mut *const libc::c_char,\n    mut result: *mut libc::c_double,\n    mut convert: Option::<\n        unsafe extern \"C\" fn(\n            *const libc::c_char,\n            *mut *mut libc::c_char,\n        ) -> libc::c_double,\n    >,\n) -> bool {\n    let mut val: libc::c_double = 0.;\n    let mut terminator: *mut libc::c_char = 0 as *mut libc::c_char;\nlet mut ok: bool = 1 as libc::c_int != 0;\n*__errno_location() = 0 as libc::c_int;\nval = convert.expect(\"non-null function pointer\")(str, &mut terminator);\nif terminator == str as *mut libc::c_char\n        || ptr.is_null() && *terminator as libc::c_int != '\\0' as i32\n    {\n        ok = 0 as libc::c_int != 0;\n    } else if val != 0 as libc::c_int as libc::c_double\n        && *__errno_location() == 34 as libc::c_int\n    {\n        ok = 0 as libc::c_int != 0;\n    }\nif !ptr.is_null() {\n        *ptr = terminator;\n    }\n*result = val;\nreturn ok;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\xstrtod.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtoumax(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __base: libc::c_int,\n    ) -> uintmax_t;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n}\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub const _ISspace: C2RustUnnamed = 8192;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\xstrtoumax.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn bkm_scale(\n    mut x: *mut uintmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: uintmax_t = 0;\n    if if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t\n        && (if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_ulong } else { *x })\n            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n            < 0 as libc::c_int as libc::c_ulong\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_ulong {\n                if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        -(1 as libc::c_int) as uintmax_t\n                    })\n                        .wrapping_add(scale_factor as libc::c_ulong)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    (*x\n                        < (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(scale_factor as libc::c_ulong)) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(-(1 as libc::c_int) as uintmax_t)\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(-scale_factor as libc::c_ulong)\n                    }) <= (-(1 as libc::c_int) as libc::c_ulong).wrapping_sub(*x))\n                        as libc::c_int\n                }\n            } else {\n                if (if (if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    !((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                }) < 0 as libc::c_int as libc::c_ulong\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                        < (if (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_ulong)\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            < 0 as libc::c_int as libc::c_ulong\n                        {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                << (::core::mem::size_of::<libc::c_ulong>()\n                                    as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        })\n                            .wrapping_neg()) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_ulong)\n                        < ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        *x\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (*x).wrapping_add(0 as libc::c_int as uintmax_t))\n                            as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong) < *x\n                            && (-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (*x).wrapping_sub(1 as libc::c_int as libc::c_ulong))\n                            as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }\n            }\n        } else {\n            if scale_factor == 0 {\n    0\n} else {\n    if *x < 0 {\n        if (*x.wrapping_sub(1) < 0) {\n            if !(*x.wrapping_add(1) << (std::mem::size_of::<u64>() * 8 - 2)).wrapping_sub(1).wrapping_mul(2).wrapping_add(1) < 0 {\n                if (scale_factor - 1) < 0 {\n                    (0 < scale_factor as u64) as i32\n                } else {\n                    (u64::MAX.wrapping_sub(0) < (scale_factor - 1) as u64) as i32\n                }\n            } else {\n                (0_u64.wrapping_div(*x) < scale_factor as u64) as i32\n            }\n        } else {\n            (u64::MAX.wrapping_div(scale_factor as u64) < *x) as i32\n        }\n    } else {\n        // Handle the case where *x is not less than 0\n        // This part of the logic was not included in the original code\n        0 // Placeholder for the else case\n    }\n}\n\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_ulong {\n            !if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n                -(1 as libc::c_int) as uintmax_t\n            } else {\n                ((1 as libc::c_int as uintmax_t)\n                    << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            }\n        } else if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n            -(1 as libc::c_int) as uintmax_t\n        } else {\n            ((1 as libc::c_int as uintmax_t)\n                << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\xstrtoumax.rs"
    },
    {
      "chunk": "fn bkm_scale_by_power(\n    x: &mut u64,\n    base: i32,\n    mut power: i32,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    while power > 0 {\n        power -= 1;\n        // Safe wrapper around the unsafe function\n        err = (err as u32 | unsafe { bkm_scale(x, base) } as u32) as strtol_error;\n    }\n    err\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrtoumax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut uintmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: uintmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 79],\n                &[libc::c_char; 79],\n            >(\n                b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2256: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 79],\n                    &[libc::c_char; 79],\n                >(\n                    b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoumax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as uintmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if !(*p).is_null() && **p != 0 {\n    let mut base: i32 = 1024;\n    let mut suffixes: i32 = 1;\n    let mut overflow: strtol_error = LONGINT_OK;\n\n    let valid_suffixes_str = unsafe { std::ffi::CStr::from_ptr(valid_suffixes).to_string_lossy() };\n    let current_char = **p as u8 as char;\n\n    if !valid_suffixes_str.contains(current_char) {\n        *val = tmp;\n        return (err | LONGINT_INVALID_SUFFIX_CHAR) as strtol_error;\n    }\n\n    match current_char {\n        'E' | 'G' | 'g' | 'K' | 'k' | 'M' | 'm' | 'P' | 'Q' | 'R' | 'T' | 't' | 'Y' | 'Z' => {\n            if valid_suffixes_str.contains('0') {\n                match unsafe { *(*p).offset(1) } as u8 as char {\n                    'i' => {\n                        if unsafe { *(*p).offset(2) } as u8 as char == 'B' {\n                            suffixes += 2;\n                        }\n                    }\n                    'B' | 'D' => {\n                        base = 1000;\n                        suffixes += 1;\n                    }\n                    _ => {}\n                }\n            }\n        }\n        _ => {}\n    }\n\n    match current_char {\n        'b' => {\n            overflow = bkm_scale(&mut tmp, 512);\n        }\n        'B' => {\n            overflow = bkm_scale(&mut tmp, 1024);\n        }\n        'c' => {\n            overflow = LONGINT_OK;\n        }\n        'E' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 6);\n        }\n        'G' | 'g' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 3);\n        }\n        'K' | 'k' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 1);\n        }\n        'M' | 'm' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 2);\n        }\n        'P' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 5);\n        }\n        'Q' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 10);\n        }\n        'R' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 9);\n        }\n        'T' | 't' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 4);\n        }\n        'w' => {\n            overflow = bkm_scale(&mut tmp, 2);\n        }\n        'Y' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 8);\n        }\n        'Z' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 7);\n        }\n        _ => {\n            *val = tmp;\n            return (err | LONGINT_INVALID_SUFFIX_CHAR) as strtol_error;\n        }\n    }\n\n    err |= overflow as u32;\n    *p = unsafe { (*p).offset(suffixes as isize) };\n    if **p != 0 {\n        err |= LONGINT_INVALID_SUFFIX_CHAR;\n    }\n}\n*val = tmp;\nreturn err;\n\n}",
      "file_name": "c2saferrust/coreutils/src\\tail\\rust_WIP\\src\\xstrtoumax.rs"
    }
  ],
  "truncate": [
    {
      "chunk": "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\build.rs"
    },
    {
      "chunk": "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(label_break_value)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod close_stream;\npub mod closeout;\npub mod exitfail;\npub mod fclose;\npub mod fflush;\npub mod fseeko;\npub mod hard_locale;\npub mod ialloc;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalloc_die;\npub mod xdectoimax;\npub mod xmalloc;\npub mod xstrtoimax;\n}\n// mod src",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\lib.rs"
    },
    {
      "chunk": "use std::ffi::CString;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub fn close_stdout_set_file_name(file: &str) {\n    let c_string = CString::new(file).expect(\"CString::new failed\");\n    unsafe {\n        file_name = c_string.into_raw();\n    }\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\npub fn close_stdout_set_ignore_EPIPE(ignore: bool) {\n    unsafe {\n        ignore_EPIPE = ignore;\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\closeout.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn close_stream(stream: *mut _IO_FILE) -> libc::c_int {\n    let some_pending: bool = unsafe { __fpending(stream) != 0 };\n    let prev_fail: bool = unsafe { ferror_unlocked(stream) != 0 };\n    let fclose_fail: bool = unsafe { rpl_fclose(stream) != 0 };\n\n    if prev_fail\n        || (fclose_fail && (some_pending || unsafe { *__errno_location() != 9 }))\n    {\n        if !fclose_fail {\n            unsafe { *__errno_location() = 0 };\n        }\n        return -1;\n    }\n    return 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\close_stream.rs"
    },
    {
      "chunk": "use std::ops::RangeInclusive;\nuse ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalnum(c: i32) -> bool {\n    matches!(c, 48..=57 | 65..=90 | 97..=122)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalpha(c: i32) -> bool {\n    (b'a'..=b'z').contains(&(c as u8)) || (b'A'..=b'Z').contains(&(c as u8))\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isascii(c: i32) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isblank(c: i32) -> bool {\n    c == ' ' as i32 || c == '\\t' as i32\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_iscntrl(c: i32) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isdigit(c: i32) -> bool {\n    matches!(c, 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isgraph(c: i32) -> bool {\n    match c {\n        48..=57 | 97..=122 | 33..=47 | 58..=64 | 91..=96 | 123..=126 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_islower(c: i32) -> bool {\n    match c {\n        97..=122 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isprint(c: i32) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_ispunct(c: i32) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isspace(c: i32) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isupper(c: i32) -> bool {\n    (65..=90).contains(&c)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isxdigit(c: i32) -> bool {\n    matches!(c, 48..=57 | 97..=102 | 65..=70)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_tolower(c: i32) -> i32 {\n    match c {\n        65..=90 => c + ('a' as i32 - 'A' as i32),\n        _ => c,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_toupper(c: i32) -> i32 {\n    match c {\n        97..=122 => c - ('a' as i32) + ('A' as i32),\n        _ => c,\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\c_ctype.rs"
    },
    {
      "chunk": "use ::libc;\n#[inline]\nfn c_tolower(c: i32) -> i32 {\n    match c {\n        65..=90 => c - 'A' as i32 + 'a' as i32,\n        _ => c,\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        let c1 = c_tolower(*p1 as i32) as u8;\n        let c2 = c_tolower(*p2 as i32) as u8;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\c_strcasecmp.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\exitfail.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn rpl_fclose(fp: &mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0;\n    \n    unsafe {\n        let fd = fileno(fp);\n        \n        if fd < 0 {\n            return fclose(fp);\n        }\n        \n        let is_reading = __freading(fp) != 0;\n        let seek_result = lseek(fd, 0, 1);\n        \n        if (!is_reading || seek_result == -1) && rpl_fflush(fp) != 0 {\n            saved_errno = *__errno_location();\n        }\n        \n        let result = fclose(fp);\n        \n        if saved_errno != 0 {\n            *__errno_location() = saved_errno;\n            return -1;\n        }\n        \n        result\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\fclose.rs"
    },
    {
      "chunk": "use std::ptr;\nuse std::option::Option;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nfn clear_ungetc_buffer_preserving_position(fp: &mut FILE) {\n    if (fp._flags & 0x100) != 0 {\n        unsafe {\n            rpl_fseeko(fp, 0, 1); // 1 corresponds to SEEK_CUR\n        }\n    }\n}\n#[no_mangle]\npub fn rpl_fflush(stream: Option<&mut FILE>) -> libc::c_int {\n    if let Some(s) = stream {\n        if unsafe { __freading(s) != 0 } {\n            unsafe { clear_ungetc_buffer_preserving_position(s) };\n        }\n        return unsafe { fflush(s) };\n    }\n    unsafe { fflush(std::ptr::null_mut()) }\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\fflush.rs"
    },
    {
      "chunk": "use std::os::raw::c_int;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub fn rpl_fseeko(\n    fp: &mut FILE,\n    offset: off_t,\n    whence: libc::c_int,\n) -> libc::c_int {\n    if fp._IO_read_end == fp._IO_read_ptr\n        && fp._IO_write_ptr == fp._IO_write_base && fp._IO_save_base.is_null()\n    {\n        let pos: off_t;\n        unsafe {\n            pos = lseek(fileno(fp), offset, whence);\n        }\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        fp._flags &= !(0x10 as libc::c_int);\n        fp._offset = pos;\n        return 0 as libc::c_int;\n    }\n    unsafe {\n        return fseeko(fp, offset, whence);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\fseeko.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn hard_locale(category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    unsafe {\n        if setlocale_null_r(\n            category,\n            locale.as_mut_ptr(),\n            locale.len() as libc::c_ulong,\n        ) != 0 {\n            return false;\n        }\n    }\n    let locale_str = unsafe { CStr::from_ptr(locale.as_ptr()).to_string_lossy() };\n    if locale_str == \"C\" || locale_str == \"POSIX\" {\n        return false;\n    }\n    return true;\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\hard_locale.rs"
    },
    {
      "chunk": "use std::usize;\nuse std::option::Option;\nuse std::vec::Vec;\nuse std::alloc;\nuse std::ptr;\nuse std::slice;\nuse ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn ireallocarray(\n    p: Option<&mut Vec<u8>>,\n    n: idx_t,\n    s: idx_t,\n) -> Option<Vec<u8>> {\n    if n as usize <= usize::MAX && s as usize <= usize::MAX {\n        let mut nx: usize = n as usize;\n        let mut sx: usize = s as usize;\n        if n == 0 || s == 0 {\n            sx = 1;\n            nx = sx;\n        }\n        let mut vec = p.map_or_else(|| Vec::with_capacity(nx * sx), |v| {\n            v.resize(nx * sx, 0);\n            v.clone()\n        });\n        Some(vec)\n    } else {\n        return None; // Assuming _gl_alloc_nomem() returns None in this context\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn icalloc(n: usize, s: usize) -> Option<Vec<u8>> {\n    if n > usize::MAX / s {\n        if s != 0 {\n            return None; // Equivalent to _gl_alloc_nomem()\n        }\n        return Some(Vec::new()); // Return an empty Vec\n    }\n    if s > usize::MAX / n {\n        if n != 0 {\n            return None; // Equivalent to _gl_alloc_nomem()\n        }\n        return Some(Vec::new()); // Return an empty Vec\n    }\n    let total_size = n * s;\n    let vec = vec![0u8; total_size]; // Allocate and zero-initialize\n    Some(vec)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn irealloc(p: Option<&mut [u8]>, s: usize) -> Option<Vec<u8>> {\n    if s <= usize::MAX {\n        let new_size = if s == 0 { 1 } else { s };\n        let mut vec = Vec::with_capacity(new_size);\n        if let Some(old) = p {\n            vec.extend_from_slice(old);\n        }\n        Some(vec)\n    } else {\n        None\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn imalloc(s: idx_t) -> Option<Box<[u8]>> {\n    if s as usize <= usize::MAX {\n        let layout = std::alloc::Layout::from_size_align(s as usize, 1).ok()?;\n        let ptr = unsafe { std::alloc::alloc(layout) };\n        if ptr.is_null() {\n            None\n        } else {\n            Some(unsafe { Box::from_raw(std::slice::from_raw_parts_mut(ptr, s as usize)) })\n        }\n    } else {\n        None // Return None instead of calling _gl_alloc_nomem()\n    }\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub fn _gl_alloc_nomem() -> *mut libc::c_void {\n    // Simulating allocation failure by setting errno and returning a null pointer\n    unsafe {\n        *__errno_location() = 12; // Set errno to ENOMEM\n    }\n    std::ptr::null_mut() // Return a null pointer\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\ialloc.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;\npub const _NL_WAM_STR: C2RustUnnamed = 131162;",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "pub const _NL_WMON_12: C2RustUnnamed = 131161;\npub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub fn locale_charset() -> String {\n    let codeset_ptr: *const libc::c_char = unsafe { nl_langinfo(CODESET as libc::c_int) };\n    let codeset = unsafe { CStr::from_ptr(codeset_ptr) };\n    \n    if codeset.to_bytes().is_empty() {\n        return \"ASCII\".to_string();\n    }\n    \n    codeset.to_string_lossy().into_owned()\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "use std::option::Option;\nuse std::slice;\nuse std::process;\nuse ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nfn mbszero(ps: &mut mbstate_t) {\n    let size = std::mem::size_of::<mbstate_t>();\n    let bytes: &mut [u8] = unsafe { std::slice::from_raw_parts_mut(ps as *mut _ as *mut u8, size) };\n    bytes.fill(0);\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub fn rpl_mbrtoc32(\n    pwc: &mut Option<char32_t>,\n    s: Option<&[u8]>,\n    n: usize,\n    ps: &mut Option<mbstate_t>,\n) -> usize {\n    let mut local_s = s.unwrap_or_else(|| &[0]);\n    \n    let local_ps = ps.get_or_insert_with(|| {\n        // Create a new instance of internal_state\n        unsafe { internal_state }\n    });\n\n    if local_s.is_empty() {\n        pwc.take(); // Set pwc to None\n        local_s = &[0]; // Set s to a null byte\n    }\n\n    let ret: usize;\n    unsafe {\n        ret = mbrtoc32(\n            pwc.as_mut().map(|p| p as *mut char32_t).unwrap_or(std::ptr::null_mut()),\n            local_s.as_ptr() as *const libc::c_char,\n            n as libc::c_ulong,\n            local_ps,\n        ) as usize;\n    }\n\n    if ret < !(3 as libc::c_int) as usize && unsafe { mbsinit(local_ps) } == 0 {\n        unsafe { mbszero(local_ps) };\n    }\n    if ret == !(3 as libc::c_int) as usize {\n        std::process::abort();\n    }\n    if !(2 as libc::c_int) as usize <= ret && n != 0 && !unsafe { hard_locale(0 as libc::c_int) } {\n        if let Some(p) = pwc {\n            *p = *local_s.get(0).unwrap_or(&0) as libc::c_uchar as char32_t;\n        }\n        return 1;\n    }\n    ret\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\mbrtoc32.rs"
    },
    {
      "chunk": "use std::mem;\nuse ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn mbszero(ps: &mut mbstate_t) {\n    // Zero out the mbstate_t structure\n    let zeroed: mbstate_t = unsafe { std::mem::zeroed() };\n    *ps = zeroed;\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\mbszero.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse std::process;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub fn set_program_name(argv0: *const libc::c_char) {\n    if argv0.is_null() {\n        eprintln!(\"A NULL argv[0] was passed through an exec system call.\");\n        std::process::abort();\n    }\n\n    let c_str = unsafe { std::ffi::CStr::from_ptr(argv0) };\n    let argv0_str = c_str.to_string_lossy();\n    let slash = argv0_str.rfind('/').map(|index| &argv0_str[index + 1..]).unwrap_or(&argv0_str);\n    \n    if slash.len() >= 7 && slash.ends_with(\"/.libs/\") {\n        let base = &slash[7..];\n        if base.starts_with(\"lt-\") {\n            unsafe {\n                program_invocation_short_name = base[3..].as_ptr() as *mut libc::c_char;\n            }\n        }\n        unsafe {\n            program_name = base.as_ptr() as *mut libc::c_char;\n            program_invocation_name = base.as_ptr() as *mut libc::c_char;\n        }\n    } else {\n        unsafe {\n            program_name = argv0 as *mut libc::c_char;\n            program_invocation_name = argv0 as *mut libc::c_char;\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\progname.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\propername_lite.rs"
    },
    {
      "chunk": "use std::clone::Clone;\nuse std::char;\nuse std::option::Option;\nuse std::ffi::CStr;\nuse std::os::raw::c_char;\nuse std::ffi::CString;\nuse ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nfn c32isprint(wc: u32) -> i32 {\n    if char::from_u32(wc).map_or(false, |c| c.is_ascii()) {\n        1\n    } else {\n        0\n    }\n}\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub fn clone_quoting_options(o: Option<&quoting_options>) -> Box<quoting_options> {\n    let options = match o {\n        Some(opt) => opt,\n        None => unsafe { &default_quoting_options },\n    };\n    Box::new(options.clone())\n}\n#[no_mangle]\npub fn get_quoting_style(o: Option<&quoting_options>) -> quoting_style {\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &default_quoting_options },\n    };\n    options.style\n}\n#[no_mangle]\npub fn set_quoting_style(\n    o: Option<&mut quoting_options>,\n    s: quoting_style,\n) {\n    if let Some(opts) = o {\n        opts.style = s;\n    } else {\n        // Safely modify the static variable using an unsafe block\n        unsafe {\n            default_quoting_options.style = s;\n        }\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}\n#[no_mangle]\npub fn set_quoting_flags(\n    mut o: Option<&mut quoting_options>,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    let options = o.get_or_insert_with(|| unsafe { &mut default_quoting_options });\n    r = options.flags;\n    options.flags = i;\n    return r;\n}\n#[no_mangle]\npub fn set_custom_quoting(\n    o: *mut quoting_options,\n    left_quote: *const libc::c_char,\n    right_quote: *const libc::c_char,\n) {\n    let options = if o.is_null() {\n        unsafe { &mut *(&mut default_quoting_options as *mut _) }\n    } else {\n        unsafe { &mut *o }\n    };\n\n    options.style = custom_quoting_style;\n\n    if left_quote.is_null() || right_quote.is_null() {\n        panic!(\"Quotes cannot be null\");\n    }\n\n    options.left_quote = left_quote;\n    options.right_quote = right_quote;\n}\nfn quoting_options_from_style(style: quoting_style) -> quoting_options {\n    let mut o = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: std::ptr::null(),\n        right_quote: std::ptr::null(),\n    };\n\n    if style as u32 == custom_quoting_style as i32 as u32 {\n        panic!(\"Custom quoting style is not allowed\");\n    }\n\n    o.style = style;\n    o\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: u8 = 0;\nlet mut esc: u8 = 0;\nlet mut is_right_quote: bool = false;\nlet mut escaping: bool = false;\nlet mut c_and_shell_quote_compat: bool = false;\n\nlet arg_slice = unsafe { std::slice::from_raw_parts(arg as *const u8, argsize as usize) };\n\nif backslash_escapes\n    && quoting_style != shell_always_quoting_style\n    && quote_string_len != 0\n    && i + quote_string_len <= if argsize == u64::MAX && 1 < quote_string_len {\n        argsize = arg_slice.len() as u64;\n        argsize\n    } else {\n        argsize\n    }\n    && &arg_slice[i as usize..(i + quote_string_len) as usize] == unsafe { std::slice::from_raw_parts(quote_string as *const u8, quote_string_len as usize) }\n{\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    is_right_quote = true;\n}\n\nc = arg_slice[i as usize];\nmatch c {\n    0 => {\n         if backslash_escapes {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    escaping = true;\n    if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '\\'' as i8 };\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '$' as i8 };\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '\\'' as i8 };\n        }\n        len += 1;\n        pending_shell_escape_end = true;\n    }\n    if len < buffersize {\n        unsafe { *buffer.offset(len as isize) = '\\\\' as i8 };\n    }\n    len += 1;\n    if quoting_style != shell_always_quoting_style\n        && i + 1 < argsize\n        && ('0' as i8 <= unsafe { *arg.offset((i + 1) as isize) } && unsafe { *arg.offset((i + 1) as isize) } <= '9' as i8)\n    {\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '0' as i8 };\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '0' as i8 };\n        }\n        len += 1;\n    }\n    c = '0' as u8;\n    current_block = 253337042034819032;\n} else if (flags & QA_ELIDE_NULL_BYTES as i32) != 0 {\n    current_block = 13619784596304402172;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n    63 => {\n         match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n\n    }\n    7 => {\n        esc = 'a' as u8;\n        current_block = 1190876092451756080;\n    }\n    8 => {\n        esc = 'b' as u8;\n        current_block = 1190876092451756080;\n    }\n    12 => {\n        esc = 'f' as u8;\n        current_block = 1190876092451756080;\n    }\n    10 => {\n        esc = 'n' as u8;\n        current_block = 9215498979640025612;\n    }\n    13 => {\n        esc = 'r' as u8;\n        current_block = 9215498979640025612;\n    }\n    9 => {\n        esc = 't' as u8;\n        current_block = 9215498979640025612;\n    }\n    11 => {\n        esc = 'v' as u8;\n        current_block = 1190876092451756080;\n    }\n    92 => {\n         esc = c;\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    current_block = 4476262310586904498;\n} else if backslash_escapes && elide_outer_quotes && quote_string_len != 0 {\n    current_block = 4476262310586904498;\n} else {\n    current_block = 9215498979640025612;\n}\n\n\n    }\n    123 | 125 => {\n         if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n\n    }\n    35 | 126 => {\n        current_block = 16442922512115311366;\n    }\n    32 => {\n        current_block = 4634307283396172174;\n    }\n    33 => {\n        current_block = 7549413860336125482;\n    }\n    34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n        current_block = 13059411171234995867;\n    }\n    62 | 91 | 94 => {\n        current_block = 16620298045565028098;\n    }\n    96 | 124 => {\n        current_block = 15155215915847730705;\n    }\n    39 => {\n         encountered_single_quote = true;\nc_and_shell_quote_compat = true;\n\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    if buffersize != 0 && orig_buffersize == 0 {\n        orig_buffersize = buffersize;\n        buffersize = 0;\n    }\n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\'' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    \n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\\\' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    \n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\'' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    \n    pending_shell_escape_end = false;\n    current_block = 253337042034819032;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n    37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n    | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n    | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n    | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n    | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n    | 120 | 121 | 122 => {\n        c_and_shell_quote_compat = true;\n        current_block = 253337042034819032;\n    }\n    _ => {\n         let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n\n         if m > 1 || (backslash_escapes && !printable) {\n    let ilim = i.wrapping_add(m);\n    let buffer_slice = unsafe { std::slice::from_raw_parts_mut(buffer, buffersize as usize) };\n    loop {\n        if backslash_escapes && !printable {\n            if elide_outer_quotes {\n                current_block = 7928555609993211441;\n                break 's_25;\n            }\n            escaping = true;\n            if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n                if len < buffersize {\n                    buffer_slice[len as usize] = '\\'' as i8;\n                }\n                len = len.wrapping_add(1);\n                if len < buffersize {\n                    buffer_slice[len as usize] = '$' as i8;\n                }\n                len = len.wrapping_add(1);\n                if len < buffersize {\n                    buffer_slice[len as usize] = '\\'' as i8;\n                }\n                len = len.wrapping_add(1);\n                pending_shell_escape_end = true;\n            }\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\\\' as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as i32 + (c as i32 >> 6)) as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as i32 + ((c as i32 >> 3) & 7)) as i8;\n            }\n            len = len.wrapping_add(1);\n            c = ('0' as i32 + (c as i32 & 7)) as u8;\n        } else if is_right_quote {\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\\\' as i8;\n            }\n            len = len.wrapping_add(1);\n            is_right_quote = false;\n        }\n        if ilim <= i.wrapping_add(1) {",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "            break;\n        }\n        if pending_shell_escape_end && !escaping {\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\'' as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\'' as i8;\n            }\n            len = len.wrapping_add(1);\n            pending_shell_escape_end = false;\n        }\n        if len < buffersize {\n            buffer_slice[len as usize] = c as i8;\n        }\n        len = len.wrapping_add(1);\n        i = i.wrapping_add(1);\n        c = unsafe { *arg.offset(i as isize) } as u8;\n    }\n    current_block = 4476262310586904498;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n}\n\nmatch current_block {\n    16442922512115311366 => {\n        if i != 0 {\n            current_block = 253337042034819032;\n        } else {\n            current_block = 4634307283396172174;\n        }\n    }\n    9215498979640025612 => {\n        if quoting_style == shell_always_quoting_style && elide_outer_quotes {\n            current_block = 7928555609993211441;\n            break 's_25;\n        }\n        current_block = 1190876092451756080;\n    }\n    _ => {}\n}\n\nmatch current_block {\n    1190876092451756080 => {\n        if backslash_escapes {\n            c = esc;\n            current_block = 3173013908131212616;\n        } else {\n            current_block = 253337042034819032;\n        }\n    }\n    4634307283396172174 => {\n        c_and_shell_quote_compat = true;\n        current_block = 7549413860336125482;\n    }\n    _ => {}\n}\n\nmatch current_block {\n    7549413860336125482 => {\n        current_block = 13059411171234995867;\n    }\n    _ => {}\n}\n\nmatch current_block {\n    13059411171234995867 => {\n        current_block = 16620298045565028098;\n    }\n    _ => {}\n}\n/*\nThe variables live at this point are:\n(mut buffer: *mut i8, mut buffersize: u64, mut arg: *const i8, mut argsize: u64, mut quoting_style: u32, mut flags: i32, mut pending_shell_escape_end: bool, mut current_block: u64, mut i: u64, mut len: u64, mut orig_buffersize: u64, mut quote_string: *const i8, mut quote_string_len: u64, mut backslash_escapes: bool, mut unibyte_locale: bool, mut elide_outer_quotes: bool, mut encountered_single_quote: bool, mut c: u8, mut esc: u8, mut is_right_quote: bool, mut escaping: bool, mut c_and_shell_quote_compat: bool)\n*/\n\n            let mut current_block = match current_block {\n    16620298045565028098 => {\n        15155215915847730705\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    15155215915847730705 => {\n        if quoting_style == shell_always_quoting_style && elide_outer_quotes {\n            break 's_25;\n        }\n        253337042034819032\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    253337042034819032 => {\n        if !((backslash_escapes && quoting_style != shell_always_quoting_style) || elide_outer_quotes) \n            && !quote_these_too.is_null() \n            && (unsafe { *quote_these_too.add(c as usize / (std::mem::size_of::<u32>() * 8)) } >> (c as usize % (std::mem::size_of::<u32>() * 8)) & 1) != 0 \n            && !is_right_quote {\n            4476262310586904498\n        } else {\n            3173013908131212616\n        }\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    3173013908131212616 => {\n        if elide_outer_quotes {\n            break 's_25;\n        }\n        escaping = true;\n        if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n            if len < buffersize {\n                unsafe { *buffer.add(len as usize) = '\\'' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.add(len as usize) = '$' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.add(len as usize) = '\\'' as i8; }\n            }\n            len += 1;\n            pending_shell_escape_end = true;\n        }\n        if len < buffersize {\n            unsafe { *buffer.add(len as usize) = '\\\\' as i8; }\n        }\n        len += 1;\n        4476262310586904498\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    4476262310586904498 => {\n        if pending_shell_escape_end && !escaping {\n            if len < buffersize {\n                unsafe { *buffer.add(len as usize) = '\\'' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.add(len as usize) = '\\'' as i8; }\n            }\n            len += 1;\n            pending_shell_escape_end = false;\n        }\n        if len < buffersize {\n            unsafe { *buffer.add(len as usize) = c as i8; }\n        }\n        len += 1;\n        if !c_and_shell_quote_compat {\n            all_c_and_shell_quote_compat = false;\n        }\n        current_block\n    }\n    _ => current_block,\n};\n\ni += 1;\n\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n    return quotearg_buffer_restyled(\n        buffer,\n        orig_buffersize,\n        arg,\n        argsize,\n        c_quoting_style,\n        flags,\n        quote_these_too,\n        left_quote,\n        right_quote,\n    );\n} else {\n    if !(buffersize == 0 && orig_buffersize != 0) {\n        current_block = 6412618891452676311;\n        break;\n    }\n    buffersize = orig_buffersize;\n    len = 0;\n}\n\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub fn quotearg_buffer(\n    buffer: &mut [libc::c_char],\n    arg: &[libc::c_char],\n    o: Option<&quoting_options>,\n) -> usize {\n    let p = match o {\n        Some(options) => options,\n        None => unsafe { &default_quoting_options },\n    };\n    \n    let r = unsafe {\n        quotearg_buffer_restyled(\n            buffer.as_mut_ptr(),\n            buffer.len() as u64,\n            arg.as_ptr(),\n            arg.len() as u64,\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        )\n    };\n\n    r as usize\n}\n#[no_mangle]\npub fn quotearg_alloc(\n    arg: &str,\n    o: &quoting_options,\n) -> *mut libc::c_char {\n    let argsize = arg.len() as u64; // Convert usize to u64\n    let c_string = CString::new(arg).expect(\"CString::new failed\");\n    let size_ptr: *mut u64 = std::ptr::null_mut(); // Create a null pointer for size\n    unsafe { quotearg_alloc_mem(c_string.as_ptr(), argsize, size_ptr, o) } // Call the unsafe function\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};\nstatic mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub fn quotearg_free() {\n    unsafe {\n        let sv = &mut *slotvec;\n        for i in 1..nslots {\n            let val = (*sv).val.offset(i as isize);\n            if !val.is_null() {\n                drop(Box::from_raw(val)); // Assuming val is a pointer to allocated memory\n            }\n        }\n        if (*sv).val != slot0.as_mut_ptr() {\n            let val = (*sv).val;\n            if !val.is_null() {\n                drop(Box::from_raw(val)); // Assuming val is a pointer to allocated memory\n            }\n            slotvec0.size = std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n            slotvec0.val = slot0.as_mut_ptr();\n        }\n        if sv as *mut _ != &mut slotvec0 as *mut _ {\n            drop(Box::from_raw(sv)); // Assuming sv is a pointer to allocated memory\n            slotvec = &mut slotvec0;\n        }\n        nslots = 1;\n    }\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}\n#[no_mangle]\npub fn quotearg(arg: &str) -> String {\n    unsafe {\n        let quoted_arg = quotearg_n(0, CString::new(arg).expect(\"CString::new failed\").as_ptr());\n        CString::from_raw(quoted_arg).into_string().expect(\"Failed to convert CString to String\")\n    }\n}\n#[no_mangle]\npub fn quotearg_mem(arg: &str) -> String {\n    let argsize = arg.len() as u64;\n    let c_string = CString::new(arg).expect(\"CString::new failed\");\n    let result_ptr;\n    unsafe {\n        result_ptr = quotearg_n_mem(0, c_string.as_ptr(), argsize);\n    }\n    unsafe { CString::from_raw(result_ptr).into_string().expect(\"Failed to convert to String\") }\n}\n#[no_mangle]\npub fn quotearg_n_style(\n    n: i32,\n    s: quoting_style,\n    arg: &CStr,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    unsafe {\n        quotearg_n_options(n, arg.as_ptr(), u64::MAX, &o)\n    }\n}\n#[no_mangle]\npub fn quotearg_n_style_mem(\n    n: i32,\n    s: quoting_style,\n    arg: &CStr,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    let argsize: u64 = arg.to_bytes().len() as u64;\n    unsafe { quotearg_n_options(n, arg.as_ptr(), argsize, &o) }\n}\n#[no_mangle]\npub fn quotearg_style(\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let result_ptr = quotearg_n_style(0, s, arg);\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub fn quotearg_style_mem(\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let result_ptr = quotearg_n_style_mem(0, s, arg);\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub fn quotearg_char(arg: &CStr, ch: char) -> CString {\n    let ch_as_c_char = ch as libc::c_char;\n    let result_ptr = unsafe {\n        quotearg_char_mem(arg.as_ptr(), 18446744073709551615 as libc::c_ulong, ch_as_c_char)\n    };\n    unsafe { CStr::from_ptr(result_ptr).to_owned() }\n}\n#[no_mangle]\npub fn quotearg_colon(arg: &CStr) -> CString {\n    quotearg_char(arg, ':' as char)\n}\n#[no_mangle]\npub fn quotearg_colon_mem(arg: &str) -> CString {\n    let argsize = arg.len() as size_t;\n    let result_ptr = unsafe {\n        quotearg_char_mem(arg.as_ptr() as *const libc::c_char, argsize, ':' as i32 as libc::c_char)\n    };\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub fn quotearg_n_style_colon(\n    n: i32,\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: std::ptr::null(),\n        right_quote: std::ptr::null(),\n    };\n    options = quoting_options_from_style(s);\n    \n    unsafe {\n        set_char_quoting(&mut options, ':' as i32 as i8, 1);\n        let result = quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            u64::MAX,\n            &mut options,\n        );\n        CString::from_raw(result)\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o as *mut quoting_options, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub fn quotearg_custom(\n    left_quote: &str,\n    right_quote: &str,\n    arg: &str,\n) -> String {\n    let left_quote_c = CString::new(left_quote).unwrap();\n    let right_quote_c = CString::new(right_quote).unwrap();\n    let arg_c = CString::new(arg).unwrap();\n\n    let quoted_arg_ptr;\n    unsafe {\n        quoted_arg_ptr = quotearg_n_custom(0, left_quote_c.as_ptr(), right_quote_c.as_ptr(), arg_c.as_ptr());\n    }\n    \n    unsafe {\n        CStr::from_ptr(quoted_arg_ptr).to_string_lossy().into_owned()\n    }\n}\n#[no_mangle]\npub fn quotearg_custom_mem(\n    left_quote: &str,\n    right_quote: &str,\n    arg: &str,\n) -> String {\n    let argsize = arg.len() as u64;\n    let left_quote_c = std::ffi::CString::new(left_quote).unwrap();\n    let right_quote_c = std::ffi::CString::new(right_quote).unwrap();\n    let arg_c = std::ffi::CString::new(arg).unwrap();\n\n    let result_ptr;\n    unsafe {\n        result_ptr = quotearg_n_custom_mem(\n            0,\n            left_quote_c.as_ptr(),\n            right_quote_c.as_ptr(),\n            arg_c.as_ptr(),\n            argsize,\n        );\n    }\n\n    unsafe { std::ffi::CString::from_raw(result_ptr).into_string().unwrap() }\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}\n#[no_mangle]\npub fn quote_mem(arg: &CStr) -> CString {\n    let argsize = arg.to_bytes().len() as u64;\n    let quoted_ptr: *const c_char = unsafe { quote_n_mem(0, arg.as_ptr(), argsize) };\n    unsafe { CString::from_raw(quoted_ptr as *mut c_char) }\n}\n#[no_mangle]\npub fn quote_n(n: i32, arg: &str) -> *const libc::c_char {\n    let c_string = CString::new(arg).unwrap();\n    unsafe { quote_n_mem(n, c_string.as_ptr(), u64::MAX) }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    let arg_str = unsafe { CStr::from_ptr(arg).to_string_lossy().into_owned() };\nreturn quote_n(0, &arg_str);\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn setlocale_null_r(\n    category: libc::c_int,\n    buf: &mut Vec<u8>,\n) -> libc::c_int {\n    let bufsize = buf.len() as u64; // Convert usize to u64\n    let buf_ptr = buf.as_mut_ptr() as *mut libc::c_char;\n\n    unsafe {\n        return setlocale_null_r_unlocked(category, buf_ptr, bufsize);\n    }\n}\n#[no_mangle]\npub fn setlocale_null(category: libc::c_int) -> Option<String> {\n    let result = unsafe { setlocale_null_unlocked(category) };\n    if result.is_null() {\n        None\n    } else {\n        unsafe { Some(CStr::from_ptr(result).to_string_lossy().into_owned()) }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\setlocale_null.rs"
    },
    {
      "chunk": "use std::slice;\nuse ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub fn setlocale_null_r_unlocked(\n    category: libc::c_int,\n    buf: &mut Vec<u8>,\n) -> libc::c_int {\n    let result: *const libc::c_char;\n\n    unsafe {\n        result = setlocale_null_unlocked(category);\n    }\n\n    if result.is_null() {\n        if !buf.is_empty() {\n            buf[0] = 0; // Set the first byte to null terminator\n        }\n        return 22;\n    } else {\n        let length: usize = unsafe { strlen(result) } as usize; // Cast to usize\n        if length < buf.len() {\n            buf[..length].copy_from_slice(unsafe { std::slice::from_raw_parts(result as *const u8, length) });\n            buf[length] = 0; // Null terminate\n            return 0;\n        } else {\n            let copy_length = buf.len() - 1;\n            if !buf.is_empty() {\n                let source = unsafe { std::slice::from_raw_parts(result as *const u8, copy_length) };\n                buf[..copy_length].copy_from_slice(source);\n                buf[copy_length] = 0; // Null terminate\n            }\n            return 34;\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\setlocale_null_unlocked.rs"
    },
    {
      "chunk": "#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut, unused_imports)]\n#![feature(extern_types)]\nuse std::ffi::CString;\nuse std::ptr;\nuse std::process;\nuse std::ffi::CStr;\nuse std::io::Write;\nuse ::rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static mut optarg: *mut libc::c_char;\n    static mut optind: libc::c_int;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n    fn ftruncate(__fd: libc::c_int, __length: __off_t) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut Version: *const libc::c_char;\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn close_stdout();\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    static mut program_name: *const libc::c_char;\n    fn set_program_name(argv0: *const libc::c_char);\n    fn exit(_: libc::c_int) -> !;\n    fn atexit(__func: Option::<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn quote_n(n: libc::c_int, arg: *const libc::c_char) -> *const libc::c_char;\n    fn xdectoimax(\n        n_str: *const libc::c_char,\n        min: intmax_t,\n        max: intmax_t,\n        suffixes: *const libc::c_char,\n        err: *const libc::c_char,\n        err_exit: libc::c_int,\n    ) -> intmax_t;\n}\npub type __intmax_t = libc::c_long;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISspace: C2RustUnnamed = 8192;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;\npub type size_t = libc::c_ulong;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type ptrdiff_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\npub type intmax_t = __intmax_t;\npub type C2RustUnnamed_0 = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed_0 = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed_0 = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type rel_mode_t = libc::c_uint;\npub const rm_rup: rel_mode_t = 5;\npub const rm_rdn: rel_mode_t = 4;\npub const rm_max: rel_mode_t = 3;\npub const rm_min: rel_mode_t = 2;\npub const rm_rel: rel_mode_t = 1;\npub const rm_abs: rel_mode_t = 0;\n#[inline]\nfn usable_st_size(sb: &stat) -> bool {\n    (sb.st_mode & 0o170000 as libc::c_uint == 0o100000 as libc::c_uint)\n        || (sb.st_mode & 0o170000 as libc::c_uint == 0o120000 as libc::c_uint)\n        || (sb.st_mode.wrapping_sub(sb.st_mode) != 0 || 0 != 0)\n}\n#[inline]\nfn emit_ancillary_info(program: &CStr) {\n    let infomap_0: [(&CStr, &CStr); 7] = [\n        (CStr::from_bytes_with_nul(b\"[\\0\").unwrap(), CStr::from_bytes_with_nul(b\"test invocation\\0\").unwrap()),\n        (CStr::from_bytes_with_nul(b\"coreutils\\0\").unwrap(), CStr::from_bytes_with_nul(b\"Multi-call invocation\\0\").unwrap()),\n        (CStr::from_bytes_with_nul(b\"sha224sum\\0\").unwrap(), CStr::from_bytes_with_nul(b\"sha2 utilities\\0\").unwrap()),\n        (CStr::from_bytes_with_nul(b\"sha256sum\\0\").unwrap(), CStr::from_bytes_with_nul(b\"sha2 utilities\\0\").unwrap()),\n        (CStr::from_bytes_with_nul(b\"sha384sum\\0\").unwrap(), CStr::from_bytes_with_nul(b\"sha2 utilities\\0\").unwrap()),\n        (CStr::from_bytes_with_nul(b\"sha512sum\\0\").unwrap(), CStr::from_bytes_with_nul(b\"sha2 utilities\\0\").unwrap()),\n        (CStr::from_bytes_with_nul(b\"\\0\").unwrap(), CStr::from_bytes_with_nul(b\"\\0\").unwrap()),\n    ];\n    \n    let mut node = program.as_ptr();\n    let mut map_prog = infomap_0.iter();\n\n    while let Some(&(prog, ref n)) = map_prog.next() {\n        if prog.as_ptr().is_null() || program.as_ptr() == prog.as_ptr() {\n            node = n.as_ptr();\n            break;\n        }\n    }\n\n    let help_url = CStr::from_bytes_with_nul(b\"https://www.gnu.org/software/coreutils/\\0\").unwrap();\n    println!(\n        \"{} online help: <{}>\",\n        CStr::from_bytes_with_nul(b\"GNU coreutils\\0\").unwrap().to_string_lossy(),\n        help_url.to_string_lossy()\n    );\n\n    let lc_messages: *const libc::c_char;\n    unsafe {\n        lc_messages = setlocale(5, std::ptr::null());\n    }\n    \n    if !lc_messages.is_null() {\n        let lc_messages_str = unsafe { CStr::from_ptr(lc_messages) };\n        if !lc_messages_str.to_string_lossy().starts_with(\"en_\") {\n            writeln!(\n                std::io::stdout(),\n                \"{}\",\n                CStr::from_bytes_with_nul(b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\").unwrap().to_string_lossy()\n            ).unwrap();\n        }\n    }\n\n    let url_program = if program.to_bytes() == b\"[\\0\" {\n        CStr::from_bytes_with_nul(b\"test\\0\").unwrap()\n    } else {\n        program\n    };\n\n    println!(\n        \"Full documentation <{}{}>\",\n        help_url.to_string_lossy(),\n        url_program.to_string_lossy()\n    );\n\n    let invocation_suffix = if node == program.as_ptr() {\n        CStr::from_bytes_with_nul(b\" invocation\\0\").unwrap().to_string_lossy()\n    } else {\n        \"\".into()\n    };\n\n    println!(\n        \"or available locally via: info '(coreutils) {}{}'\",\n        unsafe { CStr::from_ptr(node) }.to_string_lossy(),\n        invocation_suffix\n    );\n}\n#[inline]\nfn to_uchar(ch: i8) -> u8 {\n    ch as u8\n}\n#[inline]\nfn emit_mandatory_arg_note() {\n    let message = \"\\nMandatory arguments to long options are mandatory for short options too.\\n\";\n    print!(\"{}\", message);\n}\n#[inline]",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\truncate.rs"
    },
    {
      "chunk": "fn emit_size_note() {\n    let message = \"\\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\\nUnits are K,M,G,T,P,E,Z,Y,R,Q (powers of 1024) or KB,MB,... (powers of 1000).\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\";\n    let translated_message = unsafe { gettext(message.as_ptr() as *const libc::c_char) };\n    let _ = std::io::stdout().write_all(unsafe { std::ffi::CStr::from_ptr(translated_message).to_bytes() });\n}\nstatic mut no_create: bool = false;\nstatic mut block_mode: bool = false;\nstatic mut ref_file: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut longopts: [option; 7] = [\n    {\n        let mut init = option {\n            name: b\"no-create\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'c' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"io-blocks\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'o' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"reference\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'r' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"size\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 's' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];\n#[no_mangle]\npub fn usage(status: i32) {\n    if status != 0 {\n        eprintln!(\n            \"{}\", \n            unsafe { CStr::from_ptr(gettext(format!(\"Try '{} --help' for more information.\\n\", unsafe { CStr::from_ptr(program_name).to_string_lossy() }).as_ptr() as *const i8)).to_string_lossy() }\n        );\n    } else {\n        println!(\n            \"{}\", \n            unsafe { CStr::from_ptr(gettext(format!(\"Usage: {} OPTION... FILE...\\n\", unsafe { CStr::from_ptr(program_name).to_string_lossy() }).as_ptr() as *const i8)).to_string_lossy() }\n        );\n        print!(\n            \"{}\",\n            unsafe { CStr::from_ptr(gettext(\"Shrink or extend the size of each FILE to the specified size\\n\\nA FILE argument that does not exist is created.\\n\\nIf a FILE is larger than the specified size, the extra data is lost.\\nIf a FILE is shorter, it is extended and the sparse extended part (hole)\\nreads as zero bytes.\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        emit_mandatory_arg_note();\n        print!(\n            \"{}\",\n            unsafe { CStr::from_ptr(gettext(\"  -c, --no-create        do not create any files\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        print!(\n            \"{}\",\n            unsafe { CStr::from_ptr(gettext(\"  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        print!(\n            \"{}\",\n            unsafe { CStr::from_ptr(gettext(\"  -r, --reference=RFILE  base size on RFILE\\n  -s, --size=SIZE        set or adjust the file size by SIZE bytes\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        print!(\n            \"{}\",\n            unsafe { CStr::from_ptr(gettext(\"      --help        display this help and exit\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        print!(\n            \"{}\",\n            unsafe { CStr::from_ptr(gettext(\"      --version     output version information and exit\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        emit_size_note();\n        print!(\n            \"{}\",\n            unsafe { CStr::from_ptr(gettext(\"\\nSIZE may also be prefixed by one of the following modifying characters:\\n'+' extend by, '-' reduce by, '<' at most, '>' at least,\\n'/' round down to multiple of, '%' round up to multiple of.\\n\".as_ptr() as *const i8)).to_string_lossy() }\n        );\n        emit_ancillary_info(CStr::from_bytes_with_nul(b\"truncate\\0\").unwrap());\n    }\n    std::process::exit(status);\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\truncate.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn do_ftruncate(\n    mut fd: libc::c_int,\n    mut fname: *const libc::c_char,\n    mut ssize: off_t,\n    mut rsize: off_t,\n    mut rel_mode: rel_mode_t,\n) -> bool {\n    let mut sb: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut nsize: off_t = 0;\n    if (block_mode as libc::c_int != 0\n        || rel_mode as libc::c_uint != 0 && rsize < 0 as libc::c_int as libc::c_long)\n        && fstat(fd, &mut sb) != 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, fname),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    if block_mode {\n        let mut blksize: ptrdiff_t = (if (0 as libc::c_int) < sb.st_blksize\n            && sb.st_blksize as libc::c_ulong\n                <= (-(1 as libc::c_int) as size_t)\n                    .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        {\n            sb.st_blksize\n        } else {\n            512 as libc::c_int\n        }) as ptrdiff_t;\n        let mut ssize0: intmax_t = ssize;\n        if if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t\n            && ((if 1 as libc::c_int != 0 {\n                0 as libc::c_int as libc::c_long\n            } else {\n                ssize\n            }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n            && ((if 1 as libc::c_int != 0 {\n                0 as libc::c_int as libc::c_long\n            } else {\n                blksize\n            }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n            && (if blksize < 0 as libc::c_int as libc::c_long {\n                if ssize < 0 as libc::c_int as libc::c_long {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            -(1 as libc::c_int) as off_t\n                        }) + blksize\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        (ssize < -(1 as libc::c_int) as off_t / blksize) as libc::c_int\n                    } else {\n                        ((if (if (if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            blksize\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            !(((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<ptrdiff_t>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as libc::c_long\n                        }) < 0 as libc::c_int as libc::c_long\n                        {\n                            (blksize\n                                < -(if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    blksize\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<ptrdiff_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) - 1 as libc::c_int as libc::c_long\n                                })) as libc::c_int\n                        } else {\n                            ((0 as libc::c_int as libc::c_long) < blksize) as libc::c_int\n                        }) != 0\n                        {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + -(1 as libc::c_int) as off_t\n                                >> (::core::mem::size_of::<ptrdiff_t>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        } else {\n                            -(1 as libc::c_int) as off_t / -blksize\n                        }) <= -(1 as libc::c_int) as libc::c_long - ssize) as libc::c_int\n                    }\n                } else {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            blksize\n                        }) + 0 as libc::c_int as off_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as off_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as off_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            blksize\n                        }) + 0 as libc::c_int as off_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    blksize\n                                }) + 0 as libc::c_int as off_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) + 0 as libc::c_int as off_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) + 0 as libc::c_int as off_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as off_t) as libc::c_int\n                    }) != 0 && blksize == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            ssize\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < ssize + 0 as libc::c_int as off_t) as libc::c_int\n                        } else {\n                            ((0 as libc::c_int as libc::c_long) < ssize\n                                && (-(1 as libc::c_int) as libc::c_long\n                                    - 0 as libc::c_int as off_t)\n                                    < ssize - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as off_t / blksize < ssize) as libc::c_int\n                    }\n                }\n            } else {\n                if blksize == 0 as libc::c_int as libc::c_long {\n                    0 as libc::c_int\n                } else {\n                    if ssize < 0 as libc::c_int as libc::c_long {\n                        if (if (if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                ssize\n                            }) + 0 as libc::c_int as off_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\truncate.rs"
    },
    {
      "chunk": "                        {\n                            !(((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    ssize\n                                }) + 0 as libc::c_int as off_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    ssize\n                                }) + 0 as libc::c_int as off_t\n                            }) + 0 as libc::c_int as libc::c_long\n                        }) < 0 as libc::c_int as libc::c_long\n                        {\n                            (((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                ssize\n                            }) + 0 as libc::c_int as off_t)\n                                < -(if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        ssize\n                                    }) + 0 as libc::c_int as off_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            ssize\n                                        }) + 0 as libc::c_int as off_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            ssize\n                                        }) + 0 as libc::c_int as off_t\n                                    }) - 1 as libc::c_int as libc::c_long\n                                })) as libc::c_int\n                        } else {\n                            ((0 as libc::c_int as libc::c_long)\n                                < (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    ssize\n                                }) + 0 as libc::c_int as off_t) as libc::c_int\n                        }) != 0 && ssize == -(1 as libc::c_int) as libc::c_long\n                        {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < blksize + 0 as libc::c_int as off_t) as libc::c_int\n                            } else {\n                                ((-(1 as libc::c_int) as libc::c_long\n                                    - 0 as libc::c_int as off_t)\n                                    < blksize - 1 as libc::c_int as libc::c_long) as libc::c_int\n                            }\n                        } else {\n                            (0 as libc::c_int as off_t / ssize < blksize) as libc::c_int\n                        }\n                    } else {\n                        (-(1 as libc::c_int) as off_t / blksize < ssize) as libc::c_int\n                    }\n                }\n            }) != 0\n        {\n            let (fresh4, _fresh5) = ssize.overflowing_mul(blksize);\n            *(&mut ssize as *mut off_t) = fresh4;\n            1 as libc::c_int\n        } else {\n            let (fresh6, fresh7) = ssize.overflowing_mul(blksize);\n            *(&mut ssize as *mut off_t) = fresh6;\n            fresh7 as libc::c_int\n        } != 0\n        {\n            if false {\n    error(\n        0,\n        0,\n        gettext(b\"overflow in %jd * %td byte blocks for file %s\\0\" as *const u8 as *const libc::c_char),\n        ssize0,\n        blksize,\n        quotearg_style(shell_escape_always_quoting_style, fname),\n    );\n    unreachable!();\n} else {\n    let __errstatus: i32 = 0;\n    error(\n        __errstatus,\n        0,\n        gettext(b\"overflow in %jd * %td byte blocks for file %s\\0\" as *const u8 as *const libc::c_char),\n        ssize0,\n        blksize,\n        quotearg_style(shell_escape_always_quoting_style, fname),\n    );\n    unreachable!();\n    \n    let __errstatus: i32 = 0;\n    error(\n        __errstatus,\n        0,\n        gettext(b\"overflow in %jd * %td byte blocks for file %s\\0\" as *const u8 as *const libc::c_char),\n        ssize0,\n        blksize,\n        quotearg_style(shell_escape_always_quoting_style, fname),\n    );\n    unreachable!();\n}\nreturn false;\n\n        }\n    }\n    if rel_mode as u64 != 0 {\n        let mut fsize: i64 = 0;\nif rsize >= 0 {\n    fsize = rsize;\n} else if usable_st_size(&sb) {\n    fsize = sb.st_size;\n    if fsize < 0 {\n        error(\n            0,\n            0,\n            gettext(b\"%s has unusable, apparently negative size\\0\" as *const u8 as *const libc::c_char),\n            quotearg_style(shell_escape_always_quoting_style, fname),\n        );\n        return false;\n    }\n} else {\n    fsize = lseek(fd, 0, 2);\n    if fsize < 0 {\n        error(\n            0,\n            *__errno_location(),\n            gettext(b\"cannot get the size of %s\\0\" as *const u8 as *const libc::c_char),\n            quotearg_style(shell_escape_always_quoting_style, fname),\n        );\n        return false;\n    }\n}\n\n        if rel_mode == rm_min {\n    nsize = fsize.max(ssize);\n} else if rel_mode == rm_max {\n    nsize = fsize.min(ssize);\n} else if rel_mode == rm_rdn {\n    nsize = fsize - fsize % ssize;\n} else {\n    if rel_mode == rm_rup {\n        let r: i64 = fsize % ssize;\n        ssize = if r == 0 { 0 } else { ssize - r };\n    }\n    let (new_nsize, overflowed) = fsize.overflowing_add(ssize);\n    nsize = new_nsize;\n    if overflowed {\n        let __errstatus: i32 = 0;\n        error(\n            __errstatus,\n            0,\n            gettext(b\"overflow extending size of file %s\\0\" as *const u8 as *const libc::c_char),\n            quotearg_style(shell_escape_always_quoting_style, fname),\n        );\n        return false as i32 != 0;\n    }\n}\n\n    } else {\n        nsize = ssize;\n    }\n    if nsize < 0 as libc::c_int as libc::c_long {\n        nsize = 0 as libc::c_int as off_t;\n    }\n    if ftruncate(fd, nsize) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"failed to truncate %s at %jd bytes\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, fname),\n                nsize,\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to truncate %s at %jd bytes\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                    nsize,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to truncate %s at %jd bytes\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                    nsize,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    return 1 as libc::c_int != 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\truncate.rs"
    },
    {
      "chunk": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut got_size: bool = 0 as libc::c_int != 0;\n    let mut size: off_t = 0 as libc::c_int as off_t;\n    let mut rsize: off_t = -(1 as libc::c_int) as off_t;\n    let mut rel_mode: rel_mode_t = rm_abs;\n    let mut c: libc::c_int = 0;\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    loop {\n        c = getopt_long(\n            argc,\n            argv,\n            b\"cor:s:\\0\" as *const u8 as *const libc::c_char,\n            longopts.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if !(c != -(1 as libc::c_int)) {\n            break;\n        }\n        match c {\n            99 => {\n                no_create = 1 as libc::c_int != 0;\n            }\n            111 => {\n                block_mode = 1 as libc::c_int != 0;\n            }\n            114 => {\n                ref_file = optarg;\n            }\n            115 => {\n                while *(*__ctype_b_loc())\n                    .offset(to_uchar(*optarg) as libc::c_int as isize) as libc::c_int\n                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n                {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                match *optarg as libc::c_int {\n                    60 => {\n                        rel_mode = rm_max;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    62 => {\n                        rel_mode = rm_min;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    47 => {\n                        rel_mode = rm_rdn;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    37 => {\n                        rel_mode = rm_rup;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    _ => {}\n                }\n                while *(*__ctype_b_loc())\n                    .offset(to_uchar(*optarg) as libc::c_int as isize) as libc::c_int\n                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n                {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                if *optarg as libc::c_int == '+' as i32\n                    || *optarg as libc::c_int == '-' as i32\n                {\n                    if rel_mode as u64 != 0 {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"multiple relative modifiers specified\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"multiple relative modifiers specified\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"multiple relative modifiers specified\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                        usage(1);\n                    }\n                    rel_mode = rm_rel;\n                }\n                size = xdectoimax(\n                    optarg,\n                    !if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                        -(1 as libc::c_int) as off_t\n                    } else {\n                        (((1 as libc::c_int as off_t)\n                            << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long\n                    },\n                    if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                        -(1 as libc::c_int) as off_t\n                    } else {\n                        (((1 as libc::c_int as off_t)\n                            << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long\n                    },\n                    b\"EgGkKmMPQRtTYZ0\\0\" as *const u8 as *const libc::c_char,\n                    gettext(b\"Invalid number\\0\" as *const u8 as *const libc::c_char),\n                    0 as libc::c_int,\n                );\n                if (rel_mode == rm_rup || rel_mode == rm_rdn) && size == 0 {\n    if 0 != 0 {\n        error(\n            1,\n            0,\n            gettext(b\"division by zero\\0\".as_ptr() as *const libc::c_char),\n        );\n        if true {\n            unreachable!();\n        }\n    } else {\n        let __errstatus: i32 = 1;\n        error(\n            __errstatus,\n            0,\n            gettext(b\"division by zero\\0\".as_ptr() as *const libc::c_char),\n        );\n        if __errstatus != 0 {\n            unreachable!();\n        }\n\n        let __errstatus: i32 = 1;\n        error(\n            __errstatus,\n            0,\n            gettext(b\"division by zero\\0\".as_ptr() as *const libc::c_char),\n        );\n        if __errstatus != 0 {\n            unreachable!();\n        }\n    }\n}\ngot_size = true;\n\n            }\n            -2 => {\n                usage(0);\n            }\n            -3 => {\n                version_etc(\n    stdout,\n    CString::new(\"truncate\").unwrap().as_ptr(),\n    CString::new(\"GNU coreutils\").unwrap().as_ptr(),\n    Version,\n    proper_name_lite(\n        CString::new(\"Padraig Brady\").unwrap().as_ptr(),\n        CString::new(\"P\u00e1draig Brady\").unwrap().as_ptr(),\n    ),\n    std::ptr::null_mut::<libc::c_char>(),\n);\nstd::process::exit(0);\n\n            }\n            _ => {\n                usage(1);\n            }\n        }\n    }\n    argv = argv.offset(optind as isize);\n    argc -= optind;\n    if ref_file.is_null() && !got_size {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"you must specify either %s or %s\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quote_n(\n                    0 as libc::c_int,\n                    b\"--size\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote_n(\n                    1 as libc::c_int,\n                    b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify either %s or %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify either %s or %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1);\n    }\n    if !ref_file.is_null() && got_size as libc::c_int != 0 && rel_mode as u64 == 0 {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"you must specify a relative %s with %s\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quote_n(\n                    0 as libc::c_int,\n                    b\"--size\\0\" as *const u8 as *const libc::c_char,\n                ),",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\truncate.rs"
    },
    {
      "chunk": "                quote_n(\n                    1 as libc::c_int,\n                    b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify a relative %s with %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify a relative %s with %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1);\n    }\n    if block_mode as libc::c_int != 0 && !got_size {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s was specified but %s was not\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quote_n(\n                    0 as libc::c_int,\n                    b\"--io-blocks\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote_n(\n                    1 as libc::c_int,\n                    b\"--size\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s was specified but %s was not\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--io-blocks\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s was specified but %s was not\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--io-blocks\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1);\n    }\n    if argc < 1 {\n    let errstatus = 0;\n    error(errstatus, 0, gettext(b\"missing file operand\\0\".as_ptr() as *const libc::c_char));\n    if errstatus != 0 {\n        unreachable!();\n    }\n    usage(1);\n}\n\n    if !ref_file.is_null() {\n    let ref_file_str = unsafe { std::ffi::CStr::from_ptr(ref_file) };\n    let ref_file_path = ref_file_str.to_str().unwrap();\n\n    let sb = std::fs::metadata(ref_file_path).map_err(|e| {\n        error(\n            1,\n            e.raw_os_error().unwrap_or(0),\n            gettext(b\"cannot stat %s\\0\" as *const u8 as *const libc::c_char),\n            quotearg_style(shell_escape_always_quoting_style, ref_file),\n        );\n    });\n\n    let mut file_size: i64 = -1;\n    if let Ok(metadata) = sb {\n        file_size = metadata.len() as i64;\n    } else {\n        let ref_fd = open(ref_file, 0);\n        if ref_fd >= 0 {\n            let file_end = unsafe { lseek(ref_fd, 0, 2) };\n            let saved_errno = std::io::Error::last_os_error().raw_os_error().unwrap_or(0);\n            unsafe { close(ref_fd) };\n            if file_end >= 0 {\n                file_size = file_end;\n            } else {\n                // Note: We cannot set errno directly in safe Rust.\n                // This is a workaround to handle the error appropriately.\n                std::process::exit(saved_errno);\n            }\n        }\n    }\n\n    if file_size < 0 {\n        error(\n            1,\n            std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n            gettext(b\"cannot get the size of %s\\0\" as *const u8 as *const libc::c_char),\n            quotearg_style(shell_escape_always_quoting_style, ref_file),\n        );\n    }\n\n    if !got_size {\n        size = file_size;\n    } else {\n        rsize = file_size;\n    }\n}\n\nlet oflags = 0o1 | if no_create { 0 } else { 0o100 } | 0o4000;\nlet mut errors = false;\nlet mut fname: *const libc::c_char = std::ptr::null();\n\n    loop {\n    let fname = match unsafe { *argv } {\n        ptr if ptr.is_null() => break,\n        ptr => ptr,\n    };\n\n    let fd = open(fname, oflags, 0o400 | 0o200 | 0o400 >> 3 | 0o200 >> 3 | 0o400 >> 6 | 0o200 >> 6);\n    \n    if fd < 0 {\n        if !(no_create && unsafe { *__errno_location() } == 2) {\n            let error_message = gettext(b\"cannot open %s for writing\\0\" as *const u8 as *const libc::c_char);\n            error(0, unsafe { *__errno_location() }, error_message, quotearg_style(shell_escape_always_quoting_style, fname));\n            errors = true;\n        }\n    } else {\n        errors |= !do_ftruncate(fd, fname, size, rsize, rel_mode);\n        if close(fd) != 0 {\n            let error_message = gettext(b\"failed to close %s\\0\" as *const u8 as *const libc::c_char);\n            error(0, unsafe { *__errno_location() }, error_message, quotearg_style(shell_escape_always_quoting_style, fname));\n            errors = true;\n        }\n    }\n    argv = argv.add(1);\n}\nreturn if errors { 1 } else { 0 };\n\n}\nub fn main() {\n    let args: Vec<CString> = ::std::env::args()\n        .map(|arg| CString::new(arg).expect(\"Failed to convert argument into CString.\"))\n        .collect();\n    \n    let argc = args.len() as libc::c_int;\n    let argv: Vec<*mut libc::c_char> = args.iter()\n        .map(|cstr| cstr.as_ptr() as *mut libc::c_char)\n        .chain(std::iter::once(std::ptr::null_mut()))\n        .collect();\n    \n    let status = unsafe { main_0(argc, argv.as_ptr() as *mut *mut libc::c_char) };\n    ::std::process::exit(status as i32);\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\truncate.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\version.rs"
    },
    {
      "chunk": "use std::ffi;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n    0 => {}\n    1 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n            );\n        }\n    }\n    2 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n            );\n        }\n    }\n    3 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n            );\n        }\n    }\n    4 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n            );\n        }\n    }\n    5 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n                *authors.offset(4),\n            );\n        }\n    }\n    6 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n                *authors.offset(4),\n                *authors.offset(5),\n            );\n        }\n    }\n    7 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, %s, %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n                *authors.offset(4),\n                *authors.offset(5),\n                *authors.offset(6),\n            );\n        }\n    }\n    8 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, %s, %s, %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n                *authors.offset(4),\n                *authors.offset(5),\n                *authors.offset(6),\n                *authors.offset(7),\n            );\n        }\n    }\n    9 => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, %s, %s, %s, %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n                *authors.offset(4),\n                *authors.offset(5),\n                *authors.offset(6),\n                *authors.offset(7),\n                *authors.offset(8),\n            );\n        }\n    }\n    _ => {\n        unsafe {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s, %s, %s, %s, %s, %s, %s, %s, and others.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0),\n                *authors.offset(1),\n                *authors.offset(2),\n                *authors.offset(3),\n                *authors.offset(4),\n                *authors.offset(5),\n                *authors.offset(6),\n                *authors.offset(7),\n                *authors.offset(8),\n            );\n        }\n    }\n};\n\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\version_etc.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub fn emit_bug_reporting_address() {\n    println!();\n    let report_bugs = unsafe {\n        gettext(b\"Report bugs to: bug-coreutils@gnu.org\\0\".as_ptr() as *const libc::c_char)\n    };\n    let home_page = unsafe {\n        gettext(b\"GNU coreutils home page: <https://www.gnu.org/software/coreutils/>\\0\".as_ptr() as *const libc::c_char)\n    };\n    let help_page = unsafe {\n        gettext(b\"General help using GNU software: <https://www.gnu.org/gethelp/>\\0\".as_ptr() as *const libc::c_char)\n    };\n    \n    println!(\"{}\", unsafe { std::ffi::CStr::from_ptr(report_bugs).to_string_lossy() });\n    println!(\"{}\", unsafe { std::ffi::CStr::from_ptr(home_page).to_string_lossy() });\n    println!(\"{}\", unsafe { std::ffi::CStr::from_ptr(help_page).to_string_lossy() });\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\version_etc.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\version_etc_fsf.rs"
    },
    {
      "chunk": "use std::process;\nuse ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub fn xalloc_die() {\n    unsafe {\n        if 0 != 0 {\n            error(\n                exit_failure,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if exit_failure != 0 {\n                unreachable!();\n            }\n        } else {\n            let errstatus = exit_failure;\n            error(\n                errstatus,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if errstatus != 0 {\n                unreachable!();\n            }\n\n            let errstatus = exit_failure;\n            error(\n                errstatus,\n                0,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if errstatus != 0 {\n                unreachable!();\n            }\n        }\n    }\n    std::process::abort();\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\xalloc_die.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn xstrtoimax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut intmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n}\npub type __intmax_t = libc::c_long;\npub type intmax_t = __intmax_t;\npub const LONGINT_OK: strtol_error = 0;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\n#[no_mangle]\npub unsafe extern \"C\" fn xnumtoimax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: intmax_t = 0;\n    s_err = xstrtoimax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_long {\n                *__errno_location() = 75 as libc::c_int;\n            } else if tnum\n                < ((-(2147483647 as libc::c_int) - 1 as libc::c_int) / 2 as libc::c_int)\n                    as libc::c_long\n            {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xdectoimax(\n    mut n_str: *const libc::c_char,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    return xnumtoimax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\xdectoimax.rs"
    },
    {
      "chunk": "use std::option::Option;\nuse std::string::String;\nuse std::slice;\nuse std::alloc::{self, Layout};\nuse std::mem;\nuse std::vec::Vec;\nuse ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nunsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[inline]\nunsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[inline]\nfn ireallocarray(n: usize, s: usize) -> *mut libc::c_void {\n    if n <= usize::MAX && s <= usize::MAX {\n        let mut nx = n;\n        let mut sx = s;\n        if n == 0 || s == 0 {\n            sx = 1;\n            nx = sx;\n        }\n        let p = unsafe { reallocarray(std::ptr::null_mut(), nx.try_into().unwrap(), sx.try_into().unwrap()) };\n        return p;\n    } else {\n        return std::ptr::null_mut(); // Handle out of memory or invalid allocation\n    }\n}\n#[cold]\n#[inline]\nunsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}\n#[inline]\nfn imalloc(s: usize) -> *mut libc::c_void {\n    if s <= usize::MAX {\n        let layout = std::alloc::Layout::from_size_align(s, 1).unwrap();\n        let ptr = unsafe { std::alloc::alloc(layout) };\n        if ptr.is_null() {\n            std::ptr::null_mut()\n        } else {\n            ptr as *mut libc::c_void\n        }\n    } else {\n        std::ptr::null_mut()\n    }\n}\nfn check_nonnull(p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        unsafe { xalloc_die() };\n    }\n    p\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    let allocated_memory = imalloc(s.try_into().unwrap());\nreturn check_nonnull(allocated_memory);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}\n#[no_mangle]\npub fn xrealloc(p: *mut libc::c_void, s: usize) -> *mut libc::c_void {\n    if p.is_null() && s == 0 {\n        return std::ptr::null_mut();\n    }\n\n    let mut vec = if p.is_null() {\n        vec![0; s]\n    } else {\n        let slice = unsafe { std::slice::from_raw_parts_mut(p as *mut u8, s) };\n        let mut v = Vec::from(slice);\n        v.resize(s, 0);\n        v\n    };\n\n    let ptr = vec.as_mut_ptr();\n    std::mem::forget(vec); // Prevent Vec from deallocating the memory\n    ptr as *mut libc::c_void\n}\n#[no_mangle]\npub fn xirealloc(p: &mut Vec<u8>, s: usize) -> Option<Vec<u8>> {\n    let mut new_vec = Vec::with_capacity(s);\n    let len = p.len();\n    new_vec.extend_from_slice(p);\n    new_vec.resize(s, 0);\n    Some(new_vec)\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub fn xireallocarray(n: usize, s: usize) -> Option<Vec<u8>> {\n    let total_size = n.checked_mul(s)?;\n    let mut vec = Vec::with_capacity(total_size);\n    // Assuming that the original function's purpose is to reallocate an array,\n    // we can return the vector as a byte array.\n    Some(vec)\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub fn xinmalloc(n: idx_t, s: idx_t) -> Vec<u8> {\n    let size = n.checked_mul(s).expect(\"Overflow in allocation size\");\n    Vec::with_capacity(size as usize)\n}\n#[no_mangle]\npub fn x2realloc(\n    p: &[u8],\n    ps: &mut usize,\n) -> Vec<u8> {\n    let new_size = *ps + 1; // Assuming we want to allocate one more byte\n    let mut new_vec = Vec::with_capacity(new_size);\n    new_vec.extend_from_slice(p);\n    *ps = new_size; // Update the size\n    new_vec\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa as *mut libc::c_void, nbytes as usize);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub fn xzalloc(s: usize) -> Vec<u8> {\n    let size = s * std::mem::size_of::<u8>();\n    Vec::with_capacity(size)\n}\n#[no_mangle]\npub fn xizalloc(s: idx_t) -> Vec<u8> {\n    let layout = Layout::from_size_align(s as usize, 1).expect(\"Invalid layout\");\n    let ptr = unsafe { alloc::alloc(layout) };\n    if ptr.is_null() {\n        panic!(\"Memory allocation failed\");\n    }\n    let vec = unsafe { Vec::from_raw_parts(ptr, s as usize, s as usize) };\n    vec\n}\n#[no_mangle]\npub fn xcalloc(n: usize, s: usize) -> *mut libc::c_void {\n    let total_size = n.checked_mul(s).expect(\"Overflow in multiplication\");\n    let vec = vec![0u8; total_size];\n    let boxed_slice = vec.into_boxed_slice();\n    Box::into_raw(boxed_slice) as *mut libc::c_void\n}\n#[no_mangle]\npub fn xicalloc(n: usize, s: usize) -> *mut libc::c_void {\n    let total_size = n.checked_mul(s).expect(\"Overflow in allocation size\");\n    let allocation = vec![0u8; total_size].into_boxed_slice();\n    Box::into_raw(allocation) as *mut libc::c_void\n}\n#[no_mangle]\npub fn xmemdup(p: &[u8]) -> Vec<u8> {\n    let mut result = vec![0; p.len()];\n    result.copy_from_slice(p);\n    result\n}\n#[no_mangle]\npub fn ximemdup(p: &[u8]) -> Vec<u8> {\n    let mut result = vec![0; p.len()];\n    result.copy_from_slice(p);\n    result\n}\n#[no_mangle]\npub fn ximemdup0(p: &[u8]) -> Vec<u8> {\n    let mut result = vec![0; p.len() + 1];\n    result[..p.len()].copy_from_slice(p);\n    result[p.len()] = 0; // Null-terminate the string\n    result\n}\n#[no_mangle]\npub fn xstrdup(string: &str) -> String {\n    let length = string.len();\n    let mut vec = Vec::with_capacity(length + 1);\n    vec.extend_from_slice(string.as_bytes());\n    vec.push(0); // Null-terminate the string\n    String::from_utf8(vec).expect(\"Failed to convert to String\")\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtoimax(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __base: libc::c_int,\n    ) -> intmax_t;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n}\npub type __intmax_t = libc::c_long;\npub type intmax_t = __intmax_t;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub const _ISspace: C2RustUnnamed = 8192;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\xstrtoimax.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn bkm_scale(\n    mut x: *mut intmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: intmax_t = 0;\n    if if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { *x })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as intmax_t\n                    }) + scale_factor as libc::c_long\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (*x < -(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + -(1 as libc::c_int) as intmax_t\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as intmax_t / -scale_factor as libc::c_long\n                    }) <= -(1 as libc::c_int) as libc::c_long - *x) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n                        as libc::c_long + 0 as libc::c_int as intmax_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        *x\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < *x + 0 as libc::c_int as intmax_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < *x\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < *x - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as intmax_t / scale_factor as libc::c_long) < *x)\n                        as libc::c_int\n                }\n            }\n        } else {\n            if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    *x\n                                }) + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < scale_factor as libc::c_long\n                                    + 0 as libc::c_int as intmax_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_long)",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\xstrtoimax.rs"
    },
    {
      "chunk": "                                as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as intmax_t / *x\n                            < scale_factor as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        < *x) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_long {\n            !if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n                -(1 as libc::c_int) as intmax_t\n            } else {\n                (((1 as libc::c_int as intmax_t)\n                    << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            }\n        } else if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n            -(1 as libc::c_int) as intmax_t\n        } else {\n            (((1 as libc::c_int as intmax_t)\n                << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}\nfn bkm_scale_by_power(\n    x: &mut i64, // Assuming intmax_t is equivalent to i64 in Rust\n    base: i32,\n    mut power: i32,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    while power > 0 {\n        power -= 1;\n        // Call to the unsafe function is wrapped in an unsafe block\n        unsafe {\n            err |= bkm_scale(x, base);\n        }\n    }\n    err\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrtoimax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut intmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: intmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 78],\n                &[libc::c_char; 78],\n            >(\n                b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2247: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 78],\n                    &[libc::c_char; 78],\n                >(\n                    b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoimax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as intmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if !(*p).is_null() && **p != 0 {\n    let mut base: i32 = 1024;\n    let mut suffixes: i32 = 1;\n    let mut overflow: strtol_error = LONGINT_OK;\n\n    let valid_suffixes_str = unsafe { std::ffi::CStr::from_ptr(valid_suffixes).to_string_lossy() };\n    if !valid_suffixes_str.contains(**p as u8 as char) {\n        *val = tmp;\n        return (err | LONGINT_INVALID_SUFFIX_CHAR) as strtol_error;\n    }\n\n    match **p as u8 {\n        b'E' | b'G' | b'g' | b'k' | b'K' | b'M' | b'm' | b'P' | b'Q' | b'R' | b'T' | b't' | b'Y' | b'Z' => {\n            if valid_suffixes_str.contains('0') {\n                match unsafe { *(*p).offset(1) } as u8 {\n                    b'i' => {\n                        if unsafe { *(*p).offset(2) } as u8 == b'B' {\n                            suffixes += 2;\n                        }\n                    }\n                    b'B' | b'D' => {\n                        base = 1000;\n                        suffixes += 1;\n                    }\n                    _ => {}\n                }\n            }\n        }\n        _ => {}\n    }\n\n    match **p as u8 {\n        b'b' => {\n            overflow = bkm_scale(&mut tmp, 512);\n        }\n        b'B' => {\n            overflow = bkm_scale(&mut tmp, 1024);\n        }\n        b'c' => {\n            overflow = LONGINT_OK;\n        }\n        b'E' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 6);\n        }\n        b'G' | b'g' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 3);\n        }\n        b'k' | b'K' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 1);\n        }\n        b'M' | b'm' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 2);\n        }\n        b'P' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 5);\n        }\n        b'Q' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 10);\n        }\n        b'R' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 9);\n        }\n        b'T' | b't' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 4);\n        }\n        b'w' => {\n            overflow = bkm_scale(&mut tmp, 2);\n        }\n        b'Y' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 8);\n        }\n        b'Z' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 7);\n        }\n        _ => {\n            *val = tmp;\n            return (err | LONGINT_INVALID_SUFFIX_CHAR) as strtol_error;\n        }\n    }\n\n    err |= overflow as u32;\n    *p = unsafe { (*p).offset(suffixes as isize) };\n    if **p != 0 {\n        err |= LONGINT_INVALID_SUFFIX_CHAR;\n    }\n}\n*val = tmp;\nreturn err;\n\n}",
      "file_name": "c2saferrust/coreutils/src\\truncate\\rust_WIP\\src\\xstrtoimax.rs"
    }
  ],
  "uniq": [
    {
      "chunk": "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\build.rs"
    },
    {
      "chunk": "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(label_break_value)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod argmatch;\npub mod c32isblank;\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod close_stream;\npub mod closeout;\npub mod exitfail;\npub mod fadvise;\npub mod fclose;\npub mod fflush;\npub mod fpurge;\npub mod freopen_safer;\npub mod fseeko;\npub mod hard_locale;\npub mod ialloc;\npub mod linebuffer;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod mcel;\npub mod memcasecmp;\npub mod posixver;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod skipchars;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalloc_die;\npub mod xmalloc;\npub mod xstrtoimax;\n}\n// mod src",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\lib.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stderr: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn putc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn quote_n(n: libc::c_int, arg: *const libc::c_char) -> *const libc::c_char;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn quotearg_n_style(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn usage(_e: libc::c_int);\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type argmatch_exit_fn = Option::<unsafe extern \"C\" fn() -> ()>\n;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\nunsafe extern \"C\" fn __argmatch_die() {\n    usage(1 as libc::c_int);\n}\n#[no_mangle]\npub static mut argmatch_die: argmatch_exit_fn = unsafe {\n    Some(__argmatch_die as unsafe extern \"C\" fn() -> ())\n};\n#[no_mangle]\npub fn argmatch(\n    arg: &str,\n    arglist: &[&str],\n    vallist: Option<&[u8]>,\n    valsize: usize,\n) -> isize {\n    let arglen = arg.len();\n    let mut matchind: isize = -1;\n    let mut ambiguous = false;\n\n    for (i, &arg_item) in arglist.iter().enumerate() {\n        if arg_item.starts_with(arg) {\n            if arg_item.len() == arglen {\n                return i as isize;\n            } else if matchind == -1 {\n                matchind = i as isize;\n            } else if let Some(vallist) = vallist {\n                if valsize * matchind as usize >= vallist.len() || valsize * i >= vallist.len() {\n                    ambiguous = true;\n                    break;\n                }\n                if &vallist[valsize * matchind as usize..valsize * matchind as usize + valsize] != \n                   &vallist[valsize * i..valsize * i + valsize] {\n                    ambiguous = true;\n                }\n            } else {\n                ambiguous = true;\n            }\n        }\n    }\n\n    if ambiguous {\n        -2\n    } else {\n        matchind\n    }\n}\n#[no_mangle]\npub fn argmatch_exact(\n    arg: &str,\n    arglist: &[&str],\n) -> isize {\n    for (i, &item) in arglist.iter().enumerate() {\n        if item == arg {\n            return i as isize;\n        }\n    }\n    return -1;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch_invalid(\n    mut context: *const libc::c_char,\n    mut value: *const libc::c_char,\n    mut problem: ptrdiff_t,\n) {\n    let mut format: *const libc::c_char = if problem\n        == -(1 as libc::c_int) as libc::c_long\n    {\n        gettext(b\"invalid argument %s for %s\\0\" as *const u8 as *const libc::c_char)\n    } else {\n        gettext(b\"ambiguous argument %s for %s\\0\" as *const u8 as *const libc::c_char)\n    };\n    if 0 != 0 {\n        error(\n            0 as libc::c_int,\n            0 as libc::c_int,\n            format,\n            quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n            quote_n(1 as libc::c_int, context),\n        );\n        if 0 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 0 as libc::c_int;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                format,\n                quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n                quote_n(1 as libc::c_int, context),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 0 as libc::c_int;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                format,\n                quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n                quote_n(1 as libc::c_int, context),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch_valid(\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) {\n    let mut i: size_t = 0;\n    let mut last_val: *const libc::c_char = 0 as *const libc::c_char;\n    fputs_unlocked(\n        gettext(b\"Valid arguments are:\\0\" as *const u8 as *const libc::c_char),\n        stderr,\n    );\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if i == 0 as libc::c_int as libc::c_ulong\n            || memcmp(\n                last_val as *const libc::c_void,\n                (vallist as *const libc::c_char).offset(valsize.wrapping_mul(i) as isize)\n                    as *const libc::c_void,\n                valsize,\n            ) != 0\n        {\n            fprintf(\n                stderr,\n                b\"\\n  - %s\\0\" as *const u8 as *const libc::c_char,\n                quote(*arglist.offset(i as isize)),\n            );\n            last_val = (vallist as *const libc::c_char)\n                .offset(valsize.wrapping_mul(i) as isize);\n        } else {\n            fprintf(\n                stderr,\n                b\", %s\\0\" as *const u8 as *const libc::c_char,\n                quote(*arglist.offset(i as isize)),\n            );\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    putc_unlocked('\\n' as i32, stderr);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn __xargmatch_internal(\n    mut context: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n    mut exit_fn: argmatch_exit_fn,\n    mut allow_abbreviation: bool,\n) -> ptrdiff_t {\n    let mut res: ptrdiff_t = 0;\n    if allow_abbreviation {\n        let arg_str = unsafe { std::ffi::CStr::from_ptr(arg).to_string_lossy().into_owned() };\nlet arglist_slice: Vec<&str> = unsafe {\n    let mut vec = Vec::new();\n    let mut i = 0;\n    while !(*arglist.offset(i as isize)).is_null() {\n        vec.push(std::ffi::CStr::from_ptr(*arglist.offset(i as isize)).to_str().unwrap());\n        i += 1;\n    }\n    vec\n};\nlet res = argmatch(\n    &arg_str,\n    &arglist_slice,\n    if vallist.is_null() { None } else { Some(std::slice::from_raw_parts(vallist as *const u8, valsize.try_into().unwrap())) },\n    valsize as usize,\n);\n    } else {\n        let arg_str = unsafe { std::ffi::CStr::from_ptr(arg).to_string_lossy().into_owned() };\nlet mut arglist_vec = Vec::new();\nlet mut i = 0;\nwhile !unsafe { *arglist.offset(i) }.is_null() {\n    let item = unsafe { std::ffi::CStr::from_ptr(*arglist.offset(i)).to_string_lossy().into_owned() };\n    arglist_vec.push(item.to_string());\n    i += 1;\n}\nlet arglist_slice: Vec<&str> = arglist_vec.iter().map(|s| s.as_str()).collect();\nlet res = argmatch_exact(&arg_str, &arglist_slice);\n    }\n    if res >= 0 as libc::c_int as libc::c_long {\n        return res;\n    }\n    argmatch_invalid(context, arg, res);\n    argmatch_valid(arglist, vallist, valsize);\n    (Some(exit_fn.expect(\"non-null function pointer\")))\n        .expect(\"non-null function pointer\")();\n    return -(1 as libc::c_int) as ptrdiff_t;\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\argmatch.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn argmatch_to_argument(\n    mut value: *const libc::c_void,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) -> *const libc::c_char {\n    let mut i: size_t = 0;\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if memcmp(\n            value,\n            (vallist as *const libc::c_char).offset(valsize.wrapping_mul(i) as isize)\n                as *const libc::c_void,\n            valsize,\n        ) == 0\n        {\n            return *arglist.offset(i as isize);\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as *const libc::c_char;\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\argmatch.rs"
    },
    {
      "chunk": "use std::ffi::CString;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub fn close_stdout_set_file_name(file: &str) {\n    let c_file = std::ffi::CString::new(file).expect(\"CString::new failed\");\n    unsafe {\n        file_name = c_file.into_raw();\n    }\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\nuse std::sync::atomic::{AtomicBool, Ordering};\nstatic IGNORE_EPIPE: AtomicBool = AtomicBool::new(false);\npub fn close_stdout_set_ignore_EPIPE(ignore: bool) {\n    IGNORE_EPIPE.store(ignore, Ordering::Relaxed);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\closeout.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn close_stream(stream: *mut _IO_FILE) -> libc::c_int {\n    let some_pending: bool = unsafe { __fpending(stream) != 0 };\n    let prev_fail: bool = unsafe { ferror_unlocked(stream) != 0 };\n    let fclose_fail: bool = unsafe { rpl_fclose(stream) != 0 };\n\n    if prev_fail\n        || (fclose_fail && (some_pending || unsafe { *__errno_location() != 9 }))\n    {\n        if !fclose_fail {\n            unsafe { *__errno_location() = 0 };\n        }\n        return -1;\n    }\n    return 0;\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\close_stream.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalnum(c: i32) -> bool {\n    matches!(c, 48..=57 | 65..=90 | 97..=122)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isalpha(c: i32) -> bool {\n    (c >= 65 && c <= 90) || (c >= 97 && c <= 122)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isascii(c: i32) -> bool {\n    (0..=127).contains(&c)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isblank(c: i32) -> bool {\n    c == ' ' as i32 || c == '\\t' as i32\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_iscntrl(c: i32) -> bool {\n    match c {\n        0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 \n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isdigit(c: i32) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isgraph(c: i32) -> bool {\n    match c {\n        48..=57 | 97..=122 | 33..=47 | 58..=64 | 91..=96 | 123..=126 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_islower(c: i32) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isprint(c: i32) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_ispunct(c: i32) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isspace(c: i32) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isupper(c: i32) -> bool {\n    matches!(c, 65..=90)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_isxdigit(c: i32) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => true,\n        _ => false,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_tolower(c: i32) -> i32 {\n    match c {\n        65..=90 => c + 32,\n        _ => c,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn c_toupper(c: i32) -> i32 {\n    match c {\n        97..=122 => c - ('a' as i32) + ('A' as i32),\n        _ => c,\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\c_ctype.rs"
    },
    {
      "chunk": "use std::char;\nuse ::libc;\n#[inline]\nfn c_tolower(c: i32) -> i32 {\n    match c {\n        65..=90 => c - 'A' as i32 + 'a' as i32,\n        _ => c,\n    }\n}\n#[no_mangle]\npub fn c_strcasecmp(s1: &str, s2: &str) -> libc::c_int {\n    let c1 = s1.chars().map(|c| c_tolower(c as i32));\n    let c2 = s2.chars().map(|c| c_tolower(c as i32));\n    \n    for (ch1, ch2) in c1.zip(c2) {\n        if ch1 != ch2 {\n            return ch1 - ch2;\n        }\n    }\n    \n    // If one string is a prefix of the other, we need to compare their lengths\n    let len_diff = s1.len() as libc::c_int - s2.len() as libc::c_int;\n    if len_diff != 0 {\n        return len_diff;\n    }\n    \n    0\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\c_strcasecmp.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\exitfail.rs"
    },
    {
      "chunk": "use std::os::unix::io::AsRawFd;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn posix_fadvise(\n        __fd: libc::c_int,\n        __offset: off_t,\n        __len: off_t,\n        __advise: libc::c_int,\n    ) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type fadvice_t = libc::c_uint;\npub const FADVISE_RANDOM: fadvice_t = 1;\npub const FADVISE_WILLNEED: fadvice_t = 3;\npub const FADVISE_DONTNEED: fadvice_t = 4;\npub const FADVISE_NOREUSE: fadvice_t = 5;\npub const FADVISE_SEQUENTIAL: fadvice_t = 2;\npub const FADVISE_NORMAL: fadvice_t = 0;\n#[no_mangle]\npub fn fdadvise(\n    fd: i32,\n    offset: i64,\n    len: i64,\n    advice: fadvice_t,\n) {\n    unsafe {\n        posix_fadvise(fd, offset, len, advice as i32);\n    }\n}\n#[no_mangle]\npub fn fadvise(fp: &mut std::fs::File, advice: fadvice_t) {\n    let fd = fp.as_raw_fd();\n    fdadvise(fd, 0, 0, advice);\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\fadvise.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub fn rpl_fclose(fp: &mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0;\n    \n    // Unsafe block for operations that require raw pointers or FFI\n    let fd = unsafe { fileno(fp) };\n    \n    if fd < 0 {\n        return unsafe { fclose(fp) };\n    }\n    \n    let is_reading = unsafe { __freading(fp) != 0 };\n    let seek_result = unsafe { lseek(fd, 0, libc::SEEK_CUR) };\n    \n    if (!is_reading || seek_result == -1) && unsafe { rpl_fflush(fp) } != 0 {\n        saved_errno = unsafe { *__errno_location() };\n    }\n    \n    let result = unsafe { fclose(fp) };\n    \n    if saved_errno != 0 {\n        unsafe { *__errno_location() = saved_errno };\n        return -1;\n    }\n    \n    result\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\fclose.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nfn clear_ungetc_buffer_preserving_position(fp: *mut FILE) {\n    let flags = unsafe { (*fp)._flags }; // Accessing _flags from the raw pointer\n    if flags & 0x100 != 0 {\n        unsafe {\n            rpl_fseeko(fp, 0, 1); // Using 1 for SEEK_CUR\n        }\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\fflush.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __fpurge(__fp: *mut FILE);\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn fpurge(mut fp: *mut FILE) -> libc::c_int {\n    __fpurge(fp);\n    return 0 as libc::c_int;\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\fpurge.rs"
    },
    {
      "chunk": "use std::fs::OpenOptions;\nuse std::os::unix::io::AsRawFd;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn freopen(\n        __filename: *const libc::c_char,\n        __modes: *const libc::c_char,\n        __stream: *mut FILE,\n    ) -> *mut FILE;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn dup2(__fd: libc::c_int, __fd2: libc::c_int) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\nfn protect_fd(fd: i32) -> bool {\n    let value = std::fs::OpenOptions::new()\n        .read(true)\n        .write(false)\n        .open(\"/dev/null\");\n\n    match value {\n        Ok(file) => {\n            let file_fd = file.as_raw_fd();\n            if file_fd != fd {\n                // Close the file if it's valid\n                if file_fd >= 0 {\n                    drop(file); // This will close the file\n                    // Note: Setting errno directly is not idiomatic in Rust.\n                    // Instead, we can return false to indicate an error.\n                }\n                return false;\n            }\n            return true;\n        }\n        Err(_) => {\n            return false;\n        }\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn freopen_safer(\n    mut name: *const libc::c_char,\n    mut mode: *const libc::c_char,\n    mut f: *mut FILE,\n) -> *mut FILE {\n    let mut protect_in: bool = 0 as libc::c_int != 0;\n    let mut protect_out: bool = 0 as libc::c_int != 0;\n    let mut protect_err: bool = 0 as libc::c_int != 0;\n    let mut saved_errno: libc::c_int = 0;\n    let mut current_block_8: u64;\n    match fileno(f) {\n        2 => {\n            current_block_8 = 8409498848974359248;\n        }\n        1 => {\n            current_block_8 = 878006807312935268;\n        }\n        0 => {\n            current_block_8 = 2868539653012386629;\n        }\n        _ => {\n            if dup2(2 as libc::c_int, 2 as libc::c_int) != 2 as libc::c_int {\n                protect_err = 1 as libc::c_int != 0;\n            }\n            current_block_8 = 8409498848974359248;\n        }\n    }\n    match current_block_8 {\n        8409498848974359248 => {\n            if dup2(1 as libc::c_int, 1 as libc::c_int) != 1 as libc::c_int {\n                protect_out = 1 as libc::c_int != 0;\n            }\n            current_block_8 = 878006807312935268;\n        }\n        _ => {}\n    }\n    match current_block_8 {\n        878006807312935268 => {\n            if dup2(0 as libc::c_int, 0 as libc::c_int) != 0 as libc::c_int {\n                protect_in = 1 as libc::c_int != 0;\n            }\n        }\n        _ => {}\n    }\n    if protect_in as libc::c_int != 0 && !protect_fd(0 as libc::c_int) {\n        f = 0 as *mut FILE;\n    } else if protect_out as libc::c_int != 0 && !protect_fd(1 as libc::c_int) {\n        f = 0 as *mut FILE;\n    } else if protect_err as libc::c_int != 0 && !protect_fd(2 as libc::c_int) {\n        f = 0 as *mut FILE;\n    } else {\n        f = freopen(name, mode, f);\n    }\n    saved_errno = *__errno_location();\n    if protect_err {\n        close(2 as libc::c_int);\n    }\n    if protect_out {\n        close(1 as libc::c_int);\n    }\n    if protect_in {\n        close(0 as libc::c_int);\n    }\n    if f.is_null() {\n        *__errno_location() = saved_errno;\n    }\n    return f;\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\freopen_safer.rs"
    },
    {
      "chunk": "use std::os::raw::c_int;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub fn rpl_fseeko(\n    fp: &mut FILE,\n    offset: off_t,\n    whence: libc::c_int,\n) -> libc::c_int {\n    if fp._IO_read_end == fp._IO_read_ptr\n        && fp._IO_write_ptr == fp._IO_write_base && fp._IO_save_base.is_null()\n    {\n        let pos: off_t;\n        unsafe {\n            pos = lseek(fileno(fp), offset, whence);\n            if pos == -(1 as libc::c_int) as libc::c_long {\n                return -(1 as libc::c_int);\n            }\n            fp._flags &= !(0x10 as libc::c_int);\n            fp._offset = pos;\n        }\n        return 0 as libc::c_int;\n    }\n    unsafe {\n        return fseeko(fp, offset, whence);\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\fseeko.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn hard_locale(category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    let result = unsafe {\n        setlocale_null_r(\n            category,\n            locale.as_mut_ptr(),\n            locale.len() as libc::c_ulong,\n        )\n    };\n\n    if result == 0 {\n        return false;\n    }\n\n    let locale_str = unsafe { CStr::from_ptr(locale.as_ptr()).to_string_lossy() };\n    if locale_str == \"C\" || locale_str == \"POSIX\" {\n        return false;\n    }\n    return true;\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\hard_locale.rs"
    },
    {
      "chunk": "use std::option::Option;\nuse std::vec::Vec;\nuse ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn ireallocarray(\n    mut p: Option<Vec<u8>>,\n    mut n: usize,\n    mut s: usize,\n) -> Option<Vec<u8>> {\n    if n <= usize::MAX && s <= usize::MAX {\n        let mut nx: usize = n;\n        let mut sx: usize = s;\n        if n == 0 || s == 0 {\n            sx = 1;\n            nx = sx;\n        }\n        let new_size = nx.checked_mul(sx)?;\n        p = p.map(|mut vec| {\n            vec.resize(new_size, 0);\n            vec\n        });\n        return p;\n    } else {\n        return None; // Assuming _gl_alloc_nomem() returns a null pointer, we return None here.\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn icalloc(n: usize, s: usize) -> Option<Vec<u8>> {\n    if n > usize::MAX {\n        if s != 0 {\n            return None; // Equivalent to _gl_alloc_nomem()\n        }\n        return Some(Vec::new()); // Return an empty vector\n    }\n    if s > usize::MAX {\n        if n != 0 {\n            return None; // Equivalent to _gl_alloc_nomem()\n        }\n        return Some(Vec::new()); // Return an empty vector\n    }\n    let total_size = n.checked_mul(s)?;\n    Some(vec![0u8; total_size]) // Allocate a vector filled with zeros\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn irealloc(p: Option<Vec<u8>>, s: usize) -> Option<Vec<u8>> {\n    if s <= usize::MAX {\n        let new_size = if s == 0 { 1 } else { s };\n        let mut vec = p.unwrap_or_else(|| Vec::with_capacity(new_size));\n        vec.resize(new_size, 0);\n        Some(vec)\n    } else {\n        None // Assuming _gl_alloc_nomem() returns None in this context\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn imalloc(s: idx_t) -> Option<Vec<u8>> {\n    if s as usize <= usize::MAX {\n        let vec = vec![0u8; s as usize];\n        Some(vec)\n    } else {\n        None // Assuming _gl_alloc_nomem() indicates failure by returning None\n    }\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\ialloc.rs"
    },
    {
      "chunk": "use std::os::raw::c_char;\nuse std::ptr;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn getc_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn feof_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn free(_: *mut libc::c_void);\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type ptrdiff_t = libc::c_long;\npub type idx_t = ptrdiff_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct linebuffer {\n    pub size: idx_t,\n    pub length: idx_t,\n    pub buffer: *mut libc::c_char,\n}\n#[no_mangle]\npub fn initbuffer(linebuffer: &mut linebuffer) {\n    linebuffer.buffer = ptr::null_mut(); // Assuming buffer is a mutable pointer\n    linebuffer.length = 0;\n    linebuffer.size = 0;\n}\n#[no_mangle]\npub fn readlinebuffer<'a>(\n    linebuffer: &'a mut linebuffer,\n    stream: &'a mut FILE,\n) -> &'a mut linebuffer {\n    let result = unsafe {\n        readlinebuffer_delim(linebuffer, stream, b'\\n' as i32 as libc::c_char)\n    };\n    unsafe { &mut *result }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn readlinebuffer_delim(\n    mut linebuffer: *mut linebuffer,\n    mut stream: *mut FILE,\n    mut delimiter: libc::c_char,\n) -> *mut linebuffer {\n    let mut c: libc::c_int = 0;\n    let mut buffer: *mut libc::c_char = (*linebuffer).buffer;\n    let mut p: *mut libc::c_char = (*linebuffer).buffer;\n    let mut end: *mut libc::c_char = buffer.offset((*linebuffer).size as isize);\n    if feof_unlocked(stream) != 0 {\n        return 0 as *mut linebuffer;\n    }\n    loop {\n        c = getc_unlocked(stream);\n        if c == -(1 as libc::c_int) {\n            if p == buffer || ferror_unlocked(stream) != 0 {\n                return 0 as *mut linebuffer;\n            }\n            if *p.offset(-(1 as libc::c_int) as isize) as libc::c_int\n                == delimiter as libc::c_int\n            {\n                break;\n            }\n            c = delimiter as libc::c_int;\n        }\n        if p == end {\n            let mut oldsize: idx_t = (*linebuffer).size;\n            buffer = xpalloc(\n                buffer as *mut libc::c_void,\n                &mut (*linebuffer).size,\n                1 as libc::c_int as idx_t,\n                -(1 as libc::c_int) as ptrdiff_t,\n                1 as libc::c_int as idx_t,\n            ) as *mut libc::c_char;\n            p = buffer.offset(oldsize as isize);\n            (*linebuffer).buffer = buffer;\n            end = buffer.offset((*linebuffer).size as isize);\n        }\n        let fresh0 = p;\n        p = p.offset(1);\n        *fresh0 = c as libc::c_char;\n        if !(c != delimiter as libc::c_int) {\n            break;\n        }\n    }\n    (*linebuffer).length = p.offset_from(buffer) as libc::c_long;\n    return linebuffer;\n}\n#[no_mangle]\npub fn freebuffer(linebuffer: &mut linebuffer) {\n    if !linebuffer.buffer.is_null() {\n        unsafe {\n            let _ = Box::from_raw(linebuffer.buffer); // Convert the raw pointer back to a Box to free the memory\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\linebuffer.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;\npub const _NL_WAM_STR: C2RustUnnamed = 131162;\npub const _NL_WMON_12: C2RustUnnamed = 131161;",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "pub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\localcharset.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\mbrtoc32.rs"
    },
    {
      "chunk": "use std::mem;\nuse ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn mbszero(ps: &mut mbstate_t) {\n    *ps = mbstate_t {\n        __count: 0,\n        __value: unsafe { std::mem::zeroed() }, // Using zeroed to initialize __value\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\mbszero.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const MCEL_LEN_MAX: C2RustUnnamed_0 = 4;\npub type C2RustUnnamed_1 = libc::c_uint;\npub const MCEL_CHAR_MAX: C2RustUnnamed_1 = 1114111;\npub type C2RustUnnamed_2 = libc::c_uint;\npub const MCEL_ERR_MIN: C2RustUnnamed_2 = 128;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mcel_t {\n    pub ch: char32_t,\n    pub err: libc::c_uchar,\n    pub len: libc::c_uchar,\n}\npub type C2RustUnnamed_3 = libc::c_uint;\npub const MCEL_ERR_SHIFT: C2RustUnnamed_3 = 14;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn mcel_scanz(p: &str) -> mcel_t {\n    return mcel_scant(p, '\\0');\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn mcel_scant(p: &str, terminator: char) -> mcel_t {\n    if mcel_isbasic(p.chars().next().unwrap() as i8) {\n        return mcel_ch(p.chars().next().unwrap() as char32_t, 1);\n    }\n    \n    let mut lim = &p[1..];\n    let mut i = 0;\n\n    while i < MCEL_LEN_MAX - 1 {\n        if lim.is_empty() || lim.chars().next().unwrap() == terminator {\n            break;\n        }\n        lim = &lim[1..];\n        i += 1;\n    }\n    \n    return mcel_scan(p, lim);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn mcel_scan(p: &str, lim: &str) -> mcel_t {\n    let c = p.chars().next().unwrap_or('\\0') as i8;\n    if mcel_isbasic(c) {\n        return mcel_ch(c as char32_t, 1);\n    }\n    \n    let mut mbs: mbstate_t = mbstate_t {\n        __count: 0,\n        __value: C2RustUnnamed { __wch: 0 },\n    };\n    \n    let mut ch: char32_t = 0;\n    let len: u64;\n    \n    unsafe {\n        len = mbrtoc32(&mut ch, p.as_ptr() as *const i8, (lim.as_ptr().offset_from(p.as_ptr()) as isize) as u64, &mut mbs);\n    }\n    \n    if len > (-(1 as isize) as u64).wrapping_div(2) {\n        return mcel_err(c as u8);\n    }\n    \n    return mcel_ch(ch, len as usize);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn mcel_isbasic(c: i8) -> bool {\n    (0 <= c && c < MCEL_ERR_MIN as i8)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn mcel_tocmp(\n    to: Option<fn(wint_t) -> wint_t>,\n    c1: mcel_t,\n    c2: mcel_t,\n) -> libc::c_int {\n    let cmp: libc::c_int = mcel_cmp(c1, c2);\n    if (c1.err as libc::c_int - c2.err as libc::c_int | (cmp == 0) as libc::c_int) != 0 {\n        return cmp;\n    }\n    let ch1: libc::c_int = to.expect(\"non-null function pointer\")(c1.ch).try_into().unwrap();\n    let ch2: libc::c_int = to.expect(\"non-null function pointer\")(c2.ch).try_into().unwrap();\n    ch1 - ch2\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn mcel_cmp(c1: mcel_t, c2: mcel_t) -> i32 {\n    let ch1: i32 = c1.ch as i32;\n    let ch2: i32 = c2.ch as i32;\n    (c1.err as i32 - c2.err as i32) * (1 << MCEL_ERR_SHIFT as i32) + (ch1 - ch2)\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn mcel_err(err: u8) -> mcel_t {\n    assert!(MCEL_ERR_MIN as i32 <= err as i32, \"Error value out of range\");\n    \n    mcel_t {\n        ch: 0,\n        err,\n        len: 1,\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn mcel_ch(ch: char32_t, len: usize) -> mcel_t {\n    assert!(len > 0, \"Length must be greater than 0\");\n    assert!(len <= MCEL_LEN_MAX as usize, \"Length exceeds maximum allowed\");\n    assert!(ch <= MCEL_CHAR_MAX as u32, \"Character exceeds maximum allowed\");\n\n    mcel_t {\n        ch,\n        err: 0,\n        len: len as u8,\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\mcel.rs"
    },
    {
      "chunk": "use std::cmp::Ordering;\nuse ::libc;\nextern \"C\" {\n    fn toupper(_: libc::c_int) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn memcasecmp(vs1: &[u8], vs2: &[u8]) -> libc::c_int {\n    let n = vs1.len().min(vs2.len());\n    for i in 0..n {\n        let u1 = vs1[i];\n        let u2 = vs2[i];\n        let U1 = u1.to_ascii_uppercase();\n        let U2 = u2.to_ascii_uppercase();\n        let diff = U1.cmp(&U2);\n        if diff != std::cmp::Ordering::Equal {\n            return diff as libc::c_int;\n        }\n    }\n    return 0 as libc::c_int;\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\memcasecmp.rs"
    },
    {
      "chunk": "use std::env;\nuse ::libc;\nextern \"C\" {\n    fn strtol(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n    ) -> libc::c_long;\n    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub fn posix2_version() -> libc::c_int {\n    let mut v: libc::c_long = 200809;\n    if let Ok(s) = std::env::var(\"_POSIX2_VERSION\") {\n        if let Ok(i) = s.parse::<libc::c_long>() {\n            v = i;\n        }\n    }\n    return (if v < (-(2147483647) - 1) {\n        (-(2147483647) - 1) as libc::c_long\n    } else if v < 2147483647 {\n        v\n    } else {\n        2147483647\n    }) as libc::c_int;\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\posixver.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\progname.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\propername_lite.rs"
    },
    {
      "chunk": "use std::os::raw::c_int;\nuse std::boxed::Box;\nuse std::clone::Clone;\nuse std::option::Option;\nuse std::convert::TryInto;\nuse std::ffi::CStr;\nuse std::os::raw::c_char;\nuse std::ptr;\nuse std::ffi::CString;\nuse ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nfn c32isprint(wc: wint_t) -> libc::c_int {\n    unsafe { iswprint(wc) }\n}\n#[inline]\nfn mbszero(ps: &mut mbstate_t) {\n    *ps = mbstate_t {\n        __count: 0,\n        __value: unsafe { std::mem::zeroed() }, // Zero-initialize the union\n    };\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub fn clone_quoting_options(o: Option<&quoting_options>) -> Box<quoting_options> {\n    let options = o.unwrap_or_else(|| unsafe { &default_quoting_options });\n    let cloned_options = options.clone();\n    Box::new(cloned_options)\n}\n#[no_mangle]\npub fn get_quoting_style(o: Option<&quoting_options>) -> quoting_style {\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &default_quoting_options },\n    };\n    options.style\n}\n#[no_mangle]\npub fn set_quoting_style(\n    mut o: Option<Box<quoting_options>>,\n    s: quoting_style,\n) {\n    let options = o.get_or_insert_with(|| Box::new(quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: std::ptr::null(),\n        right_quote: std::ptr::null(),\n    }));\n    options.style = s;\n}\n#[no_mangle]\npub fn set_char_quoting(\n    o: Option<&mut quoting_options>,\n    c: char,\n    i: i32,\n) -> i32 {\n    let uc = c as u8;\n    let options = match o {\n        Some(opts) => opts,\n        None => unsafe { &mut default_quoting_options },\n    };\n    let index = (uc as usize) / (std::mem::size_of::<u32>() * 8);\n    let shift = (uc as usize) % (std::mem::size_of::<u32>() * 8);\n    \n    let p = &mut options.quote_these_too[index];\n    let r = (*p >> shift) & 1;\n    *p ^= ((i & 1 ^ r as i32) << shift) as u32;\n    \n    r as i32\n}\n#[no_mangle]\npub fn set_quoting_flags(\n    mut o: Option<&mut quoting_options>,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    let options: &mut quoting_options;\n\n    if let Some(ref mut opt) = o {\n        options = opt;\n    } else {\n        options = unsafe { &mut default_quoting_options };\n    }\n\n    r = options.flags;\n    options.flags = i;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}\nfn quoting_options_from_style(style: quoting_style) -> quoting_options {\n    if style == custom_quoting_style {\n        panic!(\"Custom quoting style is not allowed\");\n    }\n    \n    quoting_options {\n        style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: std::ptr::null(),\n        right_quote: std::ptr::null(),\n    }\n}\nfn gettext_quote(msgid: &str, s: quoting_style) -> String {\n    let translation = unsafe {\n        let translation_ptr = gettext(msgid.as_ptr() as *const libc::c_char);\n        std::ffi::CStr::from_ptr(translation_ptr).to_string_lossy().into_owned()\n    };\n    \n    let locale_code = unsafe {\n        let locale_code_ptr = locale_charset();\n        std::ffi::CStr::from_ptr(locale_code_ptr).to_string_lossy().into_owned()\n    };\n\n    if translation != msgid {\n        return translation;\n    }\n\n    if locale_code.eq_ignore_ascii_case(\"UTF-8\") {\n        return if msgid.chars().next() == Some('`') {\n            \"\\u{2018}\".to_string() // Left single quotation mark\n        } else {\n            \"\\u{2019}\".to_string() // Right single quotation mark\n        };\n    }\n\n    if locale_code.eq_ignore_ascii_case(\"GB18030\") {\n        return if msgid.chars().next() == Some('`') {\n            \"\\u{A1E7}\".to_string() // GB18030 left quote\n        } else {\n            \"\\u{A1AF}\".to_string() // GB18030 right quote\n        };\n    }\n\n    if s as u32 == clocale_quoting_style as u32 {\n        return \"\\\"\".to_string();\n    } else {\n        return \"'\".to_string();\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    let left_quote = gettext_quote(\n    \"`\",\n    quoting_style,\n);\n                    let right_quote = gettext_quote(\n    \"'\",\n    quoting_style,\n);\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: u8 = 0;\nlet mut esc: u8 = 0;\nlet mut is_right_quote: bool = false;\nlet mut escaping: bool = false;\nlet mut c_and_shell_quote_compat: bool = false;\n\nlet arg_slice = unsafe { std::ffi::CStr::from_ptr(arg).to_bytes() }; // Convert raw pointer to slice\n\nif backslash_escapes\n    && quoting_style != shell_always_quoting_style\n    && quote_string_len != 0\n    && i + quote_string_len <= if argsize == u64::MAX && 1 < quote_string_len {\n        argsize = arg_slice.len() as u64; // Get length of the slice\n        argsize\n    } else {\n        argsize\n    }\n    && &arg_slice[i as usize..(i + quote_string_len) as usize] == unsafe { std::ffi::CStr::from_ptr(quote_string).to_bytes() }\n{\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    is_right_quote = true;\n}\n\nc = arg_slice[i as usize];\n\nmatch c {\n    0 => {\n         if backslash_escapes {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    escaping = true;\n    if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n        if len < buffersize {\n            unsafe { *buffer.add(len as usize) = '\\'' as i8; }\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.add(len as usize) = '$' as i8; }\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.add(len as usize) = '\\'' as i8; }\n        }\n        len += 1;\n        pending_shell_escape_end = true;\n    }\n    if len < buffersize {\n        unsafe { *buffer.add(len as usize) = '\\\\' as i8; }\n    }\n    len += 1;\n    if quoting_style != shell_always_quoting_style\n        && i + 1 < argsize\n        && ('0' as i8 <= unsafe { *arg.add((i + 1) as usize) } && unsafe { *arg.add((i + 1) as usize) } <= '9' as i8)\n    {\n        if len < buffersize {\n            unsafe { *buffer.add(len as usize) = '0' as i8; }\n        }\n        len += 1;\n        if len < buffersize {\n            unsafe { *buffer.add(len as usize) = '0' as i8; }\n        }\n        len += 1;\n    }\n    c = '0' as u8;\n    current_block = 253337042034819032;\n} else if (flags & QA_ELIDE_NULL_BYTES as i32) != 0 {\n    current_block = 13619784596304402172;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n    63 => {\n         match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n\n    }\n    7 => {\n        esc = 'a' as u8;\n        current_block = 1190876092451756080;\n    }\n    8 => {\n        esc = 'b' as u8;\n        current_block = 1190876092451756080;\n    }\n    12 => {\n        esc = 'f' as u8;\n        current_block = 1190876092451756080;\n    }\n    10 => {\n        esc = 'n' as u8;\n        current_block = 9215498979640025612;\n    }\n    13 => {\n        esc = 'r' as u8;\n        current_block = 9215498979640025612;\n    }\n    9 => {\n        esc = 't' as u8;\n        current_block = 9215498979640025612;\n    }\n    11 => {\n        esc = 'v' as u8;\n        current_block = 1190876092451756080;\n    }\n    92 => {\n         esc = c;\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    current_block = 4476262310586904498;\n} else if backslash_escapes && elide_outer_quotes && quote_string_len != 0 {\n    current_block = 4476262310586904498;\n} else {\n    current_block = 9215498979640025612;\n}\n\n\n    }\n    123 | 125 => {\n         if if argsize == u64::MAX {\n    unsafe { *arg.offset(1) == '\\0' as i8 }\n} else {\n    argsize == 1\n} {\n    current_block = 16442922512115311366;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n    35 | 126 => {\n        current_block = 16442922512115311366;\n    }\n    32 => {\n        current_block = 4634307283396172174;\n    }\n    33 => {\n        current_block = 7549413860336125482;\n    }\n    34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n        current_block = 13059411171234995867;\n    }\n    62 | 91 | 94 => {\n        current_block = 16620298045565028098;\n    }\n    96 | 124 => {\n        current_block = 15155215915847730705;\n    }\n    39 => {\n         encountered_single_quote = true;\nc_and_shell_quote_compat = true;\n\nif quoting_style == shell_always_quoting_style {\n    if elide_outer_quotes {\n        current_block = 7928555609993211441;\n        break 's_25;\n    }\n    if buffersize != 0 && orig_buffersize == 0 {\n        orig_buffersize = buffersize;\n        buffersize = 0;\n    }\n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\'' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    \n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\\\' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    \n    if len < buffersize {\n        unsafe {\n            *buffer.offset(len as isize) = '\\'' as i8;\n        }\n    }\n    len = len.wrapping_add(1);\n    \n    pending_shell_escape_end = false;\n    current_block = 253337042034819032;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n    37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n    | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n    | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n    | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n    | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n    | 120 | 121 | 122 => {\n        c_and_shell_quote_compat = true;\n        current_block = 253337042034819032;\n    }\n    _ => {\n         let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n\n         if m > 1 || (backslash_escapes && !printable) {\n    let ilim = i.wrapping_add(m);\n    let buffer_slice = unsafe { std::slice::from_raw_parts_mut(buffer, buffersize as usize) };\n    loop {\n        if backslash_escapes && !printable {\n            if elide_outer_quotes {\n                current_block = 7928555609993211441;\n                break 's_25;\n            }\n            escaping = true;\n            if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n                if len < buffersize {\n                    buffer_slice[len as usize] = '\\'' as i8;\n                }\n                len = len.wrapping_add(1);\n                if len < buffersize {\n                    buffer_slice[len as usize] = '$' as i8;\n                }\n                len = len.wrapping_add(1);\n                if len < buffersize {\n                    buffer_slice[len as usize] = '\\'' as i8;\n                }\n                len = len.wrapping_add(1);\n                pending_shell_escape_end = true;\n            }\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\\\' as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as i32 + (c as i32 >> 6)) as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = ('0' as i32 + ((c as i32 >> 3) & 7)) as i8;\n            }\n            len = len.wrapping_add(1);\n            c = ('0' as i32 + (c as i32 & 7)) as u8;\n        } else if is_right_quote {\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\\\' as i8;\n            }\n            len = len.wrapping_add(1);\n            is_right_quote = false;\n        }\n        if ilim <= i.wrapping_add(1) {",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "            break;\n        }\n        if pending_shell_escape_end && !escaping {\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\'' as i8;\n            }\n            len = len.wrapping_add(1);\n            if len < buffersize {\n                buffer_slice[len as usize] = '\\'' as i8;\n            }\n            len = len.wrapping_add(1);\n            pending_shell_escape_end = false;\n        }\n        if len < buffersize {\n            buffer_slice[len as usize] = c as i8;\n        }\n        len = len.wrapping_add(1);\n        i = i.wrapping_add(1);\n        c = unsafe { *arg.offset(i as isize) } as u8;\n    }\n    current_block = 4476262310586904498;\n} else {\n    current_block = 253337042034819032;\n}\n\n\n    }\n}\n\nmatch current_block {\n    16442922512115311366 => {\n        if i != 0 {\n            current_block = 253337042034819032;\n        } else {\n            current_block = 4634307283396172174;\n        }\n    }\n    9215498979640025612 => {\n        if quoting_style == shell_always_quoting_style && elide_outer_quotes {\n            current_block = 7928555609993211441;\n            break 's_25;\n        }\n        current_block = 1190876092451756080;\n    }\n    _ => {}\n}\n\nmatch current_block {\n    1190876092451756080 => {\n        if backslash_escapes {\n            c = esc;\n            current_block = 3173013908131212616;\n        } else {\n            current_block = 253337042034819032;\n        }\n    }\n    4634307283396172174 => {\n        c_and_shell_quote_compat = true;\n        current_block = 7549413860336125482;\n    }\n    _ => {}\n}\n\nmatch current_block {\n    7549413860336125482 => {\n        current_block = 13059411171234995867;\n    }\n    _ => {}\n}\n\nmatch current_block {\n    13059411171234995867 => {\n        current_block = 16620298045565028098;\n    }\n    _ => {}\n}\n\n            let mut current_block = match current_block {\n    16620298045565028098 => {\n        15155215915847730705\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    15155215915847730705 => {\n        if quoting_style == shell_always_quoting_style && elide_outer_quotes {\n            break 's_25;\n        }\n        253337042034819032\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    253337042034819032 => {\n        if !((backslash_escapes && quoting_style != shell_always_quoting_style) || elide_outer_quotes)\n            && !quote_these_too.is_null()\n            && (unsafe { *quote_these_too.offset(c as isize / (std::mem::size_of::<libc::c_int>() * 8) as isize) } >> (c as usize % (std::mem::size_of::<libc::c_int>() * 8)) & 1) != 0\n            && !is_right_quote {\n            4476262310586904498\n        } else {\n            3173013908131212616\n        }\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    3173013908131212616 => {\n        if elide_outer_quotes {\n            break 's_25;\n        }\n        escaping = true;\n        if quoting_style == shell_always_quoting_style && !pending_shell_escape_end {\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '$' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            pending_shell_escape_end = true;\n        }\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = '\\\\' as i8; }\n        }\n        len += 1;\n        4476262310586904498\n    }\n    _ => current_block,\n};\n\ncurrent_block = match current_block {\n    4476262310586904498 => {\n        if pending_shell_escape_end && !escaping {\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            if len < buffersize {\n                unsafe { *buffer.offset(len as isize) = '\\'' as i8; }\n            }\n            len += 1;\n            pending_shell_escape_end = false;\n        }\n        if len < buffersize {\n            unsafe { *buffer.offset(len as isize) = c as i8; }\n        }\n        len += 1;\n        if !c_and_shell_quote_compat {\n            all_c_and_shell_quote_compat = false;\n        }\n        current_block\n    }\n    _ => current_block,\n};\n\ni += 1;\n\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n    return quotearg_buffer_restyled(\n        buffer,\n        orig_buffersize,\n        arg,\n        argsize,\n        c_quoting_style,\n        flags,\n        quote_these_too,\n        left_quote,\n        right_quote,\n    );\n} else {\n    if !(buffersize == 0 && orig_buffersize != 0) {\n        current_block = 6412618891452676311;\n        break;\n    }\n    buffersize = orig_buffersize;\n    len = 0;\n}\n\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub fn quotearg_buffer(\n    buffer: &mut [c_char],\n    arg: &[c_char],\n    o: Option<&quoting_options>,\n) -> usize {\n    let p: &quoting_options = o.unwrap_or_else(|| unsafe { &default_quoting_options });\n    let e = std::io::Error::last_os_error();\n    let r = unsafe {\n        quotearg_buffer_restyled(\n            buffer.as_mut_ptr(),\n            buffer.len().try_into().unwrap(),\n            arg.as_ptr(),\n            arg.len().try_into().unwrap(),\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        )\n    };\n    std::mem::forget(e); // Handle the error if necessary\n    r.try_into().unwrap()\n}\n#[no_mangle]\npub fn quotearg_alloc(\n    arg: &CStr,\n    argsize: usize,\n    o: &quoting_options,\n) -> CString {\n    let result = unsafe { quotearg_alloc_mem(arg.as_ptr(), argsize.try_into().unwrap(), std::ptr::null_mut(), o) };\n    unsafe { CString::from_raw(result) }\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};\nstatic mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub fn quotearg_free() {\n    unsafe {\n        let mut sv = slotvec;\n        let mut i: libc::c_int = 1;\n\n        while i < nslots {\n            let val = (*sv.offset(i as isize)).val;\n            if !val.is_null() {\n                let _ = Box::from_raw(val); // Automatically frees the memory\n            }\n            i += 1;\n        }\n\n        if (*sv.offset(0)).val != slot0.as_mut_ptr() {\n            let val = (*sv.offset(0)).val;\n            if !val.is_null() {\n                let _ = Box::from_raw(val); // Automatically frees the memory\n            }\n            slotvec0.size = std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n            slotvec0.val = slot0.as_mut_ptr();\n        }\n\n        if sv != &mut slotvec0 as *mut slotvec {\n            let _ = Box::from_raw(sv); // Automatically frees the memory\n            slotvec = &mut slotvec0;\n        }\n        nslots = 1;\n    }\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}\n#[no_mangle]\npub fn quotearg_n_mem(\n    n: i32,\n    arg: &CStr,\n    argsize: usize,\n) -> *mut libc::c_char {\n    unsafe {\n        let options = &default_quoting_options;\n        let result_ptr = quotearg_n_options(n, arg.as_ptr(), argsize.try_into().unwrap(), options);\n        result_ptr\n    }\n}\n#[no_mangle]\npub fn quotearg(arg: &CStr) -> CString {\n    let n = 0;\n    let arg_ptr = arg.as_ptr();\n    let result_ptr = unsafe { quotearg_n(n, arg_ptr) };\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub fn quotearg_mem(arg: &CStr) -> CString {\n    let argsize: usize = arg.to_bytes().len();\n    let result_ptr = quotearg_n_mem(0, arg, argsize);\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}\n#[no_mangle]\npub fn quotearg_n_style_mem(\n    n: i32,\n    s: quoting_style,\n    arg: &CStr,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    let argsize = arg.to_bytes().len() as u64; // Convert to u64\n    unsafe {\n        quotearg_n_options(n, arg.as_ptr(), argsize, &o)\n    }\n}\n#[no_mangle]\npub fn quotearg_style(\n    s: quoting_style,\n    arg: &str,\n) -> String {\n    let c_string = std::ffi::CString::new(arg).expect(\"CString::new failed\");\n    let c_arg = c_string.as_ptr();\n    let result_ptr = unsafe { quotearg_n_style(0, s, c_arg) };\n    unsafe { CString::from_raw(result_ptr).into_string().expect(\"Failed to convert CString to String\") }\n}\n#[no_mangle]\npub fn quotearg_style_mem(\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let result_ptr = quotearg_n_style_mem(0, s, arg);\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    let result = set_char_quoting(Some(&mut options), ch as u8 as char, 1);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub fn quotearg_char(arg: &CStr, ch: char) -> *mut c_char {\n    let ch_as_i8 = ch as i8;\n    unsafe { quotearg_char_mem(arg.as_ptr(), u64::MAX, ch_as_i8) }\n}\n#[no_mangle]\npub fn quotearg_colon(arg: &CStr) -> CString {\n    let ch: char = ':'; // Define the character to be used\n    let result_ptr = quotearg_char(arg, ch);\n    unsafe { CString::from_raw(result_ptr) } // Convert the raw pointer back to CString\n}\n#[no_mangle]\npub fn quotearg_colon_mem(arg: &CStr) -> CString {\n    let argsize = arg.to_bytes().len();\n    let result_ptr = unsafe {\n        quotearg_char_mem(arg.as_ptr(), argsize.try_into().unwrap(), ':' as i32 as c_char)\n    };\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "pub fn quotearg_n_style_colon(\n    n: i32,\n    s: quoting_style,\n    arg: &CStr,\n) -> CString {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: ptr::null(),\n        right_quote: ptr::null(),\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(Some(&mut options), ':' as char, 1);\n    \n    let result = unsafe {\n        quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            u64::MAX,\n            &mut options,\n        )\n    };\n    \n    unsafe { CString::from_raw(result) }\n}\n#[no_mangle]\npub fn quotearg_n_custom(\n    n: i32,\n    left_quote: *const libc::c_char,\n    right_quote: *const libc::c_char,\n    arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    unsafe {\n        quotearg_n_custom_mem(\n            n,\n            left_quote,\n            right_quote,\n            arg,\n            std::usize::MAX as libc::c_ulong,\n        )\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub fn quotearg_custom(\n    left_quote: &str,\n    right_quote: &str,\n    arg: &str,\n) -> String {\n    let left_quote_c = std::ffi::CString::new(left_quote).unwrap();\n    let right_quote_c = std::ffi::CString::new(right_quote).unwrap();\n    let arg_c = std::ffi::CString::new(arg).unwrap();\n    \n    let result = quotearg_n_custom(0, left_quote_c.as_ptr(), right_quote_c.as_ptr(), arg_c.as_ptr());\n    \n    unsafe { std::ffi::CStr::from_ptr(result).to_string_lossy().into_owned() }\n}\n#[no_mangle]\npub fn quotearg_custom_mem(\n    left_quote: &CStr,\n    right_quote: &CStr,\n    arg: &CStr,\n) -> CString {\n    let argsize = arg.to_bytes().len() as u64;\n    let result_ptr: *mut libc::c_char = unsafe {\n        quotearg_n_custom_mem(\n            0,\n            left_quote.as_ptr(),\n            right_quote.as_ptr(),\n            arg.as_ptr(),\n            argsize,\n        )\n    };\n    unsafe { CString::from_raw(result_ptr) }\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}\n#[no_mangle]\npub fn quote_mem(arg: &CStr) -> CString {\n    let argsize = arg.to_bytes().len();\n    let quoted = unsafe { quote_n_mem(0, arg.as_ptr(), argsize.try_into().unwrap()) };\n    unsafe { CStr::from_ptr(quoted).to_owned() }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}\n#[no_mangle]\npub fn quote(arg: &CStr) -> CString {\n    let arg_ptr = arg.as_ptr();\n    let result_ptr = unsafe { quote_n(0, arg_ptr) };\n    unsafe { CString::from_raw(result_ptr as *mut c_char) }\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\quotearg.rs"
    },
    {
      "chunk": "use std::slice;\nuse ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub fn setlocale_null_r(\n    category: libc::c_int,\n    buf: &mut [u8],\n) -> libc::c_int {\n    let bufsize = buf.len() as u64;\n    unsafe {\n        return setlocale_null_r_unlocked(category, buf.as_mut_ptr() as *mut libc::c_char, bufsize);\n    }\n}\n#[no_mangle]\npub fn setlocale_null(category: libc::c_int) -> *const libc::c_char {\n    unsafe { setlocale_null_unlocked(category) }\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\setlocale_null.rs"
    },
    {
      "chunk": "use std::slice;\nuse ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub fn setlocale_null_r_unlocked(\n    category: libc::c_int,\n    buf: &mut Vec<u8>,\n) -> libc::c_int {\n    let result: *const libc::c_char;\n    unsafe {\n        result = setlocale_null_unlocked(category);\n    }\n\n    if result.is_null() {\n        if !buf.is_empty() {\n            buf[0] = 0; // Null-terminate the buffer\n        }\n        return 22; // EINVAL\n    } else {\n        let length: usize = unsafe { strlen(result) } as usize;\n        if length < buf.len() {\n            buf[..length].copy_from_slice(unsafe { std::slice::from_raw_parts(result as *const u8, length) });\n            buf[length] = 0; // Null-terminate the buffer\n            return 0; // Success\n        } else {\n            if !buf.is_empty() {\n                let copy_length = buf.len() - 1;\n                buf.copy_from_slice(unsafe { std::slice::from_raw_parts(result as *const u8, copy_length) });\n                buf[copy_length] = 0; // Null-terminate the buffer\n            }\n            return 34; // ERANGE\n        }\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\setlocale_null_unlocked.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const MCEL_LEN_MAX: C2RustUnnamed_0 = 4;\npub type C2RustUnnamed_1 = libc::c_uint;\npub const MCEL_CHAR_MAX: C2RustUnnamed_1 = 1114111;\npub type C2RustUnnamed_2 = libc::c_uint;\npub const MCEL_ERR_MIN: C2RustUnnamed_2 = 128;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mcel_t {\n    pub ch: char32_t,\n    pub err: libc::c_uchar,\n    pub len: libc::c_uchar,\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub fn skip_buf_matching<'a>(\n    buf: &'a [libc::c_char],\n    lim: &'a [libc::c_char],\n    predicate: Option<fn(mcel_t) -> bool>,\n    ok: bool,\n) -> *mut libc::c_char {\n    let mut s = buf.as_ptr();\n    let lim_ptr = lim.as_ptr();\n    let mut g: mcel_t = mcel_t { ch: 0, err: 0, len: 0 };\n\n    while s < lim_ptr && {\n        g = unsafe { mcel_scan(s, lim_ptr) };\n        predicate.expect(\"non-null function pointer\")(g) == ok\n    } {\n        unsafe {\n            s = s.add(g.len as usize);\n        }\n    }\n    s as *mut libc::c_char\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn skip_str_matching(\n    mut str: *const libc::c_char,\n    mut predicate: Option::<unsafe extern \"C\" fn(mcel_t) -> bool>,\n    mut ok: bool,\n) -> *mut libc::c_char {\n    let mut s: *const libc::c_char = str;\n    let mut g: mcel_t = mcel_t { ch: 0, err: 0, len: 0 };\n    while *s as libc::c_int != 0\n        && {\n            g = mcel_scanz(s);\n            predicate.expect(\"non-null function pointer\")(g) as libc::c_int\n                == ok as libc::c_int\n        }\n    {\n        s = s.offset(g.len as libc::c_int as isize);\n    }\n    return s as *mut libc::c_char;\n}\n#[inline]\nunsafe extern \"C\" fn mcel_scanz(mut p: *const libc::c_char) -> mcel_t {\n    return mcel_scant(p, '\\0' as i32 as libc::c_char);\n}\n#[inline]\nunsafe extern \"C\" fn mcel_scant(\n    mut p: *const libc::c_char,\n    mut terminator: libc::c_char,\n) -> mcel_t {\n    if mcel_isbasic(*p) {\n        return mcel_ch(*p as char32_t, 1usize);\n    }\n    let mut lim: *const libc::c_char = p.offset(1 as libc::c_int as isize);\n    let mut i: libc::c_int = 0 as libc::c_int;\n    while i < MCEL_LEN_MAX as libc::c_int - 1 as libc::c_int {\n        lim = lim\n            .offset(\n                (*lim as libc::c_int != terminator as libc::c_int) as libc::c_int\n                    as isize,\n            );\n        i += 1;\n        i;\n    }\n    return mcel_scan(p, lim);\n}\n#[inline]\nfn mcel_scan(p: *const libc::c_char, lim: *const libc::c_char) -> mcel_t {\n    let c = unsafe { *p };\n    if unsafe { mcel_isbasic(c) } {\n        return mcel_ch(c as char32_t, 1);\n    }\n    \n    let mut mbs: mbstate_t = mbstate_t {\n        __count: 0,\n        __value: C2RustUnnamed { __wch: 0 },\n    };\n    \n    mbs.__count = 0;\n    let mut ch: char32_t = 0;\n    let mut len: size_t = unsafe {\n        mbrtoc32(\n            &mut ch,\n            p,\n            lim.offset_from(p) as libc::c_long as size_t,\n            &mut mbs,\n        )\n    };\n    \n    if len > (-(1 as libc::c_int) as size_t).wrapping_div(2 as libc::c_int as libc::c_ulong) {\n        return mcel_err(c as libc::c_uchar);\n    }\n    \n    return mcel_ch(ch, len.try_into().unwrap());\n}\n#[inline]\nfn mcel_isbasic(c: i8) -> bool {\n    (0 <= c as i32 && (c as i32) < MCEL_ERR_MIN as i32)\n}\n#[inline]\nfn mcel_err(err: u8) -> mcel_t {\n    assert!(MCEL_ERR_MIN as i32 <= err as i32);\n    \n    mcel_t {\n        ch: 0,\n        err,\n        len: 1u8,\n    }\n}\n#[inline]\nfn mcel_ch(ch: char32_t, len: usize) -> mcel_t {\n    assert!(len > 0);\n    assert!(len <= MCEL_LEN_MAX as usize);\n    assert!(ch <= MCEL_CHAR_MAX as u32);\n\n    mcel_t {\n        ch,\n        err: 0,\n        len: len as u8,\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\skipchars.rs"
    },
    {
      "chunk": "#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut, unused_imports)]\n#![feature(extern_types)]\nuse std::os::raw::c_char;\nuse std::ffi::CString;\nuse std::mem;\nuse std::ffi::CStr;\nuse std::io::Write;\nuse ::rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut optarg: *mut libc::c_char;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    static mut optind: libc::c_int;\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn atexit(__func: Option::<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn free(_: *mut libc::c_void);\n    fn __errno_location() -> *mut libc::c_int;\n    fn exit(_: libc::c_int) -> !;\n    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;\n    static mut Version: *const libc::c_char;\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    static mut stdin: *mut FILE;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn putchar_unlocked(__c: libc::c_int) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn fwrite_unlocked(\n        __ptr: *const libc::c_void,\n        __size: size_t,\n        __n: size_t,\n        __stream: *mut FILE,\n    ) -> size_t;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn feof_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn fpurge(gl_stream: *mut FILE) -> libc::c_int;\n    fn close_stdout();\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    static mut program_name: *const libc::c_char;\n    fn set_program_name(argv0: *const libc::c_char);\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn quotearg_n_style_colon(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    static mut argmatch_die: argmatch_exit_fn;\n    fn __xargmatch_internal(\n        context: *const libc::c_char,\n        arg: *const libc::c_char,\n        arglist: *const *const libc::c_char,\n        vallist: *const libc::c_void,\n        valsize: size_t,\n        exit_fn: argmatch_exit_fn,\n        allow_abbreviation: bool,\n    ) -> ptrdiff_t;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn initbuffer(linebuffer: *mut linebuffer);\n    fn readlinebuffer_delim(\n        linebuffer: *mut linebuffer,\n        stream: *mut FILE,\n        delimiter: libc::c_char,\n    ) -> *mut linebuffer;\n    fn fadvise(fp: *mut FILE, advice: fadvice_t);\n    fn iswblank(__wc: wint_t) -> libc::c_int;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn posix2_version() -> libc::c_int;\n    fn freopen_safer(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: *mut FILE,\n    ) -> *mut FILE;\n    fn xstrtoimax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut intmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n    fn memcasecmp(\n        vs1: *const libc::c_void,\n        vs2: *const libc::c_void,\n        n: size_t,\n    ) -> libc::c_int;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type __intmax_t = libc::c_long;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type ptrdiff_t = libc::c_long;\npub type intmax_t = __intmax_t;\npub type idx_t = ptrdiff_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type C2RustUnnamed_0 = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed_0 = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed_0 = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type argmatch_exit_fn = Option::<unsafe extern \"C\" fn() -> ()>;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct linebuffer {\n    pub size: idx_t,\n    pub length: idx_t,\n    pub buffer: *mut libc::c_char,\n}\npub type fadvice_t = libc::c_uint;\npub const FADVISE_RANDOM: fadvice_t = 1;\npub const FADVISE_WILLNEED: fadvice_t = 3;\npub const FADVISE_DONTNEED: fadvice_t = 4;\npub const FADVISE_NOREUSE: fadvice_t = 5;\npub const FADVISE_SEQUENTIAL: fadvice_t = 2;\npub const FADVISE_NORMAL: fadvice_t = 0;\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub type C2RustUnnamed_1 = libc::c_uint;\npub const MCEL_LEN_MAX: C2RustUnnamed_1 = 4;\npub type C2RustUnnamed_2 = libc::c_uint;\npub const MCEL_CHAR_MAX: C2RustUnnamed_2 = 1114111;\npub type C2RustUnnamed_3 = libc::c_uint;\npub const MCEL_ERR_MIN: C2RustUnnamed_3 = 128;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mcel_t {\n    pub ch: char32_t,\n    pub err: libc::c_uchar,\n    pub len: libc::c_uchar,\n}\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub type delimit_method = libc::c_uint;\npub const DM_SEPARATE: delimit_method = 2;\npub const DM_PREPEND: delimit_method = 1;\npub const DM_NONE: delimit_method = 0;\npub type grouping_method = libc::c_uint;\npub const GM_BOTH: grouping_method = 4;\npub const GM_SEPARATE: grouping_method = 3;\npub const GM_APPEND: grouping_method = 2;\npub const GM_PREPEND: grouping_method = 1;\npub const GM_NONE: grouping_method = 0;\npub type C2RustUnnamed_4 = libc::c_uint;\npub const GROUP_OPTION: C2RustUnnamed_4 = 256;\npub type Skip_field_option_type = libc::c_uint;\npub const SFO_NEW: Skip_field_option_type = 2;\npub const SFO_OBSOLETE: Skip_field_option_type = 1;\npub const SFO_NONE: Skip_field_option_type = 0;\n#[inline]\nfn emit_mandatory_arg_note() {\n    let message = \"\\nMandatory arguments to long options are mandatory for short options too.\\n\";\n    let stdout_handle = std::io::stdout();\n    let mut handle = stdout_handle.lock();\n    handle.write_all(message.as_bytes()).expect(\"Failed to write to stdout\");\n}\n#[inline]",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\uniq.rs"
    },
    {
      "chunk": "fn emit_ancillary_info(program: &str) {\n    let infomap_0: [( &str, &str); 7] = [\n        ( \"[\", \"test invocation\" ),\n        ( \"coreutils\", \"Multi-call invocation\" ),\n        ( \"sha224sum\", \"sha2 utilities\" ),\n        ( \"sha256sum\", \"sha2 utilities\" ),\n        ( \"sha384sum\", \"sha2 utilities\" ),\n        ( \"sha512sum\", \"sha2 utilities\" ),\n        ( \"\", \"\" ),\n    ];\n\n    let mut node = program;\n    let mut map_prog = infomap_0.iter();\n\n    while let Some(&(prog, n)) = map_prog.next() {\n        if prog.is_empty() || program == prog {\n            node = n;\n            break;\n        }\n    }\n\n    let help_message = unsafe { CStr::from_ptr(gettext(b\"GNU coreutils\\0\".as_ptr() as *const i8)).to_string_lossy() };\n    let help_url = \"https://www.gnu.org/software/coreutils/\";\n    println!(\"{} online help: <{}>\", help_message, help_url);\n\n    let lc_messages = unsafe { setlocale(5, std::ptr::null()) };\n    if !lc_messages.is_null() {\n        let lc_str = unsafe { CStr::from_ptr(lc_messages).to_str().unwrap_or(\"\") };\n        if !lc_str.starts_with(\"en_\") {\n            let report_message = unsafe { CStr::from_ptr(gettext(b\"Report any translation bugs to <https://translationproject.org/team/>\\0\".as_ptr() as *const i8)).to_string_lossy() };\n            writeln!(std::io::stdout(), \"{}\", report_message).unwrap();\n        }\n    }\n\n    let url_program = if program == \"[\" { \"test\" } else { program };\n\n    println!(\n        \"Full documentation <{}{}>\",\n        help_url,\n        url_program\n    );\n\n    println!(\n        \"or available locally via: info '(coreutils) {}{}'\",\n        node,\n        if node == program { \" invocation\" } else { \"\" }\n    );\n}\n#[inline]\nfn write_error() {\n    let saved_errno = std::io::Error::last_os_error();\n    let _ = std::io::stdout().flush();\n    \n    if false {\n        unsafe {\n            error(\n                1,\n                saved_errno.raw_os_error().unwrap_or(0),\n                gettext(b\"write error\\0\".as_ptr() as *const libc::c_char),\n            );\n        }\n        if true {\n            unreachable!();\n        }\n    } else {\n        {\n            let errstatus = 1;\n            unsafe {\n                error(\n                    errstatus,\n                    saved_errno.raw_os_error().unwrap_or(0),\n                    gettext(b\"write error\\0\".as_ptr() as *const libc::c_char),\n                );\n            }\n            if errstatus != 0 {\n                unreachable!();\n            }\n        }\n        {\n            let errstatus = 1;\n            unsafe {\n                error(\n                    errstatus,\n                    saved_errno.raw_os_error().unwrap_or(0),\n                    gettext(b\"write error\\0\".as_ptr() as *const libc::c_char),\n                );\n            }\n            if errstatus != 0 {\n                unreachable!();\n            }\n        }\n    }\n}\n#[inline]\nfn c32isblank(wc: char) -> bool {\n    wc.is_whitespace() && !wc.is_ascii_graphic()\n}\n#[inline]\nfn mcel_ch(ch: char32_t, len: size_t) -> mcel_t {\n    assert!(len > 0, \"Length must be greater than 0\");\n    assert!(len <= MCEL_LEN_MAX as libc::c_int as libc::c_ulong, \"Length exceeds maximum allowed\");\n    assert!(ch <= MCEL_CHAR_MAX as libc::c_int as libc::c_uint, \"Character exceeds maximum allowed\");\n\n    mcel_t {\n        ch,\n        err: 0,\n        len: len as libc::c_uchar,\n    }\n}\n#[inline]\nfn mcel_err(err: u8) -> mcel_t {\n    assert!(MCEL_ERR_MIN as i32 <= err as i32, \"Error value out of range\");\n    \n    mcel_t {\n        ch: 0,\n        err,\n        len: 1u8,\n    }\n}\n#[inline]\nfn mcel_isbasic(c: i8) -> bool {\n    let c_int = c as i32;\n    c_int >= 0 && c_int < MCEL_ERR_MIN as i32\n}\n#[inline]\nfn mcel_scan(p: *const libc::c_char, lim: *const libc::c_char) -> mcel_t {\n    let c = unsafe { *p };\n    if mcel_isbasic(c) {\n        return mcel_ch(c as char32_t, 1 as libc::c_int as size_t);\n    }\n    \n    let mut mbs: mbstate_t = mbstate_t {\n        __count: 0,\n        __value: C2RustUnnamed { __wch: 0 },\n    };\n    \n    mbs.__count = 0;\n    let mut ch: char32_t = 0;\n    let mut len: size_t = unsafe {\n        mbrtoc32(\n            &mut ch,\n            p,\n            lim.offset_from(p) as libc::c_long as size_t,\n            &mut mbs,\n        )\n    };\n    \n    if ((-(1 as libc::c_int) as size_t).wrapping_div(2 as libc::c_int as libc::c_ulong) < len) as libc::c_int as libc::c_long != 0 {\n        return mcel_err(c as libc::c_uchar);\n    }\n    \n    return mcel_ch(ch, len);\n}\n#[inline]\nunsafe extern \"C\" fn skip_buf_matching(\n    mut buf: *const libc::c_char,\n    mut lim: *const libc::c_char,\n    mut predicate: Option::<unsafe extern \"C\" fn(mcel_t) -> bool>,\n    mut ok: bool,\n) -> *mut libc::c_char {\n    let mut s: *const libc::c_char = buf;\n    let mut g: mcel_t = mcel_t { ch: 0, err: 0, len: 0 };\n    while s < lim\n        && {\n            g = mcel_scan(s, lim);\n            predicate.expect(\"non-null function pointer\")(g) as libc::c_int\n                == ok as libc::c_int\n        }\n    {\n        s = s.offset(g.len as libc::c_int as isize);\n    }\n    return s as *mut libc::c_char;\n}\nfn swap_lines(a: &mut *mut linebuffer, b: &mut *mut linebuffer) {\n    std::mem::swap(a, b);\n}\nstatic mut skip_fields: idx_t = 0 as libc::c_int as idx_t;\nstatic mut skip_chars: idx_t = 0 as libc::c_int as idx_t;\nstatic mut check_chars: idx_t = 9223372036854775807 as libc::c_long;\nstatic mut count_occurrences: bool = 0 as libc::c_int != 0;\nstatic mut output_unique: bool = 1 as libc::c_int != 0;\nstatic mut output_first_repeated: bool = 1 as libc::c_int != 0;\nstatic mut output_later_repeated: bool = 0 as libc::c_int != 0;\nstatic mut ignore_case: bool = false;\nstatic mut delimit_method_string: [*const libc::c_char; 4] = [\n    b\"none\\0\" as *const u8 as *const libc::c_char,\n    b\"prepend\\0\" as *const u8 as *const libc::c_char,\n    b\"separate\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\nstatic mut delimit_method_map: [delimit_method; 3] = [DM_NONE, DM_PREPEND, DM_SEPARATE];\nstatic mut delimit_groups: delimit_method = DM_NONE;\nstatic mut grouping_method_string: [*const libc::c_char; 5] = [\n    b\"prepend\\0\" as *const u8 as *const libc::c_char,\n    b\"append\\0\" as *const u8 as *const libc::c_char,\n    b\"separate\\0\" as *const u8 as *const libc::c_char,\n    b\"both\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\nstatic mut grouping_method_map: [grouping_method; 4] = [\n    GM_PREPEND,\n    GM_APPEND,\n    GM_SEPARATE,\n    GM_BOTH,\n];\nstatic mut grouping: grouping_method = GM_NONE;",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\uniq.rs"
    },
    {
      "chunk": "static mut longopts: [option; 13] = [\n    {\n        let mut init = option {\n            name: b\"count\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'c' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"repeated\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'd' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"all-repeated\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 2 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'D' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"group\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 2 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GROUP_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"ignore-case\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'i' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"unique\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'u' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"skip-fields\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'f' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"skip-chars\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 's' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"check-chars\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'w' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"zero-terminated\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'z' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];\n#[no_mangle]\npub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [INPUT [OUTPUT]]\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Filter adjacent matching lines from INPUT (or standard input),\\nwriting to OUTPUT (or standard output).\\n\\nWith no options, matching lines are merged to the first occurrence.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_mandatory_arg_note();\n        fputs_unlocked(\n            gettext(\n                b\"  -c, --count           prefix lines by the number of occurrences\\n  -d, --repeated        only print duplicate lines, one for each group\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -D                    print all duplicate lines\\n      --all-repeated[=METHOD]  like -D, but allow separating groups\\n                                 with an empty line;\\n                                 METHOD={none(default),prepend,separate}\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -f, --skip-fields=N   avoid comparing the first N fields\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --group[=METHOD]  show all items, separating groups with an empty line;\\n                          METHOD={separate(default),prepend,append,both}\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -i, --ignore-case     ignore differences in case when comparing\\n  -s, --skip-chars=N    avoid comparing the first N characters\\n  -u, --unique          only print unique lines\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -z, --zero-terminated     line delimiter is NUL, not newline\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -w, --check-chars=N   compare no more than N characters in lines\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"\\nA field is a run of blanks (usually spaces and/or TABs), then non-blank\\ncharacters.  Fields are skipped before chars.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"\\n'uniq' does not detect repeated lines unless they are adjacent.\\nYou may want to sort the input first, or use 'sort -u' without 'uniq'.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_ancillary_info(\"uniq\");\n    }\n    exit(status);\n}\nfn strict_posix2() -> bool {\n    unsafe {\n        let posix_ver = posix2_version();\n        200112 <= posix_ver && posix_ver < 200809\n    }\n}\nfn size_opt(opt: &CStr, msgid: &CStr) -> idx_t {\n    let mut size: i64 = 0;\n    let opt_str = opt.to_str().unwrap(); // Convert CStr to &str\n\n    if let Err(_) = opt_str.parse::<i64>().map(|s| {\n        if s < 0 {\n            return Err(());\n        }\n        size = s;\n        Ok(())\n    }) {\n        let error_msg = format!(\"{}: {}\", opt_str, msgid.to_string_lossy());\n        // Use a safe block to call the unsafe function\n        unsafe {\n            error(1, 0, error_msg.as_ptr() as *const i8); // Pass raw pointer to error function\n        }\n    }\n\n    if size < 9223372036854775807 {\n        size\n    } else {\n        9223372036854775807\n    }\n}\nunsafe extern \"C\" fn newline_or_blank(mut g: mcel_t) -> bool {\n    let is_newline = g.ch == '\\n' as u32;\nlet is_blank = match char::from_u32(g.ch) {\n    Some(c) => c32isblank(c),\n    None => false,\n};\nreturn is_newline || is_blank;\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\uniq.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn find_field(\n    mut line: *const linebuffer,\n    mut plen: *mut idx_t,\n) -> *mut libc::c_char {\n    let mut lp: *mut libc::c_char = (*line).buffer;\n    let mut lim: *const libc::c_char = lp\n        .offset((*line).length as isize)\n        .offset(-(1 as libc::c_int as isize));\n    let mut i: idx_t = skip_fields;\n    while (0 as libc::c_int as libc::c_long) < i && lp < lim as *mut libc::c_char {\n        lp = skip_buf_matching(\n            lp,\n            lim,\n            Some(newline_or_blank as unsafe extern \"C\" fn(mcel_t) -> bool),\n            1 as libc::c_int != 0,\n        );\n        lp = skip_buf_matching(\n            lp,\n            lim,\n            Some(newline_or_blank as unsafe extern \"C\" fn(mcel_t) -> bool),\n            0 as libc::c_int != 0,\n        );\n        i -= 1;\n        i;\n    }\n    let mut i_0: idx_t = skip_chars;\n    while (0 as libc::c_int as libc::c_long) < i_0 && lp < lim as *mut libc::c_char {\n        lp = lp.offset((mcel_scan(lp, lim)).len as libc::c_int as isize);\n        i_0 -= 1;\n        i_0;\n    }\n    let mut len: idx_t = 0;\n    if lim.offset_from(lp) as libc::c_long <= check_chars {\n        len = lim.offset_from(lp) as libc::c_long;\n    } else if __ctype_get_mb_cur_max() <= 1 as libc::c_int as libc::c_ulong {\n        len = check_chars;\n    } else {\n        let mut ep: *mut libc::c_char = lp;\n        let mut i_1: idx_t = check_chars;\n        while (0 as libc::c_int as libc::c_long) < i_1 && lp < lim as *mut libc::c_char {\n            ep = ep.offset((mcel_scan(lp, lim)).len as libc::c_int as isize);\n            i_1 -= 1;\n            i_1;\n        }\n        len = ep.offset_from(lp) as libc::c_long;\n    }\n    *plen = len;\n    return lp;\n}\nunsafe extern \"C\" fn different(\n    mut old: *mut libc::c_char,\n    mut new: *mut libc::c_char,\n    mut oldlen: idx_t,\n    mut newlen: idx_t,\n) -> bool {\n    if ignore_case {\n        return oldlen != newlen\n            || memcasecmp(\n                old as *const libc::c_void,\n                new as *const libc::c_void,\n                oldlen as size_t,\n            ) != 0\n    } else {\n        return oldlen != newlen\n            || memcmp(\n                old as *const libc::c_void,\n                new as *const libc::c_void,\n                oldlen as libc::c_ulong,\n            ) != 0\n    };\n}\nunsafe extern \"C\" fn writeline(\n    mut line: *const linebuffer,\n    mut match_0: bool,\n    mut linecount: intmax_t,\n) {\n    if if linecount == 0 as libc::c_int as libc::c_long {\n        output_unique as libc::c_int\n    } else if !match_0 {\n        output_first_repeated as libc::c_int\n    } else {\n        output_later_repeated as libc::c_int\n    } == 0\n    {\n        return;\n    }\n    if count_occurrences {\n        printf(\n            b\"%7jd \\0\" as *const u8 as *const libc::c_char,\n            linecount + 1 as libc::c_int as libc::c_long,\n        );\n    }\n    if fwrite_unlocked(\n        (*line).buffer as *const libc::c_void,\n        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,\n        (*line).length as size_t,\n        stdout,\n    ) != (*line).length as libc::c_ulong\n    {\n        write_error();\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\uniq.rs"
    },
    {
      "chunk": "unsafe extern \"C\" fn check_file(\n    mut infile: *const libc::c_char,\n    mut outfile: *const libc::c_char,\n    mut delimiter: libc::c_char,\n) {\n    let mut current_block: u64;\n    let mut lb1: linebuffer = linebuffer {\n        size: 0,\n        length: 0,\n        buffer: 0 as *mut libc::c_char,\n    };\n    let mut lb2: linebuffer = linebuffer {\n        size: 0,\n        length: 0,\n        buffer: 0 as *mut libc::c_char,\n    };\n    let mut thisline: *mut linebuffer = 0 as *mut linebuffer;\n    let mut prevline: *mut linebuffer = 0 as *mut linebuffer;\n    if !(strcmp(infile, b\"-\\0\" as *const u8 as *const libc::c_char) == 0 as libc::c_int\n        || !(freopen_safer(infile, b\"r\\0\" as *const u8 as *const libc::c_char, stdin))\n            .is_null())\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    infile,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if !(strcmp(outfile, b\"-\\0\" as *const u8 as *const libc::c_char) == 0 as libc::c_int\n        || !(freopen_safer(outfile, b\"w\\0\" as *const u8 as *const libc::c_char, stdout))\n            .is_null())\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    outfile,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        outfile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        outfile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    fadvise(stdin, FADVISE_SEQUENTIAL);\n    thisline = &mut lb1;\n    prevline = &mut lb2;\n    initbuffer(thisline);\n    initbuffer(prevline);\n    if output_unique as libc::c_int != 0 && output_first_repeated as libc::c_int != 0\n        && !count_occurrences\n    {\n        let mut prevfield: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut prevlen: idx_t = 0;\n        let mut first_group_printed: bool = 0 as libc::c_int != 0;\n        while feof_unlocked(stdin) == 0\n            && !(readlinebuffer_delim(thisline, stdin, delimiter)).is_null()\n        {\n            let mut thislen: idx_t = 0;\n            let mut thisfield: *mut libc::c_char = find_field(thisline, &mut thislen);\n            let mut new_group: bool = prevfield.is_null()\n                || different(thisfield, prevfield, thislen, prevlen) as libc::c_int != 0;\n            if new_group as libc::c_int != 0\n                && grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint\n                && (grouping as libc::c_uint == GM_PREPEND as libc::c_int as libc::c_uint\n                    || grouping as libc::c_uint == GM_BOTH as libc::c_int as libc::c_uint\n                    || first_group_printed as libc::c_int != 0\n                        && (grouping as libc::c_uint\n                            == GM_APPEND as libc::c_int as libc::c_uint\n                            || grouping as libc::c_uint\n                                == GM_SEPARATE as libc::c_int as libc::c_uint))\n            {\n                putchar_unlocked(delimiter as libc::c_int);\n            }\n            if new_group as libc::c_int != 0\n                || grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint\n            {\n                if fwrite_unlocked(\n                    (*thisline).buffer as *const libc::c_void,\n                    ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,\n                    (*thisline).length as size_t,\n                    stdout,\n                ) != (*thisline).length as libc::c_ulong\n                {\n                    write_error();\n                }\n                swap_lines(&mut prevline, &mut thisline);\n                prevfield = thisfield;\n                prevlen = thislen;\n                first_group_printed = 1 as libc::c_int != 0;\n            }\n        }\n        if (grouping as libc::c_uint == GM_BOTH as libc::c_int as libc::c_uint\n            || grouping as libc::c_uint == GM_APPEND as libc::c_int as libc::c_uint)\n            && first_group_printed as libc::c_int != 0\n        {\n            putchar_unlocked(delimiter as libc::c_int);\n        }\n    } else if !(readlinebuffer_delim(prevline, stdin, delimiter)).is_null() {\n        let mut prevlen_0: idx_t = 0;\n        let mut prevfield_0: *mut libc::c_char = find_field(prevline, &mut prevlen_0);\n        let mut match_count: intmax_t = 0 as libc::c_int as intmax_t;\n        let mut first_delimiter: bool = 1 as libc::c_int != 0;\n        loop {\n            if !(feof_unlocked(stdin) == 0) {\n                current_block = 6476622998065200121;\n                break;\n            }\n            if (readlinebuffer_delim(thisline, stdin, delimiter)).is_null() {\n                if ferror_unlocked(stdin) != 0 {\n                    current_block = 6469497169255231809;\n                    break;\n                } else {\n                    current_block = 6476622998065200121;\n                    break;\n                }\n            } else {\n                let mut thislen_0: idx_t = 0;\n                let mut thisfield_0: *mut libc::c_char = find_field(\n                    thisline,\n                    &mut thislen_0,\n                );\n                let mut match_0: bool = !different(\n                    thisfield_0,\n                    prevfield_0,\n                    thislen_0,\n                    prevlen_0,\n                );\n                match_count += match_0 as libc::c_long;\n                if match_count == 9223372036854775807 as libc::c_long {\n                    if count_occurrences {\n                        if 0 != 0 {\n                            error(\n                                1 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"too many repeated lines\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if 1 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"too many repeated lines\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"too many repeated lines\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    }\n                    match_count -= 1;\n                    match_count;\n                }\n                if delimit_groups as libc::c_uint\n                    != DM_NONE as libc::c_int as libc::c_uint\n                {\n                    if !match_0 {\n                        if match_count != 0 {\n                            first_delimiter = 0 as libc::c_int != 0;\n                        }\n                    } else if match_count == 1 as libc::c_int as libc::c_long {\n                        if delimit_groups as libc::c_uint\n                            == DM_PREPEND as libc::c_int as libc::c_uint\n                            || delimit_groups as libc::c_uint\n                                == DM_SEPARATE as libc::c_int as libc::c_uint\n                                && !first_delimiter\n                        {\n                            putchar_unlocked(delimiter as libc::c_int);\n                        }\n                    }\n                }\n                if !match_0 || output_later_repeated as libc::c_int != 0 {\n                    writeline(prevline, match_0, match_count);\n                    swap_lines(&mut prevline, &mut thisline);\n                    prevfield_0 = thisfield_0;\n                    prevlen_0 = thislen_0;\n                    if !match_0 {\n                        match_count = 0 as libc::c_int as intmax_t;\n                    }\n                }\n            }\n        }\n        match current_block {\n            6469497169255231809 => {}\n            _ => {\n                writeline(prevline, 0 as libc::c_int != 0, match_count);\n            }\n        }\n    }\n    if ferror_unlocked(stdin) != 0 || rpl_fclose(stdin) != 0 {",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\uniq.rs"
    },
    {
      "chunk": "    let errstatus = 1;\n    error(\n        errstatus,\n        *__errno_location(),\n        gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, infile),\n    );\n    unreachable!();\n}\n\ndrop(lb1);\ndrop(lb2);\n\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\uniq.rs"
    },
    {
      "chunk": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut optc: libc::c_int = 0 as libc::c_int;\n    let mut posixly_correct: bool = !(getenv(\n        b\"POSIXLY_CORRECT\\0\" as *const u8 as *const libc::c_char,\n    ))\n        .is_null();\n    let mut skip_field_option_type: Skip_field_option_type = SFO_NONE;\n    let mut nfiles: libc::c_int = 0 as libc::c_int;\n    let mut file: [*const libc::c_char; 2] = [0 as *const libc::c_char; 2];\n    let mut delimiter: libc::c_char = '\\n' as i32 as libc::c_char;\n    let mut output_option_used: bool = 0 as libc::c_int != 0;\n    file[1 as libc::c_int as usize] = b\"-\\0\" as *const u8 as *const libc::c_char;\n    file[0 as libc::c_int as usize] = file[1 as libc::c_int as usize];\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    loop {\n        if optc == -(1 as libc::c_int)\n            || posixly_correct as libc::c_int != 0 && nfiles != 0 as libc::c_int\n            || {\n                optc = getopt_long(\n                    argc,\n                    argv,\n                    b\"-0123456789Dcdf:is:uw:z\\0\" as *const u8 as *const libc::c_char,\n                    longopts.as_ptr(),\n                    0 as *mut libc::c_int,\n                );\n                optc == -(1 as libc::c_int)\n            }\n        {\n            if argc <= optind {\n    break;\n}\nif nfiles == 2 {\n    let extra_operand = quote(unsafe { *argv.offset(optind as isize) });\n    error(0, 0, gettext(b\"extra operand %s\\0\" as *const u8 as *const libc::c_char), extra_operand);\n    usage(1);\n}\nlet fresh0 = optind;\noptind += 1;\nlet fresh1 = nfiles;\nnfiles += 1;\nfile[fresh1 as usize] = unsafe { *argv.offset(fresh0 as isize) };\n\n        } else {\n            match optc {\n    1 => {\n         let mut size: intmax_t = 0;\n                    if *optarg.offset(0 as libc::c_int as isize) as libc::c_int\n                        == '+' as i32 && !strict_posix2()\n                        && xstrtoimax(\n                            optarg,\n                            0 as *mut *mut libc::c_char,\n                            10 as libc::c_int,\n                            &mut size,\n                            b\"\\0\" as *const u8 as *const libc::c_char,\n                        ) as libc::c_uint\n                            <= LONGINT_OVERFLOW as libc::c_int as libc::c_uint\n                    {\n                        skip_chars = if size < 9223372036854775807 as libc::c_long {\n                            size\n                        } else {\n                            9223372036854775807 as libc::c_long\n                        };\n                    } else if nfiles == 2 as libc::c_int {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                                    ),\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                                    ),\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                        usage(1 as libc::c_int);\n                    } else {\n                        let fresh2 = nfiles;\n                        nfiles = nfiles + 1;\n                        file[fresh2 as usize] = optarg;\n                    }\n\n    }\n    48..=57 => {\n         if skip_field_option_type as libc::c_uint\n                        == SFO_NEW as libc::c_int as libc::c_uint\n                    {\n                        skip_fields = 0 as libc::c_int as idx_t;\n                    }\n                    if !(!((if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                        && ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            skip_fields\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        && ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            10 as libc::c_int\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        && (if (10 as libc::c_int) < 0 as libc::c_int {\n                            if skip_fields < 0 as libc::c_int as libc::c_long {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        -(1 as libc::c_int) as idx_t\n                                    }) + 10 as libc::c_int as libc::c_long\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    (skip_fields\n                                        < -(1 as libc::c_int) as idx_t\n                                            / 10 as libc::c_int as libc::c_long) as libc::c_int\n                                } else {\n                                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                                    {\n                                        !(((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) + 1 as libc::c_int)\n                                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) + 0 as libc::c_int\n                                    }) < 0 as libc::c_int\n                                    {\n                                        ((10 as libc::c_int)\n                                            < -(if ((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                                            {\n                                                ((((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    10 as libc::c_int\n                                                }) + 1 as libc::c_int)\n                                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    10 as libc::c_int\n                                                }) - 1 as libc::c_int\n                                            })) as libc::c_int\n                                    } else {\n                                        ((0 as libc::c_int) < 10 as libc::c_int) as libc::c_int\n                                    }) != 0\n                                    {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + -(1 as libc::c_int) as idx_t\n                                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                    } else {\n                                        -(1 as libc::c_int) as idx_t\n                                            / -(10 as libc::c_int) as libc::c_long\n                                    }) <= -(1 as libc::c_int) as libc::c_long - skip_fields)\n                                        as libc::c_int\n                                }\n                            } else {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) as libc::c_long + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    10 as libc::c_int\n                                                }) as libc::c_long + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\uniq.rs"
    },
    {
      "chunk": "                                                } else {\n                                                    10 as libc::c_int\n                                                }) as libc::c_long + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + 0 as libc::c_int as idx_t)\n                                        as libc::c_int\n                                }) != 0 && 10 as libc::c_int == -(1 as libc::c_int)\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        skip_fields\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < skip_fields + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((0 as libc::c_int as libc::c_long) < skip_fields\n                                            && (-(1 as libc::c_int) as libc::c_long\n                                                - 0 as libc::c_int as idx_t)\n                                                < skip_fields - 1 as libc::c_int as libc::c_long)\n                                            as libc::c_int\n                                    }\n                                } else {\n                                    ((0 as libc::c_int as idx_t\n                                        / 10 as libc::c_int as libc::c_long) < skip_fields)\n                                        as libc::c_int\n                                }\n                            }\n                        } else {\n                            if 10 as libc::c_int == 0 as libc::c_int {\n                                0 as libc::c_int\n                            } else {\n                                if skip_fields < 0 as libc::c_int as libc::c_long {\n                                    if (if (if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            skip_fields\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        !(((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                skip_fields\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long)\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                skip_fields\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 0 as libc::c_int as libc::c_long\n                                    }) < 0 as libc::c_int as libc::c_long\n                                    {\n                                        (((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            skip_fields\n                                        }) + 0 as libc::c_int as idx_t)\n                                            < -(if ((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    skip_fields\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long)\n                                                < 0 as libc::c_int as libc::c_long\n                                            {\n                                                ((((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        skip_fields\n                                                    }) + 0 as libc::c_int as idx_t\n                                                }) + 1 as libc::c_int as libc::c_long)\n                                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                    - 1 as libc::c_int as libc::c_long)\n                                                    * 2 as libc::c_int as libc::c_long\n                                                    + 1 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        skip_fields\n                                                    }) + 0 as libc::c_int as idx_t\n                                                }) - 1 as libc::c_int as libc::c_long\n                                            })) as libc::c_int\n                                    } else {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                skip_fields\n                                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                    }) != 0\n                                        && skip_fields == -(1 as libc::c_int) as libc::c_long\n                                    {\n                                        if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                                        {\n                                            ((0 as libc::c_int as libc::c_long)\n                                                < 10 as libc::c_int as libc::c_long\n                                                    + 0 as libc::c_int as idx_t) as libc::c_int\n                                        } else {\n                                            ((-(1 as libc::c_int) as libc::c_long\n                                                - 0 as libc::c_int as idx_t)\n                                                < (10 as libc::c_int - 1 as libc::c_int) as libc::c_long)\n                                                as libc::c_int\n                                        }\n                                    } else {\n                                        (0 as libc::c_int as idx_t / skip_fields\n                                            < 10 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    ((-(1 as libc::c_int) as idx_t\n                                        / 10 as libc::c_int as libc::c_long) < skip_fields)\n                                        as libc::c_int\n                                }\n                            }\n                        }) != 0\n                    {\n                        let (fresh7, _fresh8) = skip_fields\n                            .overflowing_mul((10 as libc::c_int).into());\n                        *(&mut skip_fields as *mut idx_t) = fresh7;\n                        1 as libc::c_int\n                    } else {\n                        let (fresh9, fresh10) = skip_fields\n                            .overflowing_mul((10 as libc::c_int).into());\n                        *(&mut skip_fields as *mut idx_t) = fresh9;\n                        fresh10 as libc::c_int\n                    }) != 0)\n                        && {\n                            let (fresh11, fresh12) = skip_fields\n                                .overflowing_add((optc - '0' as i32).into());\n                            *(&mut skip_fields as *mut idx_t) = fresh11;\n                            !fresh12\n                        })\n                    {\n                        skip_fields = 9223372036854775807 as libc::c_long;\n                    }\n                    skip_field_option_type = SFO_OBSOLETE;\n\n    }\n    99 => {\n        count_occurrences = true;\n        output_option_used = true;\n    }\n    100 => {\n        output_unique = false;\n        output_option_used = true;\n    }\n    68 => {\n         output_unique = false;\noutput_later_repeated = true;\n\nif optarg.is_null() {\n    delimit_groups = DM_NONE;\n} else {\n    let optarg_str = unsafe { std::ffi::CStr::from_ptr(optarg) };\n    delimit_groups = delimit_method_map[__xargmatch_internal(\n        std::ffi::CString::new(\"--all-repeated\").unwrap().as_ptr(),\n        optarg_str.as_ptr(),\n        delimit_method_string.as_ptr(),\n        delimit_method_map.as_ptr() as *const libc::c_void,\n        std::mem::size_of::<delimit_method>() as u64,\n        argmatch_die,\n        true,\n    ) as usize];\n}\n\noutput_option_used = true;\n\n\n    }\n    256 => {\n         if optarg.is_null() {\n    grouping = GM_SEPARATE;\n} else {\n    let optarg_str = unsafe { std::ffi::CStr::from_ptr(optarg) };\n    grouping = grouping_method_map[__xargmatch_internal(\n        std::ffi::CString::new(\"--group\").unwrap().as_ptr(),\n        optarg_str.as_ptr(),\n        grouping_method_string.as_ptr(),\n        grouping_method_map.as_ptr() as *const libc::c_void,\n        std::mem::size_of::<grouping_method>() as u64,\n        argmatch_die,\n        true,\n    ) as usize];\n}\n\n\n    }\n    102 => {\n        skip_field_option_type = SFO_NEW;\n        skip_fields = size_opt(\n            unsafe { CStr::from_ptr(optarg) },\n            unsafe { CStr::from_bytes_with_nul_unchecked(b\"invalid number of fields to skip\\0\") },\n        );\n    }\n    105 => {\n        ignore_case = true;\n    }\n    115 => {\n        skip_chars = size_opt(\n            unsafe { CStr::from_ptr(optarg) },\n            unsafe { CStr::from_bytes_with_nul_unchecked(b\"invalid number of bytes to skip\\0\") },\n        );\n    }\n    117 => {\n        output_first_repeated = false;\n        output_option_used = true;\n    }\n    119 => {\n        check_chars = size_opt(\n            unsafe { CStr::from_ptr(optarg) },\n            unsafe { CStr::from_bytes_with_nul_unchecked(b\"invalid number of bytes to compare\\0\") },\n        );\n    }\n    122 => {\n        delimiter = b'\\0' as i8;\n    }\n    -2 => {\n        usage(0);\n    }\n    -3 => {\n         version_etc(\n                        stdout,\n                        b\"uniq\\0\" as *const u8 as *const libc::c_char,\n                        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                        Version,\n                        proper_name_lite(\n                            b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                            b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        proper_name_lite(\n                            b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                            b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        0 as *mut libc::c_void as *mut libc::c_char,\n                    );\n                    exit(0 as libc::c_int);\n\n    }\n    _ => {\n        usage(1);\n    }\n}\n/*\nThe variables live at this point are:\n(mut optc: i32, mut skip_field_option_type: u32, mut nfiles: i32, mut file: [*const i8; 2], mut delimiter: i8, mut output_option_used: bool)\n*/\n\n        }\n    }\n    if grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint\n        && output_option_used as libc::c_int != 0\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\uniq.rs"
    },
    {
      "chunk": "                    b\"--group is mutually exclusive with -c/-d/-D/-u\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"--group is mutually exclusive with -c/-d/-D/-u\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"--group is mutually exclusive with -c/-d/-D/-u\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint\n        && count_occurrences as libc::c_int != 0\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"grouping and printing repeat counts is meaningless\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"grouping and printing repeat counts is meaningless\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"grouping and printing repeat counts is meaningless\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if count_occurrences as libc::c_int != 0 && output_later_repeated as libc::c_int != 0\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"printing all duplicated lines and repeat counts is meaningless\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"printing all duplicated lines and repeat counts is meaningless\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"printing all duplicated lines and repeat counts is meaningless\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    check_file(\n        file[0 as libc::c_int as usize],\n        file[1 as libc::c_int as usize],\n        delimiter,\n    );\n    return 0 as libc::c_int;\n}\npub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\uniq.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\version.rs"
    },
    {
      "chunk": "use std::ffi::CStr;\nuse ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\version_etc.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub fn emit_bug_reporting_address() {\n    println!();\n    println!(\n        \"Report bugs to: {}\",\n        unsafe { CStr::from_ptr(gettext(b\"Report bugs to: \\0\".as_ptr() as *const libc::c_char)).to_string_lossy() }\n    );\n    println!(\n        \"{} home page: <{}>\",\n        unsafe { CStr::from_ptr(gettext(b\"GNU coreutils\\0\".as_ptr() as *const libc::c_char)).to_string_lossy() },\n        unsafe { CStr::from_ptr(b\"https://www.gnu.org/software/coreutils/\\0\".as_ptr() as *const libc::c_char).to_string_lossy() }\n    );\n    println!(\n        \"General help using GNU software: <{}>\",\n        \"https://www.gnu.org/gethelp/\"\n    );\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\version_etc.rs"
    },
    {
      "chunk": "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\version_etc_fsf.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\xalloc_die.rs"
    },
    {
      "chunk": "use std::string::String;\nuse std::slice;\nuse std::mem;\nuse std::vec::Vec;\nuse std::convert::TryInto;\nuse ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nfn irealloc(p: *mut u8, s: usize) -> *mut u8 {\n    if s <= usize::MAX {\n        let new_size = if s == 0 { 1 } else { s };\n        let new_ptr = unsafe { libc::realloc(p as *mut libc::c_void, new_size) };\n        new_ptr as *mut u8\n    } else {\n        unsafe { _gl_alloc_nomem() as *mut u8 }\n    }\n}\n#[inline]\nfn icalloc(n: i64, s: i64) -> *mut libc::c_void {\n    let n_usize: usize = n.try_into().unwrap();\n    let s_usize: usize = s.try_into().unwrap();\n\n    if n_usize > usize::MAX / s_usize {\n        if s_usize != 0 {\n            unsafe { return _gl_alloc_nomem(); }\n        }\n        return std::ptr::null_mut(); // Equivalent to allocating zero size\n    }\n    if s_usize > usize::MAX / n_usize {\n        if n_usize != 0 {\n            unsafe { return _gl_alloc_nomem(); }\n        }\n        return std::ptr::null_mut(); // Equivalent to allocating zero size\n    }\n    let total_size = n_usize.checked_mul(s_usize).expect(\"Overflow in allocation size\");\n    let mut vec = vec![0u8; total_size]; // Allocating and initializing to zero\n    let ptr = vec.as_mut_ptr();\n    std::mem::forget(vec); // Prevent dropping the Vec\n    ptr as *mut libc::c_void // Return the raw pointer as *mut c_void\n}\n#[inline]\nfn ireallocarray(\n    p: *mut libc::c_void,\n    n: usize,\n    s: usize,\n) -> *mut libc::c_void {\n    if n <= usize::MAX && s <= usize::MAX {\n        let mut nx = n;\n        let mut sx = s;\n        if n == 0 || s == 0 {\n            sx = 1;\n            nx = sx;\n        }\n        let new_size = nx.checked_mul(sx).expect(\"Overflow in allocation size\");\n        let new_ptr = unsafe { libc::reallocarray(p, new_size, 1) };\n        new_ptr\n    } else {\n        unsafe { _gl_alloc_nomem() }\n    }\n}\n#[cold]\n#[inline]\nunsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}\n#[inline]\nfn imalloc(s: usize) -> *mut libc::c_void {\n    if s <= usize::MAX {\n        let layout = std::alloc::Layout::from_size_align(s, 1).unwrap();\n        let ptr = unsafe { std::alloc::alloc(layout) };\n        if ptr.is_null() {\n            std::ptr::null_mut()\n        } else {\n            ptr as *mut libc::c_void\n        }\n    } else {\n        std::ptr::null_mut()\n    }\n}\nfn check_nonnull(p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        unsafe { xalloc_die() };\n    }\n    p\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    let allocated_memory = imalloc(s.try_into().unwrap());\nreturn check_nonnull(allocated_memory);\n}\n#[no_mangle]\npub fn xcharalloc(n: usize) -> Vec<libc::c_char> {\n    let size_of_char = std::mem::size_of::<libc::c_char>();\n    if size_of_char == 1 {\n        // Call to unsafe function xmalloc\n        let ptr = unsafe { xmalloc(n.try_into().unwrap()) };\n        unsafe { Vec::from_raw_parts(ptr as *mut libc::c_char, n, n) }\n    } else {\n        // Call to unsafe function xnmalloc\n        let ptr = unsafe { xnmalloc(n.try_into().unwrap(), size_of_char.try_into().unwrap()) };\n        unsafe { Vec::from_raw_parts(ptr as *mut libc::c_char, n, n) }\n    }\n}\n#[no_mangle]\npub fn xrealloc(\n    p: *mut libc::c_void,\n    s: usize,\n) -> *mut libc::c_void {\n    if s == 0 {\n        if !p.is_null() {\n            unsafe { libc::free(p) };\n        }\n        return std::ptr::null_mut();\n    }\n\n    let r = unsafe { libc::realloc(p, s) };\n    if r.is_null() && (p.is_null() || s != 0) {\n        unsafe { xalloc_die() };\n    }\n    r\n}\n#[no_mangle]\npub fn xirealloc(p: &[u8], s: usize) -> Vec<u8> {\n    let new_size: usize = s; // Assuming idx_t is usize\n    let mut vec = Vec::with_capacity(new_size);\n    vec.copy_from_slice(p);\n    vec.resize(new_size, 0);\n    return vec;\n}\n#[no_mangle]\npub fn xreallocarray(vec: &mut Vec<u8>, n: usize, s: usize) {\n    let current_len = vec.len() / s;\n    if n > current_len {\n        vec.resize(n * s, 0);\n    } else {\n        vec.truncate(n * s);\n    }\n}\n#[no_mangle]\npub fn xireallocarray(n: idx_t, s: idx_t) -> Vec<u8> {\n    let size: usize = (n as usize).checked_mul(s as usize).expect(\"Multiplication overflow\");\n    let mut vec = Vec::with_capacity(size);\n    vec.resize(size, 0);\n    vec\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    let mut vec = Vec::with_capacity((n * s).try_into().unwrap());\nxreallocarray(&mut vec, n.try_into().unwrap(), s.try_into().unwrap());\nreturn vec.as_mut_ptr() as *mut libc::c_void;\n}\n#[no_mangle]\npub fn xinmalloc(n: idx_t, s: idx_t) -> Vec<u8> {\n    let total_size: usize = (n as usize).checked_mul(s as usize).expect(\"Overflow in multiplication\");\n    Vec::with_capacity(total_size)\n}\n#[no_mangle]\npub fn x2realloc(\n    p: &mut Vec<u8>,\n    ps: &mut usize,\n) -> Vec<u8> {\n    let new_size = 1; // Assuming the size to be allocated is 1\n    p.resize(*ps + new_size, 0);\n    *ps += new_size;\n    p.clone() // Return a clone of the vector\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    let mut vec = Vec::from_raw_parts(p as *mut u8, (n * s).try_into().unwrap(), s.try_into().unwrap());\nxreallocarray(&mut vec, n.try_into().unwrap(), s.try_into().unwrap());\np = vec.as_mut_ptr() as *mut libc::c_void;\nstd::mem::forget(vec);\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as usize);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub fn xzalloc(s: usize) -> Vec<u8> {\n    let size: usize = s.try_into().unwrap_or(0);\n    vec![0; size]\n}\n#[no_mangle]\npub fn xizalloc(s: idx_t) -> Vec<u8> {\n    let size: usize = s.try_into().expect(\"Conversion failed\");\n    let vec = vec![0u8; size];\n    vec\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}\n#[no_mangle]\npub fn xicalloc(n: usize, s: usize) -> *mut libc::c_void {\n    let total_size = n.checked_mul(s).expect(\"Overflow in allocation size\");\n    let vec = vec![0u8; total_size];\n    let ptr = check_nonnull(vec.as_ptr() as *mut libc::c_void);\n    std::mem::forget(vec); // Prevent the Vec from being dropped and freeing the memory\n    ptr\n}\n#[no_mangle]\npub fn xmemdup(p: &[u8]) -> Vec<u8> {\n    let mut result = vec![0; p.len()];\n    result.copy_from_slice(p);\n    result\n}\n#[no_mangle]\npub fn ximemdup(p: &[u8]) -> Vec<u8> {\n    let s = p.len();\n    let mut new_vec = Vec::with_capacity(s);\n    new_vec.copy_from_slice(p);\n    new_vec\n}\n#[no_mangle]\npub fn ximemdup0(p: &[u8]) -> Vec<u8> {\n    let s = p.len();\n    let mut result = Vec::with_capacity(s + 1);\n    result.extend_from_slice(p);\n    result.push(0); // Null-terminate the string\n    result\n}\n#[no_mangle]\npub fn xstrdup(string: &str) -> String {\n    let length = string.len();\n    let mut vec = Vec::with_capacity(length + 1);\n    vec.extend_from_slice(string.as_bytes());\n    vec.push(0); // Null-terminator\n    String::from_utf8(vec).expect(\"Failed to convert to String\")\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\xmalloc.rs"
    },
    {
      "chunk": "use ::libc;\nextern \"C\" {\n    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtoimax(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __base: libc::c_int,\n    ) -> intmax_t;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n}\npub type __intmax_t = libc::c_long;\npub type intmax_t = __intmax_t;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub const _ISspace: C2RustUnnamed = 8192;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\xstrtoimax.rs"
    },
    {
      "chunk": "fn bkm_scale(\n    x: &mut i64,\n    scale_factor: i32,\n) -> strtol_error {\n     let mut scaled: i64 = 0;\nif (0 < -1)\n    && ((if true { 0 } else { *x }) - 1) < 0\n    && ((if true { 0 } else { scale_factor }) - 1) < 0\n    && (if scale_factor < 0 {\n        if *x < 0 {\n             if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as intmax_t\n                    }) + scale_factor as libc::c_long\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (*x < -(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + -(1 as libc::c_int) as intmax_t\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as intmax_t / -scale_factor as libc::c_long\n                    }) <= -(1 as libc::c_int) as libc::c_long - *x) as libc::c_int\n                }\n            \n        } else {\n             if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n                        as libc::c_long + 0 as libc::c_int as intmax_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        *x\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < *x + 0 as libc::c_int as intmax_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < *x\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < *x - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as intmax_t / scale_factor as libc::c_long) < *x)\n                        as libc::c_int\n                }\n            \n        }\n    } else {\n         if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    *x\n                                }) + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < scale_factor as libc::c_long\n                                    + 0 as libc::c_int as intmax_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_long)",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\xstrtoimax.rs"
    },
    {
      "chunk": "                                as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as intmax_t / *x\n                            < scale_factor as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        < *x) as libc::c_int\n                }\n            }\n        \n    }) != 0\n{\n    let (result, overflowed) = (*x).overflowing_mul(scale_factor as i64);\n    scaled = result;\n    return 1;\n} else {\n    let (result, overflowed) = (*x).overflowing_mul(scale_factor as i64);\n    scaled = result;\n    if overflowed {\n        return 1;\n    }\n}\n{\n     *x = if *x < 0 as libc::c_int as libc::c_long {\n            !if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n                -(1 as libc::c_int) as intmax_t\n            } else {\n                (((1 as libc::c_int as intmax_t)\n                    << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            }\n        } else if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n            -(1 as libc::c_int) as intmax_t\n        } else {\n            (((1 as libc::c_int as intmax_t)\n                << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        };\n        return LONGINT_OVERFLOW;\n    \n}\n*x = scaled;\nreturn LONGINT_OK;\n/*\nThe variables live at this point are:\n(mut x: *mut i64, mut scale_factor: i32, mut scaled: i64)\n*/\n\n\n}\nfn bkm_scale_by_power(\n    x: &mut i64, // Assuming intmax_t is equivalent to i64 in Rust\n    base: i32,\n    mut power: i32,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    while power > 0 {\n        power -= 1;\n        err |= bkm_scale(x, base);\n    }\n    err\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrtoimax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut intmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    use std::ffi::CStr;\nuse std::os::raw::c_char;\nuse std::str;\n\nlet mut t_ptr: *mut c_char = std::ptr::null_mut();\nlet mut p: *mut *mut c_char = if !ptr.is_null() { ptr } else { &mut t_ptr };\nlet mut tmp: i64 = 0;\nlet mut err: strtol_error = LONGINT_OK;\n\nif !(0 <= strtol_base && strtol_base <= 36) {\n    panic!(\"0 <= strtol_base && strtol_base <= 36\");\n}\n\nlet mut q: *const c_char = s;\nlet mut ch: u8 = unsafe { *q as u8 };\n\nwhile unsafe { *__ctype_b_loc() }.offset(ch as i32 as isize) as i32 & _ISspace as u16 as i32 != 0 {\n    q = unsafe { q.offset(1) };\n    ch = unsafe { *q as u8 };\n}\n\nif ch as i32 == '-' as i32 {\n    return LONGINT_INVALID;\n}\n\ntmp = strtoimax(s, p, strtol_base);\n\nif *p == s as *mut c_char {\n    if !valid_suffixes.is_null() && **p as i32 != 0 && !strchr(valid_suffixes, **p as i32).is_null() {\n        tmp = 1;\n    } else {\n        return LONGINT_INVALID;\n    }\n} else if unsafe { *__errno_location() } != 0 {\n    if unsafe { *__errno_location() } != 34 {\n        return LONGINT_INVALID;\n    }\n    err = LONGINT_OVERFLOW;\n}\n\nif valid_suffixes.is_null() {\n    *val = tmp;\n    return err;\n}\n\n    if !(*p).is_null() && **p != 0 {\n    let mut base: i32 = 1024;\n    let mut suffixes: i32 = 1;\n    let mut overflow: strtol_error = LONGINT_OK;\n\n    let valid_suffixes_str = unsafe { std::ffi::CStr::from_ptr(valid_suffixes).to_string_lossy() };\n    if !valid_suffixes_str.contains(**p as u8 as char) {\n        *val = tmp;\n        return (err | LONGINT_INVALID_SUFFIX_CHAR) as strtol_error;\n    }\n\n    match **p as u8 {\n        b'E' | b'G' | b'g' | b'k' | b'K' | b'M' | b'm' | b'P' | b'Q' | b'R' | b'T' | b't' | b'Y' | b'Z' => {\n            if valid_suffixes_str.contains('0') {\n                match unsafe { *(*p).offset(1) } as u8 {\n                    b'i' => {\n                        if unsafe { *(*p).offset(2) } as u8 == b'B' {\n                            suffixes += 2;\n                        }\n                    }\n                    b'B' | b'D' => {\n                        base = 1000;\n                        suffixes += 1;\n                    }\n                    _ => {}\n                }\n            }\n        }\n        _ => {}\n    }\n\n    match **p as u8 {\n        b'b' => {\n            overflow = bkm_scale(&mut tmp, 512);\n        }\n        b'B' => {\n            overflow = bkm_scale(&mut tmp, 1024);\n        }\n        b'c' => {\n            overflow = LONGINT_OK;\n        }\n        b'E' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 6);\n        }\n        b'G' | b'g' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 3);\n        }\n        b'k' | b'K' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 1);\n        }\n        b'M' | b'm' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 2);\n        }\n        b'P' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 5);\n        }\n        b'Q' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 10);\n        }\n        b'R' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 9);\n        }\n        b'T' | b't' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 4);\n        }\n        b'w' => {\n            overflow = bkm_scale(&mut tmp, 2);\n        }\n        b'Y' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 8);\n        }\n        b'Z' => {\n            overflow = bkm_scale_by_power(&mut tmp, base, 7);\n        }\n        _ => {\n            *val = tmp;\n            return (err | LONGINT_INVALID_SUFFIX_CHAR) as strtol_error;\n        }\n    }\n\n    err |= overflow as u32;\n    *p = unsafe { (*p).offset(suffixes as isize) };\n    if **p != 0 {\n        err |= LONGINT_INVALID_SUFFIX_CHAR as u32;\n    }\n}\n*val = tmp;\nreturn err;\n\n}",
      "file_name": "c2saferrust/coreutils/src\\uniq\\rust_WIP\\src\\xstrtoimax.rs"
    }
  ]
}