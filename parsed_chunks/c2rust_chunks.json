{
  "cat": [
    "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
    "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod alignalloc;\npub mod binary_io;\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod close_stream;\npub mod closeout;\npub mod copy_file_range;\npub mod exitfail;\npub mod fadvise;\npub mod fclose;\npub mod fcntl;\npub mod fflush;\npub mod fpurge;\npub mod fseeko;\npub mod full_write;\npub mod hard_locale;\npub mod ialloc;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod safe_read;\npub mod safe_write;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod stdbit;\npub mod stdc_leading_zeros;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalignalloc;\npub mod xalloc_die;\npub mod xbinary_io;\npub mod xmalloc;\n}\n// mod src",
    "use ::libc;\nextern \"C\" {\n    fn free(_: *mut libc::c_void);\n    fn aligned_alloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n}\npub type size_t = libc::c_ulong;\npub type ptrdiff_t = libc::c_long;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn alignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    if (-(1 as libc::c_int) as size_t) < alignment as libc::c_ulong {\n        alignment = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    if (-(1 as libc::c_int) as size_t) < size as libc::c_ulong {\n        size = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    return aligned_alloc(alignment as libc::c_ulong, size as libc::c_ulong);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn alignfree(mut ptr: *mut libc::c_void) {\n    free(ptr);\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut, unused_imports)]\n#![feature(extern_types)]\nuse ::rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn fpurge(gl_stream: *mut FILE) -> libc::c_int;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    static mut optind: libc::c_int;\n    fn ioctl(__fd: libc::c_int, __request: libc::c_ulong, _: ...) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn getpagesize() -> libc::c_int;\n    fn rpl_copy_file_range(\n        ifd: libc::c_int,\n        ipos: *mut off_t,\n        ofd: libc::c_int,\n        opos: *mut off_t,\n        len: size_t,\n        flags: libc::c_uint,\n    ) -> ssize_t;\n    fn memmove(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn stpcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;\n    fn free(_: *mut libc::c_void);\n    fn __errno_location() -> *mut libc::c_int;\n    fn quotearg_n_style_colon(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    static mut Version: *const libc::c_char;\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn rpl_fcntl(fd: libc::c_int, action: libc::c_int, _: ...) -> libc::c_int;\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn xalloc_die();\n    fn close_stdout();\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    static mut program_name: *const libc::c_char;\n    fn set_program_name(argv0: *const libc::c_char);\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn atexit(__func: Option::<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn exit(_: libc::c_int) -> !;\n    fn xalignalloc(_: idx_t, _: idx_t) -> *mut libc::c_void;\n    fn fdadvise(fd: libc::c_int, offset: off_t, len: off_t, advice: fadvice_t);\n    fn full_write(fd: libc::c_int, buf: *const libc::c_void, count: size_t) -> size_t;\n    fn safe_read(fd: libc::c_int, buf: *mut libc::c_void, count: size_t) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __ssize_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type ssize_t = __ssize_t;\npub type ptrdiff_t = libc::c_long;\npub type ino_t = __ino_t;\npub type dev_t = __dev_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const IO_BUFSIZE: C2RustUnnamed_0 = 262144;\npub type fadvice_t = libc::c_uint;\npub const FADVISE_RANDOM: fadvice_t = 1;\npub const FADVISE_WILLNEED: fadvice_t = 3;\npub const FADVISE_DONTNEED: fadvice_t = 4;\npub const FADVISE_NOREUSE: fadvice_t = 5;\npub const FADVISE_SEQUENTIAL: fadvice_t = 2;\npub const FADVISE_NORMAL: fadvice_t = 0;\n#[inline]\nunsafe extern \"C\" fn is_ENOTSUP(mut err: libc::c_int) -> bool {\n    return err == 95 as libc::c_int\n        || 95 as libc::c_int != 95 as libc::c_int && err == 95 as libc::c_int;\n}\n#[inline]\nunsafe extern \"C\" fn emit_stdin_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nWith no FILE, or when FILE is -, read standard input.\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        stdout,\n    );\n}\n#[inline]\nunsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}\n#[inline]\nunsafe extern \"C\" fn write_error() {\n    let mut saved_errno: libc::c_int = *__errno_location();\n    fflush_unlocked(stdout);\n    fpurge(stdout);\n    clearerr_unlocked(stdout);\n    if 0 != 0 {\n        error(\n            1 as libc::c_int,\n            saved_errno,\n            gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n        );\n        if 1 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}\n#[inline]\nunsafe extern \"C\" fn alignfree(mut ptr: *mut libc::c_void) {\n    free(ptr);\n}\n#[inline]\nunsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[inline]\nunsafe extern \"C\" fn stdc_leading_zeros_ull(mut n: libc::c_ulonglong) -> libc::c_uint {\n    return __gl_stdbit_clzll(n) as libc::c_uint;\n}\n#[inline]\nunsafe extern \"C\" fn io_blksize(mut st: *const stat) -> idx_t {\n    let mut blocksize: idx_t = (if (if (0 as libc::c_int) < (*st).st_blksize\n        && (*st).st_blksize as libc::c_ulong\n            <= (-(1 as libc::c_int) as size_t)\n                .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        (*st).st_blksize\n    } else {\n        512 as libc::c_int\n    }) <= 0 as libc::c_int\n    {\n        IO_BUFSIZE as libc::c_int\n    } else if (0 as libc::c_int) < (*st).st_blksize\n        && (*st).st_blksize as libc::c_ulong\n            <= (-(1 as libc::c_int) as size_t)\n                .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        (*st).st_blksize\n    } else {\n        512 as libc::c_int\n    }) as idx_t;\n    blocksize\n        += (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long\n            - (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long % blocksize;\n    if (*st).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        && blocksize & blocksize - 1 as libc::c_int as libc::c_long != 0\n    {\n        let mut leading_zeros: libc::c_int = stdc_leading_zeros_ull(\n            blocksize as libc::c_ulonglong,\n        ) as libc::c_int;\n        if (9223372036854775807 as libc::c_long as libc::c_ulonglong)\n            < (9223372036854775807 as libc::c_longlong as libc::c_ulonglong)\n                .wrapping_mul(2 as libc::c_ulonglong)\n                .wrapping_add(1 as libc::c_ulonglong) || leading_zeros != 0\n        {\n            let mut power: libc::c_ulonglong = (1 as libc::c_ulonglong)\n                << 64 as libc::c_int - leading_zeros;\n            if power <= 9223372036854775807 as libc::c_long as libc::c_ulonglong {\n                blocksize = power as idx_t;\n            }\n        }\n    }\n    return (if (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n        < 18446744073709551615 as libc::c_ulong\n    {\n        9223372036854775807 as libc::c_long as libc::c_ulong\n    } else {\n        18446744073709551615 as libc::c_ulong\n    })\n        .wrapping_div(2 as libc::c_int as libc::c_ulong)\n        .wrapping_add(1 as libc::c_int as libc::c_ulong) < blocksize as libc::c_ulong\n    {\n        (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        })\n            .wrapping_div(2 as libc::c_int as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    } else {\n        blocksize as libc::c_ulong\n    }) as idx_t;\n}\n#[inline]\nunsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}\n#[inline]\nunsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[inline]\nunsafe extern \"C\" fn xset_binary_mode_error() {}\n#[inline]\nunsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}\nstatic mut infile: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut input_desc: libc::c_int = 0;",
    "static mut line_buf: [libc::c_char; 20] = [\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    '0' as i32 as libc::c_char,\n    '\\t' as i32 as libc::c_char,\n    '\\0' as i32 as libc::c_char,\n];\nstatic mut line_num_print: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;\nstatic mut line_num_start: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;\nstatic mut line_num_end: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;\nstatic mut newlines2: libc::c_int = 0 as libc::c_int;\nstatic mut pending_cr: bool = 0 as libc::c_int != 0;\n#[no_mangle]\npub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [FILE]...\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Concatenate FILE(s) to standard output.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_stdin_note();\n        fputs_unlocked(\n            gettext(\n                b\"\\n  -A, --show-all           equivalent to -vET\\n  -b, --number-nonblank    number nonempty output lines, overrides -n\\n  -e                       equivalent to -vE\\n  -E, --show-ends          display $ at end of each line\\n  -n, --number             number all output lines\\n  -s, --squeeze-blank      suppress repeated empty output lines\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -t                       equivalent to -vT\\n  -T, --show-tabs          display TAB characters as ^I\\n  -u                       (ignored)\\n  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        printf(\n            gettext(\n                b\"\\nExamples:\\n  %s f - g  Output f's contents, then standard input, then g's contents.\\n  %s        Copy standard input to standard output.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            program_name,\n            program_name,\n        );\n        emit_ancillary_info(b\"cat\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}\nunsafe extern \"C\" fn next_line_num() {\n    let mut endp: *mut libc::c_char = line_num_end;\n    loop {\n        let fresh0 = *endp;\n        *endp = *endp + 1;\n        if (fresh0 as libc::c_int) < '9' as i32 {\n            return;\n        }\n        let fresh1 = endp;\n        endp = endp.offset(-1);\n        *fresh1 = '0' as i32 as libc::c_char;\n        if !(endp >= line_num_start) {\n            break;\n        }\n    }\n    if line_num_start > line_buf.as_mut_ptr() {\n        line_num_start = line_num_start.offset(-1);\n        *line_num_start = '1' as i32 as libc::c_char;\n    } else {\n        *line_buf.as_mut_ptr() = '>' as i32 as libc::c_char;\n    }\n    if line_num_start < line_num_print {\n        line_num_print = line_num_print.offset(-1);\n        line_num_print;\n    }\n}\nunsafe extern \"C\" fn simple_cat(mut buf: *mut libc::c_char, mut bufsize: idx_t) -> bool {\n    loop {\n        let mut n_read: size_t = safe_read(\n            input_desc,\n            buf as *mut libc::c_void,\n            bufsize as size_t,\n        );\n        if n_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n        if n_read == 0 as libc::c_int as libc::c_ulong {\n            return 1 as libc::c_int != 0;\n        }\n        if full_write(1 as libc::c_int, buf as *const libc::c_void, n_read) != n_read {\n            write_error();\n        }\n    };\n}\n#[inline]\nunsafe extern \"C\" fn write_pending(\n    mut outbuf: *mut libc::c_char,\n    mut bpout: *mut *mut libc::c_char,\n) {\n    let mut n_write: idx_t = (*bpout).offset_from(outbuf) as libc::c_long;\n    if (0 as libc::c_int as libc::c_long) < n_write {\n        if full_write(1 as libc::c_int, outbuf as *const libc::c_void, n_write as size_t)\n            != n_write as libc::c_ulong\n        {\n            write_error();\n        }\n        *bpout = outbuf;\n    }\n}",
    "unsafe extern \"C\" fn cat(\n    mut inbuf: *mut libc::c_char,\n    mut insize: idx_t,\n    mut outbuf: *mut libc::c_char,\n    mut outsize: idx_t,\n    mut show_nonprinting: bool,\n    mut show_tabs: bool,\n    mut number: bool,\n    mut number_nonblank: bool,\n    mut show_ends: bool,\n    mut squeeze_blank: bool,\n) -> bool {\n    let mut ch: libc::c_uchar = 0;\n    let mut newlines: libc::c_int = newlines2;\n    let mut use_fionread: bool = 1 as libc::c_int != 0;\n    let mut eob: *mut libc::c_char = inbuf;\n    let mut bpin: *mut libc::c_char = eob.offset(1 as libc::c_int as isize);\n    let mut bpout: *mut libc::c_char = outbuf;\n    loop {\n        let mut current_block_52: u64;\n        loop {\n            if outbuf.offset(outsize as isize) <= bpout {\n                let mut wp: *mut libc::c_char = outbuf;\n                let mut remaining_bytes: idx_t = 0;\n                loop {\n                    if full_write(\n                        1 as libc::c_int,\n                        wp as *const libc::c_void,\n                        outsize as size_t,\n                    ) != outsize as libc::c_ulong\n                    {\n                        write_error();\n                    }\n                    wp = wp.offset(outsize as isize);\n                    remaining_bytes = bpout.offset_from(wp) as libc::c_long;\n                    if !(outsize <= remaining_bytes) {\n                        break;\n                    }\n                }\n                memmove(\n                    outbuf as *mut libc::c_void,\n                    wp as *const libc::c_void,\n                    remaining_bytes as libc::c_ulong,\n                );\n                bpout = outbuf.offset(remaining_bytes as isize);\n            }\n            if bpin > eob {\n                let mut input_pending: bool = 0 as libc::c_int != 0;\n                let mut n_to_read: libc::c_int = 0 as libc::c_int;\n                if use_fionread as libc::c_int != 0\n                    && ioctl(\n                        input_desc,\n                        0x541b as libc::c_int as libc::c_ulong,\n                        &mut n_to_read as *mut libc::c_int,\n                    ) < 0 as libc::c_int\n                {\n                    if *__errno_location() == 95 as libc::c_int\n                        || *__errno_location() == 25 as libc::c_int\n                        || *__errno_location() == 22 as libc::c_int\n                        || *__errno_location() == 19 as libc::c_int\n                        || *__errno_location() == 38 as libc::c_int\n                    {\n                        use_fionread = 0 as libc::c_int != 0;\n                    } else {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot do ioctl on %s\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, infile),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    gettext(\n                                        b\"cannot do ioctl on %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quotearg_style(shell_escape_always_quoting_style, infile),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    gettext(\n                                        b\"cannot do ioctl on %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quotearg_style(shell_escape_always_quoting_style, infile),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                        newlines2 = newlines;\n                        return 0 as libc::c_int != 0;\n                    }\n                }\n                if n_to_read != 0 as libc::c_int {\n                    input_pending = 1 as libc::c_int != 0;\n                }\n                if !input_pending {\n                    write_pending(outbuf, &mut bpout);\n                }\n                let mut n_read: size_t = safe_read(\n                    input_desc,\n                    inbuf as *mut libc::c_void,\n                    insize as size_t,\n                );\n                if n_read == -(1 as libc::c_int) as size_t {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    write_pending(outbuf, &mut bpout);\n                    newlines2 = newlines;\n                    return 0 as libc::c_int != 0;\n                }\n                if n_read == 0 as libc::c_int as libc::c_ulong {\n                    write_pending(outbuf, &mut bpout);\n                    newlines2 = newlines;\n                    return 1 as libc::c_int != 0;\n                }\n                bpin = inbuf;\n                eob = bpin.offset(n_read as isize);\n                *eob = '\\n' as i32 as libc::c_char;\n                current_block_52 = 6476622998065200121;\n            } else {\n                newlines += 1;\n                if newlines > 0 as libc::c_int {\n                    if newlines >= 2 as libc::c_int {\n                        newlines = 2 as libc::c_int;\n                        if squeeze_blank {\n                            let fresh2 = bpin;\n                            bpin = bpin.offset(1);\n                            ch = *fresh2 as libc::c_uchar;\n                            current_block_52 = 16658872821858055392;\n                        } else {\n                            current_block_52 = 15597372965620363352;\n                        }\n                    } else {\n                        current_block_52 = 15597372965620363352;\n                    }\n                    match current_block_52 {\n                        16658872821858055392 => {}\n                        _ => {\n                            if number as libc::c_int != 0 && !number_nonblank {\n                                next_line_num();\n                                bpout = stpcpy(bpout, line_num_print);\n                            }\n                            current_block_52 = 17784502470059252271;\n                        }\n                    }\n                } else {\n                    current_block_52 = 17784502470059252271;\n                }\n                match current_block_52 {\n                    16658872821858055392 => {}\n                    _ => {\n                        if show_ends {\n                            if pending_cr {\n                                let fresh3 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh3 = '^' as i32 as libc::c_char;\n                                let fresh4 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh4 = 'M' as i32 as libc::c_char;\n                                pending_cr = 0 as libc::c_int != 0;\n                            }\n                            let fresh5 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh5 = '$' as i32 as libc::c_char;\n                        }\n                        let fresh6 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh6 = '\\n' as i32 as libc::c_char;\n                        current_block_52 = 6476622998065200121;\n                    }\n                }\n            }\n            match current_block_52 {\n                6476622998065200121 => {\n                    let fresh7 = bpin;\n                    bpin = bpin.offset(1);\n                    ch = *fresh7 as libc::c_uchar;\n                }\n                _ => {}\n            }\n            if !(ch as libc::c_int == '\\n' as i32) {\n                break;\n            }\n        }\n        if pending_cr {\n            let fresh8 = bpout;\n            bpout = bpout.offset(1);\n            *fresh8 = '\\r' as i32 as libc::c_char;\n            pending_cr = 0 as libc::c_int != 0;\n        }\n        if newlines >= 0 as libc::c_int && number as libc::c_int != 0 {\n            next_line_num();\n            bpout = stpcpy(bpout, line_num_print);\n        }\n        if show_nonprinting {\n            loop {\n                if ch as libc::c_int >= 32 as libc::c_int {\n                    if (ch as libc::c_int) < 127 as libc::c_int {\n                        let fresh9 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh9 = ch as libc::c_char;\n                    } else if ch as libc::c_int == 127 as libc::c_int {\n                        let fresh10 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh10 = '^' as i32 as libc::c_char;\n                        let fresh11 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh11 = '?' as i32 as libc::c_char;\n                    } else {\n                        let fresh12 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh12 = 'M' as i32 as libc::c_char;\n                        let fresh13 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh13 = '-' as i32 as libc::c_char;\n                        if ch as libc::c_int >= 128 as libc::c_int + 32 as libc::c_int {\n                            if (ch as libc::c_int)\n                                < 128 as libc::c_int + 127 as libc::c_int\n                            {\n                                let fresh14 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh14 = (ch as libc::c_int - 128 as libc::c_int)\n                                    as libc::c_char;\n                            } else {\n                                let fresh15 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh15 = '^' as i32 as libc::c_char;\n                                let fresh16 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh16 = '?' as i32 as libc::c_char;\n                            }\n                        } else {\n                            let fresh17 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh17 = '^' as i32 as libc::c_char;\n                            let fresh18 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh18 = (ch as libc::c_int - 128 as libc::c_int\n                                + 64 as libc::c_int) as libc::c_char;\n                        }\n                    }\n                } else if ch as libc::c_int == '\\t' as i32 && !show_tabs {\n                    let fresh19 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh19 = '\\t' as i32 as libc::c_char;\n                } else if ch as libc::c_int == '\\n' as i32 {\n                    newlines = -(1 as libc::c_int);\n                    break;\n                } else {\n                    let fresh20 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh20 = '^' as i32 as libc::c_char;\n                    let fresh21 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh21 = (ch as libc::c_int + 64 as libc::c_int) as libc::c_char;\n                }\n                let fresh22 = bpin;\n                bpin = bpin.offset(1);\n                ch = *fresh22 as libc::c_uchar;\n            }\n        } else {\n            loop {\n                if ch as libc::c_int == '\\t' as i32 && show_tabs as libc::c_int != 0 {\n                    let fresh23 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh23 = '^' as i32 as libc::c_char;\n                    let fresh24 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh24 = (ch as libc::c_int + 64 as libc::c_int) as libc::c_char;\n                } else if ch as libc::c_int != '\\n' as i32 {\n                    if ch as libc::c_int == '\\r' as i32\n                        && *bpin as libc::c_int == '\\n' as i32\n                        && show_ends as libc::c_int != 0\n                    {\n                        if bpin == eob {\n                            pending_cr = 1 as libc::c_int != 0;\n                        } else {\n                            let fresh25 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh25 = '^' as i32 as libc::c_char;\n                            let fresh26 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh26 = 'M' as i32 as libc::c_char;\n                        }\n                    } else {\n                        let fresh27 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh27 = ch as libc::c_char;\n                    }\n                } else {\n                    newlines = -(1 as libc::c_int);\n                    break;\n                }\n                let fresh28 = bpin;\n                bpin = bpin.offset(1);\n                ch = *fresh28 as libc::c_uchar;\n            }\n        }\n    };\n}\nunsafe extern \"C\" fn copy_cat() -> libc::c_int {\n    let mut copy_max: ssize_t = (((if (9223372036854775807 as libc::c_long\n        as libc::c_ulong) < 18446744073709551615 as libc::c_ulong\n    {\n        9223372036854775807 as libc::c_long as libc::c_ulong\n    } else {\n        18446744073709551615 as libc::c_ulong\n    }) >> 30 as libc::c_int) << 30 as libc::c_int) as ssize_t;\n    let mut some_copied: bool = 0 as libc::c_int != 0;\n    loop {\n        match rpl_copy_file_range(\n            input_desc,\n            0 as *mut off_t,\n            1 as libc::c_int,\n            0 as *mut off_t,\n            copy_max as size_t,\n            0 as libc::c_int as libc::c_uint,\n        ) {\n            0 => return some_copied as libc::c_int,\n            -1 => {\n                if *__errno_location() == 38 as libc::c_int\n                    || is_ENOTSUP(*__errno_location()) as libc::c_int != 0\n                    || *__errno_location() == 22 as libc::c_int\n                    || *__errno_location() == 9 as libc::c_int\n                    || *__errno_location() == 18 as libc::c_int\n                    || *__errno_location() == 26 as libc::c_int\n                    || *__errno_location() == 1 as libc::c_int\n                {\n                    return 0 as libc::c_int;\n                }\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                return -(1 as libc::c_int);\n            }\n            _ => {}\n        }\n        some_copied = 1 as libc::c_int != 0;\n    };\n}",
    "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut insize: idx_t = 0;\n    let mut inbuf: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut current_block: u64;\n    let mut have_read_stdin: bool = 0 as libc::c_int != 0;\n    let mut stat_buf: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut number: bool = 0 as libc::c_int != 0;\n    let mut number_nonblank: bool = 0 as libc::c_int != 0;\n    let mut squeeze_blank: bool = 0 as libc::c_int != 0;\n    let mut show_ends: bool = 0 as libc::c_int != 0;\n    let mut show_nonprinting: bool = 0 as libc::c_int != 0;\n    let mut show_tabs: bool = 0 as libc::c_int != 0;\n    let mut file_open_mode: libc::c_int = 0 as libc::c_int;\n    static mut long_options: [option; 10] = [\n        {\n            let mut init = option {\n                name: b\"number-nonblank\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'b' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"number\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'n' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"squeeze-blank\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 's' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-nonprinting\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'v' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-ends\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'E' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-tabs\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'T' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-all\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'A' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"help\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: GETOPT_HELP_CHAR as libc::c_int,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"version\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: GETOPT_VERSION_CHAR as libc::c_int,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: 0 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 0 as libc::c_int,\n            };\n            init\n        },\n    ];\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    let mut c: libc::c_int = 0;\n    loop {\n        c = getopt_long(\n            argc,\n            argv,\n            b\"benstuvAET\\0\" as *const u8 as *const libc::c_char,\n            long_options.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if !(c != -(1 as libc::c_int)) {\n            break;\n        }\n        match c {\n            98 => {\n                number = 1 as libc::c_int != 0;\n                number_nonblank = 1 as libc::c_int != 0;\n            }\n            101 => {\n                show_ends = 1 as libc::c_int != 0;\n                show_nonprinting = 1 as libc::c_int != 0;\n            }\n            110 => {\n                number = 1 as libc::c_int != 0;\n            }\n            115 => {\n                squeeze_blank = 1 as libc::c_int != 0;\n            }\n            116 => {\n                show_tabs = 1 as libc::c_int != 0;\n                show_nonprinting = 1 as libc::c_int != 0;\n            }\n            117 => {}\n            118 => {\n                show_nonprinting = 1 as libc::c_int != 0;\n            }\n            65 => {\n                show_nonprinting = 1 as libc::c_int != 0;\n                show_ends = 1 as libc::c_int != 0;\n                show_tabs = 1 as libc::c_int != 0;\n            }\n            69 => {\n                show_ends = 1 as libc::c_int != 0;\n            }\n            84 => {\n                show_tabs = 1 as libc::c_int != 0;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n            }\n            -3 => {\n                version_etc(\n                    stdout,\n                    b\"cat\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Torbjorn Granlund\\0\" as *const u8 as *const libc::c_char,\n                        b\"Torbj\\xC3\\xB6rn Granlund\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                        b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);\n            }\n            _ => {\n                usage(1 as libc::c_int);\n            }\n        }\n    }\n    if fstat(1 as libc::c_int, &mut stat_buf) < 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    let mut outsize: idx_t = io_blksize(&mut stat_buf);\n    let mut out_dev: dev_t = stat_buf.st_dev;\n    let mut out_ino: ino_t = stat_buf.st_ino;\n    let mut out_flags: libc::c_int = -(2 as libc::c_int);\n    let mut out_isreg: bool = (stat_buf.st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint) as libc::c_int != 0 as libc::c_int;\n    if !(number as libc::c_int != 0 || show_ends as libc::c_int != 0\n        || squeeze_blank as libc::c_int != 0)\n    {\n        file_open_mode |= 0 as libc::c_int;\n        xset_binary_mode(1 as libc::c_int, 0 as libc::c_int);\n    }\n    infile = b\"-\\0\" as *const u8 as *const libc::c_char;\n    let mut argind: libc::c_int = optind;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut page_size: idx_t = getpagesize() as idx_t;\n    loop {\n        if argind < argc {\n            infile = *argv.offset(argind as isize);\n        }\n        let mut reading_stdin: bool = strcmp(\n            infile,\n            b\"-\\0\" as *const u8 as *const libc::c_char,\n        ) == 0 as libc::c_int;\n        if reading_stdin {\n            have_read_stdin = 1 as libc::c_int != 0;\n            input_desc = 0 as libc::c_int;\n            if file_open_mode & 0 as libc::c_int != 0 {\n                xset_binary_mode(0 as libc::c_int, 0 as libc::c_int);\n            }\n            current_block = 13321564401369230990;\n        } else {\n            input_desc = open(infile, file_open_mode);\n            if input_desc < 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                ok = 0 as libc::c_int != 0;\n                current_block = 4567019141635105728;\n            } else {\n                current_block = 13321564401369230990;\n            }\n        }\n        match current_block {\n            13321564401369230990 => {\n                if fstat(input_desc, &mut stat_buf) < 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                } else {\n                    insize = io_blksize(&mut stat_buf);\n                    fdadvise(\n                        input_desc,\n                        0 as libc::c_int as off_t,\n                        0 as libc::c_int as off_t,\n                        FADVISE_SEQUENTIAL,\n                    );\n                    if stat_buf.st_dev == out_dev && stat_buf.st_ino == out_ino {\n                        if out_flags < -(1 as libc::c_int) {\n                            out_flags = rpl_fcntl(1 as libc::c_int, 3 as libc::c_int);\n                        }\n                        let mut exhausting: bool = 0 as libc::c_int <= out_flags\n                            && out_flags & 0o2000 as libc::c_int != 0;\n                        if !exhausting {\n                            let mut in_pos: off_t = lseek(\n                                input_desc,\n                                0 as libc::c_int as __off_t,\n                                1 as libc::c_int,\n                            );\n                            if 0 as libc::c_int as libc::c_long <= in_pos {\n                                exhausting = in_pos\n                                    < lseek(\n                                        1 as libc::c_int,\n                                        0 as libc::c_int as __off_t,\n                                        1 as libc::c_int,\n                                    );\n                            }\n                        }\n                        if exhausting {\n                            if 0 != 0 {\n                                error(\n                                    0 as libc::c_int,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"%s: input file is output file\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        infile,\n                                    ),\n                                );\n                                if 0 as libc::c_int != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                            } else {\n                                ({\n                                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                                    error(\n                                        __errstatus,\n                                        0 as libc::c_int,\n                                        gettext(\n                                            b\"%s: input file is output file\\0\" as *const u8\n                                                as *const libc::c_char,\n                                        ),\n                                        quotearg_n_style_colon(\n                                            0 as libc::c_int,\n                                            shell_escape_quoting_style,\n                                            infile,\n                                        ),\n                                    );\n                                    if __errstatus != 0 as libc::c_int {\n                                        unreachable!();\n                                    } else {};\n                                    \n                                });\n                                ({\n                                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                                    error(\n                                        __errstatus,\n                                        0 as libc::c_int,\n                                        gettext(\n                                            b\"%s: input file is output file\\0\" as *const u8\n                                                as *const libc::c_char,\n                                        ),\n                                        quotearg_n_style_colon(\n                                            0 as libc::c_int,\n                                            shell_escape_quoting_style,\n                                            infile,\n                                        ),\n                                    );\n                                    if __errstatus != 0 as libc::c_int {\n                                        unreachable!();\n                                    } else {};\n                                    \n                                });\n                            };\n                            ok = 0 as libc::c_int != 0;\n                            current_block = 7239751344758050955;\n                        } else {\n                            current_block = 5372832139739605200;\n                        }\n                    } else {\n                        current_block = 5372832139739605200;\n                    }\n                    match current_block {\n                        7239751344758050955 => {}\n                        _ => {\n                            inbuf = 0 as *mut libc::c_char;\n                            if !(number as libc::c_int != 0\n                                || show_ends as libc::c_int != 0\n                                || show_nonprinting as libc::c_int != 0\n                                || show_tabs as libc::c_int != 0\n                                || squeeze_blank as libc::c_int != 0)\n                            {\n                                let mut copy_cat_status: libc::c_int = if out_isreg\n                                    as libc::c_int != 0\n                                    && stat_buf.st_mode\n                                        & 0o170000 as libc::c_int as libc::c_uint\n                                        == 0o100000 as libc::c_int as libc::c_uint\n                                {\n                                    copy_cat()",
    "                                } else {\n                                    0 as libc::c_int\n                                };\n                                if copy_cat_status != 0 as libc::c_int {\n                                    inbuf = 0 as *mut libc::c_char;\n                                    ok = (ok as libc::c_int\n                                        & ((0 as libc::c_int) < copy_cat_status) as libc::c_int) != 0;\n                                } else {\n                                    insize = if insize > outsize { insize } else { outsize };\n                                    inbuf = xalignalloc(page_size, insize) as *mut libc::c_char;\n                                    ok = (ok as libc::c_int\n                                        & simple_cat(inbuf, insize) as libc::c_int) != 0;\n                                }\n                            } else {\n                                inbuf = xalignalloc(\n                                    page_size,\n                                    insize + 1 as libc::c_int as libc::c_long,\n                                ) as *mut libc::c_char;\n                                let mut bufsize: idx_t = 0;\n                                if (if (0 as libc::c_int as idx_t)\n                                    < -(1 as libc::c_int) as idx_t\n                                    && ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        insize\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    && ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        4 as libc::c_int\n                                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                                    && (if (4 as libc::c_int) < 0 as libc::c_int {\n                                        if insize < 0 as libc::c_int as libc::c_long {\n                                            if ((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    -(1 as libc::c_int) as idx_t\n                                                }) + 4 as libc::c_int as libc::c_long\n                                            }) - 1 as libc::c_int as libc::c_long)\n                                                < 0 as libc::c_int as libc::c_long\n                                            {\n                                                (insize\n                                                    < -(1 as libc::c_int) as idx_t\n                                                        / 4 as libc::c_int as libc::c_long) as libc::c_int\n                                            } else {\n                                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    4 as libc::c_int\n                                                }) - 1 as libc::c_int) < 0 as libc::c_int\n                                                {\n                                                    !(((((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) + 1 as libc::c_int)\n                                                        << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                        - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) + 0 as libc::c_int\n                                                }) < 0 as libc::c_int\n                                                {\n                                                    ((4 as libc::c_int)\n                                                        < -(if ((if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int\n                                                        } else {\n                                                            4 as libc::c_int\n                                                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                                                        {\n                                                            ((((if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) + 1 as libc::c_int)\n                                                                << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                                - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) - 1 as libc::c_int\n                                                        })) as libc::c_int\n                                                } else {\n                                                    ((0 as libc::c_int) < 4 as libc::c_int) as libc::c_int\n                                                }) != 0\n                                                {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) as libc::c_long + -(1 as libc::c_int) as idx_t\n                                                        >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                                } else {\n                                                    -(1 as libc::c_int) as idx_t\n                                                        / -(4 as libc::c_int) as libc::c_long\n                                                }) <= -(1 as libc::c_int) as libc::c_long - insize)\n                                                    as libc::c_int\n                                            }\n                                        } else {\n                                            if (if (if ((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    4 as libc::c_int\n                                                }) as libc::c_long + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long)\n                                                < 0 as libc::c_int as libc::c_long\n                                            {\n                                                !(((((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                }) + 1 as libc::c_int as libc::c_long)\n                                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                    - 1 as libc::c_int as libc::c_long)\n                                                    * 2 as libc::c_int as libc::c_long\n                                                    + 1 as libc::c_int as libc::c_long)\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                }) + 0 as libc::c_int as libc::c_long\n                                            }) < 0 as libc::c_int as libc::c_long\n                                            {\n                                                (((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    4 as libc::c_int\n                                                }) as libc::c_long + 0 as libc::c_int as idx_t)\n                                                    < -(if ((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int\n                                                        } else {\n                                                            4 as libc::c_int\n                                                        }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                    }) - 1 as libc::c_int as libc::c_long)\n                                                        < 0 as libc::c_int as libc::c_long\n                                                    {\n                                                        ((((if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                        }) + 1 as libc::c_int as libc::c_long)\n                                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                            - 1 as libc::c_int as libc::c_long)\n                                                            * 2 as libc::c_int as libc::c_long\n                                                            + 1 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                        }) - 1 as libc::c_int as libc::c_long\n                                                    })) as libc::c_int\n                                            } else {\n                                                ((0 as libc::c_int as libc::c_long)\n                                                    < (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) as libc::c_long + 0 as libc::c_int as idx_t)\n                                                    as libc::c_int\n                                            }) != 0 && 4 as libc::c_int == -(1 as libc::c_int)\n                                            {\n                                                if ((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    insize\n                                                }) - 1 as libc::c_int as libc::c_long)\n                                                    < 0 as libc::c_int as libc::c_long\n                                                {\n                                                    ((0 as libc::c_int as libc::c_long)\n                                                        < insize + 0 as libc::c_int as idx_t) as libc::c_int\n                                                } else {\n                                                    ((0 as libc::c_int as libc::c_long) < insize\n                                                        && (-(1 as libc::c_int) as libc::c_long\n                                                            - 0 as libc::c_int as idx_t)\n                                                            < insize - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                                }\n                                            } else {\n                                                ((0 as libc::c_int as idx_t\n                                                    / 4 as libc::c_int as libc::c_long) < insize) as libc::c_int\n                                            }\n                                        }\n                                    } else {\n                                        if 4 as libc::c_int == 0 as libc::c_int {\n                                            0 as libc::c_int\n                                        } else {\n                                            if insize < 0 as libc::c_int as libc::c_long {\n                                                if (if (if ((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        insize\n                                                    }) + 0 as libc::c_int as idx_t\n                                                }) - 1 as libc::c_int as libc::c_long)\n                                                    < 0 as libc::c_int as libc::c_long\n                                                {\n                                                    !(((((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            insize\n                                                        }) + 0 as libc::c_int as idx_t\n                                                    }) + 1 as libc::c_int as libc::c_long)\n                                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                        - 1 as libc::c_int as libc::c_long)\n                                                        * 2 as libc::c_int as libc::c_long\n                                                        + 1 as libc::c_int as libc::c_long)\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            insize\n                                                        }) + 0 as libc::c_int as idx_t\n                                                    }) + 0 as libc::c_int as libc::c_long\n                                                }) < 0 as libc::c_int as libc::c_long\n                                                {\n                                                    (((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        insize\n                                                    }) + 0 as libc::c_int as idx_t)\n                                                        < -(if ((if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int as libc::c_long\n                                                            } else {\n                                                                insize\n                                                            }) + 0 as libc::c_int as idx_t\n                                                        }) - 1 as libc::c_int as libc::c_long)\n                                                            < 0 as libc::c_int as libc::c_long\n                                                        {\n                                                            ((((if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int as libc::c_long\n                                                            } else {\n                                                                (if 1 as libc::c_int != 0 {\n                                                                    0 as libc::c_int as libc::c_long\n                                                                } else {\n                                                                    insize\n                                                                }) + 0 as libc::c_int as idx_t\n                                                            }) + 1 as libc::c_int as libc::c_long)\n                                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                                - 1 as libc::c_int as libc::c_long)\n                                                                * 2 as libc::c_int as libc::c_long\n                                                                + 1 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int as libc::c_long\n                                                            } else {\n                                                                (if 1 as libc::c_int != 0 {\n                                                                    0 as libc::c_int as libc::c_long\n                                                                } else {\n                                                                    insize\n                                                                }) + 0 as libc::c_int as idx_t\n                                                            }) - 1 as libc::c_int as libc::c_long\n                                                        })) as libc::c_int\n                                                } else {\n                                                    ((0 as libc::c_int as libc::c_long)\n                                                        < (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            insize\n                                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                                }) != 0 && insize == -(1 as libc::c_int) as libc::c_long\n                                                {\n                                                    if ((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                                                    {\n                                                        ((0 as libc::c_int as libc::c_long)\n                                                            < 4 as libc::c_int as libc::c_long\n                                                                + 0 as libc::c_int as idx_t) as libc::c_int\n                                                    } else {\n                                                        ((-(1 as libc::c_int) as libc::c_long\n                                                            - 0 as libc::c_int as idx_t)\n                                                            < (4 as libc::c_int - 1 as libc::c_int) as libc::c_long)\n                                                            as libc::c_int\n                                                    }\n                                                } else {\n                                                    (0 as libc::c_int as idx_t / insize\n                                                        < 4 as libc::c_int as libc::c_long) as libc::c_int\n                                                }\n                                            } else {\n                                                ((-(1 as libc::c_int) as idx_t\n                                                    / 4 as libc::c_int as libc::c_long) < insize) as libc::c_int\n                                            }\n                                        }\n                                    }) != 0\n                                {\n                                    let (fresh33, _fresh34) = insize\n                                        .overflowing_mul((4 as libc::c_int).into());\n                                    *(&mut bufsize as *mut idx_t) = fresh33;\n                                    1 as libc::c_int\n                                } else {\n                                    let (fresh35, fresh36) = insize\n                                        .overflowing_mul((4 as libc::c_int).into());\n                                    *(&mut bufsize as *mut idx_t) = fresh35;\n                                    fresh36 as libc::c_int\n                                }) != 0\n                                    || {\n                                        let (fresh37, fresh38) = bufsize.overflowing_add(outsize);\n                                        *(&mut bufsize as *mut idx_t) = fresh37;\n                                        fresh38 as libc::c_int != 0\n                                    }\n                                    || {\n                                        let (fresh39, fresh40) = bufsize\n                                            .overflowing_add((20 as libc::c_int - 1 as libc::c_int).into());\n                                        *(&mut bufsize as *mut idx_t) = fresh39;\n                                        fresh40 as libc::c_int != 0\n                                    }\n                                {\n                                    xalloc_die();\n                                }\n                                let mut outbuf: *mut libc::c_char = xalignalloc(\n                                    page_size,\n                                    bufsize,\n                                ) as *mut libc::c_char;\n                                ok = (ok as libc::c_int\n                                    & cat(\n                                        inbuf,\n                                        insize,\n                                        outbuf,\n                                        outsize,\n                                        show_nonprinting,\n                                        show_tabs,\n                                        number,\n                                        number_nonblank,\n                                        show_ends,\n                                        squeeze_blank,\n                                    ) as libc::c_int) != 0;\n                                alignfree(outbuf as *mut libc::c_void);\n                            }\n                            alignfree(inbuf as *mut libc::c_void);\n                        }\n                    }\n                }\n                if !reading_stdin && close(input_desc) < 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                }\n            }\n            _ => {}\n        }\n        argind += 1;\n        if !(argind < argc) {\n            break;\n        }\n    }\n    if pending_cr {\n        if full_write(\n            1 as libc::c_int,\n            b\"\\r\\0\" as *const u8 as *const libc::c_char as *const libc::c_void,\n            1 as libc::c_int as size_t,\n        ) != 1 as libc::c_int as libc::c_ulong\n        {\n            write_error();\n        }\n    }\n    if have_read_stdin as libc::c_int != 0 && close(0 as libc::c_int) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"closing standard input\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"closing standard input\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"closing standard input\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};",
    "                \n            });\n        };\n    }\n    return if ok as libc::c_int != 0 { 0 as libc::c_int } else { 1 as libc::c_int };\n}\npub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}\nunsafe extern \"C\" fn run_static_initializers() {\n    line_num_print = line_buf\n        .as_mut_ptr()\n        .offset(20 as libc::c_int as isize)\n        .offset(-(8 as libc::c_int as isize));\n    line_num_start = line_buf\n        .as_mut_ptr()\n        .offset(20 as libc::c_int as isize)\n        .offset(-(3 as libc::c_int as isize));\n    line_num_end = line_buf\n        .as_mut_ptr()\n        .offset(20 as libc::c_int as isize)\n        .offset(-(3 as libc::c_int as isize));\n}\n#[used]\n#[cfg_attr(target_os = \"linux\", link_section = \".init_array\")]\n#[cfg_attr(target_os = \"windows\", link_section = \".CRT$XIB\")]\n#[cfg_attr(target_os = \"macos\", link_section = \"__DATA,__mod_init_func\")]\nstatic INIT_ARRAY: [unsafe extern \"C\" fn(); 1] = [run_static_initializers];",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    fn copy_file_range(\n        __infd: libc::c_int,\n        __pinoff: *mut __off64_t,\n        __outfd: libc::c_int,\n        __poutoff: *mut __off64_t,\n        __length: size_t,\n        __flags: libc::c_uint,\n    ) -> ssize_t;\n    fn __errno_location() -> *mut libc::c_int;\n    fn uname(__name: *mut utsname) -> libc::c_int;\n}\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __ssize_t = libc::c_long;\npub type ssize_t = __ssize_t;\npub type size_t = libc::c_ulong;\npub type off_t = __off_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct utsname {\n    pub sysname: [libc::c_char; 65],\n    pub nodename: [libc::c_char; 65],\n    pub release: [libc::c_char; 65],\n    pub version: [libc::c_char; 65],\n    pub machine: [libc::c_char; 65],\n    pub domainname: [libc::c_char; 65],\n}\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_copy_file_range(\n    mut infd: libc::c_int,\n    mut pinoff: *mut off_t,\n    mut outfd: libc::c_int,\n    mut poutoff: *mut off_t,\n    mut length: size_t,\n    mut flags: libc::c_uint,\n) -> ssize_t {\n    static mut ok: libc::c_schar = 0;\n    if ok == 0 {\n        let mut name: utsname = utsname {\n            sysname: [0; 65],\n            nodename: [0; 65],\n            release: [0; 65],\n            version: [0; 65],\n            machine: [0; 65],\n            domainname: [0; 65],\n        };\n        uname(&mut name);\n        let mut p: *mut libc::c_char = (name.release).as_mut_ptr();\n        ok = (if *p.offset(1 as libc::c_int as isize) as libc::c_int != '.' as i32\n            || ('5' as i32) < *p.offset(0 as libc::c_int as isize) as libc::c_int\n            || *p.offset(0 as libc::c_int as isize) as libc::c_int == '5' as i32\n                && (*p.offset(3 as libc::c_int as isize) as libc::c_int != '.' as i32\n                    || ('2' as i32)\n                        < *p.offset(2 as libc::c_int as isize) as libc::c_int)\n        {\n            1 as libc::c_int\n        } else {\n            -(1 as libc::c_int)\n        }) as libc::c_schar;\n    }\n    if (0 as libc::c_int) < ok as libc::c_int {\n        return copy_file_range(infd, pinoff, outfd, poutoff, length, flags);\n    }\n    *__errno_location() = 38 as libc::c_int;\n    return -(1 as libc::c_int) as ssize_t;\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "use ::libc;\n#[inline]\nunsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn posix_fadvise(\n        __fd: libc::c_int,\n        __offset: off_t,\n        __len: off_t,\n        __advise: libc::c_int,\n    ) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type fadvice_t = libc::c_uint;\npub const FADVISE_RANDOM: fadvice_t = 1;\npub const FADVISE_WILLNEED: fadvice_t = 3;\npub const FADVISE_DONTNEED: fadvice_t = 4;\npub const FADVISE_NOREUSE: fadvice_t = 5;\npub const FADVISE_SEQUENTIAL: fadvice_t = 2;\npub const FADVISE_NORMAL: fadvice_t = 0;\n#[no_mangle]\npub unsafe extern \"C\" fn fdadvise(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut len: off_t,\n    mut advice: fadvice_t,\n) {\n    posix_fadvise(fd, offset, len, advice as libc::c_int);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn fadvise(mut fp: *mut FILE, mut advice: fadvice_t) {\n    if !fp.is_null() {\n        fdadvise(\n            fileno(fp),\n            0 as libc::c_int as off_t,\n            0 as libc::c_int as off_t,\n            advice,\n        );\n    }\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "use ::libc;\nextern \"C\" {\n    fn fcntl(__fd: libc::c_int, __cmd: libc::c_int, _: ...) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fcntl(\n    mut fd: libc::c_int,\n    mut action: libc::c_int,\n    mut args: ...\n) -> libc::c_int {\n    let mut arg: ::core::ffi::VaListImpl;\n    let mut result: libc::c_int = -(1 as libc::c_int);\n    arg = args.clone();\n    match action {\n        0 => {\n            let mut target: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD(fd, target);\n        }\n        1030 => {\n            let mut target_0: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD_CLOEXEC(fd, target_0);\n        }\n        _ => {\n            let mut current_block_7: u64;\n            match action {\n                1 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                3 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                1025 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                9 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                1032 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                1034 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                11 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                1033 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                0 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                1030 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                1026 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                2 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                4 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                8 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1031 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1024 | 10 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {\n                    let mut p: *mut libc::c_void = arg.arg::<*mut libc::c_void>();\n                    result = fcntl(fd, action, p);\n                    current_block_7 = 7175849428784450219;\n                }\n            }\n            match current_block_7 {\n                4046302689674688614 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                8871774344836507656 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                12013198723313890981 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6453289516101043606 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                5351856672558463576 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                13722137258147953758 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                9332010126091029806 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                12766345184754617216 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                17966572639739034653 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6940526744265269810 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                15280576717888187136 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                7022052692272556539 => {\n                    result = fcntl(fd, action);\n                }\n                14034191772621753005 => {\n                    let mut x: libc::c_int = arg.arg::<libc::c_int>();\n                    result = fcntl(fd, action, x);\n                }\n                _ => {}\n            }\n        }\n    }\n    return result;\n}\nunsafe extern \"C\" fn rpl_fcntl_DUPFD(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    result = fcntl(fd, 0 as libc::c_int, target);\n    return result;\n}\nstatic mut have_dupfd_cloexec: libc::c_int = 0;\nunsafe extern \"C\" fn rpl_fcntl_DUPFD_CLOEXEC(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    if 0 as libc::c_int <= have_dupfd_cloexec {\n        result = fcntl(fd, 1030 as libc::c_int, target);\n        if 0 as libc::c_int <= result || *__errno_location() != 22 as libc::c_int {\n            have_dupfd_cloexec = 1 as libc::c_int;\n        } else {\n            result = rpl_fcntl_DUPFD(fd, target);\n            if result >= 0 as libc::c_int {\n                have_dupfd_cloexec = -(1 as libc::c_int);\n            }\n        }\n    } else {\n        result = rpl_fcntl_DUPFD(fd, target);\n    }\n    if 0 as libc::c_int <= result && have_dupfd_cloexec == -(1 as libc::c_int) {\n        let mut flags: libc::c_int = fcntl(result, 1 as libc::c_int);\n        if flags < 0 as libc::c_int\n            || fcntl(result, 2 as libc::c_int, flags | 1 as libc::c_int)\n                == -(1 as libc::c_int)\n        {\n            let mut saved_errno: libc::c_int = *__errno_location();\n            close(result);\n            *__errno_location() = saved_errno;\n            result = -(1 as libc::c_int);\n        }\n    }\n    return result;\n}\nunsafe extern \"C\" fn run_static_initializers() {\n    have_dupfd_cloexec = if 0 as libc::c_int != 0 {\n        -(1 as libc::c_int)\n    } else {\n        0 as libc::c_int\n    };\n}\n#[used]\n#[cfg_attr(target_os = \"linux\", link_section = \".init_array\")]\n#[cfg_attr(target_os = \"windows\", link_section = \".CRT$XIB\")]\n#[cfg_attr(target_os = \"macos\", link_section = \"__DATA,__mod_init_func\")]\nstatic INIT_ARRAY: [unsafe extern \"C\" fn(); 1] = [run_static_initializers];",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nunsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __fpurge(__fp: *mut FILE);\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn fpurge(mut fp: *mut FILE) -> libc::c_int {\n    __fpurge(fp);\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn safe_write(fd: libc::c_int, buf: *const libc::c_void, count: size_t) -> size_t;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn full_write(\n    mut fd: libc::c_int,\n    mut buf: *const libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    let mut total: size_t = 0 as libc::c_int as size_t;\n    let mut ptr: *const libc::c_char = buf as *const libc::c_char;\n    while count > 0 as libc::c_int as libc::c_ulong {\n        let mut n_rw: size_t = safe_write(fd, ptr as *const libc::c_void, count);\n        if n_rw == -(1 as libc::c_int) as size_t {\n            break;\n        }\n        if n_rw == 0 as libc::c_int as libc::c_ulong {\n            *__errno_location() = 28 as libc::c_int;\n            break;\n        } else {\n            total = (total as libc::c_ulong).wrapping_add(n_rw) as size_t as size_t;\n            ptr = ptr.offset(n_rw as isize);\n            count = (count as libc::c_ulong).wrapping_sub(n_rw) as size_t as size_t;\n        }\n    }\n    return total;\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "use ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;\npub const _NL_WAM_STR: C2RustUnnamed = 131162;\npub const _NL_WMON_12: C2RustUnnamed = 131161;\npub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nunsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}\nunsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}\nunsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;",
    "                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};",
    "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "use ::libc;\nextern \"C\" {\n    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type ssize_t = __ssize_t;\npub type __ssize_t = libc::c_long;\npub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn safe_read(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = read(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn write(__fd: libc::c_int, __buf: *const libc::c_void, __n: size_t) -> ssize_t;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type ssize_t = __ssize_t;\npub type __ssize_t = libc::c_long;\npub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn safe_write(\n    mut fd: libc::c_int,\n    mut buf: *const libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = write(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_clz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_clzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_ctz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_ctzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_ctzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "use ::libc;\n#[inline]\nunsafe extern \"C\" fn __gl_stdbit_clz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[inline]\nunsafe extern \"C\" fn __gl_stdbit_clzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[inline]\nunsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn stdc_leading_zeros_ui(mut n: libc::c_uint) -> libc::c_uint {\n    return __gl_stdbit_clz(n) as libc::c_uint;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn stdc_leading_zeros_uc(mut n: libc::c_uchar) -> libc::c_uint {\n    return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)\n        .wrapping_sub(\n            (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(\n                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n                        .wrapping_sub(\n                            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong,\n                        ),\n                ),\n        ) as libc::c_uint;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn stdc_leading_zeros_us(mut n: libc::c_ushort) -> libc::c_uint {\n    return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)\n        .wrapping_sub(\n            (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(\n                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n                        .wrapping_sub(\n                            ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong,\n                        ),\n                ),\n        ) as libc::c_uint;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn stdc_leading_zeros_ul(mut n: libc::c_ulong) -> libc::c_uint {\n    return __gl_stdbit_clzl(n) as libc::c_uint;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn stdc_leading_zeros_ull(\n    mut n: libc::c_ulonglong,\n) -> libc::c_uint {\n    return __gl_stdbit_clzll(n) as libc::c_uint;\n}",
    "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
    "use ::libc;\nextern \"C\" {\n    fn aligned_alloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn xalloc_die();\n}\npub type size_t = libc::c_ulong;\npub type ptrdiff_t = libc::c_long;\npub type idx_t = ptrdiff_t;\n#[inline]\nunsafe extern \"C\" fn alignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    if (-(1 as libc::c_int) as size_t) < alignment as libc::c_ulong {\n        alignment = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    if (-(1 as libc::c_int) as size_t) < size as libc::c_ulong {\n        size = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    return aligned_alloc(alignment as libc::c_ulong, size as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xalignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    let mut p: *mut libc::c_void = alignalloc(alignment, size);\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "use ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn xset_binary_mode_error() {}\n#[inline]\nunsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[inline]\nunsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nunsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[inline]\nunsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[inline]\nunsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[cold]\n#[inline]\nunsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}\n#[inline]\nunsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\nunsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t",
    "                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}"
  ],
  "head": [
    "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
    "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(label_break_value)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod binary_io;\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod close_stream;\npub mod closeout;\npub mod exitfail;\npub mod fclose;\npub mod fflush;\npub mod fpurge;\npub mod fseeko;\npub mod full_read;\npub mod hard_locale;\npub mod ialloc;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod offtostr;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod safe_read;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod umaxtostr;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalloc_die;\npub mod xbinary_io;\npub mod xdectoumax;\npub mod xmalloc;\npub mod xstrtoumax;\n}\n// mod src",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "use ::libc;\n#[inline]\nunsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nunsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __fpurge(__fp: *mut FILE);\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn fpurge(mut fp: *mut FILE) -> libc::c_int {\n    __fpurge(fp);\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "use ::libc;\nextern \"C\" {\n    fn safe_read(fd: libc::c_int, buf: *mut libc::c_void, count: size_t) -> size_t;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn full_read(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    let mut total: size_t = 0 as libc::c_int as size_t;\n    let mut ptr: *mut libc::c_char = buf as *mut libc::c_char;\n    while count > 0 as libc::c_int as libc::c_ulong {\n        let mut n_rw: size_t = safe_read(fd, ptr as *mut libc::c_void, count);\n        if n_rw == -(1 as libc::c_int) as size_t {\n            break;\n        }\n        if n_rw == 0 as libc::c_int as libc::c_ulong {\n            *__errno_location() = 0 as libc::c_int;\n            break;\n        } else {\n            total = (total as libc::c_ulong).wrapping_add(n_rw) as size_t as size_t;\n            ptr = ptr.offset(n_rw as isize);\n            count = (count as libc::c_ulong).wrapping_sub(n_rw) as size_t as size_t;\n        }\n    }\n    return total;\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut, unused_imports)]\n#![feature(extern_types, label_break_value)]\nuse ::rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn fwrite_unlocked(\n        __ptr: *const libc::c_void,\n        __size: size_t,\n        __n: size_t,\n        __stream: *mut FILE,\n    ) -> size_t;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn fpurge(gl_stream: *mut FILE) -> libc::c_int;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    static mut optarg: *mut libc::c_char;\n    static mut optind: libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memchr(\n        _: *const libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn rawmemchr(__s: *const libc::c_void, __c: libc::c_int) -> *mut libc::c_void;\n    fn memrchr(\n        __s: *const libc::c_void,\n        __c: libc::c_int,\n        __n: size_t,\n    ) -> *mut libc::c_void;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn free(_: *mut libc::c_void);\n    fn __errno_location() -> *mut libc::c_int;\n    fn quotearg_n_style_colon(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn umaxtostr(_: uintmax_t, _: *mut libc::c_char) -> *mut libc::c_char;\n    fn offtostr(_: off_t, _: *mut libc::c_char) -> *mut libc::c_char;\n    static mut Version: *const libc::c_char;\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn xmalloc(s: size_t) -> *mut libc::c_void;\n    fn xreallocarray(p: *mut libc::c_void, n: size_t, s: size_t) -> *mut libc::c_void;\n    fn xnmalloc(n: size_t, s: size_t) -> *mut libc::c_void;\n    fn close_stdout();\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    static mut program_name: *const libc::c_char;\n    fn set_program_name(argv0: *const libc::c_char);\n    fn exit(_: libc::c_int) -> !;\n    fn atexit(__func: Option::<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn full_read(fd: libc::c_int, buf: *mut libc::c_void, count: size_t) -> size_t;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn safe_read(fd: libc::c_int, buf: *mut libc::c_void, count: size_t) -> size_t;\n    fn xdectoumax(\n        n_str: *const libc::c_char,\n        min: uintmax_t,\n        max: uintmax_t,\n        suffixes: *const libc::c_char,\n        err: *const libc::c_char,\n        err_exit: libc::c_int,\n    ) -> uintmax_t;\n}\npub type size_t = libc::c_ulong;\npub type __uintmax_t = libc::c_ulong;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\npub type uintmax_t = __uintmax_t;\npub type C2RustUnnamed = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type header_mode = libc::c_uint;\npub const never: header_mode = 2;\npub const always: header_mode = 1;\npub const multiple_files: header_mode = 0;\npub type Copy_fd_status = libc::c_uint;\npub const COPY_FD_UNEXPECTED_EOF: Copy_fd_status = 2;\npub const COPY_FD_READ_ERROR: Copy_fd_status = 1;\npub const COPY_FD_OK: Copy_fd_status = 0;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const PRESUME_INPUT_PIPE_OPTION: C2RustUnnamed_0 = 256;\npub type LBUFFER = linebuffer;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct linebuffer {\n    pub buffer: [libc::c_char; 8193],\n    pub nbytes: size_t,\n    pub nlines: size_t,\n    pub next: *mut linebuffer,\n}\n#[inline]\nunsafe extern \"C\" fn usable_st_size(mut sb: *const stat) -> bool {\n    return (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        || (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o120000 as libc::c_int as libc::c_uint\n        || ((*sb).st_mode).wrapping_sub((*sb).st_mode) != 0 || 0 as libc::c_int != 0;\n}\n#[inline]\nunsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}\n#[inline]\nunsafe extern \"C\" fn xnrealloc(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return xreallocarray(p, n, s);\n}\n#[inline]\nunsafe extern \"C\" fn emit_stdin_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nWith no FILE, or when FILE is -, read standard input.\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        stdout,\n    );\n}\n#[inline]\nunsafe extern \"C\" fn emit_mandatory_arg_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nMandatory arguments to long options are mandatory for short options too.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}\n#[inline]\nunsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}\n#[inline]\nunsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[inline]\nunsafe extern \"C\" fn xset_binary_mode_error() {}\n#[inline]\nunsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}\nstatic mut presume_input_pipe: bool = false;\nstatic mut print_headers: bool = false;\nstatic mut line_end: libc::c_char = 0;\nstatic mut have_read_stdin: bool = false;",
    "static mut long_options: [option; 10] = [\n    {\n        let mut init = option {\n            name: b\"bytes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'c' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"lines\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'n' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"-presume-input-pipe\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: PRESUME_INPUT_PIPE_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"quiet\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'q' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"silent\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'q' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"verbose\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'v' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"zero-terminated\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'z' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];\n#[no_mangle]\npub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [FILE]...\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        printf(\n            gettext(\n                b\"Print the first %d lines of each FILE to standard output.\\nWith more than one FILE, precede each with a header giving the file name.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            10 as libc::c_int,\n        );\n        emit_stdin_note();\n        emit_mandatory_arg_note();\n        printf(\n            gettext(\n                b\"  -c, --bytes=[-]NUM       print the first NUM bytes of each file;\\n                             with the leading '-', print all but the last\\n                             NUM bytes of each file\\n  -n, --lines=[-]NUM       print the first NUM lines instead of the first %d;\\n                             with the leading '-', print all but the last\\n                             NUM lines of each file\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            10 as libc::c_int,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -q, --quiet, --silent    never print headers giving file names\\n  -v, --verbose            always print headers giving file names\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -z, --zero-terminated    line delimiter is NUL, not newline\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"\\nNUM may have a multiplier suffix:\\nb 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\\nGB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_ancillary_info(b\"head\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}\nunsafe extern \"C\" fn diagnose_copy_fd_failure(\n    mut err: Copy_fd_status,\n    mut filename: *const libc::c_char,\n) {\n    match err as libc::c_uint {\n        1 => {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        2 => {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: file has shrunk too much\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: file has shrunk too much\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: file has shrunk too much\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _ => {\n            __assert_fail(\n                b\"0\\0\" as *const u8 as *const libc::c_char,\n                b\"head.c\\0\" as *const u8 as *const libc::c_char,\n                162 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 65],\n                    &[libc::c_char; 65],\n                >(b\"void diagnose_copy_fd_failure(enum Copy_fd_status, const char *)\\0\"))\n                    .as_ptr(),\n            );\n            'c_7166: {\n                __assert_fail(\n                    b\"0\\0\" as *const u8 as *const libc::c_char,\n                    b\"head.c\\0\" as *const u8 as *const libc::c_char,\n                    162 as libc::c_int as libc::c_uint,\n                    (*::core::mem::transmute::<\n                        &[u8; 65],\n                        &[libc::c_char; 65],\n                    >(\n                        b\"void diagnose_copy_fd_failure(enum Copy_fd_status, const char *)\\0\",\n                    ))\n                        .as_ptr(),\n                );\n            };\n        }\n    };\n}\nunsafe extern \"C\" fn write_header(mut filename: *const libc::c_char) {\n    static mut first_file: bool = 1 as libc::c_int != 0;\n    printf(\n        b\"%s==> %s <==\\n\\0\" as *const u8 as *const libc::c_char,\n        if first_file as libc::c_int != 0 {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\n\\0\" as *const u8 as *const libc::c_char\n        },\n        filename,\n    );\n    first_file = 0 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn xwrite_stdout(\n    mut buffer: *const libc::c_char,\n    mut n_bytes: size_t,\n) {\n    if n_bytes > 0 as libc::c_int as libc::c_ulong\n        && fwrite_unlocked(\n            buffer as *const libc::c_void,\n            1 as libc::c_int as size_t,\n            n_bytes,\n            stdout,\n        ) < n_bytes\n    {\n        clearerr_unlocked(stdout);\n        fpurge(stdout);\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n}\nunsafe extern \"C\" fn copy_fd(\n    mut src_fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n) -> Copy_fd_status {\n    let mut buf: [libc::c_char; 8192] = [0; 8192];\n    let buf_size: size_t = ::core::mem::size_of::<[libc::c_char; 8192]>()\n        as libc::c_ulong;\n    while (0 as libc::c_int as libc::c_ulong) < n_bytes {\n        let mut n_to_read: size_t = if buf_size < n_bytes { buf_size } else { n_bytes };\n        let mut n_read: size_t = safe_read(\n            src_fd,\n            buf.as_mut_ptr() as *mut libc::c_void,\n            n_to_read,\n        );\n        if n_read == -(1 as libc::c_int) as size_t {\n            return COPY_FD_READ_ERROR;\n        }\n        n_bytes = (n_bytes as libc::c_ulong).wrapping_sub(n_read) as uintmax_t\n            as uintmax_t;\n        if n_read == 0 as libc::c_int as libc::c_ulong\n            && n_bytes != 0 as libc::c_int as libc::c_ulong\n        {\n            return COPY_FD_UNEXPECTED_EOF;\n        }\n        xwrite_stdout(buf.as_mut_ptr(), n_read);\n    }\n    return COPY_FD_OK;\n}\nunsafe extern \"C\" fn elseek(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n    mut filename: *const libc::c_char,\n) -> off_t {\n    let mut new_offset: off_t = lseek(fd, offset, whence);\n    let mut buf: [libc::c_char; 21] = [0; 21];\n    if new_offset < 0 as libc::c_int as libc::c_long {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    if whence == 0 as libc::c_int {\n                        b\"%s: cannot seek to offset %s\\0\" as *const u8\n                            as *const libc::c_char\n                    } else {\n                        b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                            as *const libc::c_char\n                    },\n                ),\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    filename,\n                ),\n                offtostr(offset, buf.as_mut_ptr()),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        if whence == 0 as libc::c_int {\n                            b\"%s: cannot seek to offset %s\\0\" as *const u8\n                                as *const libc::c_char\n                        } else {\n                            b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                                as *const libc::c_char\n                        },\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                    offtostr(offset, buf.as_mut_ptr()),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        if whence == 0 as libc::c_int {\n                            b\"%s: cannot seek to offset %s\\0\" as *const u8\n                                as *const libc::c_char\n                        } else {\n                            b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                                as *const libc::c_char\n                        },\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                    offtostr(offset, buf.as_mut_ptr()),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    return new_offset;\n}",
    "unsafe extern \"C\" fn elide_tail_bytes_pipe(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_elide_0: uintmax_t,\n    mut current_pos: off_t,\n) -> bool {\n    let mut n_elide: size_t = n_elide_0;\n    let mut desired_pos: uintmax_t = current_pos as uintmax_t;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    if (18446744073709551615 as libc::c_ulong)\n        < n_elide_0.wrapping_add(8192 as libc::c_int as libc::c_ulong)\n    {\n        let mut umax_buf: [libc::c_char; 21] = [0; 21];\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s: number of bytes is too large\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                umaxtostr(n_elide_0, umax_buf.as_mut_ptr()),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s: number of bytes is too large\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    umaxtostr(n_elide_0, umax_buf.as_mut_ptr()),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s: number of bytes is too large\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    umaxtostr(n_elide_0, umax_buf.as_mut_ptr()),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if n_elide <= (1024 as libc::c_int * 1024 as libc::c_int) as libc::c_ulong {\n        let mut first: bool = 1 as libc::c_int != 0;\n        let mut eof: bool = 0 as libc::c_int != 0;\n        let mut n_to_read: size_t = (8192 as libc::c_int as libc::c_ulong)\n            .wrapping_add(n_elide);\n        let mut i: bool = false;\n        let mut b: [*mut libc::c_char; 2] = [0 as *mut libc::c_char; 2];\n        b[0 as libc::c_int\n            as usize] = xnmalloc(2 as libc::c_int as size_t, n_to_read)\n            as *mut libc::c_char;\n        b[1 as libc::c_int\n            as usize] = (b[0 as libc::c_int as usize]).offset(n_to_read as isize);\n        i = 0 as libc::c_int != 0;\n        while !eof {\n            let mut n_read: size_t = full_read(\n                fd,\n                b[i as usize] as *mut libc::c_void,\n                n_to_read,\n            );\n            let mut delta: size_t = 0 as libc::c_int as size_t;\n            if n_read < n_to_read {\n                if *__errno_location() != 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, filename),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, filename),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, filename),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                    break;\n                } else {\n                    if n_read <= n_elide {\n                        if !first {\n                            delta = n_elide.wrapping_sub(n_read);\n                        }\n                    }\n                    eof = 1 as libc::c_int != 0;\n                }\n            }\n            if !first {\n                desired_pos = (desired_pos as libc::c_ulong)\n                    .wrapping_add(n_elide.wrapping_sub(delta)) as uintmax_t as uintmax_t;\n                xwrite_stdout(\n                    (b[!i as libc::c_int as usize]).offset(8192 as libc::c_int as isize),\n                    n_elide.wrapping_sub(delta),\n                );\n            }\n            first = 0 as libc::c_int != 0;\n            if n_elide < n_read {\n                desired_pos = (desired_pos as libc::c_ulong)\n                    .wrapping_add(n_read.wrapping_sub(n_elide)) as uintmax_t\n                    as uintmax_t;\n                xwrite_stdout(b[i as usize], n_read.wrapping_sub(n_elide));\n            }\n            i = !i;\n        }\n        free(b[0 as libc::c_int as usize] as *mut libc::c_void);\n    } else {\n        let mut current_block_69: u64;\n        let mut eof_0: bool = 0 as libc::c_int != 0;\n        let mut n_read_0: size_t = 0;\n        let mut buffered_enough: bool = false;\n        let mut i_0: size_t = 0;\n        let mut i_next: size_t = 0;\n        let mut b_0: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n        let mut rem: size_t = (8192 as libc::c_int as libc::c_ulong)\n            .wrapping_sub(n_elide.wrapping_rem(8192 as libc::c_int as libc::c_ulong));\n        let mut n_elide_round: size_t = n_elide.wrapping_add(rem);\n        let mut n_bufs: size_t = n_elide_round\n            .wrapping_div(8192 as libc::c_int as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong);\n        let mut n_alloc: size_t = 0 as libc::c_int as size_t;\n        let mut n_array_alloc: size_t = 0 as libc::c_int as size_t;\n        buffered_enough = 0 as libc::c_int != 0;\n        i_0 = 0 as libc::c_int as size_t;\n        i_next = 1 as libc::c_int as size_t;\n        loop {\n            if eof_0 {\n                current_block_69 = 10753070352654377903;\n                break;\n            }\n            if n_array_alloc == i_0 {\n                if n_array_alloc == 0 as libc::c_int as libc::c_ulong {\n                    n_array_alloc = if n_bufs < 16 as libc::c_int as libc::c_ulong {\n                        n_bufs\n                    } else {\n                        16 as libc::c_int as libc::c_ulong\n                    };\n                } else if n_array_alloc\n                    <= n_bufs.wrapping_div(2 as libc::c_int as libc::c_ulong)\n                {\n                    n_array_alloc = (n_array_alloc as libc::c_ulong)\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong) as size_t\n                        as size_t;\n                } else {\n                    n_array_alloc = n_bufs;\n                }\n                b_0 = xnrealloc(\n                    b_0 as *mut libc::c_void,\n                    n_array_alloc,\n                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,\n                ) as *mut *mut libc::c_char;\n            }\n            if !buffered_enough {\n                let ref mut fresh0 = *b_0.offset(i_0 as isize);\n                *fresh0 = xmalloc(8192 as libc::c_int as size_t) as *mut libc::c_char;\n                n_alloc = i_0.wrapping_add(1 as libc::c_int as libc::c_ulong);\n            }\n            n_read_0 = full_read(\n                fd,\n                *b_0.offset(i_0 as isize) as *mut libc::c_void,\n                8192 as libc::c_int as size_t,\n            );\n            if n_read_0 < 8192 as libc::c_int as libc::c_ulong {\n                if *__errno_location() != 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, filename),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, filename),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, filename),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                    current_block_69 = 10121186216371937393;\n                    break;\n                } else {\n                    eof_0 = 1 as libc::c_int != 0;\n                }\n            }\n            if i_0.wrapping_add(1 as libc::c_int as libc::c_ulong) == n_bufs {\n                buffered_enough = 1 as libc::c_int != 0;\n            }\n            if buffered_enough {\n                desired_pos = (desired_pos as libc::c_ulong).wrapping_add(n_read_0)\n                    as uintmax_t as uintmax_t;\n                xwrite_stdout(*b_0.offset(i_next as isize), n_read_0);\n            }\n            i_0 = i_next;\n            i_next = i_next\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                .wrapping_rem(n_bufs);\n        }\n        match current_block_69 {\n            10753070352654377903 => {\n                if rem != 0 {\n                    if buffered_enough {\n                        let mut n_bytes_left_in_b_i: size_t = (8192 as libc::c_int\n                            as libc::c_ulong)\n                            .wrapping_sub(n_read_0);\n                        desired_pos = (desired_pos as libc::c_ulong).wrapping_add(rem)\n                            as uintmax_t as uintmax_t;\n                        if rem < n_bytes_left_in_b_i {\n                            xwrite_stdout(\n                                (*b_0.offset(i_0 as isize)).offset(n_read_0 as isize),\n                                rem,\n                            );\n                        } else {\n                            xwrite_stdout(\n                                (*b_0.offset(i_0 as isize)).offset(n_read_0 as isize),\n                                n_bytes_left_in_b_i,\n                            );\n                            xwrite_stdout(\n                                *b_0.offset(i_next as isize),\n                                rem.wrapping_sub(n_bytes_left_in_b_i),\n                            );\n                        }\n                    } else if i_0.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        == n_bufs\n                    {\n                        let mut y: size_t = (8192 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(rem);\n                        let mut x: size_t = n_read_0.wrapping_sub(y);\n                        desired_pos = (desired_pos as libc::c_ulong).wrapping_add(x)\n                            as uintmax_t as uintmax_t;\n                        xwrite_stdout(*b_0.offset(i_next as isize), x);\n                    }\n                }\n            }\n            _ => {}\n        }\n        i_0 = 0 as libc::c_int as size_t;\n        while i_0 < n_alloc {\n            free(*b_0.offset(i_0 as isize) as *mut libc::c_void);\n            i_0 = i_0.wrapping_add(1);\n            i_0;\n        }\n        free(b_0 as *mut libc::c_void);\n    }\n    if 0 as libc::c_int as libc::c_long <= current_pos\n        && elseek(fd, desired_pos as off_t, 0 as libc::c_int, filename)\n            < 0 as libc::c_int as libc::c_long\n    {\n        ok = 0 as libc::c_int != 0;\n    }\n    return ok;\n}\nunsafe extern \"C\" fn elide_tail_bytes_file(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_elide: uintmax_t,\n    mut st: *const stat,\n    mut current_pos: off_t,\n) -> bool {\n    let mut size: off_t = (*st).st_size;\n    if presume_input_pipe as libc::c_int != 0\n        || current_pos < 0 as libc::c_int as libc::c_long\n        || size\n            <= (if (0 as libc::c_int) < (*st).st_blksize\n                && (*st).st_blksize as libc::c_ulong\n                    <= (-(1 as libc::c_int) as size_t)\n                        .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            {\n                (*st).st_blksize\n            } else {\n                512 as libc::c_int\n            }) as libc::c_long\n    {\n        return elide_tail_bytes_pipe(filename, fd, n_elide, current_pos)\n    } else {\n        let mut diff: off_t = size - current_pos;\n        let mut bytes_remaining: off_t = if diff < 0 as libc::c_int as libc::c_long {\n            0 as libc::c_int as libc::c_long\n        } else {\n            diff\n        };\n        if bytes_remaining as libc::c_ulong <= n_elide {\n            return 1 as libc::c_int != 0;\n        }\n        let mut err: Copy_fd_status = copy_fd(\n            fd,\n            (bytes_remaining as libc::c_ulong).wrapping_sub(n_elide),\n        );\n        if err as libc::c_uint == COPY_FD_OK as libc::c_int as libc::c_uint {\n            return 1 as libc::c_int != 0;\n        }\n        diagnose_copy_fd_failure(err, filename);\n        return 0 as libc::c_int != 0;\n    };\n}",
    "unsafe extern \"C\" fn elide_tail_lines_pipe(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_elide: uintmax_t,\n    mut current_pos: off_t,\n) -> bool {\n    let mut desired_pos: uintmax_t = current_pos as uintmax_t;\n    let mut first: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut last: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut tmp: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut total_lines: size_t = 0 as libc::c_int as size_t;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut n_read: size_t = 0;\n    last = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong) as *mut LBUFFER;\n    first = last;\n    (*first).nlines = 0 as libc::c_int as size_t;\n    (*first).nbytes = (*first).nlines;\n    (*first).next = 0 as *mut linebuffer;\n    tmp = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong) as *mut LBUFFER;\n    loop {\n        n_read = safe_read(\n            fd,\n            ((*tmp).buffer).as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if n_read == 0 as libc::c_int as libc::c_ulong\n            || n_read == -(1 as libc::c_int) as size_t\n        {\n            break;\n        }\n        if n_elide == 0 {\n            desired_pos = (desired_pos as libc::c_ulong).wrapping_add(n_read)\n                as uintmax_t as uintmax_t;\n            xwrite_stdout(((*tmp).buffer).as_mut_ptr(), n_read);\n        } else {\n            (*tmp).nbytes = n_read;\n            (*tmp).nlines = 0 as libc::c_int as size_t;\n            (*tmp).next = 0 as *mut linebuffer;\n            let mut buffer_end: *mut libc::c_char = ((*tmp).buffer)\n                .as_mut_ptr()\n                .offset(n_read as isize);\n            *buffer_end = line_end;\n            let mut p: *const libc::c_char = ((*tmp).buffer).as_mut_ptr();\n            loop {\n                p = rawmemchr(p as *const libc::c_void, line_end as libc::c_int)\n                    as *const libc::c_char;\n                if !(p < buffer_end as *const libc::c_char) {\n                    break;\n                }\n                p = p.offset(1);\n                p;\n                (*tmp).nlines = ((*tmp).nlines).wrapping_add(1);\n                (*tmp).nlines;\n            }\n            total_lines = (total_lines as libc::c_ulong).wrapping_add((*tmp).nlines)\n                as size_t as size_t;\n            if ((*tmp).nbytes).wrapping_add((*last).nbytes)\n                < 8192 as libc::c_int as libc::c_ulong\n            {\n                memcpy(\n                    &mut *((*last).buffer).as_mut_ptr().offset((*last).nbytes as isize)\n                        as *mut libc::c_char as *mut libc::c_void,\n                    ((*tmp).buffer).as_mut_ptr() as *const libc::c_void,\n                    (*tmp).nbytes,\n                );\n                (*last)\n                    .nbytes = ((*last).nbytes as libc::c_ulong)\n                    .wrapping_add((*tmp).nbytes) as size_t as size_t;\n                (*last)\n                    .nlines = ((*last).nlines as libc::c_ulong)\n                    .wrapping_add((*tmp).nlines) as size_t as size_t;\n            } else {\n                (*last).next = tmp;\n                last = (*last).next;\n                if n_elide < total_lines.wrapping_sub((*first).nlines) {\n                    desired_pos = (desired_pos as libc::c_ulong)\n                        .wrapping_add((*first).nbytes) as uintmax_t as uintmax_t;\n                    xwrite_stdout(((*first).buffer).as_mut_ptr(), (*first).nbytes);\n                    tmp = first;\n                    total_lines = (total_lines as libc::c_ulong)\n                        .wrapping_sub((*first).nlines) as size_t as size_t;\n                    first = (*first).next;\n                } else {\n                    tmp = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong)\n                        as *mut LBUFFER;\n                }\n            }\n        }\n    }\n    free(tmp as *mut libc::c_void);\n    if n_read == -(1 as libc::c_int) as size_t {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        ok = 0 as libc::c_int != 0;\n    } else {\n        if (*last).nbytes != 0\n            && (*last)\n                .buffer[((*last).nbytes).wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                as usize] as libc::c_int != line_end as libc::c_int\n        {\n            (*last).nlines = ((*last).nlines).wrapping_add(1);\n            (*last).nlines;\n            total_lines = total_lines.wrapping_add(1);\n            total_lines;\n        }\n        tmp = first;\n        while n_elide < total_lines.wrapping_sub((*tmp).nlines) {\n            desired_pos = (desired_pos as libc::c_ulong).wrapping_add((*tmp).nbytes)\n                as uintmax_t as uintmax_t;\n            xwrite_stdout(((*tmp).buffer).as_mut_ptr(), (*tmp).nbytes);\n            total_lines = (total_lines as libc::c_ulong).wrapping_sub((*tmp).nlines)\n                as size_t as size_t;\n            tmp = (*tmp).next;\n        }\n        if n_elide < total_lines {\n            let mut n: size_t = total_lines.wrapping_sub(n_elide);\n            let mut buffer_end_0: *const libc::c_char = ((*tmp).buffer)\n                .as_mut_ptr()\n                .offset((*tmp).nbytes as isize);\n            let mut p_0: *const libc::c_char = ((*tmp).buffer).as_mut_ptr();\n            while n != 0\n                && {\n                    p_0 = memchr(\n                        p_0 as *const libc::c_void,\n                        line_end as libc::c_int,\n                        buffer_end_0.offset_from(p_0) as libc::c_long as libc::c_ulong,\n                    ) as *const libc::c_char;\n                    !p_0.is_null()\n                }\n            {\n                p_0 = p_0.offset(1);\n                p_0;\n                (*tmp).nlines = ((*tmp).nlines).wrapping_add(1);\n                (*tmp).nlines;\n                n = n.wrapping_sub(1);\n                n;\n            }\n            desired_pos = (desired_pos as libc::c_ulong)\n                .wrapping_add(\n                    p_0.offset_from(((*tmp).buffer).as_mut_ptr()) as libc::c_long\n                        as libc::c_ulong,\n                ) as uintmax_t as uintmax_t;\n            xwrite_stdout(\n                ((*tmp).buffer).as_mut_ptr(),\n                p_0.offset_from(((*tmp).buffer).as_mut_ptr()) as libc::c_long as size_t,\n            );\n        }\n    }\n    while !first.is_null() {\n        tmp = (*first).next;\n        free(first as *mut libc::c_void);\n        first = tmp;\n    }\n    if 0 as libc::c_int as libc::c_long <= current_pos\n        && elseek(fd, desired_pos as off_t, 0 as libc::c_int, filename)\n            < 0 as libc::c_int as libc::c_long\n    {\n        ok = 0 as libc::c_int != 0;\n    }\n    return ok;\n}\nunsafe extern \"C\" fn elide_tail_lines_seekable(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_lines: uintmax_t,\n    mut start_pos: off_t,\n    mut size: off_t,\n) -> bool {\n    let mut buffer: [libc::c_char; 8192] = [0; 8192];\n    let mut bytes_read: size_t = 0;\n    let mut pos: off_t = size;\n    bytes_read = ((pos - start_pos) % 8192 as libc::c_int as libc::c_long) as size_t;\n    if bytes_read == 0 as libc::c_int as libc::c_ulong {\n        bytes_read = 8192 as libc::c_int as size_t;\n    }\n    pos = (pos as libc::c_ulong).wrapping_sub(bytes_read) as off_t as off_t;\n    if elseek(fd, pos, 0 as libc::c_int, pretty_filename)\n        < 0 as libc::c_int as libc::c_long\n    {\n        return 0 as libc::c_int != 0;\n    }\n    bytes_read = safe_read(fd, buffer.as_mut_ptr() as *mut libc::c_void, bytes_read);\n    if bytes_read == -(1 as libc::c_int) as size_t {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    let all_lines: bool = n_lines == 0;\n    if n_lines != 0 && bytes_read != 0\n        && buffer[bytes_read.wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize]\n            as libc::c_int != line_end as libc::c_int\n    {\n        n_lines = n_lines.wrapping_sub(1);\n        n_lines;\n    }\n    loop {\n        let mut n: size_t = bytes_read;\n        while n != 0 {\n            if all_lines {\n                n = (n as libc::c_ulong).wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    as size_t as size_t;\n            } else {\n                let mut nl: *const libc::c_char = 0 as *const libc::c_char;\n                nl = memrchr(\n                    buffer.as_mut_ptr() as *const libc::c_void,\n                    line_end as libc::c_int,\n                    n,\n                ) as *const libc::c_char;\n                if nl.is_null() {\n                    break;\n                }\n                n = nl.offset_from(buffer.as_mut_ptr()) as libc::c_long as size_t;\n            }\n            let fresh1 = n_lines;\n            n_lines = n_lines.wrapping_sub(1);\n            if fresh1 == 0 as libc::c_int as libc::c_ulong {\n                if start_pos < pos {\n                    let mut err: Copy_fd_status = COPY_FD_OK;\n                    if elseek(fd, start_pos, 0 as libc::c_int, pretty_filename)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        return 0 as libc::c_int != 0;\n                    }\n                    err = copy_fd(fd, (pos - start_pos) as uintmax_t);\n                    if err as libc::c_uint != COPY_FD_OK as libc::c_int as libc::c_uint {\n                        diagnose_copy_fd_failure(err, pretty_filename);\n                        return 0 as libc::c_int != 0;\n                    }\n                }\n                xwrite_stdout(\n                    buffer.as_mut_ptr(),\n                    n.wrapping_add(1 as libc::c_int as libc::c_ulong),\n                );\n                return 0 as libc::c_int as libc::c_long\n                    <= elseek(\n                        fd,\n                        (pos as libc::c_ulong)\n                            .wrapping_add(n)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong) as off_t,\n                        0 as libc::c_int,\n                        pretty_filename,\n                    );\n            }\n        }\n        if pos == start_pos {\n            return 1 as libc::c_int != 0;\n        }\n        pos -= 8192 as libc::c_int as libc::c_long;\n        if elseek(fd, pos, 0 as libc::c_int, pretty_filename)\n            < 0 as libc::c_int as libc::c_long\n        {\n            return 0 as libc::c_int != 0;\n        }\n        bytes_read = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n        if bytes_read == 0 as libc::c_int as libc::c_ulong {\n            return 1 as libc::c_int != 0;\n        }\n    };\n}\nunsafe extern \"C\" fn elide_tail_lines_file(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_elide: uintmax_t,\n    mut st: *const stat,\n    mut current_pos: off_t,\n) -> bool {\n    let mut size: off_t = (*st).st_size;\n    if presume_input_pipe as libc::c_int != 0\n        || current_pos < 0 as libc::c_int as libc::c_long\n        || size\n            <= (if (0 as libc::c_int) < (*st).st_blksize\n                && (*st).st_blksize as libc::c_ulong\n                    <= (-(1 as libc::c_int) as size_t)\n                        .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            {\n                (*st).st_blksize\n            } else {\n                512 as libc::c_int\n            }) as libc::c_long\n    {\n        return elide_tail_lines_pipe(filename, fd, n_elide, current_pos)\n    } else {\n        return size <= current_pos\n            || elide_tail_lines_seekable(filename, fd, n_elide, current_pos, size)\n                as libc::c_int != 0\n    };\n}\nunsafe extern \"C\" fn head_bytes(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut bytes_to_write: uintmax_t,\n) -> bool {\n    let mut buffer: [libc::c_char; 8192] = [0; 8192];\n    let mut bytes_to_read: size_t = 8192 as libc::c_int as size_t;\n    while bytes_to_write != 0 {\n        let mut bytes_read: size_t = 0;\n        if bytes_to_write < bytes_to_read {\n            bytes_to_read = bytes_to_write;\n        }\n        bytes_read = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            bytes_to_read,\n        );\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n        if bytes_read == 0 as libc::c_int as libc::c_ulong {\n            break;\n        }\n        xwrite_stdout(buffer.as_mut_ptr(), bytes_read);\n        bytes_to_write = (bytes_to_write as libc::c_ulong).wrapping_sub(bytes_read)\n            as uintmax_t as uintmax_t;\n    }\n    return 1 as libc::c_int != 0;\n}",
    "unsafe extern \"C\" fn head_lines(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut lines_to_write: uintmax_t,\n) -> bool {\n    let mut buffer: [libc::c_char; 8192] = [0; 8192];\n    while lines_to_write != 0 {\n        let mut bytes_read: size_t = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        let mut bytes_to_write: size_t = 0 as libc::c_int as size_t;\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n        if bytes_read == 0 as libc::c_int as libc::c_ulong {\n            break;\n        }\n        while bytes_to_write < bytes_read {\n            let fresh2 = bytes_to_write;\n            bytes_to_write = bytes_to_write.wrapping_add(1);\n            if !(buffer[fresh2 as usize] as libc::c_int == line_end as libc::c_int\n                && {\n                    lines_to_write = lines_to_write.wrapping_sub(1);\n                    lines_to_write == 0 as libc::c_int as libc::c_ulong\n                })\n            {\n                continue;\n            }\n            let mut n_bytes_past_EOL: off_t = bytes_read.wrapping_sub(bytes_to_write)\n                as off_t;\n            if lseek(fd, -n_bytes_past_EOL, 1 as libc::c_int)\n                < 0 as libc::c_int as libc::c_long\n            {\n                let mut st: stat = stat {\n                    st_dev: 0,\n                    st_ino: 0,\n                    st_mode: 0,\n                    st_nlink: 0,\n                    st_uid: 0,\n                    st_gid: 0,\n                    st_rdev: 0,\n                    __pad1: 0,\n                    st_size: 0,\n                    st_blksize: 0,\n                    __pad2: 0,\n                    st_blocks: 0,\n                    st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    __glibc_reserved: [0; 2],\n                };\n                if fstat(fd, &mut st) != 0 as libc::c_int\n                    || st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                        == 0o100000 as libc::c_int as libc::c_uint\n                {\n                    elseek(fd, -n_bytes_past_EOL, 1 as libc::c_int, filename);\n                }\n            }\n            break;\n        }\n        xwrite_stdout(buffer.as_mut_ptr(), bytes_to_write);\n    }\n    return 1 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn head(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_units: uintmax_t,\n    mut count_lines: bool,\n    mut elide_from_end: bool,\n) -> bool {\n    if print_headers {\n        write_header(filename);\n    }\n    if elide_from_end {\n        let mut current_pos: off_t = -(1 as libc::c_int) as off_t;\n        let mut st: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        if fstat(fd, &mut st) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n        if !presume_input_pipe && usable_st_size(&mut st) as libc::c_int != 0 {\n            current_pos = elseek(\n                fd,\n                0 as libc::c_int as off_t,\n                1 as libc::c_int,\n                filename,\n            );\n            if current_pos < 0 as libc::c_int as libc::c_long {\n                return 0 as libc::c_int != 0;\n            }\n        }\n        if count_lines {\n            return elide_tail_lines_file(filename, fd, n_units, &mut st, current_pos)\n        } else {\n            return elide_tail_bytes_file(filename, fd, n_units, &mut st, current_pos)\n        }\n    }\n    if count_lines {\n        return head_lines(filename, fd, n_units)\n    } else {\n        return head_bytes(filename, fd, n_units)\n    };\n}\nunsafe extern \"C\" fn head_file(\n    mut filename: *const libc::c_char,\n    mut n_units: uintmax_t,\n    mut count_lines: bool,\n    mut elide_from_end: bool,\n) -> bool {\n    let mut fd: libc::c_int = 0;\n    let mut ok: bool = false;\n    let mut is_stdin: bool = strcmp(filename, b\"-\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int;\n    if is_stdin {\n        have_read_stdin = 1 as libc::c_int != 0;\n        fd = 0 as libc::c_int;\n        filename = gettext(b\"standard input\\0\" as *const u8 as *const libc::c_char);\n        xset_binary_mode(0 as libc::c_int, 0 as libc::c_int);\n    } else {\n        fd = open(filename, 0 as libc::c_int | 0 as libc::c_int);\n        if fd < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open %s for reading\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot open %s for reading\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot open %s for reading\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n    }\n    ok = head(filename, fd, n_units, count_lines, elide_from_end);\n    if !is_stdin && close(fd) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"failed to close %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to close %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to close %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    return ok;\n}\nunsafe extern \"C\" fn string_to_integer(\n    mut count_lines: bool,\n    mut n_string: *const libc::c_char,\n) -> uintmax_t {\n    return xdectoumax(\n        n_string,\n        0 as libc::c_int as uintmax_t,\n        18446744073709551615 as libc::c_ulong,\n        b\"bkKmMGTPEZYRQ0\\0\" as *const u8 as *const libc::c_char,\n        if count_lines as libc::c_int != 0 {\n            gettext(b\"invalid number of lines\\0\" as *const u8 as *const libc::c_char)\n        } else {\n            gettext(b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char)\n        },\n        0 as libc::c_int,\n    );\n}",
    "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut header_mode: header_mode = multiple_files;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut c: libc::c_int = 0;\n    let mut i: size_t = 0;\n    let mut n_units: uintmax_t = 10 as libc::c_int as uintmax_t;\n    let mut count_lines: bool = 1 as libc::c_int != 0;\n    let mut elide_from_end: bool = 0 as libc::c_int != 0;\n    static mut default_file_list: [*const libc::c_char; 2] = [\n        b\"-\\0\" as *const u8 as *const libc::c_char,\n        0 as *const libc::c_char,\n    ];\n    let mut file_list: *const *const libc::c_char = 0 as *const *const libc::c_char;\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    have_read_stdin = 0 as libc::c_int != 0;\n    print_headers = 0 as libc::c_int != 0;\n    line_end = '\\n' as i32 as libc::c_char;\n    if (1 as libc::c_int) < argc\n        && *(*argv.offset(1 as libc::c_int as isize)).offset(0 as libc::c_int as isize)\n            as libc::c_int == '-' as i32\n        && (*(*argv.offset(1 as libc::c_int as isize)).offset(1 as libc::c_int as isize)\n            as libc::c_uint)\n            .wrapping_sub('0' as i32 as libc::c_uint) <= 9 as libc::c_int as libc::c_uint\n    {\n        let mut a: *mut libc::c_char = *argv.offset(1 as libc::c_int as isize);\n        a = a.offset(1);\n        let mut n_string: *mut libc::c_char = a;\n        let mut end_n_string: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut multiplier_char: libc::c_char = 0 as libc::c_int as libc::c_char;\n        loop {\n            a = a.offset(1);\n            a;\n            if !((*a as libc::c_uint).wrapping_sub('0' as i32 as libc::c_uint)\n                <= 9 as libc::c_int as libc::c_uint)\n            {\n                break;\n            }\n        }\n        end_n_string = a;\n        while *a != 0 {\n            match *a as libc::c_int {\n                99 => {\n                    count_lines = 0 as libc::c_int != 0;\n                    multiplier_char = 0 as libc::c_int as libc::c_char;\n                }\n                98 | 107 | 109 => {\n                    count_lines = 0 as libc::c_int != 0;\n                    multiplier_char = *a;\n                }\n                108 => {\n                    count_lines = 1 as libc::c_int != 0;\n                }\n                113 => {\n                    header_mode = never;\n                }\n                118 => {\n                    header_mode = always;\n                }\n                122 => {\n                    line_end = '\\0' as i32 as libc::c_char;\n                }\n                _ => {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"invalid trailing option -- %c\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            *a as libc::c_int,\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid trailing option -- %c\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                *a as libc::c_int,\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid trailing option -- %c\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                *a as libc::c_int,\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n            }\n            a = a.offset(1);\n            a;\n        }\n        *end_n_string = multiplier_char;\n        if multiplier_char != 0 {\n            end_n_string = end_n_string.offset(1);\n            *end_n_string = 0 as libc::c_int as libc::c_char;\n        }\n        n_units = string_to_integer(count_lines, n_string);\n        let ref mut fresh3 = *argv.offset(1 as libc::c_int as isize);\n        *fresh3 = *argv.offset(0 as libc::c_int as isize);\n        argv = argv.offset(1);\n        argv;\n        argc -= 1;\n        argc;\n    }\n    loop {\n        c = getopt_long(\n            argc,\n            argv,\n            b\"c:n:qvz0123456789\\0\" as *const u8 as *const libc::c_char,\n            long_options.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if !(c != -(1 as libc::c_int)) {\n            break;\n        }\n        match c {\n            256 => {\n                presume_input_pipe = 1 as libc::c_int != 0;\n            }\n            99 => {\n                count_lines = 0 as libc::c_int != 0;\n                elide_from_end = *optarg as libc::c_int == '-' as i32;\n                if elide_from_end {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                n_units = string_to_integer(count_lines, optarg);\n            }\n            110 => {\n                count_lines = 1 as libc::c_int != 0;\n                elide_from_end = *optarg as libc::c_int == '-' as i32;\n                if elide_from_end {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                n_units = string_to_integer(count_lines, optarg);\n            }\n            113 => {\n                header_mode = never;\n            }\n            118 => {\n                header_mode = always;\n            }\n            122 => {\n                line_end = '\\0' as i32 as libc::c_char;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n            }\n            -3 => {\n                version_etc(\n                    stdout,\n                    b\"head\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                        b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);\n            }\n            _ => {\n                if (c as libc::c_uint).wrapping_sub('0' as i32 as libc::c_uint)\n                    <= 9 as libc::c_int as libc::c_uint\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"invalid trailing option -- %c\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            c,\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid trailing option -- %c\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                c,\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid trailing option -- %c\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                c,\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                usage(1 as libc::c_int);\n            }\n        }\n    }\n    if header_mode as libc::c_uint == always as libc::c_int as libc::c_uint\n        || header_mode as libc::c_uint == multiple_files as libc::c_int as libc::c_uint\n            && optind < argc - 1 as libc::c_int\n    {\n        print_headers = 1 as libc::c_int != 0;\n    }\n    if !count_lines && elide_from_end as libc::c_int != 0\n        && ((if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n            -(1 as libc::c_int) as off_t\n        } else {\n            (((1 as libc::c_int as off_t)\n                << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        }) as libc::c_ulong) < n_units\n    {\n        let mut umax_buf: [libc::c_char; 21] = [0; 21];\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                75 as libc::c_int,\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                gettext(\n                    b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote(umaxtostr(n_units, umax_buf.as_mut_ptr())),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    75 as libc::c_int,\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(\n                        b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(umaxtostr(n_units, umax_buf.as_mut_ptr())),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    75 as libc::c_int,\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(\n                        b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(umaxtostr(n_units, umax_buf.as_mut_ptr())),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    file_list = if optind < argc {\n        &mut *argv.offset(optind as isize) as *mut *mut libc::c_char\n            as *const *const libc::c_char\n    } else {\n        default_file_list.as_ptr()\n    };\n    xset_binary_mode(1 as libc::c_int, 0 as libc::c_int);\n    i = 0 as libc::c_int as size_t;\n    while !(*file_list.offset(i as isize)).is_null() {\n        ok = (ok as libc::c_int\n            & head_file(\n                *file_list.offset(i as isize),\n                n_units,\n                count_lines,\n                elide_from_end,\n            ) as libc::c_int) != 0;\n        i = i.wrapping_add(1);\n        i;\n    }\n    if have_read_stdin as libc::c_int != 0 && close(0 as libc::c_int) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"-\\0\" as *const u8 as *const libc::c_char,\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    return if ok as libc::c_int != 0 { 0 as libc::c_int } else { 1 as libc::c_int };\n}\npub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "use ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;\npub const _NL_WAM_STR: C2RustUnnamed = 131162;\npub const _NL_WMON_12: C2RustUnnamed = 131161;\npub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "use ::libc;\npub type __off_t = libc::c_long;\npub type off_t = __off_t;\n#[no_mangle]\npub unsafe extern \"C\" fn offtostr(\n    mut i: off_t,\n    mut buf: *mut libc::c_char,\n) -> *mut libc::c_char {\n    let mut p: *mut libc::c_char = buf\n        .offset(\n            (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                .wrapping_sub(\n                    !((0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t)\n                        as libc::c_int as libc::c_ulong,\n                )\n                .wrapping_mul(146 as libc::c_int as libc::c_ulong)\n                .wrapping_add(484 as libc::c_int as libc::c_ulong)\n                .wrapping_div(485 as libc::c_int as libc::c_ulong)\n                .wrapping_add(\n                    !((0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t)\n                        as libc::c_int as libc::c_ulong,\n                ) as isize,\n        );\n    *p = 0 as libc::c_int as libc::c_char;\n    if i < 0 as libc::c_int as libc::c_long {\n        loop {\n            p = p.offset(-1);\n            *p = ('0' as i32 as libc::c_long - i % 10 as libc::c_int as libc::c_long)\n                as libc::c_char;\n            i /= 10 as libc::c_int as libc::c_long;\n            if !(i != 0 as libc::c_int as libc::c_long) {\n                break;\n            }\n        }\n        p = p.offset(-1);\n        *p = '-' as i32 as libc::c_char;\n    } else {\n        loop {\n            p = p.offset(-1);\n            *p = ('0' as i32 as libc::c_long + i % 10 as libc::c_int as libc::c_long)\n                as libc::c_char;\n            i /= 10 as libc::c_int as libc::c_long;\n            if !(i != 0 as libc::c_int as libc::c_long) {\n                break;\n            }\n        }\n    }\n    return p;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nunsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}\nunsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}\nunsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;",
    "                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};",
    "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "use ::libc;\nextern \"C\" {\n    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type ssize_t = __ssize_t;\npub type __ssize_t = libc::c_long;\npub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn safe_read(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = read(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "use ::libc;\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\n#[no_mangle]\npub unsafe extern \"C\" fn umaxtostr(\n    mut i: uintmax_t,\n    mut buf: *mut libc::c_char,\n) -> *mut libc::c_char {\n    let mut p: *mut libc::c_char = buf\n        .offset(\n            (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                .wrapping_sub(\n                    !((0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t)\n                        as libc::c_int as libc::c_ulong,\n                )\n                .wrapping_mul(146 as libc::c_int as libc::c_ulong)\n                .wrapping_add(484 as libc::c_int as libc::c_ulong)\n                .wrapping_div(485 as libc::c_int as libc::c_ulong)\n                .wrapping_add(\n                    !((0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t)\n                        as libc::c_int as libc::c_ulong,\n                ) as isize,\n        );\n    *p = 0 as libc::c_int as libc::c_char;\n    if i < 0 as libc::c_int as libc::c_ulong {\n        loop {\n            p = p.offset(-1);\n            *p = ('0' as i32 as libc::c_ulong)\n                .wrapping_sub(i.wrapping_rem(10 as libc::c_int as libc::c_ulong))\n                as libc::c_char;\n            i = (i as libc::c_ulong).wrapping_div(10 as libc::c_int as libc::c_ulong)\n                as uintmax_t as uintmax_t;\n            if !(i != 0 as libc::c_int as libc::c_ulong) {\n                break;\n            }\n        }\n        p = p.offset(-1);\n        *p = '-' as i32 as libc::c_char;\n    } else {\n        loop {\n            p = p.offset(-1);\n            *p = ('0' as i32 as libc::c_ulong)\n                .wrapping_add(i.wrapping_rem(10 as libc::c_int as libc::c_ulong))\n                as libc::c_char;\n            i = (i as libc::c_ulong).wrapping_div(10 as libc::c_int as libc::c_ulong)\n                as uintmax_t as uintmax_t;\n            if !(i != 0 as libc::c_int as libc::c_ulong) {\n                break;\n            }\n        }\n    }\n    return p;\n}",
    "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
    "use ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn xset_binary_mode_error() {}\n#[inline]\nunsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[inline]\nunsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn xstrtoumax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut uintmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n}\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\npub const LONGINT_OK: strtol_error = 0;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\n#[no_mangle]\npub unsafe extern \"C\" fn xdectoumax(\n    mut n_str: *const libc::c_char,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    return xnumtoumax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnumtoumax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: uintmax_t = 0;\n    s_err = xstrtoumax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_ulong {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}",
    "use ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nunsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[inline]\nunsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[inline]\nunsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[cold]\n#[inline]\nunsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}\n#[inline]\nunsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\nunsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t",
    "                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtoumax(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __base: libc::c_int,\n    ) -> uintmax_t;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n}\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub const _ISspace: C2RustUnnamed = 8192;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;\nunsafe extern \"C\" fn bkm_scale(\n    mut x: *mut uintmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: uintmax_t = 0;\n    if if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t\n        && (if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_ulong } else { *x })\n            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n            < 0 as libc::c_int as libc::c_ulong\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_ulong {\n                if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        -(1 as libc::c_int) as uintmax_t\n                    })\n                        .wrapping_add(scale_factor as libc::c_ulong)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    (*x\n                        < (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(scale_factor as libc::c_ulong)) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(-(1 as libc::c_int) as uintmax_t)\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(-scale_factor as libc::c_ulong)\n                    }) <= (-(1 as libc::c_int) as libc::c_ulong).wrapping_sub(*x))\n                        as libc::c_int\n                }\n            } else {\n                if (if (if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    !((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                }) < 0 as libc::c_int as libc::c_ulong\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                        < (if (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_ulong)\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            < 0 as libc::c_int as libc::c_ulong\n                        {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                << (::core::mem::size_of::<libc::c_ulong>()\n                                    as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        })\n                            .wrapping_neg()) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_ulong)\n                        < ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        *x\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (*x).wrapping_add(0 as libc::c_int as uintmax_t))\n                            as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong) < *x\n                            && (-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (*x).wrapping_sub(1 as libc::c_int as libc::c_ulong))\n                            as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }\n            }\n        } else {\n            if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_ulong {\n                    if (if (if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        !((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                    }) < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                            < (if (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    *x\n                                })\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                < 0 as libc::c_int as libc::c_ulong\n                            {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                    << (::core::mem::size_of::<libc::c_ulong>()\n                                        as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            })\n                                .wrapping_neg()) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_ulong\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_ulong)\n                                < (scale_factor as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_ulong)\n                                as libc::c_int\n                        }\n                    } else {\n                        ((0 as libc::c_int as uintmax_t).wrapping_div(*x)\n                            < scale_factor as libc::c_ulong) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_ulong {\n            !if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n                -(1 as libc::c_int) as uintmax_t\n            } else {\n                ((1 as libc::c_int as uintmax_t)\n                    << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            }\n        } else if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n            -(1 as libc::c_int) as uintmax_t\n        } else {\n            ((1 as libc::c_int as uintmax_t)\n                << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}\nunsafe extern \"C\" fn bkm_scale_by_power(\n    mut x: *mut uintmax_t,\n    mut base: libc::c_int,\n    mut power: libc::c_int,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    loop {\n        let fresh8 = power;\n        power = power - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);\n    }\n    return err;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn xstrtoumax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut uintmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: uintmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 79],\n                &[libc::c_char; 79],\n            >(\n                b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2256: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 79],\n                    &[libc::c_char; 79],\n                >(\n                    b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoumax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as uintmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if **p as libc::c_int != '\\0' as i32 {\n        let mut base: libc::c_int = 1024 as libc::c_int;\n        let mut suffixes: libc::c_int = 1 as libc::c_int;\n        let mut overflow: strtol_error = LONGINT_OK;\n        if (strchr(valid_suffixes, **p as libc::c_int)).is_null() {\n            *val = tmp;\n            return (err as libc::c_uint\n                | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                as strtol_error;\n        }\n        match **p as libc::c_int {\n            69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n                if !(strchr(valid_suffixes, '0' as i32)).is_null() {\n                    match *(*p.offset(0 as libc::c_int as isize))\n                        .offset(1 as libc::c_int as isize) as libc::c_int\n                    {\n                        105 => {\n                            if *(*p.offset(0 as libc::c_int as isize))\n                                .offset(2 as libc::c_int as isize) as libc::c_int\n                                == 'B' as i32\n                            {\n                                suffixes += 2 as libc::c_int;\n                            }\n                        }\n                        66 | 68 => {\n                            base = 1000 as libc::c_int;\n                            suffixes += 1;\n                            suffixes;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n            _ => {}\n        }\n        match **p as libc::c_int {\n            98 => {\n                overflow = bkm_scale(&mut tmp, 512 as libc::c_int);\n            }\n            66 => {\n                overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);\n            }\n            99 => {\n                overflow = LONGINT_OK;\n            }\n            69 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);\n            }\n            71 | 103 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);\n            }\n            107 | 75 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);\n            }\n            77 | 109 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);\n            }\n            80 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);\n            }\n            81 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);\n            }\n            82 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);\n            }\n            84 | 116 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);\n            }\n            119 => {\n                overflow = bkm_scale(&mut tmp, 2 as libc::c_int);\n            }\n            89 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);\n            }\n            90 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);\n            }\n            _ => {\n                *val = tmp;\n                return (err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                    as strtol_error;\n            }\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | overflow as libc::c_uint);\n        *p = (*p).offset(suffixes as isize);\n        if **p != 0 {\n            err = ::core::mem::transmute::<\n                libc::c_uint,\n                strtol_error,\n            >(\n                err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint,\n            );\n        }\n    }\n    *val = tmp;\n    return err;\n}"
  ],
  "pwd": [
    "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
    "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod close_stream;\npub mod closeout;\npub mod exitfail;\npub mod fclose;\npub mod fflush;\npub mod fseeko;\npub mod hard_locale;\npub mod ialloc;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod root_dev_ino;\npub mod same_inode;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalloc_die;\npub mod xgetcwd;\npub mod xmalloc;\n}\n// mod src",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "use ::libc;\n#[inline]\nunsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nunsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "use ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;\npub const _NL_WAM_STR: C2RustUnnamed = 131162;\npub const _NL_WMON_12: C2RustUnnamed = 131161;\npub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut, unused_imports)]\n#![feature(extern_types)]\nuse ::rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    pub type __dirstream;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    static mut optind: libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn puts(__s: *const libc::c_char) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn chdir(__path: *const libc::c_char) -> libc::c_int;\n    fn fchdir(__fd: libc::c_int) -> libc::c_int;\n    fn lstat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn free(_: *mut libc::c_void);\n    fn __errno_location() -> *mut libc::c_int;\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn set_program_name(argv0: *const libc::c_char);\n    static mut program_name: *const libc::c_char;\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn close_stdout();\n    static mut Version: *const libc::c_char;\n    fn opendir(__name: *const libc::c_char) -> *mut DIR;\n    fn closedir(__dirp: *mut DIR) -> libc::c_int;\n    fn readdir(__dirp: *mut DIR) -> *mut dirent;\n    fn dirfd(__dirp: *mut DIR) -> libc::c_int;\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn xmalloc(s: size_t) -> *mut libc::c_void;\n    fn xnmalloc(n: size_t, s: size_t) -> *mut libc::c_void;\n    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;\n    fn exit(_: libc::c_int) -> !;\n    fn atexit(__func: Option::<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn get_root_dev_ino(root_d_i: *mut dev_ino) -> *mut dev_ino;\n    fn xgetcwd() -> *mut libc::c_char;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\npub type size_t = libc::c_ulong;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type ino_t = __ino_t;\npub type dev_t = __dev_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct dirent {\n    pub d_ino: __ino_t,\n    pub d_off: __off_t,\n    pub d_reclen: libc::c_ushort,\n    pub d_type: libc::c_uchar,\n    pub d_name: [libc::c_char; 256],\n}\npub type DIR = __dirstream;\npub type C2RustUnnamed = libc::c_uint;\npub const NOT_AN_INODE_NUMBER: C2RustUnnamed = 0;\npub type C2RustUnnamed_0 = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed_0 = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed_0 = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct dev_ino {\n    pub st_ino: ino_t,\n    pub st_dev: dev_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct file_name {\n    pub buf: *mut libc::c_char,\n    pub n_alloc: size_t,\n    pub start: *mut libc::c_char,\n}\n#[inline]\nunsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}\n#[inline]\nunsafe extern \"C\" fn readdir_ignoring_dot_and_dotdot(\n    mut dirp: *mut DIR,\n) -> *const dirent {\n    loop {\n        let mut dp: *const dirent = readdir(dirp);\n        if dp.is_null() || !dot_or_dotdot(((*dp).d_name).as_ptr()) {\n            return dp;\n        }\n    };\n}\n#[inline]\nunsafe extern \"C\" fn dot_or_dotdot(mut file_name: *const libc::c_char) -> bool {\n    if *file_name.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32 {\n        let mut sep: libc::c_char = *file_name\n            .offset(\n                ((*file_name.offset(1 as libc::c_int as isize) as libc::c_int\n                    == '.' as i32) as libc::c_int + 1 as libc::c_int) as isize,\n            );\n        return sep == 0 || sep as libc::c_int == '/' as i32;\n    } else {\n        return 0 as libc::c_int != 0\n    };\n}\n#[inline]\nunsafe extern \"C\" fn psame_inode(mut a: *const stat, mut b: *const stat) -> bool {\n    return (*a).st_dev ^ (*b).st_dev | (*a).st_ino ^ (*b).st_ino == 0;\n}\nstatic mut longopts: [option; 5] = [\n    {\n        let mut init = option {\n            name: b\"logical\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'L' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"physical\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'P' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];\n#[no_mangle]\npub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(b\"Usage: %s [OPTION]...\\n\\0\" as *const u8 as *const libc::c_char),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Print the full filename of the current working directory.\\n\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -L, --logical   use PWD from environment, even if it contains symlinks\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -P, --physical  resolve all symlinks\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"\\nIf no option is specified, -P is assumed.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        printf(\n            gettext(\n                b\"\\nYour shell may have its own version of %s, which usually supersedes\\nthe version described here.  Please refer to your shell's documentation\\nfor details about the options it supports.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            b\"pwd\\0\" as *const u8 as *const libc::c_char,\n        );\n        emit_ancillary_info(b\"pwd\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}\nunsafe extern \"C\" fn file_name_free(mut p: *mut file_name) {\n    free((*p).buf as *mut libc::c_void);\n    free(p as *mut libc::c_void);\n}\nunsafe extern \"C\" fn file_name_init() -> *mut file_name {\n    let mut p: *mut file_name = xmalloc(\n        ::core::mem::size_of::<file_name>() as libc::c_ulong,\n    ) as *mut file_name;\n    (*p)\n        .n_alloc = (if (2 as libc::c_int * 4096 as libc::c_int)\n        < 32 as libc::c_int * 1024 as libc::c_int\n    {\n        2 as libc::c_int * 4096 as libc::c_int\n    } else {\n        32 as libc::c_int * 1024 as libc::c_int\n    }) as size_t;\n    (*p).buf = xmalloc((*p).n_alloc) as *mut libc::c_char;\n    (*p)\n        .start = ((*p).buf)\n        .offset(((*p).n_alloc).wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize);\n    *((*p).start).offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n    return p;\n}",
    "unsafe extern \"C\" fn file_name_prepend(\n    mut p: *mut file_name,\n    mut s: *const libc::c_char,\n    mut s_len: size_t,\n) {\n    let mut n_free: size_t = ((*p).start).offset_from((*p).buf) as libc::c_long\n        as size_t;\n    if n_free < (1 as libc::c_int as libc::c_ulong).wrapping_add(s_len) {\n        let mut half: size_t = ((*p).n_alloc)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            .wrapping_add(s_len);\n        let mut q: *mut libc::c_char = xnmalloc(2 as libc::c_int as size_t, half)\n            as *mut libc::c_char;\n        let mut n_used: size_t = ((*p).n_alloc).wrapping_sub(n_free);\n        (*p)\n            .start = q\n            .offset((2 as libc::c_int as libc::c_ulong).wrapping_mul(half) as isize)\n            .offset(-(n_used as isize));\n        memcpy(\n            (*p).start as *mut libc::c_void,\n            ((*p).buf).offset(n_free as isize) as *const libc::c_void,\n            n_used,\n        );\n        free((*p).buf as *mut libc::c_void);\n        (*p).buf = q;\n        (*p).n_alloc = (2 as libc::c_int as libc::c_ulong).wrapping_mul(half);\n    }\n    (*p)\n        .start = ((*p).start)\n        .offset(-((1 as libc::c_int as libc::c_ulong).wrapping_add(s_len) as isize));\n    *((*p).start).offset(0 as libc::c_int as isize) = '/' as i32 as libc::c_char;\n    memcpy(\n        ((*p).start).offset(1 as libc::c_int as isize) as *mut libc::c_void,\n        s as *const libc::c_void,\n        s_len,\n    );\n}\nunsafe extern \"C\" fn nth_parent(mut n: size_t) -> *mut libc::c_char {\n    let mut buf: *mut libc::c_char = xnmalloc(3 as libc::c_int as size_t, n)\n        as *mut libc::c_char;\n    let mut p: *mut libc::c_char = buf;\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n {\n        memcpy(\n            p as *mut libc::c_void,\n            b\"../\\0\" as *const u8 as *const libc::c_char as *const libc::c_void,\n            3 as libc::c_int as libc::c_ulong,\n        );\n        p = p.offset(3 as libc::c_int as isize);\n        i = i.wrapping_add(1);\n        i;\n    }\n    *p.offset(-(1 as libc::c_int) as isize) = '\\0' as i32 as libc::c_char;\n    return buf;\n}\nunsafe extern \"C\" fn find_dir_entry(\n    mut dot_sb: *mut stat,\n    mut file_name: *mut file_name,\n    mut parent_height: size_t,\n) {\n    let mut dirp: *mut DIR = 0 as *mut DIR;\n    let mut fd: libc::c_int = 0;\n    let mut parent_sb: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut use_lstat: bool = false;\n    let mut found: bool = false;\n    dirp = opendir(b\"..\\0\" as *const u8 as *const libc::c_char);\n    if dirp.is_null() {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"cannot open directory %s\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote(nth_parent(parent_height)),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open directory %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open directory %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    fd = dirfd(dirp);\n    if (if 0 as libc::c_int <= fd {\n        fchdir(fd)\n    } else {\n        chdir(b\"..\\0\" as *const u8 as *const libc::c_char)\n    }) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"failed to chdir to %s\\0\" as *const u8 as *const libc::c_char),\n                quote(nth_parent(parent_height)),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to chdir to %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to chdir to %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if (if 0 as libc::c_int <= fd {\n        fstat(fd, &mut parent_sb)\n    } else {\n        stat(b\".\\0\" as *const u8 as *const libc::c_char, &mut parent_sb)\n    }) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                quote(nth_parent(parent_height)),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    use_lstat = parent_sb.st_dev != (*dot_sb).st_dev;\n    found = 0 as libc::c_int != 0;\n    loop {\n        let mut dp: *const dirent = 0 as *const dirent;\n        let mut ent_sb: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        let mut ino: ino_t = 0;\n        *__errno_location() = 0 as libc::c_int;\n        dp = readdir_ignoring_dot_and_dotdot(dirp);\n        if dp.is_null() {\n            if *__errno_location() != 0 {\n                let mut e: libc::c_int = *__errno_location();\n                closedir(dirp);\n                *__errno_location() = e;\n                dirp = 0 as *mut DIR;\n            }\n            break;\n        } else {\n            ino = (*dp).d_ino;\n            if ino == NOT_AN_INODE_NUMBER as libc::c_int as libc::c_ulong\n                || use_lstat as libc::c_int != 0\n            {\n                if lstat(((*dp).d_name).as_ptr(), &mut ent_sb) < 0 as libc::c_int {\n                    continue;\n                }\n                ino = ent_sb.st_ino;\n            }\n            if ino != (*dot_sb).st_ino {\n                continue;\n            }\n            if !(!use_lstat || ent_sb.st_dev == (*dot_sb).st_dev) {\n                continue;\n            }\n            file_name_prepend(\n                file_name,\n                ((*dp).d_name).as_ptr(),\n                strlen(((*dp).d_name).as_ptr()),\n            );\n            found = 1 as libc::c_int != 0;\n            break;\n        }\n    }\n    if dirp.is_null() || closedir(dirp) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"reading directory %s\\0\" as *const u8 as *const libc::c_char),\n                quote(nth_parent(parent_height)),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"reading directory %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"reading directory %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if !found {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"couldn't find directory entry in %s with matching i-node\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                quote(nth_parent(parent_height)),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"couldn't find directory entry in %s with matching i-node\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"couldn't find directory entry in %s with matching i-node\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    *dot_sb = parent_sb;\n}",
    "unsafe extern \"C\" fn robust_getcwd(mut file_name: *mut file_name) {\n    let mut height: size_t = 1 as libc::c_int as size_t;\n    let mut dev_ino_buf: dev_ino = dev_ino { st_ino: 0, st_dev: 0 };\n    let mut root_dev_ino: *mut dev_ino = get_root_dev_ino(&mut dev_ino_buf);\n    let mut dot_sb: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    if root_dev_ino.is_null() {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"failed to get attributes of %s\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\"/\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to get attributes of %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"/\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to get attributes of %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"/\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if stat(b\".\\0\" as *const u8 as *const libc::c_char, &mut dot_sb) < 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\".\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\".\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\".\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    while !(dot_sb.st_dev ^ (*root_dev_ino).st_dev\n        | dot_sb.st_ino ^ (*root_dev_ino).st_ino == 0)\n    {\n        let fresh0 = height;\n        height = height.wrapping_add(1);\n        find_dir_entry(&mut dot_sb, file_name, fresh0);\n    }\n    if *((*file_name).start).offset(0 as libc::c_int as isize) as libc::c_int\n        == '\\0' as i32\n    {\n        file_name_prepend(\n            file_name,\n            b\"\\0\" as *const u8 as *const libc::c_char,\n            0 as libc::c_int as size_t,\n        );\n    }\n}\nunsafe extern \"C\" fn logical_getcwd() -> *mut libc::c_char {\n    let mut st1: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut st2: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut wd: *mut libc::c_char = getenv(b\"PWD\\0\" as *const u8 as *const libc::c_char);\n    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;\n    if wd.is_null() || *wd.offset(0 as libc::c_int as isize) as libc::c_int != '/' as i32\n    {\n        return 0 as *mut libc::c_char;\n    }\n    p = wd;\n    loop {\n        p = strstr(p, b\"/.\\0\" as *const u8 as *const libc::c_char);\n        if p.is_null() {\n            break;\n        }\n        if *p.offset(2 as libc::c_int as isize) == 0\n            || *p.offset(2 as libc::c_int as isize) as libc::c_int == '/' as i32\n            || *p.offset(2 as libc::c_int as isize) as libc::c_int == '.' as i32\n                && (*p.offset(3 as libc::c_int as isize) == 0\n                    || *p.offset(3 as libc::c_int as isize) as libc::c_int == '/' as i32)\n        {\n            return 0 as *mut libc::c_char;\n        }\n        p = p.offset(1);\n        p;\n    }\n    if stat(wd, &mut st1) == 0 as libc::c_int\n        && stat(b\".\\0\" as *const u8 as *const libc::c_char, &mut st2) == 0 as libc::c_int\n        && psame_inode(&mut st1, &mut st2) as libc::c_int != 0\n    {\n        return wd;\n    }\n    return 0 as *mut libc::c_char;\n}\nunsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut wd: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut logical: bool = !(getenv(\n        b\"POSIXLY_CORRECT\\0\" as *const u8 as *const libc::c_char,\n    ))\n        .is_null();\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    loop {\n        let mut c: libc::c_int = getopt_long(\n            argc,\n            argv,\n            b\"LP\\0\" as *const u8 as *const libc::c_char,\n            longopts.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if c == -(1 as libc::c_int) {\n            break;\n        }\n        match c {\n            76 => {\n                logical = 1 as libc::c_int != 0;\n            }\n            80 => {\n                logical = 0 as libc::c_int != 0;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n            }\n            -3 => {\n                version_etc(\n                    stdout,\n                    b\"pwd\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);\n            }\n            _ => {\n                usage(1 as libc::c_int);\n            }\n        }\n    }\n    if optind < argc {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"ignoring non-option arguments\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"ignoring non-option arguments\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"ignoring non-option arguments\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if logical {\n        wd = logical_getcwd();\n        if !wd.is_null() {\n            puts(wd);\n            return 0 as libc::c_int;\n        }\n    }\n    wd = xgetcwd();\n    if !wd.is_null() {\n        puts(wd);\n        free(wd as *mut libc::c_void);\n    } else {\n        let mut file_name: *mut file_name = file_name_init();\n        robust_getcwd(file_name);\n        puts((*file_name).start);\n        file_name_free(file_name);\n    }\n    return 0 as libc::c_int;\n}\npub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "use ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nunsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}\nunsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}\nunsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;",
    "                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};",
    "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "use ::libc;\nextern \"C\" {\n    fn lstat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n}\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\npub type ino_t = __ino_t;\npub type dev_t = __dev_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct dev_ino {\n    pub st_ino: ino_t,\n    pub st_dev: dev_t,\n}\n#[no_mangle]\npub unsafe extern \"C\" fn get_root_dev_ino(mut root_d_i: *mut dev_ino) -> *mut dev_ino {\n    let mut statbuf: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    if lstat(b\"/\\0\" as *const u8 as *const libc::c_char, &mut statbuf) != 0 {\n        return 0 as *mut dev_ino;\n    }\n    (*root_d_i).st_ino = statbuf.st_ino;\n    (*root_d_i).st_dev = statbuf.st_dev;\n    return root_d_i;\n}",
    "use ::libc;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn psame_inode(mut a: *const stat, mut b: *const stat) -> bool {\n    return (*a).st_dev ^ (*b).st_dev | (*a).st_ino ^ (*b).st_ino == 0;\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
    "use ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn getcwd(__buf: *mut libc::c_char, __size: size_t) -> *mut libc::c_char;\n    fn xalloc_die();\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn xgetcwd() -> *mut libc::c_char {\n    let mut cwd: *mut libc::c_char = getcwd(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n    );\n    if cwd.is_null() && *__errno_location() == 12 as libc::c_int {\n        xalloc_die();\n    }\n    return cwd;\n}",
    "use ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nunsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[inline]\nunsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[inline]\nunsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[cold]\n#[inline]\nunsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}\n#[inline]\nunsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\nunsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t",
    "                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}"
  ],
  "split": [
    "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
    "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(label_break_value)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod alignalloc;\npub mod basename_lgpl;\npub mod binary_io;\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod close_stream;\npub mod closeout;\npub mod dup_safer;\npub mod dup_safer_flag;\npub mod exitfail;\npub mod fadvise;\npub mod fclose;\npub mod fcntl;\npub mod fd_reopen;\npub mod fd_safer;\npub mod fd_safer_flag;\npub mod fflush;\npub mod fpurge;\npub mod fseeko;\npub mod full_write;\npub mod hard_locale;\npub mod ialloc;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod mkstemp_safer;\npub mod open_safer;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod safe_write;\npub mod same_inode;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod sig2str;\npub mod stdbit;\npub mod stdc_leading_zeros;\npub mod temp_stream;\npub mod tmpdir;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalignalloc;\npub mod xalloc_die;\npub mod xbinary_io;\npub mod xdectoimax;\npub mod xdectoumax;\npub mod xmalloc;\npub mod xstrtoimax;\npub mod xstrtoumax;\n}\n// mod src",
    "use ::libc;\nextern \"C\" {\n    fn free(_: *mut libc::c_void);\n    fn aligned_alloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n}\npub type size_t = libc::c_ulong;\npub type ptrdiff_t = libc::c_long;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn alignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    if (-(1 as libc::c_int) as size_t) < alignment as libc::c_ulong {\n        alignment = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    if (-(1 as libc::c_int) as size_t) < size as libc::c_ulong {\n        size = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    return aligned_alloc(alignment as libc::c_ulong, size as libc::c_ulong);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn alignfree(mut ptr: *mut libc::c_void) {\n    free(ptr);\n}",
    "use ::libc;\nextern \"C\" {\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn last_component(\n    mut name: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut base: *const libc::c_char = name.offset(0 as libc::c_int as isize);\n    let mut p: *const libc::c_char = 0 as *const libc::c_char;\n    let mut last_was_slash: bool = 0 as libc::c_int != 0;\n    while *base as libc::c_int == '/' as i32 {\n        base = base.offset(1);\n        base;\n    }\n    p = base;\n    while *p != 0 {\n        if *p as libc::c_int == '/' as i32 {\n            last_was_slash = 1 as libc::c_int != 0;\n        } else if last_was_slash {\n            base = p;\n            last_was_slash = 0 as libc::c_int != 0;\n        }\n        p = p.offset(1);\n        p;\n    }\n    return base as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn base_len(mut name: *const libc::c_char) -> size_t {\n    let mut len: size_t = 0;\n    let mut prefix_len: size_t = 0 as libc::c_int as size_t;\n    len = strlen(name);\n    while (1 as libc::c_int as libc::c_ulong) < len\n        && *name.offset(len.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_int == '/' as i32\n    {\n        len = len.wrapping_sub(1);\n        len;\n    }\n    if 0 as libc::c_int != 0 && len == 1 as libc::c_int as libc::c_ulong\n        && *name.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32\n        && *name.offset(1 as libc::c_int as isize) as libc::c_int == '/' as i32\n        && *name.offset(2 as libc::c_int as isize) == 0\n    {\n        return 2 as libc::c_int as size_t;\n    }\n    if 0 as libc::c_int != 0 && prefix_len != 0 && len == prefix_len\n        && *name.offset(prefix_len as isize) as libc::c_int == '/' as i32\n    {\n        return prefix_len.wrapping_add(1 as libc::c_int as libc::c_ulong);\n    }\n    return len;\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "use ::libc;\n#[inline]\nunsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn rpl_fcntl(fd: libc::c_int, action: libc::c_int, _: ...) -> libc::c_int;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn dup_safer(mut fd: libc::c_int) -> libc::c_int {\n    return rpl_fcntl(fd, 0 as libc::c_int, 2 as libc::c_int + 1 as libc::c_int);\n}",
    "use ::libc;\nextern \"C\" {\n    fn rpl_fcntl(fd: libc::c_int, action: libc::c_int, _: ...) -> libc::c_int;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn dup_safer_flag(\n    mut fd: libc::c_int,\n    mut flag: libc::c_int,\n) -> libc::c_int {\n    return rpl_fcntl(\n        fd,\n        if flag & 0o2000000 as libc::c_int != 0 {\n            1030 as libc::c_int\n        } else {\n            0 as libc::c_int\n        },\n        2 as libc::c_int + 1 as libc::c_int,\n    );\n}",
    "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn posix_fadvise(\n        __fd: libc::c_int,\n        __offset: off_t,\n        __len: off_t,\n        __advise: libc::c_int,\n    ) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type fadvice_t = libc::c_uint;\npub const FADVISE_RANDOM: fadvice_t = 1;\npub const FADVISE_WILLNEED: fadvice_t = 3;\npub const FADVISE_DONTNEED: fadvice_t = 4;\npub const FADVISE_NOREUSE: fadvice_t = 5;\npub const FADVISE_SEQUENTIAL: fadvice_t = 2;\npub const FADVISE_NORMAL: fadvice_t = 0;\n#[no_mangle]\npub unsafe extern \"C\" fn fdadvise(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut len: off_t,\n    mut advice: fadvice_t,\n) {\n    posix_fadvise(fd, offset, len, advice as libc::c_int);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn fadvise(mut fp: *mut FILE, mut advice: fadvice_t) {\n    if !fp.is_null() {\n        fdadvise(\n            fileno(fp),\n            0 as libc::c_int as off_t,\n            0 as libc::c_int as off_t,\n            advice,\n        );\n    }\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "use ::libc;\nextern \"C\" {\n    fn fcntl(__fd: libc::c_int, __cmd: libc::c_int, _: ...) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fcntl(\n    mut fd: libc::c_int,\n    mut action: libc::c_int,\n    mut args: ...\n) -> libc::c_int {\n    let mut arg: ::core::ffi::VaListImpl;\n    let mut result: libc::c_int = -(1 as libc::c_int);\n    arg = args.clone();\n    match action {\n        0 => {\n            let mut target: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD(fd, target);\n        }\n        1030 => {\n            let mut target_0: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD_CLOEXEC(fd, target_0);\n        }\n        _ => {\n            let mut current_block_7: u64;\n            match action {\n                1 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                3 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                1025 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                9 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                1032 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                1034 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                11 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                1033 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                0 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                1030 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                1026 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                2 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                4 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                8 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1031 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1024 | 10 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {\n                    let mut p: *mut libc::c_void = arg.arg::<*mut libc::c_void>();\n                    result = fcntl(fd, action, p);\n                    current_block_7 = 7175849428784450219;\n                }\n            }\n            match current_block_7 {\n                4046302689674688614 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                8871774344836507656 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                12013198723313890981 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6453289516101043606 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                5351856672558463576 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                13722137258147953758 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                9332010126091029806 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                12766345184754617216 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                17966572639739034653 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6940526744265269810 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                15280576717888187136 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                7022052692272556539 => {\n                    result = fcntl(fd, action);\n                }\n                14034191772621753005 => {\n                    let mut x: libc::c_int = arg.arg::<libc::c_int>();\n                    result = fcntl(fd, action, x);\n                }\n                _ => {}\n            }\n        }\n    }\n    return result;\n}\nunsafe extern \"C\" fn rpl_fcntl_DUPFD(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    result = fcntl(fd, 0 as libc::c_int, target);\n    return result;\n}\nstatic mut have_dupfd_cloexec: libc::c_int = 0;\nunsafe extern \"C\" fn rpl_fcntl_DUPFD_CLOEXEC(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    if 0 as libc::c_int <= have_dupfd_cloexec {\n        result = fcntl(fd, 1030 as libc::c_int, target);\n        if 0 as libc::c_int <= result || *__errno_location() != 22 as libc::c_int {\n            have_dupfd_cloexec = 1 as libc::c_int;\n        } else {\n            result = rpl_fcntl_DUPFD(fd, target);\n            if result >= 0 as libc::c_int {\n                have_dupfd_cloexec = -(1 as libc::c_int);\n            }\n        }\n    } else {\n        result = rpl_fcntl_DUPFD(fd, target);\n    }\n    if 0 as libc::c_int <= result && have_dupfd_cloexec == -(1 as libc::c_int) {\n        let mut flags: libc::c_int = fcntl(result, 1 as libc::c_int);\n        if flags < 0 as libc::c_int\n            || fcntl(result, 2 as libc::c_int, flags | 1 as libc::c_int)\n                == -(1 as libc::c_int)\n        {\n            let mut saved_errno: libc::c_int = *__errno_location();\n            close(result);\n            *__errno_location() = saved_errno;\n            result = -(1 as libc::c_int);\n        }\n    }\n    return result;\n}\nunsafe extern \"C\" fn run_static_initializers() {\n    have_dupfd_cloexec = if 0 as libc::c_int != 0 {\n        -(1 as libc::c_int)\n    } else {\n        0 as libc::c_int\n    };\n}\n#[used]\n#[cfg_attr(target_os = \"linux\", link_section = \".init_array\")]\n#[cfg_attr(target_os = \"windows\", link_section = \".CRT$XIB\")]\n#[cfg_attr(target_os = \"macos\", link_section = \"__DATA,__mod_init_func\")]\nstatic INIT_ARRAY: [unsafe extern \"C\" fn(); 1] = [run_static_initializers];",
    "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn dup2(__fd: libc::c_int, __fd2: libc::c_int) -> libc::c_int;\n}\npub type __mode_t = libc::c_uint;\npub type mode_t = __mode_t;\n#[no_mangle]\npub unsafe extern \"C\" fn fd_reopen(\n    mut desired_fd: libc::c_int,\n    mut file: *const libc::c_char,\n    mut flags: libc::c_int,\n    mut mode: mode_t,\n) -> libc::c_int {\n    let mut fd: libc::c_int = open(file, flags, mode);\n    if fd == desired_fd || fd < 0 as libc::c_int {\n        return fd\n    } else {\n        let mut fd2: libc::c_int = dup2(fd, desired_fd);\n        let mut saved_errno: libc::c_int = *__errno_location();\n        close(fd);\n        *__errno_location() = saved_errno;\n        return fd2;\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn dup_safer(_: libc::c_int) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn fd_safer(mut fd: libc::c_int) -> libc::c_int {\n    if 0 as libc::c_int <= fd && fd <= 2 as libc::c_int {\n        let mut f: libc::c_int = dup_safer(fd);\n        let mut e: libc::c_int = *__errno_location();\n        close(fd);\n        *__errno_location() = e;\n        fd = f;\n    }\n    return fd;\n}",
    "use ::libc;\nextern \"C\" {\n    fn dup_safer_flag(_: libc::c_int, _: libc::c_int) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn fd_safer_flag(\n    mut fd: libc::c_int,\n    mut flag: libc::c_int,\n) -> libc::c_int {\n    if 0 as libc::c_int <= fd && fd <= 2 as libc::c_int {\n        let mut f: libc::c_int = dup_safer_flag(fd, flag);\n        let mut e: libc::c_int = *__errno_location();\n        close(fd);\n        *__errno_location() = e;\n        fd = f;\n    }\n    return fd;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nunsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __fpurge(__fp: *mut FILE);\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn fpurge(mut fp: *mut FILE) -> libc::c_int {\n    __fpurge(fp);\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn safe_write(fd: libc::c_int, buf: *const libc::c_void, count: size_t) -> size_t;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn full_write(\n    mut fd: libc::c_int,\n    mut buf: *const libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    let mut total: size_t = 0 as libc::c_int as size_t;\n    let mut ptr: *const libc::c_char = buf as *const libc::c_char;\n    while count > 0 as libc::c_int as libc::c_ulong {\n        let mut n_rw: size_t = safe_write(fd, ptr as *const libc::c_void, count);\n        if n_rw == -(1 as libc::c_int) as size_t {\n            break;\n        }\n        if n_rw == 0 as libc::c_int as libc::c_ulong {\n            *__errno_location() = 28 as libc::c_int;\n            break;\n        } else {\n            total = (total as libc::c_ulong).wrapping_add(n_rw) as size_t as size_t;\n            ptr = ptr.offset(n_rw as isize);\n            count = (count as libc::c_ulong).wrapping_sub(n_rw) as size_t as size_t;\n        }\n    }\n    return total;\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "use ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;\npub const _NL_WAM_STR: C2RustUnnamed = 131162;\npub const _NL_WMON_12: C2RustUnnamed = 131161;\npub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "use ::libc;\nextern \"C\" {\n    fn mkostemp(__template: *mut libc::c_char, __flags: libc::c_int) -> libc::c_int;\n    fn mkstemp(__template: *mut libc::c_char) -> libc::c_int;\n    fn fd_safer(_: libc::c_int) -> libc::c_int;\n    fn fd_safer_flag(_: libc::c_int, _: libc::c_int) -> libc::c_int;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn mkstemp_safer(mut templ: *mut libc::c_char) -> libc::c_int {\n    return fd_safer(mkstemp(templ));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn mkostemp_safer(\n    mut templ: *mut libc::c_char,\n    mut flags: libc::c_int,\n) -> libc::c_int {\n    return fd_safer_flag(mkostemp(templ, flags), flags);\n}",
    "use ::libc;\nextern \"C\" {\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn fd_safer(_: libc::c_int) -> libc::c_int;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type __mode_t = libc::c_uint;\npub type mode_t = __mode_t;\npub type va_list = __builtin_va_list;\n#[no_mangle]\npub unsafe extern \"C\" fn open_safer(\n    mut file: *const libc::c_char,\n    mut flags: libc::c_int,\n    mut args: ...\n) -> libc::c_int {\n    let mut mode: mode_t = 0 as libc::c_int as mode_t;\n    if flags & 0o100 as libc::c_int != 0 {\n        let mut ap: ::core::ffi::VaListImpl;\n        ap = args.clone();\n        mode = ap.arg::<mode_t>();\n    }\n    return fd_safer(open(file, flags, mode));\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nunsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}\nunsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}\nunsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;",
    "                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};",
    "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "use ::libc;\nextern \"C\" {\n    fn write(__fd: libc::c_int, __buf: *const libc::c_void, __n: size_t) -> ssize_t;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type ssize_t = __ssize_t;\npub type __ssize_t = libc::c_long;\npub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn safe_write(\n    mut fd: libc::c_int,\n    mut buf: *const libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = write(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
    "use ::libc;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn psame_inode(mut a: *const stat, mut b: *const stat) -> bool {\n    return (*a).st_dev ^ (*b).st_dev | (*a).st_ino ^ (*b).st_ino == 0;\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn __libc_current_sigrtmin() -> libc::c_int;\n    fn __libc_current_sigrtmax() -> libc::c_int;\n    fn strtol(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n    ) -> libc::c_long;\n    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct numname {\n    pub num: libc::c_int,\n    pub name: [libc::c_char; 8],\n}\nstatic mut numname_table: [numname; 35] = unsafe {\n    [\n        {\n            let mut init = numname {\n                num: 1 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"HUP\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 2 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"INT\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 3 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"QUIT\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 4 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"ILL\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 5 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"TRAP\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 6 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"ABRT\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 8 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"FPE\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 9 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"KILL\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 11 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"SEGV\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 7 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"BUS\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 13 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"PIPE\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 14 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"ALRM\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 15 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"TERM\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 10 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"USR1\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 12 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"USR2\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 17 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"CHLD\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 23 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"URG\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 19 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"STOP\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 20 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"TSTP\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 18 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"CONT\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 21 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"TTIN\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 22 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"TTOU\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 31 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"SYS\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 29 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"POLL\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 26 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"VTALRM\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 27 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"PROF\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 24 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"XCPU\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 25 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"XFSZ\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 6 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"IOT\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 17 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"CLD\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 30 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"PWR\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 28 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"WINCH\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 29 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"IO\\0\\0\\0\\0\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 16 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"STKFLT\\0\\0\"),\n            };\n            init\n        },\n        {\n            let mut init = numname {\n                num: 0 as libc::c_int,\n                name: *::core::mem::transmute::<\n                    &[u8; 8],\n                    &[libc::c_char; 8],\n                >(b\"EXIT\\0\\0\\0\\0\"),\n            };\n            init\n        },\n    ]\n};\nunsafe extern \"C\" fn str2signum(mut signame: *const libc::c_char) -> libc::c_int {\n    if (*signame as libc::c_uint).wrapping_sub('0' as i32 as libc::c_uint)\n        <= 9 as libc::c_int as libc::c_uint\n    {\n        let mut endp: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut n: libc::c_long = strtol(signame, &mut endp, 10 as libc::c_int);\n        if *endp == 0\n            && n\n                <= (64 as libc::c_int + 1 as libc::c_int - 1 as libc::c_int)\n                    as libc::c_long\n        {\n            return n as libc::c_int;\n        }\n    } else {\n        let mut i: libc::c_uint = 0;\n        i = 0 as libc::c_int as libc::c_uint;\n        while (i as libc::c_ulong)\n            < (::core::mem::size_of::<[numname; 35]>() as libc::c_ulong)\n                .wrapping_div(::core::mem::size_of::<numname>() as libc::c_ulong)\n        {\n            if strcmp((numname_table[i as usize].name).as_ptr(), signame)\n                == 0 as libc::c_int\n            {\n                return numname_table[i as usize].num;\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        let mut endp_0: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut rtmin: libc::c_int = __libc_current_sigrtmin();\n        let mut rtmax: libc::c_int = __libc_current_sigrtmax();\n        if (0 as libc::c_int) < rtmin\n            && strncmp(\n                signame,\n                b\"RTMIN\\0\" as *const u8 as *const libc::c_char,\n                5 as libc::c_int as libc::c_ulong,\n            ) == 0 as libc::c_int\n        {\n            let mut n_0: libc::c_long = strtol(\n                signame.offset(5 as libc::c_int as isize),\n                &mut endp_0,\n                10 as libc::c_int,\n            );\n            if *endp_0 == 0 && 0 as libc::c_int as libc::c_long <= n_0\n                && n_0 <= (rtmax - rtmin) as libc::c_long\n            {\n                return (rtmin as libc::c_long + n_0) as libc::c_int;\n            }\n        } else if (0 as libc::c_int) < rtmax\n            && strncmp(\n                signame,\n                b\"RTMAX\\0\" as *const u8 as *const libc::c_char,\n                5 as libc::c_int as libc::c_ulong,\n            ) == 0 as libc::c_int\n        {\n            let mut n_1: libc::c_long = strtol(\n                signame.offset(5 as libc::c_int as isize),\n                &mut endp_0,\n                10 as libc::c_int,\n            );\n            if *endp_0 == 0 && (rtmin - rtmax) as libc::c_long <= n_1\n                && n_1 <= 0 as libc::c_int as libc::c_long\n            {\n                return (rtmax as libc::c_long + n_1) as libc::c_int;\n            }\n        }\n    }\n    return -(1 as libc::c_int);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn str2sig(\n    mut signame: *const libc::c_char,\n    mut signum: *mut libc::c_int,\n) -> libc::c_int {\n    *signum = str2signum(signame);\n    return if *signum < 0 as libc::c_int {\n        -(1 as libc::c_int)\n    } else {\n        0 as libc::c_int\n    };\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn sig2str(\n    mut signum: libc::c_int,\n    mut signame: *mut libc::c_char,\n) -> libc::c_int {\n    let mut i: libc::c_uint = 0;\n    i = 0 as libc::c_int as libc::c_uint;\n    while (i as libc::c_ulong)\n        < (::core::mem::size_of::<[numname; 35]>() as libc::c_ulong)\n            .wrapping_div(::core::mem::size_of::<numname>() as libc::c_ulong)\n    {\n        if numname_table[i as usize].num == signum {\n            strcpy(signame, (numname_table[i as usize].name).as_ptr());\n            return 0 as libc::c_int;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    let mut rtmin: libc::c_int = __libc_current_sigrtmin();\n    let mut rtmax: libc::c_int = __libc_current_sigrtmax();\n    let mut base: libc::c_int = 0;\n    let mut delta: libc::c_int = 0;\n    if !(rtmin <= signum && signum <= rtmax) {\n        return -(1 as libc::c_int);\n    }\n    if signum <= rtmin + (rtmax - rtmin) / 2 as libc::c_int {\n        strcpy(signame, b\"RTMIN\\0\" as *const u8 as *const libc::c_char);\n        base = rtmin;\n    } else {\n        strcpy(signame, b\"RTMAX\\0\" as *const u8 as *const libc::c_char);\n        base = rtmax;\n    }\n    delta = signum - base;\n    if delta != 0 as libc::c_int {\n        sprintf(\n            signame.offset(5 as libc::c_int as isize),\n            b\"%+d\\0\" as *const u8 as *const libc::c_char,\n            delta,\n        );\n    }\n    return 0 as libc::c_int;\n}",
    "#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut, unused_imports)]\n#![feature(extern_types, label_break_value)]\nuse ::rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char) -> *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn fwrite_unlocked(\n        __ptr: *const libc::c_void,\n        __size: size_t,\n        __n: size_t,\n        __stream: *mut FILE,\n    ) -> size_t;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn fpurge(gl_stream: *mut FILE) -> libc::c_int;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    static mut optarg: *mut libc::c_char;\n    static mut optind: libc::c_int;\n    fn signal(__sig: libc::c_int, __handler: __sighandler_t) -> __sighandler_t;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;\n    fn pipe(__pipedes: *mut libc::c_int) -> libc::c_int;\n    fn dup2(__fd: libc::c_int, __fd2: libc::c_int) -> libc::c_int;\n    fn execl(\n        __path: *const libc::c_char,\n        __arg: *const libc::c_char,\n        _: ...\n    ) -> libc::c_int;\n    fn fork() -> __pid_t;\n    fn getpagesize() -> libc::c_int;\n    fn ftruncate(__fd: libc::c_int, __length: __off_t) -> libc::c_int;\n    fn waitpid(\n        __pid: __pid_t,\n        __stat_loc: *mut libc::c_int,\n        __options: libc::c_int,\n    ) -> __pid_t;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memmove(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memchr(\n        _: *const libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn rawmemchr(__s: *const libc::c_void, __c: libc::c_int) -> *mut libc::c_void;\n    fn memrchr(\n        __s: *const libc::c_void,\n        __c: libc::c_int,\n        __n: size_t,\n    ) -> *mut libc::c_void;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strspn(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_ulong;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn free(_: *mut libc::c_void);\n    fn __errno_location() -> *mut libc::c_int;\n    fn atexit(__func: Option::<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn exit(_: libc::c_int) -> !;\n    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;\n    fn setenv(\n        __name: *const libc::c_char,\n        __value: *const libc::c_char,\n        __replace: libc::c_int,\n    ) -> libc::c_int;\n    static mut Version: *const libc::c_char;\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn xalloc_die();\n    fn xmalloc(s: size_t) -> *mut libc::c_void;\n    fn xinmalloc(n: idx_t, s: idx_t) -> *mut libc::c_void;\n    fn xicalloc(n: idx_t, s: idx_t) -> *mut libc::c_void;\n    fn xirealloc(p: *mut libc::c_void, s: idx_t) -> *mut libc::c_void;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xstrdup(str: *const libc::c_char) -> *mut libc::c_char;\n    fn last_component(filename: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stdout();\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    static mut program_name: *const libc::c_char;\n    fn set_program_name(argv0: *const libc::c_char);\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn quotearg_n_style_colon(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn xalignalloc(_: idx_t, _: idx_t) -> *mut libc::c_void;\n    fn fdadvise(fd: libc::c_int, offset: off_t, len: off_t, advice: fadvice_t);\n    fn fd_reopen(\n        _: libc::c_int,\n        _: *const libc::c_char,\n        _: libc::c_int,\n        _: mode_t,\n    ) -> libc::c_int;\n    fn open_safer(_: *const libc::c_char, _: libc::c_int, _: ...) -> libc::c_int;\n    fn full_write(fd: libc::c_int, buf: *const libc::c_void, count: size_t) -> size_t;\n    fn quote_mem(arg: *const libc::c_char, argsize: size_t) -> *const libc::c_char;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn sig2str(_: libc::c_int, _: *mut libc::c_char) -> libc::c_int;\n    fn temp_stream(fp: *mut *mut FILE, file_name: *mut *mut libc::c_char) -> bool;\n    fn xdectoimax(\n        n_str: *const libc::c_char,\n        min: intmax_t,\n        max: intmax_t,\n        suffixes: *const libc::c_char,\n        err: *const libc::c_char,\n        err_exit: libc::c_int,\n    ) -> intmax_t;\n    fn xdectoumax(\n        n_str: *const libc::c_char,\n        min: uintmax_t,\n        max: uintmax_t,\n        suffixes: *const libc::c_char,\n        err: *const libc::c_char,\n        err_exit: libc::c_int,\n    ) -> uintmax_t;\n    fn xstrtoimax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut intmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n}\npub type __intmax_t = libc::c_long;\npub type __uintmax_t = libc::c_ulong;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __pid_t = libc::c_int;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __ssize_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISspace: C2RustUnnamed = 8192;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;\npub type size_t = libc::c_ulong;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type ssize_t = __ssize_t;\npub type ptrdiff_t = libc::c_long;\npub type mode_t = __mode_t;\npub type pid_t = __pid_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\npub type __sighandler_t = Option::<unsafe extern \"C\" fn(libc::c_int) -> ()>;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\npub type intmax_t = __intmax_t;\npub type uintmax_t = __uintmax_t;\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed_0 = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed_0 = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type fadvice_t = libc::c_uint;\npub const FADVISE_RANDOM: fadvice_t = 1;\npub const FADVISE_WILLNEED: fadvice_t = 3;\npub const FADVISE_DONTNEED: fadvice_t = 4;\npub const FADVISE_NOREUSE: fadvice_t = 5;\npub const FADVISE_SEQUENTIAL: fadvice_t = 2;\npub const FADVISE_NORMAL: fadvice_t = 0;\npub type C2RustUnnamed_1 = libc::c_uint;\npub const IO_BUFSIZE: C2RustUnnamed_1 = 262144;\npub type C2RustUnnamed_2 = libc::c_uint;\npub const SYS_BUFSIZE_MAX: C2RustUnnamed_2 = 2146435072;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub type Split_type = libc::c_uint;\npub const type_rr: Split_type = 7;\npub const type_chunk_lines: Split_type = 6;\npub const type_chunk_bytes: Split_type = 5;\npub const type_digits: Split_type = 4;\npub const type_lines: Split_type = 3;\npub const type_byteslines: Split_type = 2;\npub const type_bytes: Split_type = 1;\npub const type_undef: Split_type = 0;\npub type C2RustUnnamed_3 = libc::c_uint;\npub const ADDITIONAL_SUFFIX_OPTION: C2RustUnnamed_3 = 259;\npub const IO_BLKSIZE_OPTION: C2RustUnnamed_3 = 258;\npub const FILTER_OPTION: C2RustUnnamed_3 = 257;\npub const VERBOSE_OPTION: C2RustUnnamed_3 = 256;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct of_info {\n    pub of_name: *mut libc::c_char,\n    pub ofd: libc::c_int,\n    pub ofile: *mut FILE,\n    pub opid: pid_t,\n}\npub type of_t = of_info;\npub type C2RustUnnamed_4 = libc::c_int;\npub const OFD_APPEND: C2RustUnnamed_4 = -2;\npub const OFD_NEW: C2RustUnnamed_4 = -1;\n#[inline]\nunsafe extern \"C\" fn to_uchar(mut ch: libc::c_char) -> libc::c_uchar {\n    return ch as libc::c_uchar;\n}\n#[inline]\nunsafe extern \"C\" fn psame_inode(mut a: *const stat, mut b: *const stat) -> bool {\n    return (*a).st_dev ^ (*b).st_dev | (*a).st_ino ^ (*b).st_ino == 0;\n}\n#[inline]\nunsafe extern \"C\" fn emit_stdin_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nWith no FILE, or when FILE is -, read standard input.\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        stdout,\n    );\n}\n#[inline]\nunsafe extern \"C\" fn emit_mandatory_arg_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nMandatory arguments to long options are mandatory for short options too.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}\n#[inline]\nunsafe extern \"C\" fn emit_size_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\\nUnits are K,M,G,T,P,E,Z,Y,R,Q (powers of 1024) or KB,MB,... (powers of 1000).\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}\n#[inline]",
    "unsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}\n#[inline]\nunsafe extern \"C\" fn usable_st_size(mut sb: *const stat) -> bool {\n    return (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        || (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o120000 as libc::c_int as libc::c_uint\n        || ((*sb).st_mode).wrapping_sub((*sb).st_mode) != 0 || 0 as libc::c_int != 0;\n}\n#[inline]\nunsafe extern \"C\" fn write_error() {\n    let mut saved_errno: libc::c_int = *__errno_location();\n    fflush_unlocked(stdout);\n    fpurge(stdout);\n    clearerr_unlocked(stdout);\n    if 0 != 0 {\n        error(\n            1 as libc::c_int,\n            saved_errno,\n            gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n        );\n        if 1 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}\n#[inline]\nunsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[inline]\nunsafe extern \"C\" fn stdc_leading_zeros_ull(mut n: libc::c_ulonglong) -> libc::c_uint {\n    return __gl_stdbit_clzll(n) as libc::c_uint;\n}\n#[inline]\nunsafe extern \"C\" fn io_blksize(mut st: *const stat) -> idx_t {\n    let mut blocksize: idx_t = (if (if (0 as libc::c_int) < (*st).st_blksize\n        && (*st).st_blksize as libc::c_ulong\n            <= (-(1 as libc::c_int) as size_t)\n                .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        (*st).st_blksize\n    } else {\n        512 as libc::c_int\n    }) <= 0 as libc::c_int\n    {\n        IO_BUFSIZE as libc::c_int\n    } else if (0 as libc::c_int) < (*st).st_blksize\n        && (*st).st_blksize as libc::c_ulong\n            <= (-(1 as libc::c_int) as size_t)\n                .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        (*st).st_blksize\n    } else {\n        512 as libc::c_int\n    }) as idx_t;\n    blocksize\n        += (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long\n            - (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long % blocksize;\n    if (*st).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        && blocksize & blocksize - 1 as libc::c_int as libc::c_long != 0\n    {\n        let mut leading_zeros: libc::c_int = stdc_leading_zeros_ull(\n            blocksize as libc::c_ulonglong,\n        ) as libc::c_int;\n        if (9223372036854775807 as libc::c_long as libc::c_ulonglong)\n            < (9223372036854775807 as libc::c_longlong as libc::c_ulonglong)\n                .wrapping_mul(2 as libc::c_ulonglong)\n                .wrapping_add(1 as libc::c_ulonglong) || leading_zeros != 0\n        {\n            let mut power: libc::c_ulonglong = (1 as libc::c_ulonglong)\n                << 64 as libc::c_int - leading_zeros;\n            if power <= 9223372036854775807 as libc::c_long as libc::c_ulonglong {\n                blocksize = power as idx_t;\n            }\n        }\n    }\n    return (if (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n        < 18446744073709551615 as libc::c_ulong\n    {\n        9223372036854775807 as libc::c_long as libc::c_ulong\n    } else {\n        18446744073709551615 as libc::c_ulong\n    })\n        .wrapping_div(2 as libc::c_int as libc::c_ulong)\n        .wrapping_add(1 as libc::c_int as libc::c_ulong) < blocksize as libc::c_ulong\n    {\n        (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        })\n            .wrapping_div(2 as libc::c_int as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    } else {\n        blocksize as libc::c_ulong\n    }) as idx_t;\n}\n#[inline]\nunsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}\n#[inline]\nunsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[inline]\nunsafe extern \"C\" fn xset_binary_mode_error() {}\n#[inline]\nunsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}\nstatic mut filter_command: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut filter_pid: pid_t = 0;\nstatic mut open_pipes: *mut libc::c_int = 0 as *const libc::c_int as *mut libc::c_int;\nstatic mut open_pipes_alloc: idx_t = 0;\nstatic mut n_open_pipes: libc::c_int = 0;\nstatic mut default_SIGPIPE: bool = false;\nstatic mut outbase: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut outfile: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;\nstatic mut outfile_mid: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;\nstatic mut suffix_auto: bool = 1 as libc::c_int != 0;\nstatic mut suffix_length: idx_t = 0;\nstatic mut suffix_alphabet: *const libc::c_char = b\"abcdefghijklmnopqrstuvwxyz\\0\"\n    as *const u8 as *const libc::c_char;\nstatic mut numeric_suffix_start: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut additional_suffix: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut infile: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut in_stat_buf: stat = stat {\n    st_dev: 0,\n    st_ino: 0,\n    st_mode: 0,\n    st_nlink: 0,\n    st_uid: 0,\n    st_gid: 0,\n    st_rdev: 0,\n    __pad1: 0,\n    st_size: 0,\n    st_blksize: 0,\n    __pad2: 0,\n    st_blocks: 0,\n    st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n    st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n    st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n    __glibc_reserved: [0; 2],\n};\nstatic mut output_desc: libc::c_int = -(1 as libc::c_int);\nstatic mut verbose: bool = false;\nstatic mut elide_empty_files: bool = false;\nstatic mut unbuffered: bool = false;\nstatic mut eolchar: libc::c_int = -(1 as libc::c_int);\nstatic mut longopts: [option; 17] = [\n    {\n        let mut init = option {\n            name: b\"bytes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'b' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"lines\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'l' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"line-bytes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'C' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"number\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'n' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"elide-empty-files\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'e' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"unbuffered\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'u' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"suffix-length\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'a' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"additional-suffix\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: ADDITIONAL_SUFFIX_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"numeric-suffixes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 2 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'd' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"hex-suffixes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 2 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'x' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"filter\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: FILTER_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"verbose\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: VERBOSE_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"separator\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 't' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"-io-blksize\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: IO_BLKSIZE_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];\n#[inline]\nunsafe extern \"C\" fn ignorable(mut err: libc::c_int) -> bool {\n    return !filter_command.is_null() && err == 32 as libc::c_int;\n}",
    "unsafe extern \"C\" fn set_suffix_length(\n    mut n_units: intmax_t,\n    mut split_type: Split_type,\n) {\n    let mut suffix_length_needed: libc::c_int = 0 as libc::c_int;\n    if !numeric_suffix_start.is_null() {\n        suffix_auto = 0 as libc::c_int != 0;\n    }\n    if split_type as libc::c_uint == type_chunk_bytes as libc::c_int as libc::c_uint\n        || split_type as libc::c_uint == type_chunk_lines as libc::c_int as libc::c_uint\n        || split_type as libc::c_uint == type_rr as libc::c_int as libc::c_uint\n    {\n        let mut n_units_end: intmax_t = n_units - 1 as libc::c_int as libc::c_long;\n        if !numeric_suffix_start.is_null() {\n            let mut n_start: intmax_t = 0;\n            let mut e: strtol_error = xstrtoimax(\n                numeric_suffix_start,\n                0 as *mut *mut libc::c_char,\n                10 as libc::c_int,\n                &mut n_start,\n                b\"\\0\" as *const u8 as *const libc::c_char,\n            );\n            if e as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint\n                && n_start < n_units\n            {\n                let (fresh0, fresh1) = n_units_end.overflowing_add(n_start);\n                *(&mut n_units_end as *mut intmax_t) = fresh0;\n                if fresh1 {\n                    n_units_end = 9223372036854775807 as libc::c_long;\n                }\n            }\n        }\n        let mut alphabet_len: idx_t = strlen(suffix_alphabet) as idx_t;\n        loop {\n            suffix_length_needed += 1;\n            suffix_length_needed;\n            n_units_end /= alphabet_len;\n            if !(n_units_end != 0) {\n                break;\n            }\n        }\n        suffix_auto = 0 as libc::c_int != 0;\n    }\n    if suffix_length != 0 {\n        if suffix_length < suffix_length_needed as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"the suffix length needs to be at least %d\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    suffix_length_needed,\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"the suffix length needs to be at least %d\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        suffix_length_needed,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"the suffix length needs to be at least %d\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        suffix_length_needed,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        suffix_auto = 0 as libc::c_int != 0;\n        return;\n    } else {\n        suffix_length = (if 2 as libc::c_int > suffix_length_needed {\n            2 as libc::c_int\n        } else {\n            suffix_length_needed\n        }) as idx_t;\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [FILE [PREFIX]]\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Output pieces of FILE to PREFIXaa, PREFIXab, ...;\\ndefault size is 1000 lines, and default PREFIX is 'x'.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_stdin_note();\n        emit_mandatory_arg_note();\n        fprintf(\n            stdout,\n            gettext(\n                b\"  -a, --suffix-length=N   generate suffixes of length N (default %d)\\n      --additional-suffix=SUFFIX  append an additional SUFFIX to file names\\n  -b, --bytes=SIZE        put SIZE bytes per output file\\n  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file\\n  -d                      use numeric suffixes starting at 0, not alphabetic\\n      --numeric-suffixes[=FROM]  same as -d, but allow setting the start value\\n  -x                      use hex suffixes starting at 0, not alphabetic\\n      --hex-suffixes[=FROM]  same as -x, but allow setting the start value\\n  -e, --elide-empty-files  do not generate empty output files with '-n'\\n      --filter=COMMAND    write to shell COMMAND; file name is $FILE\\n  -l, --lines=NUMBER      put NUMBER lines/records per output file\\n  -n, --number=CHUNKS     generate CHUNKS output files; see explanation below\\n  -t, --separator=SEP     use SEP instead of newline as the record separator;\\n                            '\\\\0' (zero) specifies the NUL character\\n  -u, --unbuffered        immediately copy input to output with '-n r/...'\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            2 as libc::c_int,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --verbose           print a diagnostic just before each\\n                            output file is opened\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_size_note();\n        fputs_unlocked(\n            gettext(\n                b\"\\nCHUNKS may be:\\n  N       split into N files based on size of input\\n  K/N     output Kth of N to stdout\\n  l/N     split into N files without splitting lines/records\\n  l/K/N   output Kth of N to stdout without splitting lines/records\\n  r/N     like 'l' but use round robin distribution\\n  r/K/N   likewise but only output Kth of N to stdout\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_ancillary_info(b\"split\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}\nunsafe extern \"C\" fn copy_to_tmpfile(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n) -> off_t {\n    let mut tmp: *mut FILE = 0 as *mut FILE;\n    if !temp_stream(&mut tmp, 0 as *mut *mut libc::c_char) {\n        return -(1 as libc::c_int) as off_t;\n    }\n    let mut copied: off_t = 0 as libc::c_int as off_t;\n    let mut r: off_t = 0;\n    loop {\n        r = read(fd, buf as *mut libc::c_void, bufsize as size_t);\n        if !((0 as libc::c_int as libc::c_long) < r) {\n            break;\n        }\n        if fwrite_unlocked(\n            buf as *const libc::c_void,\n            1 as libc::c_int as size_t,\n            r as size_t,\n            tmp,\n        ) != r as libc::c_ulong\n        {\n            return -(1 as libc::c_int) as off_t;\n        }\n        let (fresh2, fresh3) = copied.overflowing_add(r);\n        *(&mut copied as *mut off_t) = fresh2;\n        if fresh3 {\n            *__errno_location() = 75 as libc::c_int;\n            return -(1 as libc::c_int) as off_t;\n        }\n    }\n    if r < 0 as libc::c_int as libc::c_long {\n        return r;\n    }\n    r = dup2(fileno(tmp), fd) as off_t;\n    if r < 0 as libc::c_int as libc::c_long {\n        return r;\n    }\n    if rpl_fclose(tmp) < 0 as libc::c_int {\n        return -(1 as libc::c_int) as off_t;\n    }\n    return copied;\n}\nunsafe extern \"C\" fn input_file_size(\n    mut fd: libc::c_int,\n    mut st: *const stat,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n) -> off_t {\n    let mut size: off_t = 0 as libc::c_int as off_t;\n    loop {\n        let mut n_read: ssize_t = read(\n            fd,\n            buf.offset(size as isize) as *mut libc::c_void,\n            (bufsize - size) as size_t,\n        );\n        if n_read <= 0 as libc::c_int as libc::c_long {\n            return if n_read < 0 as libc::c_int as libc::c_long { n_read } else { size };\n        }\n        size += n_read;\n        if !(size < bufsize) {\n            break;\n        }\n    }\n    let mut cur: off_t = 0;\n    let mut end: off_t = 0;\n    if usable_st_size(st) as libc::c_int != 0 && (*st).st_size < size\n        || {\n            cur = lseek(fd, 0 as libc::c_int as __off_t, 1 as libc::c_int);\n            cur < 0 as libc::c_int as libc::c_long\n        } || cur < size\n        || {\n            end = lseek(fd, 0 as libc::c_int as __off_t, 2 as libc::c_int);\n            end < 0 as libc::c_int as libc::c_long\n        }\n    {\n        let mut tmpbuf: *mut libc::c_char = xmalloc(bufsize as size_t)\n            as *mut libc::c_char;\n        end = copy_to_tmpfile(fd, tmpbuf, bufsize);\n        free(tmpbuf as *mut libc::c_void);\n        if end < 0 as libc::c_int as libc::c_long {\n            return end;\n        }\n        cur = 0 as libc::c_int as off_t;\n    }\n    if end\n        == (if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n            -(1 as libc::c_int) as off_t\n        } else {\n            (((1 as libc::c_int as off_t)\n                << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        })\n        || cur < end\n            && {\n                let (fresh4, fresh5) = size.overflowing_add(end - cur);\n                *(&mut size as *mut off_t) = fresh4;\n                fresh5 as libc::c_int != 0\n            }\n    {\n        *__errno_location() = 75 as libc::c_int;\n        return -(1 as libc::c_int) as off_t;\n    }\n    if cur < end {\n        let mut r: off_t = lseek(fd, cur, 0 as libc::c_int);\n        if r < 0 as libc::c_int as libc::c_long {\n            return r;\n        }\n    }\n    return size;\n}\nunsafe extern \"C\" fn next_file_name() {\n    static mut sufindex: *mut idx_t = 0 as *const idx_t as *mut idx_t;\n    static mut outbase_length: idx_t = 0;\n    static mut outfile_length: idx_t = 0;\n    static mut addsuf_length: idx_t = 0;\n    let mut overflow: bool = false;\n    let mut widen: bool = false;\n    let mut current_block_37: u64;\n    if outfile.is_null() {\n        overflow = false;\n        widen = false;\n        current_block_37 = 9769017674192345533;\n    } else {\n        let mut i_0: idx_t = suffix_length;\n        loop {\n            let fresh13 = i_0;\n            i_0 = i_0 - 1;\n            if !(fresh13 != 0 as libc::c_int as libc::c_long) {\n                current_block_37 = 14434620278749266018;\n                break;\n            }\n            let ref mut fresh14 = *sufindex.offset(i_0 as isize);\n            *fresh14 += 1;\n            let _ = *fresh14;\n            if suffix_auto as libc::c_int != 0 && i_0 == 0 as libc::c_int as libc::c_long\n                && *suffix_alphabet\n                    .offset(\n                        (*sufindex.offset(0 as libc::c_int as isize)\n                            + 1 as libc::c_int as libc::c_long) as isize,\n                    ) == 0\n            {\n                current_block_37 = 9769017674192345533;\n                break;\n            }\n            *outfile_mid\n                .offset(\n                    i_0 as isize,\n                ) = *suffix_alphabet.offset(*sufindex.offset(i_0 as isize) as isize);\n            if *outfile_mid.offset(i_0 as isize) != 0 {\n                return;\n            }\n            *sufindex.offset(i_0 as isize) = 0 as libc::c_int as idx_t;\n            *outfile_mid\n                .offset(\n                    i_0 as isize,\n                ) = *suffix_alphabet.offset(*sufindex.offset(i_0 as isize) as isize);\n        }\n        match current_block_37 {\n            9769017674192345533 => {}\n            _ => {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"output file suffixes exhausted\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"output file suffixes exhausted\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"output file suffixes exhausted\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                current_block_37 = 2873832966593178012;\n            }\n        }\n    }\n    match current_block_37 {\n        9769017674192345533 => {\n            widen = outfile_length != 0;\n            if !widen {\n                outbase_length = strlen(outbase) as idx_t;\n                addsuf_length = (if !additional_suffix.is_null() {\n                    strlen(additional_suffix)\n                } else {\n                    0 as libc::c_int as libc::c_ulong\n                }) as idx_t;\n                let (fresh6, fresh7) = (outbase_length + addsuf_length)\n                    .overflowing_add(suffix_length);\n                *(&mut outfile_length as *mut idx_t) = fresh6;\n                overflow = fresh7;\n            } else {\n                let (fresh8, fresh9) = outfile_length.overflowing_add((2 as libc::c_int).into());\n                *(&mut outfile_length as *mut idx_t) = fresh8;\n                overflow = fresh9;\n                suffix_length += 1;\n                suffix_length;\n            }\n            let mut outfile_size: idx_t = 0;\n            let (fresh10, fresh11) = outfile_length.overflowing_add((1 as libc::c_int).into());\n            *(&mut outfile_size as *mut idx_t) = fresh10;\n            overflow = (overflow as libc::c_int | fresh11 as libc::c_int) != 0;\n            if overflow {\n                xalloc_die();\n            }\n            outfile = xirealloc(outfile as *mut libc::c_void, outfile_size)\n                as *mut libc::c_char;\n            if !widen {\n                memcpy(\n                    outfile as *mut libc::c_void,\n                    outbase as *const libc::c_void,\n                    outbase_length as libc::c_ulong,\n                );\n            } else {\n                *outfile\n                    .offset(\n                        outbase_length as isize,\n                    ) = *suffix_alphabet\n                    .offset(*sufindex.offset(0 as libc::c_int as isize) as isize);\n                outbase_length += 1;\n                outbase_length;\n            }\n            outfile_mid = outfile.offset(outbase_length as isize);\n            memset(\n                outfile_mid as *mut libc::c_void,\n                *suffix_alphabet.offset(0 as libc::c_int as isize) as libc::c_int,\n                suffix_length as libc::c_ulong,\n            );\n            if !additional_suffix.is_null() {\n                memcpy(\n                    outfile_mid.offset(suffix_length as isize) as *mut libc::c_void,\n                    additional_suffix as *const libc::c_void,\n                    addsuf_length as libc::c_ulong,\n                );\n            }\n            *outfile.offset(outfile_length as isize) = 0 as libc::c_int as libc::c_char;\n            free(sufindex as *mut libc::c_void);\n            sufindex = xicalloc(\n                suffix_length,\n                ::core::mem::size_of::<idx_t>() as libc::c_ulong as idx_t,\n            ) as *mut idx_t;\n            if !numeric_suffix_start.is_null() {\n                if !widen {} else {\n                    __assert_fail(\n                        b\"! widen\\0\" as *const u8 as *const libc::c_char,\n                        b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                        423 as libc::c_int as libc::c_uint,\n                        (*::core::mem::transmute::<\n                            &[u8; 26],\n                            &[libc::c_char; 26],\n                        >(b\"void next_file_name(void)\\0\"))\n                            .as_ptr(),\n                    );\n                }\n                'c_9037: {\n                    if !widen {} else {\n                        __assert_fail(\n                            b\"! widen\\0\" as *const u8 as *const libc::c_char,\n                            b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                            423 as libc::c_int as libc::c_uint,\n                            (*::core::mem::transmute::<\n                                &[u8; 26],\n                                &[libc::c_char; 26],\n                            >(b\"void next_file_name(void)\\0\"))\n                                .as_ptr(),\n                        );\n                    }\n                };\n                let mut i: idx_t = strlen(numeric_suffix_start) as idx_t;\n                memcpy(\n                    outfile_mid.offset(suffix_length as isize).offset(-(i as isize))\n                        as *mut libc::c_void,\n                    numeric_suffix_start as *const libc::c_void,\n                    i as libc::c_ulong,\n                );\n                let mut sufindex_end: *mut idx_t = sufindex\n                    .offset(suffix_length as isize);\n                loop {\n                    let fresh12 = i;\n                    i = i - 1;\n                    if !(fresh12 != 0 as libc::c_int as libc::c_long) {\n                        break;\n                    }\n                    sufindex_end = sufindex_end.offset(-1);\n                    *sufindex_end = (*numeric_suffix_start.offset(i as isize)\n                        as libc::c_int - '0' as i32) as idx_t;\n                }\n            }\n        }\n        _ => {}\n    };\n}",
    "unsafe extern \"C\" fn create(mut name: *const libc::c_char) -> libc::c_int {\n    if filter_command.is_null() {\n        if verbose {\n            fprintf(\n                stdout,\n                gettext(b\"creating file %s\\n\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, name),\n            );\n        }\n        let mut oflags: libc::c_int = 0o1 as libc::c_int | 0o100 as libc::c_int\n            | 0 as libc::c_int;\n        let mut fd: libc::c_int = open_safer(\n            name,\n            oflags | 0o200 as libc::c_int,\n            0o400 as libc::c_int | 0o200 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int,\n        );\n        if 0 as libc::c_int <= fd || *__errno_location() != 17 as libc::c_int {\n            return fd;\n        }\n        fd = open_safer(\n            name,\n            oflags,\n            0o400 as libc::c_int | 0o200 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int,\n        );\n        if fd < 0 as libc::c_int {\n            return fd;\n        }\n        let mut out_stat_buf: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        if fstat(fd, &mut out_stat_buf) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, name),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if psame_inode(&mut in_stat_buf, &mut out_stat_buf) {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s would overwrite input; aborting\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, name),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s would overwrite input; aborting\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s would overwrite input; aborting\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if ftruncate(fd, 0 as libc::c_int as __off_t) < 0 as libc::c_int\n            && (out_stat_buf.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint\n                || (out_stat_buf.st_mode).wrapping_sub(out_stat_buf.st_mode) != 0)\n        {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: error truncating\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: error truncating\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: error truncating\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        return fd;\n    } else {\n        let mut fd_pair: [libc::c_int; 2] = [0; 2];\n        let mut child_pid: pid_t = 0;\n        let mut shell_prog: *const libc::c_char = getenv(\n            b\"SHELL\\0\" as *const u8 as *const libc::c_char,\n        );\n        if shell_prog.is_null() {\n            shell_prog = b\"/bin/sh\\0\" as *const u8 as *const libc::c_char;\n        }\n        if setenv(b\"FILE\\0\" as *const u8 as *const libc::c_char, name, 1 as libc::c_int)\n            != 0 as libc::c_int\n        {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to set FILE environment variable\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to set FILE environment variable\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to set FILE environment variable\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if verbose {\n            fprintf(\n                stdout,\n                gettext(\n                    b\"executing with FILE=%s\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    name,\n                ),\n            );\n        }\n        if pipe(fd_pair.as_mut_ptr()) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to create pipe\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to create pipe\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to create pipe\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        child_pid = fork();\n        if child_pid == 0 as libc::c_int {\n            let mut j: libc::c_int = 0;\n            j = 0 as libc::c_int;\n            while j < n_open_pipes {\n                if close(*open_pipes.offset(j as isize)) != 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"closing prior pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"closing prior pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"closing prior pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                j += 1;\n                j;\n            }\n            if close(fd_pair[1 as libc::c_int as usize]) != 0 {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"closing output pipe\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"closing output pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"closing output pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            if fd_pair[0 as libc::c_int as usize] != 0 as libc::c_int {\n                if dup2(fd_pair[0 as libc::c_int as usize], 0 as libc::c_int)\n                    != 0 as libc::c_int\n                {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"moving input pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"moving input pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"moving input pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                if close(fd_pair[0 as libc::c_int as usize]) != 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"closing input pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"closing input pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"closing input pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );",
    "                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n            }\n            if default_SIGPIPE {\n                signal(13 as libc::c_int, None);\n            }\n            execl(\n                shell_prog,\n                last_component(shell_prog),\n                b\"-c\\0\" as *const u8 as *const libc::c_char,\n                filter_command,\n                0 as *mut libc::c_void as *mut libc::c_char,\n            );\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to run command: \\\"%s -c %s\\\"\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    shell_prog,\n                    filter_command,\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to run command: \\\"%s -c %s\\\"\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        shell_prog,\n                        filter_command,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to run command: \\\"%s -c %s\\\"\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        shell_prog,\n                        filter_command,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if child_pid < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"fork system call failed\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"fork system call failed\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"fork system call failed\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if close(fd_pair[0 as libc::c_int as usize]) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to close input pipe\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to close input pipe\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to close input pipe\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        filter_pid = child_pid;\n        if n_open_pipes as libc::c_long == open_pipes_alloc {\n            open_pipes = xpalloc(\n                open_pipes as *mut libc::c_void,\n                &mut open_pipes_alloc,\n                1 as libc::c_int as idx_t,\n                if (2147483647 as libc::c_int as libc::c_long)\n                    < 9223372036854775807 as libc::c_long\n                {\n                    2147483647 as libc::c_int as libc::c_long\n                } else {\n                    9223372036854775807 as libc::c_long\n                },\n                ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as idx_t,\n            ) as *mut libc::c_int;\n        }\n        let fresh15 = n_open_pipes;\n        n_open_pipes = n_open_pipes + 1;\n        *open_pipes.offset(fresh15 as isize) = fd_pair[1 as libc::c_int as usize];\n        return fd_pair[1 as libc::c_int as usize];\n    };\n}",
    "unsafe extern \"C\" fn closeout(\n    mut fp: *mut FILE,\n    mut fd: libc::c_int,\n    mut pid: pid_t,\n    mut name: *const libc::c_char,\n) {\n    if !fp.is_null() && rpl_fclose(fp) != 0 as libc::c_int\n        && !ignorable(*__errno_location())\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    name,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if fd >= 0 as libc::c_int {\n        if fp.is_null() && close(fd) < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        let mut j: libc::c_int = 0;\n        j = 0 as libc::c_int;\n        while j < n_open_pipes {\n            if *open_pipes.offset(j as isize) == fd {\n                n_open_pipes -= 1;\n                *open_pipes\n                    .offset(j as isize) = *open_pipes.offset(n_open_pipes as isize);\n                break;\n            } else {\n                j += 1;\n                j;\n            }\n        }\n    }\n    if pid > 0 as libc::c_int {\n        let mut wstatus: libc::c_int = 0;\n        if waitpid(pid, &mut wstatus, 0 as libc::c_int) < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"waiting for child process\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"waiting for child process\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"waiting for child process\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else if ((wstatus & 0x7f as libc::c_int) + 1 as libc::c_int) as libc::c_schar\n            as libc::c_int >> 1 as libc::c_int > 0 as libc::c_int\n        {\n            let mut sig: libc::c_int = wstatus & 0x7f as libc::c_int;\n            if sig != 13 as libc::c_int {\n                let mut signame: [libc::c_char; 19] = [0; 19];\n                if sig2str(sig, signame.as_mut_ptr()) != 0 as libc::c_int {\n                    sprintf(\n                        signame.as_mut_ptr(),\n                        b\"%d\\0\" as *const u8 as *const libc::c_char,\n                        sig,\n                    );\n                }\n                if 0 != 0 {\n                    error(\n                        sig + 128 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"with FILE=%s, signal %s from command: %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                        signame.as_mut_ptr(),\n                        filter_command,\n                    );\n                    if sig + 128 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = sig + 128 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"with FILE=%s, signal %s from command: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                name,\n                            ),\n                            signame.as_mut_ptr(),\n                            filter_command,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = sig + 128 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"with FILE=%s, signal %s from command: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                name,\n                            ),\n                            signame.as_mut_ptr(),\n                            filter_command,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        } else if wstatus & 0x7f as libc::c_int == 0 as libc::c_int {\n            let mut ex: libc::c_int = (wstatus & 0xff00 as libc::c_int)\n                >> 8 as libc::c_int;\n            if ex != 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        ex,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"with FILE=%s, exit %d from command: %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                        ex,\n                        filter_command,\n                    );\n                    if ex != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = ex;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"with FILE=%s, exit %d from command: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                name,\n                            ),\n                            ex,\n                            filter_command,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = ex;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"with FILE=%s, exit %d from command: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                name,\n                            ),\n                            ex,\n                            filter_command,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        } else {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"unknown status from command (0x%X)\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    (wstatus as libc::c_uint).wrapping_add(0 as libc::c_uint),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"unknown status from command (0x%X)\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        (wstatus as libc::c_uint).wrapping_add(0 as libc::c_uint),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"unknown status from command (0x%X)\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        (wstatus as libc::c_uint).wrapping_add(0 as libc::c_uint),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    }\n}",
    "unsafe extern \"C\" fn cwrite(\n    mut new_file_flag: bool,\n    mut bp: *const libc::c_char,\n    mut bytes: idx_t,\n) -> bool {\n    if new_file_flag {\n        if bp.is_null() && bytes == 0 as libc::c_int as libc::c_long\n            && elide_empty_files as libc::c_int != 0\n        {\n            return 1 as libc::c_int != 0;\n        }\n        closeout(0 as *mut FILE, output_desc, filter_pid, outfile);\n        next_file_name();\n        output_desc = create(outfile);\n        if output_desc < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        outfile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            outfile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            outfile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    }\n    if full_write(output_desc, bp as *const libc::c_void, bytes as size_t)\n        == bytes as libc::c_ulong\n    {\n        return 1 as libc::c_int != 0\n    } else {\n        if !ignorable(*__errno_location()) {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        outfile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            outfile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            outfile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        return 0 as libc::c_int != 0;\n    };\n}\nunsafe extern \"C\" fn bytes_split(\n    mut n_bytes: intmax_t,\n    mut rem_bytes: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n    mut initial_read: ssize_t,\n    mut max_files: intmax_t,\n) {\n    let mut new_file_flag: bool = 1 as libc::c_int != 0;\n    let mut filter_ok: bool = 1 as libc::c_int != 0;\n    let mut opened: intmax_t = 0 as libc::c_int as intmax_t;\n    let mut to_write: intmax_t = n_bytes\n        + ((0 as libc::c_int as libc::c_long) < rem_bytes) as libc::c_int\n            as libc::c_long;\n    let mut eof: bool = to_write == 0;\n    while !eof {\n        let mut n_read: ssize_t = 0;\n        if 0 as libc::c_int as libc::c_long <= initial_read {\n            n_read = initial_read;\n            initial_read = -(1 as libc::c_int) as ssize_t;\n            eof = n_read < bufsize;\n        } else {\n            if !filter_ok\n                && 0 as libc::c_int as libc::c_long\n                    <= lseek(0 as libc::c_int, to_write, 1 as libc::c_int)\n            {\n                to_write = n_bytes\n                    + ((opened + 1 as libc::c_int as libc::c_long) < rem_bytes)\n                        as libc::c_int as libc::c_long;\n                new_file_flag = 1 as libc::c_int != 0;\n            }\n            n_read = read(0 as libc::c_int, buf as *mut libc::c_void, bufsize as size_t);\n            if n_read < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            eof = n_read == 0 as libc::c_int as libc::c_long;\n        }\n        let mut bp_out: *mut libc::c_char = buf;\n        while (0 as libc::c_int as libc::c_long) < to_write && to_write <= n_read {\n            if filter_ok as libc::c_int != 0 || new_file_flag as libc::c_int != 0 {\n                filter_ok = cwrite(new_file_flag, bp_out, to_write);\n            }\n            opened += new_file_flag as libc::c_long;\n            new_file_flag = max_files == 0 || opened < max_files;\n            if !filter_ok && !new_file_flag {\n                n_read = 0 as libc::c_int as ssize_t;\n                eof = 1 as libc::c_int != 0;\n                break;\n            } else {\n                bp_out = bp_out.offset(to_write as isize);\n                n_read -= to_write;\n                to_write = n_bytes + (opened < rem_bytes) as libc::c_int as libc::c_long;\n            }\n        }\n        if !((0 as libc::c_int as libc::c_long) < n_read) {\n            continue;\n        }\n        if filter_ok as libc::c_int != 0 || new_file_flag as libc::c_int != 0 {\n            filter_ok = cwrite(new_file_flag, bp_out, n_read);\n        }\n        opened += new_file_flag as libc::c_long;\n        new_file_flag = 0 as libc::c_int != 0;\n        if !filter_ok && opened == max_files {\n            break;\n        }\n        to_write -= n_read;\n    }\n    loop {\n        let fresh16 = opened;\n        opened = opened + 1;\n        if !(fresh16 < max_files) {\n            break;\n        }\n        cwrite(\n            1 as libc::c_int != 0,\n            0 as *const libc::c_char,\n            0 as libc::c_int as idx_t,\n        );\n    };\n}\nunsafe extern \"C\" fn lines_split(\n    mut n_lines: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n) {\n    let mut n_read: ssize_t = 0;\n    let mut bp: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut bp_out: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut eob: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut new_file_flag: bool = 1 as libc::c_int != 0;\n    let mut n: intmax_t = 0 as libc::c_int as intmax_t;\n    loop {\n        n_read = read(0 as libc::c_int, buf as *mut libc::c_void, bufsize as size_t);\n        if n_read < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        bp_out = buf;\n        bp = bp_out;\n        eob = bp.offset(n_read as isize);\n        *eob = eolchar as libc::c_char;\n        loop {\n            bp = rawmemchr(bp as *const libc::c_void, eolchar) as *mut libc::c_char;\n            if bp == eob {\n                if eob != bp_out {\n                    let mut len: idx_t = eob.offset_from(bp_out) as libc::c_long;\n                    cwrite(new_file_flag, bp_out, len);\n                    new_file_flag = 0 as libc::c_int != 0;\n                }\n                break;\n            } else {\n                bp = bp.offset(1);\n                bp;\n                n += 1;\n                if n >= n_lines {\n                    cwrite(\n                        new_file_flag,\n                        bp_out,\n                        bp.offset_from(bp_out) as libc::c_long,\n                    );\n                    bp_out = bp;\n                    new_file_flag = 1 as libc::c_int != 0;\n                    n = 0 as libc::c_int as intmax_t;\n                }\n            }\n        }\n        if !(n_read != 0) {\n            break;\n        }\n    };\n}",
    "unsafe extern \"C\" fn line_bytes_split(\n    mut n_bytes: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n) {\n    let mut n_read: ssize_t = 0;\n    let mut n_out: intmax_t = 0 as libc::c_int as intmax_t;\n    let mut n_hold: idx_t = 0 as libc::c_int as idx_t;\n    let mut hold: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut hold_size: idx_t = 0 as libc::c_int as idx_t;\n    let mut split_line: bool = 0 as libc::c_int != 0;\n    loop {\n        n_read = read(0 as libc::c_int, buf as *mut libc::c_void, bufsize as size_t);\n        if n_read < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        let mut n_left: idx_t = n_read;\n        let mut sob: *mut libc::c_char = buf;\n        while n_left != 0 {\n            let mut split_rest: idx_t = 0 as libc::c_int as idx_t;\n            let mut eoc: *mut libc::c_char = 0 as *mut libc::c_char;\n            let mut eol: *mut libc::c_char = 0 as *mut libc::c_char;\n            if n_bytes - n_out - n_hold <= n_left {\n                split_rest = n_bytes - n_out - n_hold;\n                eoc = sob\n                    .offset(split_rest as isize)\n                    .offset(-(1 as libc::c_int as isize));\n                eol = memrchr(sob as *const libc::c_void, eolchar, split_rest as size_t)\n                    as *mut libc::c_char;\n            } else {\n                eol = memrchr(sob as *const libc::c_void, eolchar, n_left as size_t)\n                    as *mut libc::c_char;\n            }\n            if n_hold != 0 && !(eol.is_null() && n_out != 0) {\n                cwrite(n_out == 0 as libc::c_int as libc::c_long, hold, n_hold);\n                n_out += n_hold;\n                n_hold = 0 as libc::c_int as idx_t;\n            }\n            if !eol.is_null() {\n                split_line = 1 as libc::c_int != 0;\n                let mut n_write: idx_t = eol.offset_from(sob) as libc::c_long\n                    + 1 as libc::c_int as libc::c_long;\n                cwrite(n_out == 0 as libc::c_int as libc::c_long, sob, n_write);\n                n_out += n_write;\n                n_left -= n_write;\n                sob = sob.offset(n_write as isize);\n                if !eoc.is_null() {\n                    split_rest -= n_write;\n                }\n            }\n            if n_left != 0 && !split_line {\n                let mut n_write_0: idx_t = if !eoc.is_null() {\n                    split_rest\n                } else {\n                    n_left\n                };\n                cwrite(n_out == 0 as libc::c_int as libc::c_long, sob, n_write_0);\n                n_out += n_write_0;\n                n_left -= n_write_0;\n                sob = sob.offset(n_write_0 as isize);\n                if !eoc.is_null() {\n                    split_rest -= n_write_0;\n                }\n            }\n            if !eoc.is_null() && split_rest != 0 || eoc.is_null() && n_left != 0 {\n                let mut n_buf: idx_t = if !eoc.is_null() { split_rest } else { n_left };\n                if hold_size - n_hold < n_buf {\n                    hold = xpalloc(\n                        hold as *mut libc::c_void,\n                        &mut hold_size,\n                        n_buf - (hold_size - n_hold),\n                        -(1 as libc::c_int) as ptrdiff_t,\n                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong as idx_t,\n                    ) as *mut libc::c_char;\n                }\n                memcpy(\n                    hold.offset(n_hold as isize) as *mut libc::c_void,\n                    sob as *const libc::c_void,\n                    n_buf as libc::c_ulong,\n                );\n                n_hold += n_buf;\n                n_left -= n_buf;\n                sob = sob.offset(n_buf as isize);\n            }\n            if !eoc.is_null() {\n                n_out = 0 as libc::c_int as intmax_t;\n                split_line = 0 as libc::c_int != 0;\n            }\n        }\n        if !(n_read != 0) {\n            break;\n        }\n    }\n    if n_hold != 0 {\n        cwrite(n_out == 0 as libc::c_int as libc::c_long, hold, n_hold);\n    }\n    free(hold as *mut libc::c_void);\n}\nunsafe extern \"C\" fn lines_chunk_split(\n    mut k: intmax_t,\n    mut n: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n    mut initial_read: ssize_t,\n    mut file_size: off_t,\n) {\n    if n != 0 && k <= n {} else {\n        __assert_fail(\n            b\"n && k <= n\\0\" as *const u8 as *const libc::c_char,\n            b\"split.c\\0\" as *const u8 as *const libc::c_char,\n            880 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 74],\n                &[libc::c_char; 74],\n            >(\n                b\"void lines_chunk_split(intmax_t, intmax_t, char *, idx_t, ssize_t, off_t)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_13572: {\n        if n != 0 && k <= n {} else {\n            __assert_fail(\n                b\"n && k <= n\\0\" as *const u8 as *const libc::c_char,\n                b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                880 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 74],\n                    &[libc::c_char; 74],\n                >(\n                    b\"void lines_chunk_split(intmax_t, intmax_t, char *, idx_t, ssize_t, off_t)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    let mut rem_bytes: intmax_t = file_size % n;\n    let mut chunk_size: off_t = file_size / n;\n    let mut chunk_no: intmax_t = 1 as libc::c_int as intmax_t;\n    let mut chunk_end: off_t = chunk_size\n        + ((0 as libc::c_int as libc::c_long) < rem_bytes) as libc::c_int\n            as libc::c_long;\n    let mut n_written: off_t = 0 as libc::c_int as off_t;\n    let mut new_file_flag: bool = 1 as libc::c_int != 0;\n    let mut chunk_truncated: bool = 0 as libc::c_int != 0;\n    if k > 1 as libc::c_int as libc::c_long\n        && (0 as libc::c_int as libc::c_long) < file_size\n    {\n        let mut start: off_t = (k - 1 as libc::c_int as libc::c_long) * chunk_size\n            + (if (k - 1 as libc::c_int as libc::c_long) < rem_bytes {\n                k - 1 as libc::c_int as libc::c_long\n            } else {\n                rem_bytes\n            }) - 1 as libc::c_int as libc::c_long;\n        if start < initial_read {\n            memmove(\n                buf as *mut libc::c_void,\n                buf.offset(start as isize) as *const libc::c_void,\n                (initial_read - start) as libc::c_ulong,\n            );\n            initial_read -= start;\n        } else {\n            if initial_read < start\n                && lseek(0 as libc::c_int, start - initial_read, 1 as libc::c_int)\n                    < 0 as libc::c_int as libc::c_long\n            {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            initial_read = -(1 as libc::c_int) as ssize_t;\n        }\n        n_written = start;\n        chunk_no = k - 1 as libc::c_int as libc::c_long;\n        chunk_end = start + 1 as libc::c_int as libc::c_long;\n    }\n    while n_written < file_size {\n        let mut bp: *mut libc::c_char = buf;\n        let mut eob: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut n_read: ssize_t = 0;\n        if 0 as libc::c_int as libc::c_long <= initial_read {\n            n_read = initial_read;\n            initial_read = -(1 as libc::c_int) as ssize_t;\n        } else {\n            n_read = read(\n                0 as libc::c_int,\n                buf as *mut libc::c_void,\n                (if bufsize < file_size - n_written {\n                    bufsize\n                } else {\n                    file_size - n_written\n                }) as size_t,\n            );\n            if n_read < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        }\n        if n_read == 0 as libc::c_int as libc::c_long {\n            break;\n        }\n        chunk_truncated = 0 as libc::c_int != 0;\n        eob = buf.offset(n_read as isize);\n        while bp != eob {\n            let mut to_write: idx_t = 0;\n            let mut next: bool = 0 as libc::c_int != 0;\n            let mut skip: off_t = if n_read\n                < (if 0 as libc::c_int as libc::c_long\n                    > chunk_end - 1 as libc::c_int as libc::c_long - n_written\n                {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    chunk_end - 1 as libc::c_int as libc::c_long - n_written\n                })\n            {\n                n_read\n            } else if 0 as libc::c_int as libc::c_long\n                > chunk_end - 1 as libc::c_int as libc::c_long - n_written\n            {\n                0 as libc::c_int as libc::c_long\n            } else {\n                chunk_end - 1 as libc::c_int as libc::c_long - n_written\n            };\n            let mut bp_out: *mut libc::c_char = memchr(\n                bp.offset(skip as isize) as *const libc::c_void,\n                eolchar,\n                (n_read - skip) as libc::c_ulong,\n            ) as *mut libc::c_char;\n            if !bp_out.is_null() {\n                bp_out = bp_out.offset(1);\n                bp_out;\n                next = 1 as libc::c_int != 0;\n            } else {\n                bp_out = eob;\n            }\n            to_write = bp_out.offset_from(bp) as libc::c_long;\n            if k == chunk_no {\n                if full_write(\n                    1 as libc::c_int,\n                    bp as *const libc::c_void,\n                    to_write as size_t,\n                ) != to_write as libc::c_ulong\n                {\n                    write_error();\n                }\n            } else if k == 0 {\n                cwrite(new_file_flag, bp, to_write);\n            }\n            n_written += to_write;\n            bp = bp.offset(to_write as isize);\n            n_read -= to_write;\n            new_file_flag = next;\n            while next as libc::c_int != 0 || chunk_end <= n_written {\n                if !next && bp == eob {\n                    chunk_truncated = 1 as libc::c_int != 0;\n                    break;\n                } else {\n                    if k == chunk_no {\n                        return;\n                    }\n                    chunk_end\n                        += chunk_size\n                            + (chunk_no < rem_bytes) as libc::c_int as libc::c_long;\n                    chunk_no += 1;\n                    chunk_no;\n                    if chunk_end <= n_written {\n                        if k == 0 {\n                            cwrite(\n                                1 as libc::c_int != 0,\n                                0 as *const libc::c_char,\n                                0 as libc::c_int as idx_t,\n                            );\n                        }\n                    } else {\n                        next = 0 as libc::c_int != 0;\n                    }\n                }\n            }\n        }\n    }\n    if chunk_truncated {\n        chunk_no += 1;\n        chunk_no;\n    }\n    if k == 0 {\n        loop {\n            let fresh17 = chunk_no;\n            chunk_no = chunk_no + 1;\n            if !(fresh17 <= n) {\n                break;\n            }\n            cwrite(\n                1 as libc::c_int != 0,\n                0 as *const libc::c_char,\n                0 as libc::c_int as idx_t,\n            );\n        }\n    }\n}",
    "unsafe extern \"C\" fn bytes_chunk_extract(\n    mut k: intmax_t,\n    mut n: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n    mut initial_read: ssize_t,\n    mut file_size: off_t,\n) {\n    let mut start: off_t = 0;\n    let mut end: off_t = 0;\n    if (0 as libc::c_int as libc::c_long) < k && k <= n {} else {\n        __assert_fail(\n            b\"0 < k && k <= n\\0\" as *const u8 as *const libc::c_char,\n            b\"split.c\\0\" as *const u8 as *const libc::c_char,\n            1009 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 76],\n                &[libc::c_char; 76],\n            >(\n                b\"void bytes_chunk_extract(intmax_t, intmax_t, char *, idx_t, ssize_t, off_t)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_14132: {\n        if (0 as libc::c_int as libc::c_long) < k && k <= n {} else {\n            __assert_fail(\n                b\"0 < k && k <= n\\0\" as *const u8 as *const libc::c_char,\n                b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                1009 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 76],\n                    &[libc::c_char; 76],\n                >(\n                    b\"void bytes_chunk_extract(intmax_t, intmax_t, char *, idx_t, ssize_t, off_t)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    start = (k - 1 as libc::c_int as libc::c_long) * (file_size / n)\n        + (if (k - 1 as libc::c_int as libc::c_long) < file_size % n {\n            k - 1 as libc::c_int as libc::c_long\n        } else {\n            file_size % n\n        });\n    end = if k == n {\n        file_size\n    } else {\n        k * (file_size / n) + (if k < file_size % n { k } else { file_size % n })\n    };\n    if start < initial_read {\n        memmove(\n            buf as *mut libc::c_void,\n            buf.offset(start as isize) as *const libc::c_void,\n            (initial_read - start) as libc::c_ulong,\n        );\n        initial_read -= start;\n    } else {\n        if initial_read < start\n            && lseek(0 as libc::c_int, start - initial_read, 1 as libc::c_int)\n                < 0 as libc::c_int as libc::c_long\n        {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        initial_read = -(1 as libc::c_int) as ssize_t;\n    }\n    while start < end {\n        let mut n_read: ssize_t = 0;\n        if 0 as libc::c_int as libc::c_long <= initial_read {\n            n_read = initial_read;\n            initial_read = -(1 as libc::c_int) as ssize_t;\n        } else {\n            n_read = read(0 as libc::c_int, buf as *mut libc::c_void, bufsize as size_t);\n            if n_read < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        }\n        if n_read == 0 as libc::c_int as libc::c_long {\n            break;\n        }\n        n_read = if n_read < end - start { n_read } else { end - start };\n        if full_write(1 as libc::c_int, buf as *const libc::c_void, n_read as size_t)\n            != n_read as libc::c_ulong && !ignorable(*__errno_location())\n        {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        b\"-\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            b\"-\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            b\"-\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        start += n_read;\n    }\n}\nunsafe extern \"C\" fn ofile_open(\n    mut files: *mut of_t,\n    mut i_check: idx_t,\n    mut nfiles: idx_t,\n) -> bool {\n    let mut file_limit: bool = 0 as libc::c_int != 0;\n    if (*files.offset(i_check as isize)).ofd <= OFD_NEW as libc::c_int {\n        let mut fd: libc::c_int = 0;\n        let mut i_reopen: idx_t = if i_check != 0 {\n            i_check - 1 as libc::c_int as libc::c_long\n        } else {\n            nfiles - 1 as libc::c_int as libc::c_long\n        };\n        loop {\n            if (*files.offset(i_check as isize)).ofd == OFD_NEW as libc::c_int {\n                fd = create((*files.offset(i_check as isize)).of_name);\n            } else {\n                fd = open_safer(\n                    (*files.offset(i_check as isize)).of_name,\n                    0o1 as libc::c_int | 0 as libc::c_int | 0o2000 as libc::c_int\n                        | 0o4000 as libc::c_int,\n                );\n            }\n            if 0 as libc::c_int <= fd {\n                break;\n            }\n            if !(*__errno_location() == 24 as libc::c_int\n                || *__errno_location() == 23 as libc::c_int)\n            {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            (*files.offset(i_check as isize)).of_name,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_check as isize)).of_name,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_check as isize)).of_name,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            file_limit = 1 as libc::c_int != 0;\n            while (*files.offset(i_reopen as isize)).ofd < 0 as libc::c_int {\n                i_reopen = if i_reopen != 0 {\n                    i_reopen - 1 as libc::c_int as libc::c_long\n                } else {\n                    nfiles - 1 as libc::c_int as libc::c_long\n                };\n                if i_reopen == i_check {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_check as isize)).of_name,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_check as isize)).of_name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_check as isize)).of_name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n            }\n            if rpl_fclose((*files.offset(i_reopen as isize)).ofile) != 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            (*files.offset(i_reopen as isize)).of_name,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_reopen as isize)).of_name,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_reopen as isize)).of_name,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            let ref mut fresh18 = (*files.offset(i_reopen as isize)).ofile;\n            *fresh18 = 0 as *mut FILE;\n            (*files.offset(i_reopen as isize)).ofd = OFD_APPEND as libc::c_int;\n        }\n        (*files.offset(i_check as isize)).ofd = fd;\n        let mut ofile: *mut FILE = fdopen(\n            fd,\n            b\"a\\0\" as *const u8 as *const libc::c_char,\n        );\n        if ofile.is_null() {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        (*files.offset(i_check as isize)).of_name,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            (*files.offset(i_check as isize)).of_name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            (*files.offset(i_check as isize)).of_name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        let ref mut fresh19 = (*files.offset(i_check as isize)).ofile;\n        *fresh19 = ofile;\n        (*files.offset(i_check as isize)).opid = filter_pid;\n        filter_pid = 0 as libc::c_int;\n    }\n    return file_limit;\n}",
    "unsafe extern \"C\" fn lines_rr(\n    mut k: intmax_t,\n    mut n: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n    mut filesp: *mut *mut of_t,\n) {\n    let mut wrapped: bool = 0 as libc::c_int != 0;\n    let mut wrote: bool = 0 as libc::c_int != 0;\n    let mut file_limit: bool = false;\n    let mut i_file: idx_t = 0;\n    let mut files: *mut of_t = 0 as *mut of_t;\n    let mut line_no: intmax_t = 0;\n    if k != 0 {\n        line_no = 1 as libc::c_int as intmax_t;\n    } else {\n        if (9223372036854775807 as libc::c_long) < n {\n            xalloc_die();\n        }\n        *filesp = xinmalloc(n, ::core::mem::size_of::<of_t>() as libc::c_ulong as idx_t)\n            as *mut of_t;\n        files = *filesp;\n        i_file = 0 as libc::c_int as idx_t;\n        while i_file < n {\n            next_file_name();\n            let ref mut fresh20 = (*files.offset(i_file as isize)).of_name;\n            *fresh20 = xstrdup(outfile);\n            (*files.offset(i_file as isize)).ofd = OFD_NEW as libc::c_int;\n            let ref mut fresh21 = (*files.offset(i_file as isize)).ofile;\n            *fresh21 = 0 as *mut FILE;\n            (*files.offset(i_file as isize)).opid = 0 as libc::c_int;\n            i_file += 1;\n            i_file;\n        }\n        i_file = 0 as libc::c_int as idx_t;\n        file_limit = 0 as libc::c_int != 0;\n    }\n    's_76: loop {\n        let mut bp: *mut libc::c_char = buf;\n        let mut eob: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut n_read: ssize_t = read(\n            0 as libc::c_int,\n            buf as *mut libc::c_void,\n            bufsize as size_t,\n        );\n        if n_read < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else if n_read == 0 as libc::c_int as libc::c_long {\n            break;\n        }\n        eob = buf.offset(n_read as isize);\n        while bp != eob {\n            let mut to_write: idx_t = 0;\n            let mut next: bool = 0 as libc::c_int != 0;\n            let mut bp_out: *mut libc::c_char = memchr(\n                bp as *const libc::c_void,\n                eolchar,\n                eob.offset_from(bp) as libc::c_long as libc::c_ulong,\n            ) as *mut libc::c_char;\n            if !bp_out.is_null() {\n                bp_out = bp_out.offset(1);\n                bp_out;\n                next = 1 as libc::c_int != 0;\n            } else {\n                bp_out = eob;\n            }\n            to_write = bp_out.offset_from(bp) as libc::c_long;\n            if k != 0 {\n                if line_no == k && unbuffered as libc::c_int != 0 {\n                    if full_write(\n                        1 as libc::c_int,\n                        bp as *const libc::c_void,\n                        to_write as size_t,\n                    ) != to_write as libc::c_ulong\n                    {\n                        write_error();\n                    }\n                } else if line_no == k\n                    && fwrite_unlocked(\n                        bp as *const libc::c_void,\n                        to_write as size_t,\n                        1 as libc::c_int as size_t,\n                        stdout,\n                    ) != 1 as libc::c_int as libc::c_ulong\n                {\n                    write_error();\n                }\n                if next {\n                    line_no = if line_no == n {\n                        1 as libc::c_int as libc::c_long\n                    } else {\n                        line_no + 1 as libc::c_int as libc::c_long\n                    };\n                }\n            } else {\n                file_limit = (file_limit as libc::c_int\n                    | ofile_open(files, i_file, n) as libc::c_int) != 0;\n                if unbuffered {\n                    if full_write(\n                        (*files.offset(i_file as isize)).ofd,\n                        bp as *const libc::c_void,\n                        to_write as size_t,\n                    ) != to_write as libc::c_ulong && !ignorable(*__errno_location())\n                    {\n                        if 0 != 0 {\n                            error(\n                                1 as libc::c_int,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_file as isize)).of_name,\n                                ),\n                            );\n                            if 1 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        (*files.offset(i_file as isize)).of_name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        (*files.offset(i_file as isize)).of_name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    }\n                } else if fwrite_unlocked(\n                    bp as *const libc::c_void,\n                    to_write as size_t,\n                    1 as libc::c_int as size_t,\n                    (*files.offset(i_file as isize)).ofile,\n                ) != 1 as libc::c_int as libc::c_ulong && !ignorable(*__errno_location())\n                {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_file as isize)).of_name,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_file as isize)).of_name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_file as isize)).of_name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                if !ignorable(*__errno_location()) {\n                    wrote = 1 as libc::c_int != 0;\n                }\n                if file_limit {\n                    if rpl_fclose((*files.offset(i_file as isize)).ofile)\n                        != 0 as libc::c_int\n                    {\n                        if 0 != 0 {\n                            error(\n                                1 as libc::c_int,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_file as isize)).of_name,\n                                ),\n                            );\n                            if 1 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        (*files.offset(i_file as isize)).of_name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        (*files.offset(i_file as isize)).of_name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    }\n                    let ref mut fresh22 = (*files.offset(i_file as isize)).ofile;\n                    *fresh22 = 0 as *mut FILE;\n                    (*files.offset(i_file as isize)).ofd = OFD_APPEND as libc::c_int;\n                }\n                if next as libc::c_int != 0\n                    && {\n                        i_file += 1;\n                        i_file == n\n                    }\n                {\n                    wrapped = 1 as libc::c_int != 0;\n                    if !wrote {\n                        break 's_76;\n                    }\n                    wrote = 0 as libc::c_int != 0;\n                    i_file = 0 as libc::c_int as idx_t;\n                }\n            }\n            bp = bp_out;\n        }\n    }\n    if k == 0 {\n        let mut ceiling: idx_t = if wrapped as libc::c_int != 0 { n } else { i_file };\n        i_file = 0 as libc::c_int as idx_t;\n        while i_file < n {\n            if i_file >= ceiling && !elide_empty_files {\n                file_limit = (file_limit as libc::c_int\n                    | ofile_open(files, i_file, n) as libc::c_int) != 0;\n            }\n            if (*files.offset(i_file as isize)).ofd >= 0 as libc::c_int {\n                closeout(\n                    (*files.offset(i_file as isize)).ofile,\n                    (*files.offset(i_file as isize)).ofd,\n                    (*files.offset(i_file as isize)).opid,\n                    (*files.offset(i_file as isize)).of_name,\n                );\n            }\n            (*files.offset(i_file as isize)).ofd = OFD_APPEND as libc::c_int;\n            i_file += 1;\n            i_file;\n        }\n    }\n}\nunsafe extern \"C\" fn strtoint_die(\n    mut msgid: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) {\n    if 0 != 0 {\n        error(\n            1 as libc::c_int,\n            if *__errno_location() == 22 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                *__errno_location()\n            },\n            b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n            gettext(msgid),\n            quote(arg),\n        );\n        if 1 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                gettext(msgid),\n                quote(arg),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                gettext(msgid),\n                quote(arg),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}\nunsafe extern \"C\" fn parse_n_units(\n    mut arg: *const libc::c_char,\n    mut multipliers: *const libc::c_char,\n    mut msgid: *const libc::c_char,\n) -> intmax_t {\n    let mut n: intmax_t = 0;\n    if (LONGINT_OVERFLOW as libc::c_int as libc::c_uint)\n        < xstrtoimax(\n            arg,\n            0 as *mut *mut libc::c_char,\n            10 as libc::c_int,\n            &mut n,\n            multipliers,\n        ) as libc::c_uint || n < 1 as libc::c_int as libc::c_long\n    {\n        strtoint_die(msgid, arg);\n    }\n    return n;\n}",
    "unsafe extern \"C\" fn parse_chunk(\n    mut k_units: *mut intmax_t,\n    mut n_units: *mut intmax_t,\n    mut arg: *const libc::c_char,\n) {\n    let mut argend: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut e: strtol_error = xstrtoimax(\n        arg,\n        &mut argend,\n        10 as libc::c_int,\n        n_units,\n        b\"\\0\" as *const u8 as *const libc::c_char,\n    );\n    if e as libc::c_uint == LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint\n        && *argend as libc::c_int == '/' as i32\n    {\n        *k_units = *n_units;\n        *n_units = parse_n_units(\n            argend.offset(1 as libc::c_int as isize),\n            b\"\\0\" as *const u8 as *const libc::c_char,\n            b\"invalid number of chunks\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !((0 as libc::c_int as libc::c_long) < *k_units && *k_units <= *n_units) {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(\n                        b\"invalid chunk number\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_mem(arg, argend.offset_from(arg) as libc::c_long as size_t),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        gettext(\n                            b\"invalid chunk number\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quote_mem(arg, argend.offset_from(arg) as libc::c_long as size_t),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        gettext(\n                            b\"invalid chunk number\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quote_mem(arg, argend.offset_from(arg) as libc::c_long as size_t),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    } else if !(e as libc::c_uint <= LONGINT_OVERFLOW as libc::c_int as libc::c_uint\n        && (0 as libc::c_int as libc::c_long) < *n_units)\n    {\n        strtoint_die(\n            b\"invalid number of chunks\\0\" as *const u8 as *const libc::c_char,\n            arg,\n        );\n    }\n}",
    "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut split_type: Split_type = type_undef;\n    let mut in_blk_size: idx_t = 0 as libc::c_int as idx_t;\n    let mut page_size: idx_t = getpagesize() as idx_t;\n    let mut k_units: intmax_t = 0 as libc::c_int as intmax_t;\n    let mut n_units: intmax_t = 0 as libc::c_int as intmax_t;\n    static mut multipliers: [libc::c_char; 15] = unsafe {\n        *::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b\"bEGKkMmPQRTYZ0\\0\")\n    };\n    let mut c: libc::c_int = 0;\n    let mut digits_optind: libc::c_int = 0 as libc::c_int;\n    let mut file_size: off_t = if (0 as libc::c_int as off_t)\n        < -(1 as libc::c_int) as off_t\n    {\n        -(1 as libc::c_int) as off_t\n    } else {\n        (((1 as libc::c_int as off_t)\n            << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n            - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n            + 1 as libc::c_int as libc::c_long\n    };\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    infile = b\"-\\0\" as *const u8 as *const libc::c_char;\n    outbase = b\"x\\0\" as *const u8 as *const libc::c_char;\n    loop {\n        let mut this_optind: libc::c_int = if optind != 0 {\n            optind\n        } else {\n            1 as libc::c_int\n        };\n        c = getopt_long(\n            argc,\n            argv,\n            b\"0123456789C:a:b:del:n:t:ux\\0\" as *const u8 as *const libc::c_char,\n            longopts.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if c == -(1 as libc::c_int) {\n            break;\n        }\n        match c {\n            97 => {\n                suffix_length = xdectoimax(\n                    optarg,\n                    0 as libc::c_int as intmax_t,\n                    9223372036854775807 as libc::c_long,\n                    b\"\\0\" as *const u8 as *const libc::c_char,\n                    gettext(\n                        b\"invalid suffix length\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as libc::c_int,\n                );\n            }\n            259 => {\n                let mut suffix_len: libc::c_int = strlen(optarg) as libc::c_int;\n                if last_component(optarg) != optarg\n                    || suffix_len != 0\n                        && *optarg.offset((suffix_len - 1 as libc::c_int) as isize)\n                            as libc::c_int == '/' as i32\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"invalid suffix %s, contains directory separator\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                            quote(optarg),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid suffix %s, contains directory separator\\0\"\n                                        as *const u8 as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid suffix %s, contains directory separator\\0\"\n                                        as *const u8 as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n                additional_suffix = optarg;\n            }\n            98 => {\n                if split_type as libc::c_uint\n                    != type_undef as libc::c_int as libc::c_uint\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"cannot split in more than one way\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n                split_type = type_bytes;\n                n_units = parse_n_units(\n                    optarg,\n                    multipliers.as_ptr(),\n                    b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char,\n                );\n            }\n            108 => {\n                if split_type as libc::c_uint\n                    != type_undef as libc::c_int as libc::c_uint\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"cannot split in more than one way\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n                split_type = type_lines;\n                n_units = parse_n_units(\n                    optarg,\n                    b\"\\0\" as *const u8 as *const libc::c_char,\n                    b\"invalid number of lines\\0\" as *const u8 as *const libc::c_char,\n                );\n            }\n            67 => {\n                if split_type as libc::c_uint\n                    != type_undef as libc::c_int as libc::c_uint\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"cannot split in more than one way\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n                split_type = type_byteslines;\n                n_units = parse_n_units(\n                    optarg,\n                    multipliers.as_ptr(),\n                    b\"invalid number of lines\\0\" as *const u8 as *const libc::c_char,\n                );\n            }\n            110 => {\n                if split_type as libc::c_uint\n                    != type_undef as libc::c_int as libc::c_uint\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"cannot split in more than one way\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n                while *(*__ctype_b_loc())\n                    .offset(to_uchar(*optarg) as libc::c_int as isize) as libc::c_int\n                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n                {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                if strncmp(\n                    optarg,\n                    b\"r/\\0\" as *const u8 as *const libc::c_char,\n                    (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong)\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                ) == 0 as libc::c_int\n                {\n                    split_type = type_rr;\n                    optarg = optarg.offset(2 as libc::c_int as isize);\n                } else if strncmp(\n                    optarg,\n                    b\"l/\\0\" as *const u8 as *const libc::c_char,\n                    (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong)\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                ) == 0 as libc::c_int\n                {\n                    split_type = type_chunk_lines;\n                    optarg = optarg.offset(2 as libc::c_int as isize);\n                } else {\n                    split_type = type_chunk_bytes;\n                }\n                parse_chunk(&mut k_units, &mut n_units, optarg);\n            }\n            117 => {\n                unbuffered = 1 as libc::c_int != 0;\n            }\n            116 => {\n                let mut neweol: libc::c_char = *optarg.offset(0 as libc::c_int as isize);\n                if neweol == 0 {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"empty record separator\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"empty record separator\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"empty record separator\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                if *optarg.offset(1 as libc::c_int as isize) != 0 {\n                    if strcmp(optarg, b\"\\\\0\\0\" as *const u8 as *const libc::c_char)\n                        == 0 as libc::c_int\n                    {\n                        neweol = '\\0' as i32 as libc::c_char;\n                    } else {\n                        if 0 != 0 {\n                            error(\n                                1 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"multi-character separator %s\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if 1 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"multi-character separator %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"multi-character separator %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    }\n                }\n                if 0 as libc::c_int <= eolchar && neweol as libc::c_int != eolchar {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"multiple separator characters specified\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(",
    "                                    b\"multiple separator characters specified\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"multiple separator characters specified\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                eolchar = neweol as libc::c_int;\n            }\n            48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => {\n                if split_type as libc::c_uint\n                    == type_undef as libc::c_int as libc::c_uint\n                {\n                    split_type = type_digits;\n                    n_units = 0 as libc::c_int as intmax_t;\n                }\n                if split_type as libc::c_uint\n                    != type_undef as libc::c_int as libc::c_uint\n                    && split_type as libc::c_uint\n                        != type_digits as libc::c_int as libc::c_uint\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"cannot split in more than one way\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n                if digits_optind != 0 as libc::c_int && digits_optind != this_optind {\n                    n_units = 0 as libc::c_int as intmax_t;\n                }\n                digits_optind = this_optind;\n                if (if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n_units\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        10 as libc::c_int\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    && (if (10 as libc::c_int) < 0 as libc::c_int {\n                        if n_units < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as intmax_t\n                                }) + 10 as libc::c_int as libc::c_long\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n_units\n                                    < -(1 as libc::c_int) as intmax_t\n                                        / 10 as libc::c_int as libc::c_long) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    10 as libc::c_int\n                                }) - 1 as libc::c_int) < 0 as libc::c_int\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) + 1 as libc::c_int)\n                                        << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) + 0 as libc::c_int\n                                }) < 0 as libc::c_int\n                                {\n                                    ((10 as libc::c_int)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) + 1 as libc::c_int)\n                                                << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) - 1 as libc::c_int\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int) < 10 as libc::c_int) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + -(1 as libc::c_int) as intmax_t\n                                        >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as intmax_t\n                                        / -(10 as libc::c_int) as libc::c_long\n                                }) <= -(1 as libc::c_int) as libc::c_long - n_units)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    10 as libc::c_int\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    10 as libc::c_int\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                                    as libc::c_int\n                            }) != 0 && 10 as libc::c_int == -(1 as libc::c_int)\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n_units\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n_units + 0 as libc::c_int as intmax_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n_units\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as intmax_t)\n                                            < n_units - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                ((0 as libc::c_int as intmax_t\n                                    / 10 as libc::c_int as libc::c_long) < n_units)\n                                    as libc::c_int\n                            }\n                        }\n                    } else {\n                        if 10 as libc::c_int == 0 as libc::c_int {\n                            0 as libc::c_int\n                        } else {\n                            if n_units < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n_units\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n_units\n                                        }) + 0 as libc::c_int as intmax_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n_units\n                                        }) + 0 as libc::c_int as intmax_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n_units\n                                    }) + 0 as libc::c_int as intmax_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n_units\n                                            }) + 0 as libc::c_int as intmax_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n_units\n                                                }) + 0 as libc::c_int as intmax_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n_units\n                                                }) + 0 as libc::c_int as intmax_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n_units\n                                        }) + 0 as libc::c_int as intmax_t) as libc::c_int\n                                }) != 0 && n_units == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < 10 as libc::c_int as libc::c_long\n                                                + 0 as libc::c_int as intmax_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as intmax_t)\n                                            < (10 as libc::c_int - 1 as libc::c_int) as libc::c_long)\n                                            as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as intmax_t / n_units\n                                        < 10 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                ((-(1 as libc::c_int) as intmax_t\n                                    / 10 as libc::c_int as libc::c_long) < n_units)\n                                    as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh27, _fresh28) = n_units.overflowing_mul((10 as libc::c_int).into());\n                    *(&mut n_units as *mut intmax_t) = fresh27;\n                    1 as libc::c_int\n                } else {\n                    let (fresh29, fresh30) = n_units.overflowing_mul((10 as libc::c_int).into());\n                    *(&mut n_units as *mut intmax_t) = fresh29;\n                    fresh30 as libc::c_int\n                }) != 0\n                    || {\n                        let (fresh31, fresh32) = n_units.overflowing_add((c - '0' as i32).into());\n                        *(&mut n_units as *mut intmax_t) = fresh31;\n                        fresh32 as libc::c_int != 0\n                    }\n                {\n                    n_units = 9223372036854775807 as libc::c_long;\n                }\n            }\n            100 | 120 => {\n                if c == 'd' as i32 {\n                    suffix_alphabet = b\"0123456789\\0\" as *const u8\n                        as *const libc::c_char;\n                } else {\n                    suffix_alphabet = b\"0123456789abcdef\\0\" as *const u8\n                        as *const libc::c_char;\n                }\n                if !optarg.is_null() {\n                    if strlen(optarg) != strspn(optarg, suffix_alphabet) {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                0 as libc::c_int,\n                                if c == 'd' as i32 {\n                                    gettext(\n                                        b\"%s: invalid start value for numerical suffix\\0\"\n                                            as *const u8 as *const libc::c_char,\n                                    )\n                                } else {\n                                    gettext(\n                                        b\"%s: invalid start value for hexadecimal suffix\\0\"\n                                            as *const u8 as *const libc::c_char,\n                                    )\n                                },\n                                quote(optarg),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    if c == 'd' as i32 {\n                                        gettext(\n                                            b\"%s: invalid start value for numerical suffix\\0\"\n                                                as *const u8 as *const libc::c_char,\n                                        )\n                                    } else {\n                                        gettext(\n                                            b\"%s: invalid start value for hexadecimal suffix\\0\"\n                                                as *const u8 as *const libc::c_char,\n                                        )\n                                    },\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    if c == 'd' as i32 {\n                                        gettext(\n                                            b\"%s: invalid start value for numerical suffix\\0\"\n                                                as *const u8 as *const libc::c_char,\n                                        )\n                                    } else {\n                                        gettext(\n                                            b\"%s: invalid start value for hexadecimal suffix\\0\"",
    "                                                as *const u8 as *const libc::c_char,\n                                        )\n                                    },\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                        usage(1 as libc::c_int);\n                    } else {\n                        while *optarg as libc::c_int == '0' as i32\n                            && *optarg.offset(1 as libc::c_int as isize) as libc::c_int\n                                != '\\0' as i32\n                        {\n                            optarg = optarg.offset(1);\n                            optarg;\n                        }\n                        numeric_suffix_start = optarg;\n                    }\n                }\n            }\n            101 => {\n                elide_empty_files = 1 as libc::c_int != 0;\n            }\n            257 => {\n                filter_command = optarg;\n            }\n            258 => {\n                in_blk_size = xdectoumax(\n                    optarg,\n                    1 as libc::c_int as uintmax_t,\n                    if (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong)\n                        < (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n                            < 18446744073709551615 as libc::c_ulong\n                        {\n                            9223372036854775807 as libc::c_long as libc::c_ulong\n                        } else {\n                            18446744073709551615 as libc::c_ulong\n                        })\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    {\n                        SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong\n                    } else {\n                        (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n                            < 18446744073709551615 as libc::c_ulong\n                        {\n                            9223372036854775807 as libc::c_long as libc::c_ulong\n                        } else {\n                            18446744073709551615 as libc::c_ulong\n                        })\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    },\n                    multipliers.as_ptr(),\n                    gettext(\n                        b\"invalid IO block size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as libc::c_int,\n                ) as idx_t;\n            }\n            256 => {\n                verbose = 1 as libc::c_int != 0;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n            }\n            -3 => {\n                version_etc(\n                    stdout,\n                    b\"split\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Torbjorn Granlund\\0\" as *const u8 as *const libc::c_char,\n                        b\"Torbj\\xC3\\xB6rn Granlund\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                        b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);\n            }\n            _ => {\n                usage(1 as libc::c_int);\n            }\n        }\n    }\n    if k_units != 0 as libc::c_int as libc::c_long && !filter_command.is_null() {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"--filter does not process a chunk extracted to stdout\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"--filter does not process a chunk extracted to stdout\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"--filter does not process a chunk extracted to stdout\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if split_type as libc::c_uint == type_undef as libc::c_int as libc::c_uint {\n        split_type = type_lines;\n        n_units = 1000 as libc::c_int as intmax_t;\n    }\n    if n_units == 0 as libc::c_int as libc::c_long {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"invalid number of lines: %s\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote(b\"0\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"invalid number of lines: %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote(b\"0\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"invalid number of lines: %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote(b\"0\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if eolchar < 0 as libc::c_int {\n        eolchar = '\\n' as i32;\n    }\n    set_suffix_length(n_units, split_type);\n    if optind < argc {\n        let fresh33 = optind;\n        optind = optind + 1;\n        infile = *argv.offset(fresh33 as isize);\n    }\n    if optind < argc {\n        let fresh34 = optind;\n        optind = optind + 1;\n        outbase = *argv.offset(fresh34 as isize);\n    }\n    if optind < argc {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(b\"extra operand %s\\0\" as *const u8 as *const libc::c_char),\n                quote(*argv.offset(optind as isize)),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(b\"extra operand %s\\0\" as *const u8 as *const libc::c_char),\n                    quote(*argv.offset(optind as isize)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(b\"extra operand %s\\0\" as *const u8 as *const libc::c_char),\n                    quote(*argv.offset(optind as isize)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if !numeric_suffix_start.is_null()\n        && strlen(numeric_suffix_start) > suffix_length as libc::c_ulong\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"numerical suffix start value is too large for the suffix length\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"numerical suffix start value is too large for the suffix length\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"numerical suffix start value is too large for the suffix length\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if !(strcmp(infile, b\"-\\0\" as *const u8 as *const libc::c_char) == 0 as libc::c_int)\n        && fd_reopen(\n            0 as libc::c_int,\n            infile,\n            0 as libc::c_int,\n            0 as libc::c_int as mode_t,\n        ) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"cannot open %s for reading\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, infile),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open %s for reading\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, infile),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open %s for reading\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, infile),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    xset_binary_mode(0 as libc::c_int, 0 as libc::c_int);\n    fdadvise(\n        0 as libc::c_int,\n        0 as libc::c_int as off_t,\n        0 as libc::c_int as off_t,\n        FADVISE_SEQUENTIAL,\n    );\n    if fstat(0 as libc::c_int, &mut in_stat_buf) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    infile,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if in_blk_size == 0 as libc::c_int as libc::c_long {\n        in_blk_size = io_blksize(&mut in_stat_buf);\n        if (SYS_BUFSIZE_MAX as libc::c_int as libc::c_long) < in_blk_size {\n            in_blk_size = SYS_BUFSIZE_MAX as libc::c_int as idx_t;\n        }\n    }\n    let mut buf: *mut libc::c_char = xalignalloc(\n        page_size,\n        in_blk_size + 1 as libc::c_int as libc::c_long,\n    ) as *mut libc::c_char;\n    let mut initial_read: ssize_t = -(1 as libc::c_int) as ssize_t;\n    if split_type as libc::c_uint == type_chunk_bytes as libc::c_int as libc::c_uint\n        || split_type as libc::c_uint == type_chunk_lines as libc::c_int as libc::c_uint\n    {\n        file_size = input_file_size(\n            0 as libc::c_int,\n            &mut in_stat_buf,\n            buf,\n            in_blk_size,\n        );\n        if file_size < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: cannot determine file size\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot determine file size\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot determine file size\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        initial_read = if file_size < in_blk_size { file_size } else { in_blk_size };\n    }\n    if !filter_command.is_null() {\n        default_SIGPIPE = (signal(\n            13 as libc::c_int,\n            ::core::mem::transmute::<\n                libc::intptr_t,\n                __sighandler_t,\n            >(1 as libc::c_int as libc::intptr_t),\n        ))",
    "            .is_none();\n    }\n    match split_type as libc::c_uint {\n        4 | 3 => {\n            lines_split(n_units, buf, in_blk_size);\n        }\n        1 => {\n            bytes_split(\n                n_units,\n                0 as libc::c_int as intmax_t,\n                buf,\n                in_blk_size,\n                -(1 as libc::c_int) as ssize_t,\n                0 as libc::c_int as intmax_t,\n            );\n        }\n        2 => {\n            line_bytes_split(n_units, buf, in_blk_size);\n        }\n        5 => {\n            if k_units == 0 as libc::c_int as libc::c_long {\n                bytes_split(\n                    file_size / n_units,\n                    file_size % n_units,\n                    buf,\n                    in_blk_size,\n                    initial_read,\n                    n_units,\n                );\n            } else {\n                bytes_chunk_extract(\n                    k_units,\n                    n_units,\n                    buf,\n                    in_blk_size,\n                    initial_read,\n                    file_size,\n                );\n            }\n        }\n        6 => {\n            lines_chunk_split(\n                k_units,\n                n_units,\n                buf,\n                in_blk_size,\n                initial_read,\n                file_size,\n            );\n        }\n        7 => {\n            let mut files: *mut of_t = 0 as *mut of_t;\n            lines_rr(k_units, n_units, buf, in_blk_size, &mut files);\n        }\n        _ => {\n            __assert_fail(\n                b\"0\\0\" as *const u8 as *const libc::c_char,\n                b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                1686 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 23],\n                    &[libc::c_char; 23],\n                >(b\"int main(int, char **)\\0\"))\n                    .as_ptr(),\n            );\n            'c_16295: {\n                __assert_fail(\n                    b\"0\\0\" as *const u8 as *const libc::c_char,\n                    b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                    1686 as libc::c_int as libc::c_uint,\n                    (*::core::mem::transmute::<\n                        &[u8; 23],\n                        &[libc::c_char; 23],\n                    >(b\"int main(int, char **)\\0\"))\n                        .as_ptr(),\n                );\n            };\n        }\n    }\n    if close(0 as libc::c_int) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    infile,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    closeout(0 as *mut FILE, output_desc, filter_pid, outfile);\n    exit(0 as libc::c_int);\n}\npub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_clz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_clzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_ctz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_ctzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_stdbit_ctzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "use ::libc;\n#[inline]\nunsafe extern \"C\" fn __gl_stdbit_clz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[inline]\nunsafe extern \"C\" fn __gl_stdbit_clzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[inline]\nunsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn stdc_leading_zeros_ui(mut n: libc::c_uint) -> libc::c_uint {\n    return __gl_stdbit_clz(n) as libc::c_uint;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn stdc_leading_zeros_uc(mut n: libc::c_uchar) -> libc::c_uint {\n    return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)\n        .wrapping_sub(\n            (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(\n                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n                        .wrapping_sub(\n                            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong,\n                        ),\n                ),\n        ) as libc::c_uint;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn stdc_leading_zeros_us(mut n: libc::c_ushort) -> libc::c_uint {\n    return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)\n        .wrapping_sub(\n            (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(\n                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n                        .wrapping_sub(\n                            ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong,\n                        ),\n                ),\n        ) as libc::c_uint;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn stdc_leading_zeros_ul(mut n: libc::c_ulong) -> libc::c_uint {\n    return __gl_stdbit_clzl(n) as libc::c_uint;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn stdc_leading_zeros_ull(\n    mut n: libc::c_ulonglong,\n) -> libc::c_uint {\n    return __gl_stdbit_clzll(n) as libc::c_uint;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char) -> *mut FILE;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn free(_: *mut libc::c_void);\n    fn mkstemp_safer(_: *mut libc::c_char) -> libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn unlink(__name: *const libc::c_char) -> libc::c_int;\n    fn ftruncate(__fd: libc::c_int, __length: __off_t) -> libc::c_int;\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn __errno_location() -> *mut libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn path_search(\n        tmpl: *mut libc::c_char,\n        tmpl_len: size_t,\n        dir: *const libc::c_char,\n        pfx: *const libc::c_char,\n        try_tmpdir: bool,\n    ) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\nunsafe extern \"C\" fn record_or_unlink_tempfile(\n    mut fn_0: *const libc::c_char,\n    mut _fp: *mut FILE,\n) {\n    unlink(fn_0);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn temp_stream(\n    mut fp: *mut *mut FILE,\n    mut file_name: *mut *mut libc::c_char,\n) -> bool {\n    static mut tempfile: *mut libc::c_char = 0 as *const libc::c_char\n        as *mut libc::c_char;\n    static mut tmp_fp: *mut FILE = 0 as *const FILE as *mut FILE;\n    if tempfile.is_null() {\n        's_103: {\n            let mut tempbuf: *mut libc::c_char = 0 as *mut libc::c_char;\n            let mut tempbuf_len: size_t = 128 as libc::c_int as size_t;\n            loop {\n                tempbuf = realloc(tempbuf as *mut libc::c_void, tempbuf_len)\n                    as *mut libc::c_char;\n                if tempbuf.is_null() {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to make temporary file name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"failed to make temporary file name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"failed to make temporary file name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    return 0 as libc::c_int != 0;\n                }\n                if path_search(\n                    tempbuf,\n                    tempbuf_len,\n                    0 as *const libc::c_char,\n                    b\"cutmp\\0\" as *const u8 as *const libc::c_char,\n                    1 as libc::c_int != 0,\n                ) == 0 as libc::c_int\n                {\n                    break;\n                }\n                if *__errno_location() != 22 as libc::c_int\n                    || ((4096 as libc::c_int / 2 as libc::c_int) as libc::c_ulong)\n                        < tempbuf_len\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            if *__errno_location() == 22 as libc::c_int {\n                                36 as libc::c_int\n                            } else {\n                                *__errno_location()\n                            },\n                            gettext(\n                                b\"failed to make temporary file name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                if *__errno_location() == 22 as libc::c_int {\n                                    36 as libc::c_int\n                                } else {\n                                    *__errno_location()\n                                },\n                                gettext(\n                                    b\"failed to make temporary file name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                if *__errno_location() == 22 as libc::c_int {\n                                    36 as libc::c_int\n                                } else {\n                                    *__errno_location()\n                                },\n                                gettext(\n                                    b\"failed to make temporary file name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    return 0 as libc::c_int != 0;\n                }\n                tempbuf_len = (tempbuf_len as libc::c_ulong)\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong) as size_t as size_t;\n            }\n            tempfile = tempbuf;\n            let mut fd: libc::c_int = mkstemp_safer(tempfile);\n            if fd < 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to create temporary file %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, tempfile),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to create temporary file %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, tempfile),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to create temporary file %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, tempfile),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            } else {\n                tmp_fp = fdopen(\n                    fd,\n                    if 0 as libc::c_int != 0 {\n                        b\"w+b\\0\" as *const u8 as *const libc::c_char\n                    } else {\n                        b\"w+\\0\" as *const u8 as *const libc::c_char\n                    },\n                );\n                if tmp_fp.is_null() {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to open %s for writing\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, tempfile),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"failed to open %s for writing\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, tempfile),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"failed to open %s for writing\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, tempfile),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    close(fd);\n                    unlink(tempfile);\n                } else {\n                    record_or_unlink_tempfile(tempfile, tmp_fp);\n                    break 's_103;\n                }\n            }\n            free(tempfile as *mut libc::c_void);\n            tempfile = 0 as *mut libc::c_char;\n            return 0 as libc::c_int != 0;\n        }\n    } else {\n        clearerr_unlocked(tmp_fp);\n        if rpl_fseeko(tmp_fp, 0 as libc::c_int as off_t, 0 as libc::c_int)\n            < 0 as libc::c_int\n            || ftruncate(fileno(tmp_fp), 0 as libc::c_int as __off_t) < 0 as libc::c_int\n        {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to rewind stream for %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, tempfile),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to rewind stream for %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, tempfile),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to rewind stream for %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, tempfile),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n    }\n    *fp = tmp_fp;\n    if !file_name.is_null() {\n        *file_name = tempfile;\n    }\n    return 1 as libc::c_int != 0;\n}",
    "use ::libc;\nextern \"C\" {\n    fn secure_getenv(__name: *const libc::c_char) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn __errno_location() -> *mut libc::c_int;\n    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub type __syscall_slong_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blkcnt_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __off_t = libc::c_long;\npub type __dev_t = libc::c_ulong;\npub type __gid_t = libc::c_uint;\npub type __uid_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\nunsafe extern \"C\" fn direxists(mut dir: *const libc::c_char) -> bool {\n    let mut buf: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    return stat(dir, &mut buf) == 0 as libc::c_int\n        && buf.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o40000 as libc::c_int as libc::c_uint;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn path_search(\n    mut tmpl: *mut libc::c_char,\n    mut tmpl_len: size_t,\n    mut dir: *const libc::c_char,\n    mut pfx: *const libc::c_char,\n    mut try_tmpdir: bool,\n) -> libc::c_int {\n    let mut d: *const libc::c_char = 0 as *const libc::c_char;\n    let mut dlen: size_t = 0;\n    let mut plen: size_t = 0;\n    let mut add_slash: bool = false;\n    if pfx.is_null() || *pfx.offset(0 as libc::c_int as isize) == 0 {\n        pfx = b\"file\\0\" as *const u8 as *const libc::c_char;\n        plen = 4 as libc::c_int as size_t;\n    } else {\n        plen = strlen(pfx);\n        if plen > 5 as libc::c_int as libc::c_ulong {\n            plen = 5 as libc::c_int as size_t;\n        }\n    }\n    if try_tmpdir {\n        d = secure_getenv(b\"TMPDIR\\0\" as *const u8 as *const libc::c_char);\n        if !d.is_null() && direxists(d) as libc::c_int != 0 {\n            dir = d;\n        } else if !(!dir.is_null() && direxists(dir) as libc::c_int != 0) {\n            dir = 0 as *const libc::c_char;\n        }\n    }\n    if dir.is_null() {\n        if direxists(b\"/tmp\\0\" as *const u8 as *const libc::c_char) {\n            dir = b\"/tmp\\0\" as *const u8 as *const libc::c_char;\n        } else if strcmp(\n            b\"/tmp\\0\" as *const u8 as *const libc::c_char,\n            b\"/tmp\\0\" as *const u8 as *const libc::c_char,\n        ) != 0 as libc::c_int\n            && direxists(b\"/tmp\\0\" as *const u8 as *const libc::c_char) as libc::c_int\n                != 0\n        {\n            dir = b\"/tmp\\0\" as *const u8 as *const libc::c_char;\n        } else {\n            *__errno_location() = 2 as libc::c_int;\n            return -(1 as libc::c_int);\n        }\n    }\n    dlen = strlen(dir);\n    add_slash = dlen != 0 as libc::c_int as libc::c_ulong\n        && !(*dir.offset(dlen.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_int == '/' as i32);\n    if tmpl_len\n        < dlen\n            .wrapping_add(add_slash as libc::c_ulong)\n            .wrapping_add(plen)\n            .wrapping_add(6 as libc::c_int as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        *__errno_location() = 22 as libc::c_int;\n        return -(1 as libc::c_int);\n    }\n    memcpy(tmpl as *mut libc::c_void, dir as *const libc::c_void, dlen);\n    sprintf(\n        tmpl.offset(dlen as isize),\n        &*(b\"/%.*sXXXXXX\\0\" as *const u8 as *const libc::c_char)\n            .offset(!add_slash as libc::c_int as isize) as *const libc::c_char,\n        plen as libc::c_int,\n        pfx,\n    );\n    return 0 as libc::c_int;\n}",
    "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
    "use ::libc;\nextern \"C\" {\n    fn aligned_alloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn xalloc_die();\n}\npub type size_t = libc::c_ulong;\npub type ptrdiff_t = libc::c_long;\npub type idx_t = ptrdiff_t;\n#[inline]\nunsafe extern \"C\" fn alignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    if (-(1 as libc::c_int) as size_t) < alignment as libc::c_ulong {\n        alignment = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    if (-(1 as libc::c_int) as size_t) < size as libc::c_ulong {\n        size = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    return aligned_alloc(alignment as libc::c_ulong, size as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xalignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    let mut p: *mut libc::c_void = alignalloc(alignment, size);\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "use ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn xset_binary_mode_error() {}\n#[inline]\nunsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[inline]\nunsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn xstrtoimax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut intmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n}\npub type __intmax_t = libc::c_long;\npub type intmax_t = __intmax_t;\npub const LONGINT_OK: strtol_error = 0;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\n#[no_mangle]\npub unsafe extern \"C\" fn xnumtoimax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: intmax_t = 0;\n    s_err = xstrtoimax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_long {\n                *__errno_location() = 75 as libc::c_int;\n            } else if tnum\n                < ((-(2147483647 as libc::c_int) - 1 as libc::c_int) / 2 as libc::c_int)\n                    as libc::c_long\n            {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xdectoimax(\n    mut n_str: *const libc::c_char,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    return xnumtoimax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}",
    "use ::libc;\nextern \"C\" {\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn xstrtoumax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut uintmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n}\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\npub const LONGINT_OK: strtol_error = 0;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\n#[no_mangle]\npub unsafe extern \"C\" fn xdectoumax(\n    mut n_str: *const libc::c_char,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    return xnumtoumax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnumtoumax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: uintmax_t = 0;\n    s_err = xstrtoumax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_ulong {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}",
    "use ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nunsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[inline]\nunsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[inline]\nunsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[cold]\n#[inline]\nunsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}\n#[inline]\nunsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\nunsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t",
    "                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtoimax(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __base: libc::c_int,\n    ) -> intmax_t;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n}\npub type __intmax_t = libc::c_long;\npub type intmax_t = __intmax_t;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub const _ISspace: C2RustUnnamed = 8192;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;\nunsafe extern \"C\" fn bkm_scale(\n    mut x: *mut intmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: intmax_t = 0;\n    if if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { *x })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as intmax_t\n                    }) + scale_factor as libc::c_long\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (*x < -(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + -(1 as libc::c_int) as intmax_t\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as intmax_t / -scale_factor as libc::c_long\n                    }) <= -(1 as libc::c_int) as libc::c_long - *x) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n                        as libc::c_long + 0 as libc::c_int as intmax_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        *x\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < *x + 0 as libc::c_int as intmax_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < *x\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < *x - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as intmax_t / scale_factor as libc::c_long) < *x)\n                        as libc::c_int\n                }\n            }\n        } else {\n            if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    *x\n                                }) + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < scale_factor as libc::c_long\n                                    + 0 as libc::c_int as intmax_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_long)\n                                as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as intmax_t / *x\n                            < scale_factor as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        < *x) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_long {\n            !if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n                -(1 as libc::c_int) as intmax_t\n            } else {\n                (((1 as libc::c_int as intmax_t)\n                    << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            }\n        } else if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n            -(1 as libc::c_int) as intmax_t\n        } else {\n            (((1 as libc::c_int as intmax_t)\n                << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}\nunsafe extern \"C\" fn bkm_scale_by_power(\n    mut x: *mut intmax_t,\n    mut base: libc::c_int,\n    mut power: libc::c_int,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    loop {\n        let fresh8 = power;\n        power = power - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);\n    }\n    return err;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn xstrtoimax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut intmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: intmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 78],\n                &[libc::c_char; 78],\n            >(\n                b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2247: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 78],\n                    &[libc::c_char; 78],\n                >(\n                    b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoimax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as intmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if **p as libc::c_int != '\\0' as i32 {\n        let mut base: libc::c_int = 1024 as libc::c_int;\n        let mut suffixes: libc::c_int = 1 as libc::c_int;\n        let mut overflow: strtol_error = LONGINT_OK;\n        if (strchr(valid_suffixes, **p as libc::c_int)).is_null() {\n            *val = tmp;\n            return (err as libc::c_uint\n                | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                as strtol_error;\n        }\n        match **p as libc::c_int {\n            69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n                if !(strchr(valid_suffixes, '0' as i32)).is_null() {\n                    match *(*p.offset(0 as libc::c_int as isize))\n                        .offset(1 as libc::c_int as isize) as libc::c_int\n                    {\n                        105 => {\n                            if *(*p.offset(0 as libc::c_int as isize))\n                                .offset(2 as libc::c_int as isize) as libc::c_int\n                                == 'B' as i32\n                            {\n                                suffixes += 2 as libc::c_int;\n                            }\n                        }\n                        66 | 68 => {\n                            base = 1000 as libc::c_int;\n                            suffixes += 1;\n                            suffixes;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n            _ => {}\n        }\n        match **p as libc::c_int {\n            98 => {\n                overflow = bkm_scale(&mut tmp, 512 as libc::c_int);\n            }\n            66 => {\n                overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);\n            }\n            99 => {\n                overflow = LONGINT_OK;\n            }\n            69 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);\n            }\n            71 | 103 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);\n            }\n            107 | 75 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);\n            }\n            77 | 109 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);\n            }\n            80 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);\n            }\n            81 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);\n            }\n            82 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);\n            }\n            84 | 116 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);\n            }\n            119 => {\n                overflow = bkm_scale(&mut tmp, 2 as libc::c_int);\n            }\n            89 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);\n            }\n            90 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);\n            }\n            _ => {\n                *val = tmp;\n                return (err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                    as strtol_error;\n            }\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | overflow as libc::c_uint);\n        *p = (*p).offset(suffixes as isize);\n        if **p != 0 {\n            err = ::core::mem::transmute::<\n                libc::c_uint,\n                strtol_error,\n            >(\n                err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint,\n            );\n        }\n    }\n    *val = tmp;\n    return err;\n}",
    "use ::libc;\nextern \"C\" {\n    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtoumax(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __base: libc::c_int,\n    ) -> uintmax_t;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n}\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub const _ISspace: C2RustUnnamed = 8192;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;\nunsafe extern \"C\" fn bkm_scale(\n    mut x: *mut uintmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: uintmax_t = 0;\n    if if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t\n        && (if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_ulong } else { *x })\n            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n            < 0 as libc::c_int as libc::c_ulong\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_ulong {\n                if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        -(1 as libc::c_int) as uintmax_t\n                    })\n                        .wrapping_add(scale_factor as libc::c_ulong)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    (*x\n                        < (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(scale_factor as libc::c_ulong)) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(-(1 as libc::c_int) as uintmax_t)\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(-scale_factor as libc::c_ulong)\n                    }) <= (-(1 as libc::c_int) as libc::c_ulong).wrapping_sub(*x))\n                        as libc::c_int\n                }\n            } else {\n                if (if (if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    !((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                }) < 0 as libc::c_int as libc::c_ulong\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                        < (if (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_ulong)\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            < 0 as libc::c_int as libc::c_ulong\n                        {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                << (::core::mem::size_of::<libc::c_ulong>()\n                                    as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        })\n                            .wrapping_neg()) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_ulong)\n                        < ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        *x\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (*x).wrapping_add(0 as libc::c_int as uintmax_t))\n                            as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong) < *x\n                            && (-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (*x).wrapping_sub(1 as libc::c_int as libc::c_ulong))\n                            as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }\n            }\n        } else {\n            if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_ulong {\n                    if (if (if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        !((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                    }) < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                            < (if (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    *x\n                                })\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                < 0 as libc::c_int as libc::c_ulong\n                            {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                    << (::core::mem::size_of::<libc::c_ulong>()\n                                        as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            })\n                                .wrapping_neg()) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_ulong\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_ulong)\n                                < (scale_factor as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_ulong)\n                                as libc::c_int\n                        }\n                    } else {\n                        ((0 as libc::c_int as uintmax_t).wrapping_div(*x)\n                            < scale_factor as libc::c_ulong) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_ulong {\n            !if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n                -(1 as libc::c_int) as uintmax_t\n            } else {\n                ((1 as libc::c_int as uintmax_t)\n                    << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            }\n        } else if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n            -(1 as libc::c_int) as uintmax_t\n        } else {\n            ((1 as libc::c_int as uintmax_t)\n                << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}\nunsafe extern \"C\" fn bkm_scale_by_power(\n    mut x: *mut uintmax_t,\n    mut base: libc::c_int,\n    mut power: libc::c_int,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    loop {\n        let fresh8 = power;\n        power = power - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);\n    }\n    return err;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn xstrtoumax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut uintmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: uintmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 79],\n                &[libc::c_char; 79],\n            >(\n                b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2256: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 79],\n                    &[libc::c_char; 79],\n                >(\n                    b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoumax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as uintmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if **p as libc::c_int != '\\0' as i32 {\n        let mut base: libc::c_int = 1024 as libc::c_int;\n        let mut suffixes: libc::c_int = 1 as libc::c_int;\n        let mut overflow: strtol_error = LONGINT_OK;\n        if (strchr(valid_suffixes, **p as libc::c_int)).is_null() {\n            *val = tmp;\n            return (err as libc::c_uint\n                | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                as strtol_error;\n        }\n        match **p as libc::c_int {\n            69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n                if !(strchr(valid_suffixes, '0' as i32)).is_null() {\n                    match *(*p.offset(0 as libc::c_int as isize))\n                        .offset(1 as libc::c_int as isize) as libc::c_int\n                    {\n                        105 => {\n                            if *(*p.offset(0 as libc::c_int as isize))\n                                .offset(2 as libc::c_int as isize) as libc::c_int\n                                == 'B' as i32\n                            {\n                                suffixes += 2 as libc::c_int;\n                            }\n                        }\n                        66 | 68 => {\n                            base = 1000 as libc::c_int;\n                            suffixes += 1;\n                            suffixes;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n            _ => {}\n        }\n        match **p as libc::c_int {\n            98 => {\n                overflow = bkm_scale(&mut tmp, 512 as libc::c_int);\n            }\n            66 => {\n                overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);\n            }\n            99 => {\n                overflow = LONGINT_OK;\n            }\n            69 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);\n            }\n            71 | 103 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);\n            }\n            107 | 75 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);\n            }\n            77 | 109 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);\n            }\n            80 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);\n            }\n            81 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);\n            }\n            82 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);\n            }\n            84 | 116 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);\n            }\n            119 => {\n                overflow = bkm_scale(&mut tmp, 2 as libc::c_int);\n            }\n            89 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);\n            }\n            90 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);\n            }\n            _ => {\n                *val = tmp;\n                return (err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                    as strtol_error;\n            }\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | overflow as libc::c_uint);\n        *p = (*p).offset(suffixes as isize);\n        if **p != 0 {\n            err = ::core::mem::transmute::<\n                libc::c_uint,\n                strtol_error,\n            >(\n                err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint,\n            );\n        }\n    }\n    *val = tmp;\n    return err;\n}"
  ],
  "tail": [
    "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
    "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(label_break_value)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod argmatch;\npub mod basename_lgpl;\npub mod binary_io;\npub mod bitrotate;\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod c_strtod;\npub mod cl_strtod;\npub mod close_stream;\npub mod closeout;\npub mod dirname_lgpl;\npub mod dtotimespec;\npub mod dup_safer;\npub mod exitfail;\npub mod fclose;\npub mod fcntl;\npub mod fd_safer;\npub mod fflush;\npub mod fpurge;\npub mod fseeko;\npub mod hard_locale;\npub mod hash;\npub mod ialloc;\npub mod iopoll;\npub mod isapipe;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod nanosleep;\npub mod offtostr;\npub mod open_safer;\npub mod posixver;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod safe_read;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod stat_time;\npub mod timespec;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalloc_die;\npub mod xbinary_io;\npub mod xdectoumax;\npub mod xmalloc;\npub mod xnanosleep;\npub mod xstrtod;\npub mod xstrtoumax;\n}\n// mod src",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stderr: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn putc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn quote_n(n: libc::c_int, arg: *const libc::c_char) -> *const libc::c_char;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn quotearg_n_style(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn usage(_e: libc::c_int);\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type argmatch_exit_fn = Option::<unsafe extern \"C\" fn() -> ()>\n;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\nunsafe extern \"C\" fn __argmatch_die() {\n    usage(1 as libc::c_int);\n}\n#[no_mangle]\npub static mut argmatch_die: argmatch_exit_fn = unsafe {\n    Some(__argmatch_die as unsafe extern \"C\" fn() -> ())\n};\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch(\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) -> ptrdiff_t {\n    let mut i: size_t = 0;\n    let mut arglen: size_t = 0;\n    let mut matchind: ptrdiff_t = -(1 as libc::c_int) as ptrdiff_t;\n    let mut ambiguous: bool = 0 as libc::c_int != 0;\n    arglen = strlen(arg);\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if strncmp(*arglist.offset(i as isize), arg, arglen) == 0 {\n            if strlen(*arglist.offset(i as isize)) == arglen {\n                return i as ptrdiff_t\n            } else if matchind == -(1 as libc::c_int) as libc::c_long {\n                matchind = i as ptrdiff_t;\n            } else if vallist.is_null()\n                || memcmp(\n                    (vallist as *const libc::c_char)\n                        .offset(valsize.wrapping_mul(matchind as libc::c_ulong) as isize)\n                        as *const libc::c_void,\n                    (vallist as *const libc::c_char)\n                        .offset(valsize.wrapping_mul(i) as isize) as *const libc::c_void,\n                    valsize,\n                ) != 0\n            {\n                ambiguous = 1 as libc::c_int != 0;\n            }\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    if ambiguous { return -(2 as libc::c_int) as ptrdiff_t } else { return matchind };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch_exact(\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n) -> ptrdiff_t {\n    let mut i: size_t = 0;\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if strcmp(*arglist.offset(i as isize), arg) == 0 {\n            return i as ptrdiff_t;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return -(1 as libc::c_int) as ptrdiff_t;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch_invalid(\n    mut context: *const libc::c_char,\n    mut value: *const libc::c_char,\n    mut problem: ptrdiff_t,\n) {\n    let mut format: *const libc::c_char = if problem\n        == -(1 as libc::c_int) as libc::c_long\n    {\n        gettext(b\"invalid argument %s for %s\\0\" as *const u8 as *const libc::c_char)\n    } else {\n        gettext(b\"ambiguous argument %s for %s\\0\" as *const u8 as *const libc::c_char)\n    };\n    if 0 != 0 {\n        error(\n            0 as libc::c_int,\n            0 as libc::c_int,\n            format,\n            quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n            quote_n(1 as libc::c_int, context),\n        );\n        if 0 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 0 as libc::c_int;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                format,\n                quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n                quote_n(1 as libc::c_int, context),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 0 as libc::c_int;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                format,\n                quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n                quote_n(1 as libc::c_int, context),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch_valid(\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) {\n    let mut i: size_t = 0;\n    let mut last_val: *const libc::c_char = 0 as *const libc::c_char;\n    fputs_unlocked(\n        gettext(b\"Valid arguments are:\\0\" as *const u8 as *const libc::c_char),\n        stderr,\n    );\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if i == 0 as libc::c_int as libc::c_ulong\n            || memcmp(\n                last_val as *const libc::c_void,\n                (vallist as *const libc::c_char).offset(valsize.wrapping_mul(i) as isize)\n                    as *const libc::c_void,\n                valsize,\n            ) != 0\n        {\n            fprintf(\n                stderr,\n                b\"\\n  - %s\\0\" as *const u8 as *const libc::c_char,\n                quote(*arglist.offset(i as isize)),\n            );\n            last_val = (vallist as *const libc::c_char)\n                .offset(valsize.wrapping_mul(i) as isize);\n        } else {\n            fprintf(\n                stderr,\n                b\", %s\\0\" as *const u8 as *const libc::c_char,\n                quote(*arglist.offset(i as isize)),\n            );\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    putc_unlocked('\\n' as i32, stderr);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn __xargmatch_internal(\n    mut context: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n    mut exit_fn: argmatch_exit_fn,\n    mut allow_abbreviation: bool,\n) -> ptrdiff_t {\n    let mut res: ptrdiff_t = 0;\n    if allow_abbreviation {\n        res = argmatch(arg, arglist, vallist, valsize);\n    } else {\n        res = argmatch_exact(arg, arglist);\n    }\n    if res >= 0 as libc::c_int as libc::c_long {\n        return res;\n    }\n    argmatch_invalid(context, arg, res);\n    argmatch_valid(arglist, vallist, valsize);\n    (Some(exit_fn.expect(\"non-null function pointer\")))\n        .expect(\"non-null function pointer\")();\n    return -(1 as libc::c_int) as ptrdiff_t;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch_to_argument(\n    mut value: *const libc::c_void,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) -> *const libc::c_char {\n    let mut i: size_t = 0;\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if memcmp(\n            value,\n            (vallist as *const libc::c_char).offset(valsize.wrapping_mul(i) as isize)\n                as *const libc::c_void,\n            valsize,\n        ) == 0\n        {\n            return *arglist.offset(i as isize);\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as *const libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn last_component(\n    mut name: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut base: *const libc::c_char = name.offset(0 as libc::c_int as isize);\n    let mut p: *const libc::c_char = 0 as *const libc::c_char;\n    let mut last_was_slash: bool = 0 as libc::c_int != 0;\n    while *base as libc::c_int == '/' as i32 {\n        base = base.offset(1);\n        base;\n    }\n    p = base;\n    while *p != 0 {\n        if *p as libc::c_int == '/' as i32 {\n            last_was_slash = 1 as libc::c_int != 0;\n        } else if last_was_slash {\n            base = p;\n            last_was_slash = 0 as libc::c_int != 0;\n        }\n        p = p.offset(1);\n        p;\n    }\n    return base as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn base_len(mut name: *const libc::c_char) -> size_t {\n    let mut len: size_t = 0;\n    let mut prefix_len: size_t = 0 as libc::c_int as size_t;\n    len = strlen(name);\n    while (1 as libc::c_int as libc::c_ulong) < len\n        && *name.offset(len.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_int == '/' as i32\n    {\n        len = len.wrapping_sub(1);\n        len;\n    }\n    if 0 as libc::c_int != 0 && len == 1 as libc::c_int as libc::c_ulong\n        && *name.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32\n        && *name.offset(1 as libc::c_int as isize) as libc::c_int == '/' as i32\n        && *name.offset(2 as libc::c_int as isize) == 0\n    {\n        return 2 as libc::c_int as size_t;\n    }\n    if 0 as libc::c_int != 0 && prefix_len != 0 && len == prefix_len\n        && *name.offset(prefix_len as isize) as libc::c_int == '/' as i32\n    {\n        return prefix_len.wrapping_add(1 as libc::c_int as libc::c_ulong);\n    }\n    return len;\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "use ::libc;\npub type __uint8_t = libc::c_uchar;\npub type __uint16_t = libc::c_ushort;\npub type __uint32_t = libc::c_uint;\npub type __uint64_t = libc::c_ulong;\npub type uint8_t = __uint8_t;\npub type uint16_t = __uint16_t;\npub type uint32_t = __uint32_t;\npub type uint64_t = __uint64_t;\npub type size_t = libc::c_ulong;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn rotr8(mut x: uint8_t, mut n: libc::c_int) -> uint8_t {\n    return ((x as libc::c_uint >> n | (x as libc::c_uint) << 8 as libc::c_int - n)\n        & 255 as libc::c_int as libc::c_uint) as uint8_t;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn rotl8(mut x: uint8_t, mut n: libc::c_int) -> uint8_t {\n    return (((x as libc::c_uint) << n | x as libc::c_uint >> 8 as libc::c_int - n)\n        & 255 as libc::c_int as libc::c_uint) as uint8_t;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn rotr16(mut x: uint16_t, mut n: libc::c_int) -> uint16_t {\n    return ((x as libc::c_uint >> n | (x as libc::c_uint) << 16 as libc::c_int - n)\n        & 65535 as libc::c_int as libc::c_uint) as uint16_t;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn rotl16(mut x: uint16_t, mut n: libc::c_int) -> uint16_t {\n    return (((x as libc::c_uint) << n | x as libc::c_uint >> 16 as libc::c_int - n)\n        & 65535 as libc::c_int as libc::c_uint) as uint16_t;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn rotr_sz(mut x: size_t, mut n: libc::c_int) -> size_t {\n    return (x >> n\n        | x\n            << (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<size_t>() as libc::c_ulong)\n                .wrapping_sub(n as libc::c_ulong))\n        & 18446744073709551615 as libc::c_ulong;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn rotl_sz(mut x: size_t, mut n: libc::c_int) -> size_t {\n    return (x << n\n        | x\n            >> (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<size_t>() as libc::c_ulong)\n                .wrapping_sub(n as libc::c_ulong))\n        & 18446744073709551615 as libc::c_ulong;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn rotr32(mut x: uint32_t, mut n: libc::c_int) -> uint32_t {\n    return (x >> n | x << 32 as libc::c_int - n) & 4294967295 as libc::c_uint;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn rotl32(mut x: uint32_t, mut n: libc::c_int) -> uint32_t {\n    return (x << n | x >> 32 as libc::c_int - n) & 4294967295 as libc::c_uint;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn rotr64(mut x: uint64_t, mut n: libc::c_int) -> uint64_t {\n    return (x >> n | x << 64 as libc::c_int - n) & 18446744073709551615 as libc::c_ulong;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn rotl64(mut x: uint64_t, mut n: libc::c_int) -> uint64_t {\n    return (x << n | x >> 64 as libc::c_int - n) & 18446744073709551615 as libc::c_ulong;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    fn c_strtod(\n        nptr: *const libc::c_char,\n        endptr: *mut *mut libc::c_char,\n    ) -> libc::c_double;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn cl_strtod(\n    mut nptr: *const libc::c_char,\n    mut endptr: *mut *mut libc::c_char,\n) -> libc::c_double {\n    let mut end: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut d: libc::c_double = strtod(nptr, &mut end);\n    if *end != 0 {\n        let mut strtod_errno: libc::c_int = *__errno_location();\n        let mut c_end: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut c: libc::c_double = c_strtod(nptr, &mut c_end);\n        if end < c_end {\n            d = c;\n            end = c_end;\n        } else {\n            *__errno_location() = strtod_errno;\n        }\n    }\n    if !endptr.is_null() {\n        *endptr = end;\n    }\n    return d;\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "use ::libc;\n#[inline]\nunsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    pub type __locale_data;\n    fn newlocale(\n        __category_mask: libc::c_int,\n        __locale: *const libc::c_char,\n        __base: locale_t,\n    ) -> locale_t;\n    fn strtod_l(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __loc: locale_t,\n    ) -> libc::c_double;\n}\npub type locale_t = __locale_t;\npub type __locale_t = *mut __locale_struct;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __locale_struct {\n    pub __locales: [*mut __locale_data; 13],\n    pub __ctype_b: *const libc::c_ushort,\n    pub __ctype_tolower: *const libc::c_int,\n    pub __ctype_toupper: *const libc::c_int,\n    pub __names: [*const libc::c_char; 13],\n}\nstatic mut c_locale_cache: locale_t = 0 as *const __locale_struct\n    as *mut __locale_struct;\nunsafe extern \"C\" fn c_locale() -> locale_t {\n    if c_locale_cache.is_null() {\n        ::core::ptr::write_volatile(\n            &mut c_locale_cache as *mut locale_t,\n            newlocale(\n                (1 as libc::c_int) << 0 as libc::c_int\n                    | (1 as libc::c_int) << 1 as libc::c_int\n                    | (1 as libc::c_int) << 2 as libc::c_int\n                    | (1 as libc::c_int) << 3 as libc::c_int\n                    | (1 as libc::c_int) << 4 as libc::c_int\n                    | (1 as libc::c_int) << 5 as libc::c_int\n                    | (1 as libc::c_int) << 7 as libc::c_int\n                    | (1 as libc::c_int) << 8 as libc::c_int\n                    | (1 as libc::c_int) << 9 as libc::c_int\n                    | (1 as libc::c_int) << 10 as libc::c_int\n                    | (1 as libc::c_int) << 11 as libc::c_int\n                    | (1 as libc::c_int) << 12 as libc::c_int,\n                b\"C\\0\" as *const u8 as *const libc::c_char,\n                0 as locale_t,\n            ),\n        );\n    }\n    return c_locale_cache;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn c_strtod(\n    mut nptr: *const libc::c_char,\n    mut endptr: *mut *mut libc::c_char,\n) -> libc::c_double {\n    let mut r: libc::c_double = 0.;\n    let mut locale: locale_t = c_locale();\n    if locale.is_null() {\n        if !endptr.is_null() {\n            *endptr = nptr as *mut libc::c_char;\n        }\n        return 0 as libc::c_int as libc::c_double;\n    }\n    r = strtod_l(nptr, endptr, locale);\n    return r;\n}",
    "use ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn last_component(filename: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn dir_len(mut file: *const libc::c_char) -> size_t {\n    let mut prefix_length: size_t = 0 as libc::c_int as size_t;\n    let mut length: size_t = 0;\n    prefix_length = (prefix_length as libc::c_ulong)\n        .wrapping_add(\n            (if prefix_length != 0 as libc::c_int as libc::c_ulong {\n                (0 as libc::c_int != 0\n                    && *file.offset(prefix_length as isize) as libc::c_int == '/' as i32)\n                    as libc::c_int\n            } else if *file.offset(0 as libc::c_int as isize) as libc::c_int\n                == '/' as i32\n            {\n                if 0 as libc::c_int != 0\n                    && *file.offset(1 as libc::c_int as isize) as libc::c_int\n                        == '/' as i32\n                    && !(*file.offset(2 as libc::c_int as isize) as libc::c_int\n                        == '/' as i32)\n                {\n                    2 as libc::c_int\n                } else {\n                    1 as libc::c_int\n                }\n            } else {\n                0 as libc::c_int\n            }) as libc::c_ulong,\n        ) as size_t as size_t;\n    length = (last_component(file)).offset_from(file) as libc::c_long as size_t;\n    while prefix_length < length {\n        if !(*file\n            .offset(length.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_int == '/' as i32)\n        {\n            break;\n        }\n        length = length.wrapping_sub(1);\n        length;\n    }\n    return length;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn mdir_name(mut file: *const libc::c_char) -> *mut libc::c_char {\n    let mut length: size_t = dir_len(file);\n    let mut append_dot: bool = length == 0 as libc::c_int as libc::c_ulong\n        || 0 as libc::c_int != 0 && length == 0 as libc::c_int as libc::c_ulong\n            && *file.offset(2 as libc::c_int as isize) as libc::c_int != '\\0' as i32\n            && !(*file.offset(2 as libc::c_int as isize) as libc::c_int == '/' as i32);\n    let mut dir: *mut libc::c_char = malloc(\n        length\n            .wrapping_add(append_dot as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n    if dir.is_null() {\n        return 0 as *mut libc::c_char;\n    }\n    memcpy(dir as *mut libc::c_void, file as *const libc::c_void, length);\n    if append_dot {\n        let fresh0 = length;\n        length = length.wrapping_add(1);\n        *dir.offset(fresh0 as isize) = '.' as i32 as libc::c_char;\n    }\n    *dir.offset(length as isize) = '\\0' as i32 as libc::c_char;\n    return dir;\n}",
    "use ::libc;\npub type __time_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\npub type time_t = __time_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub type C2RustUnnamed = libc::c_uint;\npub const TIMESPEC_HZ: C2RustUnnamed = 1000000000;\n#[inline]\nunsafe extern \"C\" fn make_timespec(mut s: time_t, mut ns: libc::c_long) -> timespec {\n    return {\n        let mut init = timespec { tv_sec: s, tv_nsec: ns };\n        init\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn dtotimespec(mut sec: libc::c_double) -> timespec {\n    if !((!(if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n        -(1 as libc::c_int) as time_t\n    } else {\n        (((1 as libc::c_int as time_t)\n            << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n            - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n            + 1 as libc::c_int as libc::c_long\n    }) as libc::c_double) < sec)\n    {\n        return make_timespec(\n            !if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n                -(1 as libc::c_int) as time_t\n            } else {\n                (((1 as libc::c_int as time_t)\n                    << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            },\n            0 as libc::c_int as libc::c_long,\n        )\n    } else if !(sec\n        < 1.0f64\n            + (if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n                -(1 as libc::c_int) as time_t\n            } else {\n                (((1 as libc::c_int as time_t)\n                    << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            }) as libc::c_double)\n    {\n        return make_timespec(\n            if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n                -(1 as libc::c_int) as time_t\n            } else {\n                (((1 as libc::c_int as time_t)\n                    << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            },\n            (TIMESPEC_HZ as libc::c_int - 1 as libc::c_int) as libc::c_long,\n        )\n    } else {\n        let mut s: time_t = sec as time_t;\n        let mut frac: libc::c_double = TIMESPEC_HZ as libc::c_int as libc::c_double\n            * (sec - s as libc::c_double);\n        let mut ns: libc::c_long = frac as libc::c_long;\n        ns += ((ns as libc::c_double) < frac) as libc::c_int as libc::c_long;\n        s += ns / TIMESPEC_HZ as libc::c_int as libc::c_long;\n        ns %= TIMESPEC_HZ as libc::c_int as libc::c_long;\n        if ns < 0 as libc::c_int as libc::c_long {\n            s -= 1;\n            s;\n            ns += TIMESPEC_HZ as libc::c_int as libc::c_long;\n        }\n        return make_timespec(s, ns);\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn rpl_fcntl(fd: libc::c_int, action: libc::c_int, _: ...) -> libc::c_int;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn dup_safer(mut fd: libc::c_int) -> libc::c_int {\n    return rpl_fcntl(fd, 0 as libc::c_int, 2 as libc::c_int + 1 as libc::c_int);\n}",
    "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "use ::libc;\nextern \"C\" {\n    fn fcntl(__fd: libc::c_int, __cmd: libc::c_int, _: ...) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fcntl(\n    mut fd: libc::c_int,\n    mut action: libc::c_int,\n    mut args: ...\n) -> libc::c_int {\n    let mut arg: ::core::ffi::VaListImpl;\n    let mut result: libc::c_int = -(1 as libc::c_int);\n    arg = args.clone();\n    match action {\n        0 => {\n            let mut target: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD(fd, target);\n        }\n        1030 => {\n            let mut target_0: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD_CLOEXEC(fd, target_0);\n        }\n        _ => {\n            let mut current_block_7: u64;\n            match action {\n                1 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                3 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                1025 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                9 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                1032 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                1034 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                11 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                1033 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                0 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                1030 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                1026 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                2 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                4 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                8 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1031 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1024 | 10 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {\n                    let mut p: *mut libc::c_void = arg.arg::<*mut libc::c_void>();\n                    result = fcntl(fd, action, p);\n                    current_block_7 = 7175849428784450219;\n                }\n            }\n            match current_block_7 {\n                4046302689674688614 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                8871774344836507656 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                12013198723313890981 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6453289516101043606 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                5351856672558463576 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                13722137258147953758 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                9332010126091029806 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                12766345184754617216 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                17966572639739034653 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6940526744265269810 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                15280576717888187136 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                7022052692272556539 => {\n                    result = fcntl(fd, action);\n                }\n                14034191772621753005 => {\n                    let mut x: libc::c_int = arg.arg::<libc::c_int>();\n                    result = fcntl(fd, action, x);\n                }\n                _ => {}\n            }\n        }\n    }\n    return result;\n}\nunsafe extern \"C\" fn rpl_fcntl_DUPFD(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    result = fcntl(fd, 0 as libc::c_int, target);\n    return result;\n}\nstatic mut have_dupfd_cloexec: libc::c_int = 0;\nunsafe extern \"C\" fn rpl_fcntl_DUPFD_CLOEXEC(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    if 0 as libc::c_int <= have_dupfd_cloexec {\n        result = fcntl(fd, 1030 as libc::c_int, target);\n        if 0 as libc::c_int <= result || *__errno_location() != 22 as libc::c_int {\n            have_dupfd_cloexec = 1 as libc::c_int;\n        } else {\n            result = rpl_fcntl_DUPFD(fd, target);\n            if result >= 0 as libc::c_int {\n                have_dupfd_cloexec = -(1 as libc::c_int);\n            }\n        }\n    } else {\n        result = rpl_fcntl_DUPFD(fd, target);\n    }\n    if 0 as libc::c_int <= result && have_dupfd_cloexec == -(1 as libc::c_int) {\n        let mut flags: libc::c_int = fcntl(result, 1 as libc::c_int);\n        if flags < 0 as libc::c_int\n            || fcntl(result, 2 as libc::c_int, flags | 1 as libc::c_int)\n                == -(1 as libc::c_int)\n        {\n            let mut saved_errno: libc::c_int = *__errno_location();\n            close(result);\n            *__errno_location() = saved_errno;\n            result = -(1 as libc::c_int);\n        }\n    }\n    return result;\n}\nunsafe extern \"C\" fn run_static_initializers() {\n    have_dupfd_cloexec = if 0 as libc::c_int != 0 {\n        -(1 as libc::c_int)\n    } else {\n        0 as libc::c_int\n    };\n}\n#[used]\n#[cfg_attr(target_os = \"linux\", link_section = \".init_array\")]\n#[cfg_attr(target_os = \"windows\", link_section = \".CRT$XIB\")]\n#[cfg_attr(target_os = \"macos\", link_section = \"__DATA,__mod_init_func\")]\nstatic INIT_ARRAY: [unsafe extern \"C\" fn(); 1] = [run_static_initializers];",
    "use ::libc;\nextern \"C\" {\n    fn dup_safer(_: libc::c_int) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn fd_safer(mut fd: libc::c_int) -> libc::c_int {\n    if 0 as libc::c_int <= fd && fd <= 2 as libc::c_int {\n        let mut f: libc::c_int = dup_safer(fd);\n        let mut e: libc::c_int = *__errno_location();\n        close(fd);\n        *__errno_location() = e;\n        fd = f;\n    }\n    return fd;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nunsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __fpurge(__fp: *mut FILE);\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn fpurge(mut fp: *mut FILE) -> libc::c_int {\n    __fpurge(fp);\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct hash_tuning {\n    pub shrink_threshold: libc::c_float,\n    pub shrink_factor: libc::c_float,\n    pub growth_threshold: libc::c_float,\n    pub growth_factor: libc::c_float,\n    pub is_n_buckets: bool,\n}\npub type Hash_tuning = hash_tuning;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct hash_table {\n    pub bucket: *mut hash_entry,\n    pub bucket_limit: *const hash_entry,\n    pub n_buckets: size_t,\n    pub n_buckets_used: size_t,\n    pub n_entries: size_t,\n    pub tuning: *const Hash_tuning,\n    pub hasher: Hash_hasher,\n    pub comparator: Hash_comparator,\n    pub data_freer: Hash_data_freer,\n    pub free_entry_list: *mut hash_entry,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct hash_entry {\n    pub data: *mut libc::c_void,\n    pub next: *mut hash_entry,\n}\npub type Hash_data_freer = Option::<unsafe extern \"C\" fn(*mut libc::c_void) -> ()>\n;\npub type Hash_comparator = Option::<\n    unsafe extern \"C\" fn(*const libc::c_void, *const libc::c_void) -> bool,\n>\n;\npub type Hash_hasher = Option::<\n    unsafe extern \"C\" fn(*const libc::c_void, size_t) -> size_t,\n>\n;\npub type Hash_table = hash_table;\npub type Hash_processor = Option::<\n    unsafe extern \"C\" fn(*mut libc::c_void, *mut libc::c_void) -> bool,\n>;\n#[inline]\nunsafe extern \"C\" fn rotr_sz(mut x: size_t, mut n: libc::c_int) -> size_t\n{\n    return (x >> n\n        | x\n            << (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<size_t>() as libc::c_ulong)\n                .wrapping_sub(n as libc::c_ulong))\n        & 18446744073709551615 as libc::c_ulong;\n}\nstatic mut default_tuning: Hash_tuning = {\n    let mut init = hash_tuning {\n        shrink_threshold: 0.0f32,\n        shrink_factor: 1.0f32,\n        growth_threshold: 0.8f32,\n        growth_factor: 1.414f32,\n        is_n_buckets: 0 as libc::c_int != 0,\n    };\n    init\n};\n#[no_mangle]\npub unsafe extern \"C\" fn hash_get_n_buckets(mut table: *const Hash_table) -> size_t {\n    return (*table).n_buckets;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_get_n_buckets_used(\n    mut table: *const Hash_table,\n) -> size_t {\n    return (*table).n_buckets_used;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_get_n_entries(mut table: *const Hash_table) -> size_t {\n    return (*table).n_entries;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_get_max_bucket_length(\n    mut table: *const Hash_table,\n) -> size_t {\n    let mut bucket: *const hash_entry = 0 as *const hash_entry;\n    let mut max_bucket_length: size_t = 0 as libc::c_int as size_t;\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit {\n        if !((*bucket).data).is_null() {\n            let mut cursor: *const hash_entry = bucket;\n            let mut bucket_length: size_t = 1 as libc::c_int as size_t;\n            loop {\n                cursor = (*cursor).next;\n                if cursor.is_null() {\n                    break;\n                }\n                bucket_length = bucket_length.wrapping_add(1);\n                bucket_length;\n            }\n            if bucket_length > max_bucket_length {\n                max_bucket_length = bucket_length;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    return max_bucket_length;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_table_ok(mut table: *const Hash_table) -> bool {\n    let mut bucket: *const hash_entry = 0 as *const hash_entry;\n    let mut n_buckets_used: size_t = 0 as libc::c_int as size_t;\n    let mut n_entries: size_t = 0 as libc::c_int as size_t;\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit {\n        if !((*bucket).data).is_null() {\n            let mut cursor: *const hash_entry = bucket;\n            n_buckets_used = n_buckets_used.wrapping_add(1);\n            n_buckets_used;\n            n_entries = n_entries.wrapping_add(1);\n            n_entries;\n            loop {\n                cursor = (*cursor).next;\n                if cursor.is_null() {\n                    break;\n                }\n                n_entries = n_entries.wrapping_add(1);\n                n_entries;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    if n_buckets_used == (*table).n_buckets_used && n_entries == (*table).n_entries {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_print_statistics(\n    mut table: *const Hash_table,\n    mut stream: *mut FILE,\n) {\n    let mut n_entries: size_t = hash_get_n_entries(table);\n    let mut n_buckets: size_t = hash_get_n_buckets(table);\n    let mut n_buckets_used: size_t = hash_get_n_buckets_used(table);\n    let mut max_bucket_length: size_t = hash_get_max_bucket_length(table);\n    fprintf(\n        stream,\n        b\"# entries:         %lu\\n\\0\" as *const u8 as *const libc::c_char,\n        n_entries,\n    );\n    fprintf(\n        stream,\n        b\"# buckets:         %lu\\n\\0\" as *const u8 as *const libc::c_char,\n        n_buckets,\n    );\n    fprintf(\n        stream,\n        b\"# buckets used:    %lu (%.2f%%)\\n\\0\" as *const u8 as *const libc::c_char,\n        n_buckets_used,\n        100.0f64 * n_buckets_used as libc::c_double / n_buckets as libc::c_double,\n    );\n    fprintf(\n        stream,\n        b\"max bucket length: %lu\\n\\0\" as *const u8 as *const libc::c_char,\n        max_bucket_length,\n    );\n}\nunsafe extern \"C\" fn safe_hasher(\n    mut table: *const Hash_table,\n    mut key: *const libc::c_void,\n) -> *mut hash_entry {\n    let mut n: size_t = ((*table).hasher)\n        .expect(\"non-null function pointer\")(key, (*table).n_buckets);\n    if !(n < (*table).n_buckets) {\n        abort();\n    }\n    return ((*table).bucket).offset(n as isize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_lookup(\n    mut table: *const Hash_table,\n    mut entry: *const libc::c_void,\n) -> *mut libc::c_void {\n    let mut bucket: *const hash_entry = safe_hasher(table, entry);\n    let mut cursor: *const hash_entry = 0 as *const hash_entry;\n    if ((*bucket).data).is_null() {\n        return 0 as *mut libc::c_void;\n    }\n    cursor = bucket;\n    while !cursor.is_null() {\n        if entry == (*cursor).data as *const libc::c_void\n            || ((*table).comparator)\n                .expect(\"non-null function pointer\")(entry, (*cursor).data)\n                as libc::c_int != 0\n        {\n            return (*cursor).data;\n        }\n        cursor = (*cursor).next;\n    }\n    return 0 as *mut libc::c_void;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_get_first(\n    mut table: *const Hash_table,\n) -> *mut libc::c_void {\n    let mut bucket: *const hash_entry = 0 as *const hash_entry;\n    if (*table).n_entries == 0 as libc::c_int as libc::c_ulong {\n        return 0 as *mut libc::c_void;\n    }\n    bucket = (*table).bucket;\n    loop {\n        if !(bucket < (*table).bucket_limit) {\n            abort();\n        } else if !((*bucket).data).is_null() {\n            return (*bucket).data\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_get_next(\n    mut table: *const Hash_table,\n    mut entry: *const libc::c_void,\n) -> *mut libc::c_void {\n    let mut bucket: *const hash_entry = safe_hasher(table, entry);\n    let mut cursor: *const hash_entry = 0 as *const hash_entry;\n    cursor = bucket;\n    loop {\n        if (*cursor).data == entry as *mut libc::c_void && !((*cursor).next).is_null() {\n            return (*(*cursor).next).data;\n        }\n        cursor = (*cursor).next;\n        if cursor.is_null() {\n            break;\n        }\n    }\n    loop {\n        bucket = bucket.offset(1);\n        if !(bucket < (*table).bucket_limit) {\n            break;\n        }\n        if !((*bucket).data).is_null() {\n            return (*bucket).data;\n        }\n    }\n    return 0 as *mut libc::c_void;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_get_entries(\n    mut table: *const Hash_table,\n    mut buffer: *mut *mut libc::c_void,\n    mut buffer_size: size_t,\n) -> size_t {\n    let mut counter: size_t = 0 as libc::c_int as size_t;\n    let mut bucket: *const hash_entry = 0 as *const hash_entry;\n    let mut cursor: *const hash_entry = 0 as *const hash_entry;\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit {\n        if !((*bucket).data).is_null() {\n            cursor = bucket;\n            while !cursor.is_null() {\n                if counter >= buffer_size {\n                    return counter;\n                }\n                let fresh0 = counter;\n                counter = counter.wrapping_add(1);\n                let ref mut fresh1 = *buffer.offset(fresh0 as isize);\n                *fresh1 = (*cursor).data;\n                cursor = (*cursor).next;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    return counter;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_do_for_each(\n    mut table: *const Hash_table,\n    mut processor: Hash_processor,\n    mut processor_data: *mut libc::c_void,\n) -> size_t {\n    let mut counter: size_t = 0 as libc::c_int as size_t;\n    let mut bucket: *const hash_entry = 0 as *const hash_entry;\n    let mut cursor: *const hash_entry = 0 as *const hash_entry;\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit {\n        if !((*bucket).data).is_null() {\n            cursor = bucket;\n            while !cursor.is_null() {\n                if !processor\n                    .expect(\"non-null function pointer\")((*cursor).data, processor_data)\n                {\n                    return counter;\n                }\n                counter = counter.wrapping_add(1);\n                counter;\n                cursor = (*cursor).next;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    return counter;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_string(\n    mut string: *const libc::c_char,\n    mut n_buckets: size_t,\n) -> size_t {\n    let mut value: size_t = 0 as libc::c_int as size_t;\n    let mut ch: libc::c_uchar = 0;\n    loop {\n        ch = *string as libc::c_uchar;\n        if !(ch != 0) {\n            break;\n        }\n        value = value\n            .wrapping_mul(31 as libc::c_int as libc::c_ulong)\n            .wrapping_add(ch as libc::c_ulong)\n            .wrapping_rem(n_buckets);\n        string = string.offset(1);\n        string;\n    }\n    return value;\n}\nunsafe extern \"C\" fn is_prime(mut candidate: size_t) -> bool {\n    let mut divisor: size_t = 3 as libc::c_int as size_t;\n    let mut square: size_t = divisor.wrapping_mul(divisor);\n    while square < candidate && candidate.wrapping_rem(divisor) != 0 {\n        divisor = divisor.wrapping_add(1);\n        divisor;\n        square = (square as libc::c_ulong)\n            .wrapping_add((4 as libc::c_int as libc::c_ulong).wrapping_mul(divisor))\n            as size_t as size_t;\n        divisor = divisor.wrapping_add(1);\n        divisor;\n    }\n    return if candidate.wrapping_rem(divisor) != 0 {\n        1 as libc::c_int\n    } else {\n        0 as libc::c_int\n    } != 0;\n}\nunsafe extern \"C\" fn next_prime(mut candidate: size_t) -> size_t {\n    if candidate < 10 as libc::c_int as libc::c_ulong {\n        candidate = 10 as libc::c_int as size_t;\n    }\n    candidate |= 1 as libc::c_int as libc::c_ulong;\n    while 18446744073709551615 as libc::c_ulong != candidate && !is_prime(candidate) {\n        candidate = (candidate as libc::c_ulong)\n            .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t as size_t;\n    }\n    return candidate;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_reset_tuning(mut tuning: *mut Hash_tuning) {\n    *tuning = default_tuning;\n}\nunsafe extern \"C\" fn raw_hasher(mut data: *const libc::c_void, mut n: size_t) -> size_t {\n    let mut val: size_t = rotr_sz(data as size_t, 3 as libc::c_int);\n    return val.wrapping_rem(n);\n}\nunsafe extern \"C\" fn raw_comparator(\n    mut a: *const libc::c_void,\n    mut b: *const libc::c_void,\n) -> bool {\n    return a == b;\n}\nunsafe extern \"C\" fn check_tuning(mut table: *mut Hash_table) -> bool {\n    let mut tuning: *const Hash_tuning = (*table).tuning;\n    let mut epsilon: libc::c_float = 0.;\n    if tuning == &default_tuning as *const Hash_tuning {\n        return 1 as libc::c_int != 0;\n    }\n    epsilon = 0.1f32;\n    if epsilon < (*tuning).growth_threshold\n        && (*tuning).growth_threshold < 1 as libc::c_int as libc::c_float - epsilon\n        && 1 as libc::c_int as libc::c_float + epsilon < (*tuning).growth_factor\n        && 0 as libc::c_int as libc::c_float <= (*tuning).shrink_threshold\n        && (*tuning).shrink_threshold + epsilon < (*tuning).shrink_factor\n        && (*tuning).shrink_factor <= 1 as libc::c_int as libc::c_float\n        && (*tuning).shrink_threshold + epsilon < (*tuning).growth_threshold\n    {\n        return 1 as libc::c_int != 0;\n    }\n    (*table).tuning = &default_tuning;\n    return 0 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn compute_bucket_size(\n    mut candidate: size_t,\n    mut tuning: *const Hash_tuning,\n) -> size_t {\n    let mut current_block: u64;\n    if !(*tuning).is_n_buckets {\n        let mut new_candidate: libc::c_float = candidate as libc::c_float\n            / (*tuning).growth_threshold;\n        if 18446744073709551615 as libc::c_ulong as libc::c_float <= new_candidate {\n            current_block = 8933918830699217881;\n        } else {\n            candidate = new_candidate as size_t;\n            current_block = 12675440807659640239;\n        }\n    } else {\n        current_block = 12675440807659640239;\n    }\n    match current_block {\n        12675440807659640239 => {\n            candidate = next_prime(candidate);\n            if !(::core::mem::size_of::<*mut hash_entry>() as libc::c_ulong\n                != 0 as libc::c_int as libc::c_ulong\n                && (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n                    < 18446744073709551615 as libc::c_ulong\n                {\n                    9223372036854775807 as libc::c_long as libc::c_ulong\n                } else {\n                    (18446744073709551615 as libc::c_ulong)\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                })\n                    .wrapping_div(\n                        ::core::mem::size_of::<*mut hash_entry>() as libc::c_ulong,\n                    ) < candidate)\n            {\n                return candidate;\n            }\n        }\n        _ => {}\n    }\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as libc::c_int as size_t;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn hash_initialize(\n    mut candidate: size_t,\n    mut tuning: *const Hash_tuning,\n    mut hasher: Hash_hasher,\n    mut comparator: Hash_comparator,\n    mut data_freer: Hash_data_freer,\n) -> *mut Hash_table {\n    let mut table: *mut Hash_table = 0 as *mut Hash_table;\n    if hasher.is_none() {\n        hasher = Some(\n            raw_hasher as unsafe extern \"C\" fn(*const libc::c_void, size_t) -> size_t,\n        );\n    }\n    if comparator.is_none() {\n        comparator = Some(\n            raw_comparator\n                as unsafe extern \"C\" fn(*const libc::c_void, *const libc::c_void) -> bool,\n        );\n    }\n    table = malloc(::core::mem::size_of::<Hash_table>() as libc::c_ulong)\n        as *mut Hash_table;\n    if table.is_null() {\n        return 0 as *mut Hash_table;\n    }\n    if tuning.is_null() {\n        tuning = &default_tuning;\n    }\n    (*table).tuning = tuning;\n    if !check_tuning(table) {\n        *__errno_location() = 22 as libc::c_int;\n    } else {\n        (*table).n_buckets = compute_bucket_size(candidate, tuning);\n        if !((*table).n_buckets == 0) {\n            (*table)\n                .bucket = calloc(\n                (*table).n_buckets,\n                ::core::mem::size_of::<hash_entry>() as libc::c_ulong,\n            ) as *mut hash_entry;\n            if !((*table).bucket).is_null() {\n                (*table)\n                    .bucket_limit = ((*table).bucket)\n                    .offset((*table).n_buckets as isize);\n                (*table).n_buckets_used = 0 as libc::c_int as size_t;\n                (*table).n_entries = 0 as libc::c_int as size_t;\n                (*table).hasher = hasher;\n                (*table).comparator = comparator;\n                (*table).data_freer = data_freer;\n                (*table).free_entry_list = 0 as *mut hash_entry;\n                return table;\n            }\n        }\n    }\n    free(table as *mut libc::c_void);\n    return 0 as *mut Hash_table;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_clear(mut table: *mut Hash_table) {\n    let mut bucket: *mut hash_entry = 0 as *mut hash_entry;\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit as *mut hash_entry {\n        if !((*bucket).data).is_null() {\n            let mut cursor: *mut hash_entry = 0 as *mut hash_entry;\n            let mut next: *mut hash_entry = 0 as *mut hash_entry;\n            cursor = (*bucket).next;\n            while !cursor.is_null() {\n                if ((*table).data_freer).is_some() {\n                    ((*table).data_freer)\n                        .expect(\"non-null function pointer\")((*cursor).data);\n                }\n                (*cursor).data = 0 as *mut libc::c_void;\n                next = (*cursor).next;\n                (*cursor).next = (*table).free_entry_list;\n                (*table).free_entry_list = cursor;\n                cursor = next;\n            }\n            if ((*table).data_freer).is_some() {\n                ((*table).data_freer)\n                    .expect(\"non-null function pointer\")((*bucket).data);\n            }\n            (*bucket).data = 0 as *mut libc::c_void;\n            (*bucket).next = 0 as *mut hash_entry;\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    (*table).n_buckets_used = 0 as libc::c_int as size_t;\n    (*table).n_entries = 0 as libc::c_int as size_t;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_free(mut table: *mut Hash_table) {\n    let mut bucket: *mut hash_entry = 0 as *mut hash_entry;\n    let mut cursor: *mut hash_entry = 0 as *mut hash_entry;\n    let mut next: *mut hash_entry = 0 as *mut hash_entry;\n    let mut err: libc::c_int = *__errno_location();\n    if ((*table).data_freer).is_some() && (*table).n_entries != 0 {\n        bucket = (*table).bucket;\n        while bucket < (*table).bucket_limit as *mut hash_entry {\n            if !((*bucket).data).is_null() {\n                cursor = bucket;\n                while !cursor.is_null() {\n                    ((*table).data_freer)\n                        .expect(\"non-null function pointer\")((*cursor).data);\n                    cursor = (*cursor).next;\n                }\n            }\n            bucket = bucket.offset(1);\n            bucket;\n        }\n    }\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit as *mut hash_entry {\n        cursor = (*bucket).next;\n        while !cursor.is_null() {\n            next = (*cursor).next;\n            free(cursor as *mut libc::c_void);\n            cursor = next;\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    cursor = (*table).free_entry_list;\n    while !cursor.is_null() {\n        next = (*cursor).next;\n        free(cursor as *mut libc::c_void);\n        cursor = next;\n    }\n    free((*table).bucket as *mut libc::c_void);\n    free(table as *mut libc::c_void);\n    *__errno_location() = err;\n}\nunsafe extern \"C\" fn allocate_entry(mut table: *mut Hash_table) -> *mut hash_entry {\n    let mut new: *mut hash_entry = 0 as *mut hash_entry;\n    if !((*table).free_entry_list).is_null() {\n        new = (*table).free_entry_list;\n        (*table).free_entry_list = (*new).next;\n    } else {\n        new = malloc(::core::mem::size_of::<hash_entry>() as libc::c_ulong)\n            as *mut hash_entry;\n    }\n    return new;\n}\nunsafe extern \"C\" fn free_entry(mut table: *mut Hash_table, mut entry: *mut hash_entry) {\n    (*entry).data = 0 as *mut libc::c_void;\n    (*entry).next = (*table).free_entry_list;\n    (*table).free_entry_list = entry;\n}\nunsafe extern \"C\" fn hash_find_entry(\n    mut table: *mut Hash_table,\n    mut entry: *const libc::c_void,\n    mut bucket_head: *mut *mut hash_entry,\n    mut delete: bool,\n) -> *mut libc::c_void {\n    let mut bucket: *mut hash_entry = safe_hasher(table, entry);\n    let mut cursor: *mut hash_entry = 0 as *mut hash_entry;\n    *bucket_head = bucket;\n    if ((*bucket).data).is_null() {\n        return 0 as *mut libc::c_void;\n    }\n    if entry == (*bucket).data as *const libc::c_void\n        || ((*table).comparator)\n            .expect(\"non-null function pointer\")(entry, (*bucket).data) as libc::c_int\n            != 0\n    {\n        let mut data: *mut libc::c_void = (*bucket).data;\n        if delete {\n            if !((*bucket).next).is_null() {\n                let mut next: *mut hash_entry = (*bucket).next;\n                *bucket = *next;\n                free_entry(table, next);\n            } else {\n                (*bucket).data = 0 as *mut libc::c_void;\n            }\n        }\n        return data;\n    }\n    cursor = bucket;\n    while !((*cursor).next).is_null() {\n        if entry == (*(*cursor).next).data as *const libc::c_void\n            || ((*table).comparator)\n                .expect(\"non-null function pointer\")(entry, (*(*cursor).next).data)\n                as libc::c_int != 0\n        {\n            let mut data_0: *mut libc::c_void = (*(*cursor).next).data;\n            if delete {\n                let mut next_0: *mut hash_entry = (*cursor).next;\n                (*cursor).next = (*next_0).next;\n                free_entry(table, next_0);\n            }\n            return data_0;\n        }\n        cursor = (*cursor).next;\n    }\n    return 0 as *mut libc::c_void;\n}\nunsafe extern \"C\" fn transfer_entries(\n    mut dst: *mut Hash_table,\n    mut src: *mut Hash_table,\n    mut safe: bool,\n) -> bool {\n    let mut bucket: *mut hash_entry = 0 as *mut hash_entry;\n    let mut cursor: *mut hash_entry = 0 as *mut hash_entry;\n    let mut next: *mut hash_entry = 0 as *mut hash_entry;\n    bucket = (*src).bucket;\n    while bucket < (*src).bucket_limit as *mut hash_entry {\n        if !((*bucket).data).is_null() {\n            let mut data: *mut libc::c_void = 0 as *mut libc::c_void;\n            let mut new_bucket: *mut hash_entry = 0 as *mut hash_entry;\n            cursor = (*bucket).next;\n            while !cursor.is_null() {\n                data = (*cursor).data;\n                new_bucket = safe_hasher(dst, data);\n                next = (*cursor).next;\n                if !((*new_bucket).data).is_null() {\n                    (*cursor).next = (*new_bucket).next;\n                    (*new_bucket).next = cursor;\n                } else {\n                    (*new_bucket).data = data;\n                    (*dst).n_buckets_used = ((*dst).n_buckets_used).wrapping_add(1);\n                    (*dst).n_buckets_used;\n                    free_entry(dst, cursor);\n                }\n                cursor = next;\n            }\n            data = (*bucket).data;\n            (*bucket).next = 0 as *mut hash_entry;\n            if !safe {\n                new_bucket = safe_hasher(dst, data);\n                if !((*new_bucket).data).is_null() {\n                    let mut new_entry: *mut hash_entry = allocate_entry(dst);\n                    if new_entry.is_null() {\n                        return 0 as libc::c_int != 0;\n                    }\n                    (*new_entry).data = data;\n                    (*new_entry).next = (*new_bucket).next;\n                    (*new_bucket).next = new_entry;\n                } else {\n                    (*new_bucket).data = data;\n                    (*dst).n_buckets_used = ((*dst).n_buckets_used).wrapping_add(1);\n                    (*dst).n_buckets_used;\n                }\n                (*bucket).data = 0 as *mut libc::c_void;\n                (*src).n_buckets_used = ((*src).n_buckets_used).wrapping_sub(1);\n                (*src).n_buckets_used;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    return 1 as libc::c_int != 0;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_rehash(\n    mut table: *mut Hash_table,\n    mut candidate: size_t,\n) -> bool {\n    let mut storage: Hash_table = Hash_table {\n        bucket: 0 as *mut hash_entry,\n        bucket_limit: 0 as *const hash_entry,\n        n_buckets: 0,\n        n_buckets_used: 0,\n        n_entries: 0,\n        tuning: 0 as *const Hash_tuning,\n        hasher: None,\n        comparator: None,\n        data_freer: None,\n        free_entry_list: 0 as *mut hash_entry,\n    };\n    let mut new_table: *mut Hash_table = 0 as *mut Hash_table;\n    let mut new_size: size_t = compute_bucket_size(candidate, (*table).tuning);\n    if new_size == 0 {\n        return 0 as libc::c_int != 0;\n    }\n    if new_size == (*table).n_buckets {\n        return 1 as libc::c_int != 0;\n    }\n    new_table = &mut storage;\n    (*new_table)\n        .bucket = calloc(new_size, ::core::mem::size_of::<hash_entry>() as libc::c_ulong)\n        as *mut hash_entry;\n    if ((*new_table).bucket).is_null() {\n        return 0 as libc::c_int != 0;\n    }\n    (*new_table).n_buckets = new_size;\n    (*new_table).bucket_limit = ((*new_table).bucket).offset(new_size as isize);\n    (*new_table).n_buckets_used = 0 as libc::c_int as size_t;\n    (*new_table).n_entries = 0 as libc::c_int as size_t;\n    (*new_table).tuning = (*table).tuning;\n    (*new_table).hasher = (*table).hasher;\n    (*new_table).comparator = (*table).comparator;\n    (*new_table).data_freer = (*table).data_freer;\n    (*new_table).free_entry_list = (*table).free_entry_list;\n    if transfer_entries(new_table, table, 0 as libc::c_int != 0) {\n        free((*table).bucket as *mut libc::c_void);\n        (*table).bucket = (*new_table).bucket;\n        (*table).bucket_limit = (*new_table).bucket_limit;\n        (*table).n_buckets = (*new_table).n_buckets;\n        (*table).n_buckets_used = (*new_table).n_buckets_used;\n        (*table).free_entry_list = (*new_table).free_entry_list;\n        return 1 as libc::c_int != 0;\n    }\n    let mut err: libc::c_int = *__errno_location();\n    (*table).free_entry_list = (*new_table).free_entry_list;\n    if !(transfer_entries(table, new_table, 1 as libc::c_int != 0) as libc::c_int != 0\n        && transfer_entries(table, new_table, 0 as libc::c_int != 0) as libc::c_int != 0)\n    {\n        abort();\n    }\n    free((*new_table).bucket as *mut libc::c_void);\n    *__errno_location() = err;\n    return 0 as libc::c_int != 0;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_insert_if_absent(\n    mut table: *mut Hash_table,\n    mut entry: *const libc::c_void,\n    mut matched_ent: *mut *const libc::c_void,\n) -> libc::c_int {\n    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;\n    let mut bucket: *mut hash_entry = 0 as *mut hash_entry;\n    if entry.is_null() {\n        abort();\n    }\n    data = hash_find_entry(table, entry, &mut bucket, 0 as libc::c_int != 0);\n    if !data.is_null() {\n        if !matched_ent.is_null() {\n            *matched_ent = data;\n        }\n        return 0 as libc::c_int;\n    }\n    if (*table).n_buckets_used as libc::c_float\n        > (*(*table).tuning).growth_threshold * (*table).n_buckets as libc::c_float\n    {\n        check_tuning(table);\n        if (*table).n_buckets_used as libc::c_float\n            > (*(*table).tuning).growth_threshold * (*table).n_buckets as libc::c_float\n        {\n            let mut tuning: *const Hash_tuning = (*table).tuning;\n            let mut candidate: libc::c_float = if (*tuning).is_n_buckets as libc::c_int\n                != 0\n            {\n                (*table).n_buckets as libc::c_float * (*tuning).growth_factor\n            } else {\n                (*table).n_buckets as libc::c_float * (*tuning).growth_factor\n                    * (*tuning).growth_threshold\n            };\n            if 18446744073709551615 as libc::c_ulong as libc::c_float <= candidate {\n                *__errno_location() = 12 as libc::c_int;\n                return -(1 as libc::c_int);\n            }\n            if !hash_rehash(table, candidate as size_t) {\n                return -(1 as libc::c_int);\n            }\n            if !(hash_find_entry(table, entry, &mut bucket, 0 as libc::c_int != 0))\n                .is_null()\n            {\n                abort();\n            }\n        }\n    }\n    if !((*bucket).data).is_null() {\n        let mut new_entry: *mut hash_entry = allocate_entry(table);\n        if new_entry.is_null() {\n            return -(1 as libc::c_int);\n        }\n        (*new_entry).data = entry as *mut libc::c_void;\n        (*new_entry).next = (*bucket).next;\n        (*bucket).next = new_entry;\n        (*table).n_entries = ((*table).n_entries).wrapping_add(1);\n        (*table).n_entries;\n        return 1 as libc::c_int;\n    }\n    (*bucket).data = entry as *mut libc::c_void;\n    (*table).n_entries = ((*table).n_entries).wrapping_add(1);\n    (*table).n_entries;\n    (*table).n_buckets_used = ((*table).n_buckets_used).wrapping_add(1);\n    (*table).n_buckets_used;\n    return 1 as libc::c_int;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_insert(\n    mut table: *mut Hash_table,\n    mut entry: *const libc::c_void,\n) -> *mut libc::c_void {\n    let mut matched_ent: *const libc::c_void = 0 as *const libc::c_void;\n    let mut err: libc::c_int = hash_insert_if_absent(table, entry, &mut matched_ent);\n    return if err == -(1 as libc::c_int) {\n        0 as *mut libc::c_void\n    } else {\n        (if err == 0 as libc::c_int { matched_ent } else { entry }) as *mut libc::c_void\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_remove(\n    mut table: *mut Hash_table,\n    mut entry: *const libc::c_void,\n) -> *mut libc::c_void {\n    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;\n    let mut bucket: *mut hash_entry = 0 as *mut hash_entry;\n    data = hash_find_entry(table, entry, &mut bucket, 1 as libc::c_int != 0);\n    if data.is_null() {\n        return 0 as *mut libc::c_void;\n    }\n    (*table).n_entries = ((*table).n_entries).wrapping_sub(1);\n    (*table).n_entries;\n    if ((*bucket).data).is_null() {\n        (*table).n_buckets_used = ((*table).n_buckets_used).wrapping_sub(1);\n        (*table).n_buckets_used;\n        if ((*table).n_buckets_used as libc::c_float)\n            < (*(*table).tuning).shrink_threshold * (*table).n_buckets as libc::c_float\n        {\n            check_tuning(table);\n            if ((*table).n_buckets_used as libc::c_float)\n                < (*(*table).tuning).shrink_threshold\n                    * (*table).n_buckets as libc::c_float\n            {\n                let mut tuning: *const Hash_tuning = (*table).tuning;\n                let mut candidate: size_t = (if (*tuning).is_n_buckets as libc::c_int\n                    != 0\n                {\n                    (*table).n_buckets as libc::c_float * (*tuning).shrink_factor\n                } else {\n                    (*table).n_buckets as libc::c_float * (*tuning).shrink_factor\n                        * (*tuning).growth_threshold\n                }) as size_t;\n                if !hash_rehash(table, candidate) {\n                    let mut cursor: *mut hash_entry = (*table).free_entry_list;\n                    let mut next: *mut hash_entry = 0 as *mut hash_entry;\n                    while !cursor.is_null() {\n                        next = (*cursor).next;\n                        free(cursor as *mut libc::c_void);\n                        cursor = next;\n                    }\n                    (*table).free_entry_list = 0 as *mut hash_entry;\n                }\n            }\n        }\n    }\n    return data;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn hash_delete(\n    mut table: *mut Hash_table,\n    mut entry: *const libc::c_void,\n) -> *mut libc::c_void {\n    return hash_remove(table, entry);\n}",
    "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n    fn poll(__fds: *mut pollfd, __nfds: nfds_t, __timeout: libc::c_int) -> libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn fwrite_unlocked(\n        __ptr: *const libc::c_void,\n        __size: size_t,\n        __n: size_t,\n        __stream: *mut FILE,\n    ) -> size_t;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn isapipe(fd: libc::c_int) -> libc::c_int;\n}\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __ssize_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub type nfds_t = libc::c_ulong;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct pollfd {\n    pub fd: libc::c_int,\n    pub events: libc::c_short,\n    pub revents: libc::c_short,\n}\npub type ssize_t = __ssize_t;\npub type size_t = libc::c_ulong;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\nunsafe extern \"C\" fn iopoll_internal(\n    mut fdin: libc::c_int,\n    mut fdout: libc::c_int,\n    mut block: bool,\n    mut broken_output: bool,\n) -> libc::c_int {\n    if fdin != -(1 as libc::c_int) || fdout != -(1 as libc::c_int) {} else {\n        __assert_fail(\n            b\"fdin != -1 || fdout != -1\\0\" as *const u8 as *const libc::c_char,\n            b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n            63 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 44],\n                &[libc::c_char; 44],\n            >(b\"int iopoll_internal(int, int, _Bool, _Bool)\\0\"))\n                .as_ptr(),\n        );\n    }\n    'c_6989: {\n        if fdin != -(1 as libc::c_int) || fdout != -(1 as libc::c_int) {} else {\n            __assert_fail(\n                b\"fdin != -1 || fdout != -1\\0\" as *const u8 as *const libc::c_char,\n                b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n                63 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 44],\n                    &[libc::c_char; 44],\n                >(b\"int iopoll_internal(int, int, _Bool, _Bool)\\0\"))\n                    .as_ptr(),\n            );\n        }\n    };\n    let mut pfds: [pollfd; 2] = [\n        {\n            let mut init = pollfd {\n                fd: fdin,\n                events: (0x1 as libc::c_int | 0x80 as libc::c_int) as libc::c_short,\n                revents: 0 as libc::c_int as libc::c_short,\n            };\n            init\n        },\n        {\n            let mut init = pollfd {\n                fd: fdout,\n                events: 0x80 as libc::c_int as libc::c_short,\n                revents: 0 as libc::c_int as libc::c_short,\n            };\n            init\n        },\n    ];\n    let mut check_out_events: libc::c_int = 0x8 as libc::c_int | 0x10 as libc::c_int\n        | 0x20 as libc::c_int;\n    let mut ret: libc::c_int = 0 as libc::c_int;\n    if !broken_output {\n        pfds[1 as libc::c_int as usize].events = 0x4 as libc::c_int as libc::c_short;\n        pfds[0 as libc::c_int as usize].events = pfds[1 as libc::c_int as usize].events;\n        check_out_events = 0x4 as libc::c_int;\n    }\n    while 0 as libc::c_int <= ret || *__errno_location() == 4 as libc::c_int {\n        ret = poll(\n            pfds.as_mut_ptr(),\n            2 as libc::c_int as nfds_t,\n            if block as libc::c_int != 0 {\n                -(1 as libc::c_int)\n            } else {\n                0 as libc::c_int\n            },\n        );\n        if ret < 0 as libc::c_int {\n            continue;\n        }\n        if ret == 0 as libc::c_int && !block {\n            return 0 as libc::c_int;\n        }\n        if (0 as libc::c_int) < ret {} else {\n            __assert_fail(\n                b\"0 < ret\\0\" as *const u8 as *const libc::c_char,\n                b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n                87 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 44],\n                    &[libc::c_char; 44],\n                >(b\"int iopoll_internal(int, int, _Bool, _Bool)\\0\"))\n                    .as_ptr(),\n            );\n        }\n        'c_6877: {\n            if (0 as libc::c_int) < ret {} else {\n                __assert_fail(\n                    b\"0 < ret\\0\" as *const u8 as *const libc::c_char,\n                    b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n                    87 as libc::c_int as libc::c_uint,\n                    (*::core::mem::transmute::<\n                        &[u8; 44],\n                        &[libc::c_char; 44],\n                    >(b\"int iopoll_internal(int, int, _Bool, _Bool)\\0\"))\n                        .as_ptr(),\n                );\n            }\n        };\n        if pfds[0 as libc::c_int as usize].revents != 0 {\n            return 0 as libc::c_int;\n        }\n        if pfds[1 as libc::c_int as usize].revents as libc::c_int & check_out_events != 0\n        {\n            return if broken_output as libc::c_int != 0 {\n                -(2 as libc::c_int)\n            } else {\n                0 as libc::c_int\n            };\n        }\n    }\n    return -(3 as libc::c_int);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn iopoll(\n    mut fdin: libc::c_int,\n    mut fdout: libc::c_int,\n    mut block: bool,\n) -> libc::c_int {\n    return iopoll_internal(fdin, fdout, block, 1 as libc::c_int != 0);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn iopoll_input_ok(mut fdin: libc::c_int) -> bool {\n    let mut st: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut always_ready: bool = fstat(fdin, &mut st) == 0 as libc::c_int\n        && (st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o100000 as libc::c_int as libc::c_uint\n            || st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o60000 as libc::c_int as libc::c_uint);\n    return !always_ready;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn iopoll_output_ok(mut fdout: libc::c_int) -> bool {\n    return isapipe(fdout) > 0 as libc::c_int;\n}\nunsafe extern \"C\" fn fwait_for_nonblocking_write(mut f: *mut FILE) -> bool {\n    if !(*__errno_location() == 11 as libc::c_int\n        || *__errno_location() == 11 as libc::c_int)\n    {\n        return 0 as libc::c_int != 0;\n    }\n    let mut fd: libc::c_int = fileno(f);\n    if !(fd == -(1 as libc::c_int)) {\n        if !(iopoll_internal(\n            -(1 as libc::c_int),\n            fd,\n            1 as libc::c_int != 0,\n            0 as libc::c_int != 0,\n        ) != 0 as libc::c_int)\n        {\n            clearerr_unlocked(f);\n            return 1 as libc::c_int != 0;\n        }\n    }\n    *__errno_location() = 11 as libc::c_int;\n    return 0 as libc::c_int != 0;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn fclose_wait(mut f: *mut FILE) -> bool {\n    while !(fflush_unlocked(f) == 0 as libc::c_int) {\n        if !fwait_for_nonblocking_write(f) {\n            break;\n        }\n    }\n    return rpl_fclose(f) == 0 as libc::c_int;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn fwrite_wait(\n    mut buf: *const libc::c_char,\n    mut size: ssize_t,\n    mut f: *mut FILE,\n) -> bool {\n    loop {\n        let written: size_t = fwrite_unlocked(\n            buf as *const libc::c_void,\n            1 as libc::c_int as size_t,\n            size as size_t,\n            f,\n        );\n        size = (size as libc::c_ulong).wrapping_sub(written) as ssize_t as ssize_t;\n        if size >= 0 as libc::c_int as libc::c_long {} else {\n            __assert_fail(\n                b\"size >= 0\\0\" as *const u8 as *const libc::c_char,\n                b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n                230 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 49],\n                    &[libc::c_char; 49],\n                >(b\"_Bool fwrite_wait(const char *, ssize_t, FILE *)\\0\"))\n                    .as_ptr(),\n            );\n        }\n        'c_7276: {\n            if size >= 0 as libc::c_int as libc::c_long {} else {\n                __assert_fail(\n                    b\"size >= 0\\0\" as *const u8 as *const libc::c_char,\n                    b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n                    230 as libc::c_int as libc::c_uint,\n                    (*::core::mem::transmute::<\n                        &[u8; 49],\n                        &[libc::c_char; 49],\n                    >(b\"_Bool fwrite_wait(const char *, ssize_t, FILE *)\\0\"))\n                        .as_ptr(),\n                );\n            }\n        };\n        if size <= 0 as libc::c_int as libc::c_long {\n            return 1 as libc::c_int != 0;\n        }\n        if !fwait_for_nonblocking_write(f) {\n            return 0 as libc::c_int != 0;\n        }\n        buf = buf.offset(written as isize);\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn pipe(__pipedes: *mut libc::c_int) -> libc::c_int;\n}\npub type __mode_t = libc::c_uint;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub type __syscall_slong_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blkcnt_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __off_t = libc::c_long;\npub type __dev_t = libc::c_ulong;\npub type __gid_t = libc::c_uint;\npub type __uid_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type nlink_t = __nlink_t;\n#[no_mangle]\npub unsafe extern \"C\" fn isapipe(mut fd: libc::c_int) -> libc::c_int {\n    let mut pipe_link_count_max: nlink_t = 1 as libc::c_int as nlink_t;\n    let mut check_for_fifo: bool = 1 as libc::c_int == 1 as libc::c_int;\n    let mut st: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut fstat_result: libc::c_int = fstat(fd, &mut st);\n    if fstat_result != 0 as libc::c_int {\n        return fstat_result;\n    }\n    if !((1 as libc::c_int == 0 as libc::c_int || 1 as libc::c_int == 1 as libc::c_int)\n        && 1 as libc::c_int as libc::c_uint != -(1 as libc::c_int) as nlink_t)\n        && (st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o10000 as libc::c_int as libc::c_uint) as libc::c_int\n            | (st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o140000 as libc::c_int as libc::c_uint) as libc::c_int != 0\n    {\n        let mut fd_pair: [libc::c_int; 2] = [0; 2];\n        let mut pipe_result: libc::c_int = pipe(fd_pair.as_mut_ptr());\n        if pipe_result != 0 as libc::c_int {\n            return pipe_result\n        } else {\n            let mut pipe_st: stat = stat {\n                st_dev: 0,\n                st_ino: 0,\n                st_mode: 0,\n                st_nlink: 0,\n                st_uid: 0,\n                st_gid: 0,\n                st_rdev: 0,\n                __pad1: 0,\n                st_size: 0,\n                st_blksize: 0,\n                __pad2: 0,\n                st_blocks: 0,\n                st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n                st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n                st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n                __glibc_reserved: [0; 2],\n            };\n            let mut fstat_pipe_result: libc::c_int = fstat(\n                fd_pair[0 as libc::c_int as usize],\n                &mut pipe_st,\n            );\n            let mut fstat_pipe_errno: libc::c_int = *__errno_location();\n            close(fd_pair[0 as libc::c_int as usize]);\n            close(fd_pair[1 as libc::c_int as usize]);\n            if fstat_pipe_result != 0 as libc::c_int {\n                *__errno_location() = fstat_pipe_errno;\n                return fstat_pipe_result;\n            }\n            check_for_fifo = (pipe_st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o10000 as libc::c_int as libc::c_uint) as libc::c_int\n                != 0 as libc::c_int;\n            pipe_link_count_max = pipe_st.st_nlink;\n        }\n    }\n    return (st.st_nlink <= pipe_link_count_max\n        && (if check_for_fifo as libc::c_int != 0 {\n            (st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o10000 as libc::c_int as libc::c_uint) as libc::c_int\n        } else {\n            (st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o140000 as libc::c_int as libc::c_uint) as libc::c_int\n        }) != 0) as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;\npub const _NL_WAM_STR: C2RustUnnamed = 131162;\npub const _NL_WMON_12: C2RustUnnamed = 131161;\npub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "use ::libc;\nextern \"C\" {\n    fn nanosleep(\n        __requested_time: *const timespec,\n        __remaining: *mut timespec,\n    ) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type __time_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\npub type time_t = __time_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub const BILLION: C2RustUnnamed = 1000000000;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_nanosleep(\n    mut requested_delay: *const timespec,\n    mut remaining_delay: *mut timespec,\n) -> libc::c_int {\n    if (*requested_delay).tv_nsec < 0 as libc::c_int as libc::c_long\n        || BILLION as libc::c_int as libc::c_long <= (*requested_delay).tv_nsec\n    {\n        *__errno_location() = 22 as libc::c_int;\n        return -(1 as libc::c_int);\n    }\n    let limit: time_t = (24 as libc::c_int * 24 as libc::c_int * 60 as libc::c_int\n        * 60 as libc::c_int) as time_t;\n    let mut seconds: time_t = (*requested_delay).tv_sec;\n    let mut intermediate: timespec = *requested_delay;\n    while limit < seconds {\n        let mut result: libc::c_int = 0;\n        intermediate.tv_sec = limit;\n        result = nanosleep(&mut intermediate, remaining_delay);\n        seconds -= limit;\n        if result != 0 {\n            if !remaining_delay.is_null() {\n                (*remaining_delay).tv_sec += seconds;\n            }\n            return result;\n        }\n        intermediate.tv_nsec = 0 as libc::c_int as __syscall_slong_t;\n    }\n    intermediate.tv_sec = seconds;\n    return nanosleep(&mut intermediate, remaining_delay);\n}",
    "use ::libc;\npub type __off_t = libc::c_long;\npub type off_t = __off_t;\n#[no_mangle]\npub unsafe extern \"C\" fn offtostr(\n    mut i: off_t,\n    mut buf: *mut libc::c_char,\n) -> *mut libc::c_char {\n    let mut p: *mut libc::c_char = buf\n        .offset(\n            (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                .wrapping_sub(\n                    !((0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t)\n                        as libc::c_int as libc::c_ulong,\n                )\n                .wrapping_mul(146 as libc::c_int as libc::c_ulong)\n                .wrapping_add(484 as libc::c_int as libc::c_ulong)\n                .wrapping_div(485 as libc::c_int as libc::c_ulong)\n                .wrapping_add(\n                    !((0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t)\n                        as libc::c_int as libc::c_ulong,\n                ) as isize,\n        );\n    *p = 0 as libc::c_int as libc::c_char;\n    if i < 0 as libc::c_int as libc::c_long {\n        loop {\n            p = p.offset(-1);\n            *p = ('0' as i32 as libc::c_long - i % 10 as libc::c_int as libc::c_long)\n                as libc::c_char;\n            i /= 10 as libc::c_int as libc::c_long;\n            if !(i != 0 as libc::c_int as libc::c_long) {\n                break;\n            }\n        }\n        p = p.offset(-1);\n        *p = '-' as i32 as libc::c_char;\n    } else {\n        loop {\n            p = p.offset(-1);\n            *p = ('0' as i32 as libc::c_long + i % 10 as libc::c_int as libc::c_long)\n                as libc::c_char;\n            i /= 10 as libc::c_int as libc::c_long;\n            if !(i != 0 as libc::c_int as libc::c_long) {\n                break;\n            }\n        }\n    }\n    return p;\n}",
    "use ::libc;\nextern \"C\" {\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn fd_safer(_: libc::c_int) -> libc::c_int;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type __mode_t = libc::c_uint;\npub type mode_t = __mode_t;\npub type va_list = __builtin_va_list;\n#[no_mangle]\npub unsafe extern \"C\" fn open_safer(\n    mut file: *const libc::c_char,\n    mut flags: libc::c_int,\n    mut args: ...\n) -> libc::c_int {\n    let mut mode: mode_t = 0 as libc::c_int as mode_t;\n    if flags & 0o100 as libc::c_int != 0 {\n        let mut ap: ::core::ffi::VaListImpl;\n        ap = args.clone();\n        mode = ap.arg::<mode_t>();\n    }\n    return fd_safer(open(file, flags, mode));\n}",
    "use ::libc;\nextern \"C\" {\n    fn strtol(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n    ) -> libc::c_long;\n    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn posix2_version() -> libc::c_int {\n    let mut v: libc::c_long = 200809 as libc::c_long;\n    let mut s: *const libc::c_char = getenv(\n        b\"_POSIX2_VERSION\\0\" as *const u8 as *const libc::c_char,\n    );\n    if !s.is_null() && *s as libc::c_int != 0 {\n        let mut e: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut i: libc::c_long = strtol(s, &mut e, 10 as libc::c_int);\n        if *e == 0 {\n            v = i;\n        }\n    }\n    return (if v < (-(2147483647 as libc::c_int) - 1 as libc::c_int) as libc::c_long {\n        (-(2147483647 as libc::c_int) - 1 as libc::c_int) as libc::c_long\n    } else if v < 2147483647 as libc::c_int as libc::c_long {\n        v\n    } else {\n        2147483647 as libc::c_int as libc::c_long\n    }) as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nunsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}\nunsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}\nunsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;",
    "                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};",
    "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "use ::libc;\nextern \"C\" {\n    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;\n    fn __errno_location() -> *mut libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type ssize_t = __ssize_t;\npub type __ssize_t = libc::c_long;\npub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn safe_read(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = read(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "use ::libc;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn stat_time_normalize(\n    mut result: libc::c_int,\n    mut _st: *mut stat,\n) -> libc::c_int {\n    return result;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn get_stat_birthtime(mut _st: *const stat) -> timespec {\n    let mut t: timespec = timespec { tv_sec: 0, tv_nsec: 0 };\n    t = {\n        let mut init = timespec {\n            tv_sec: -(1 as libc::c_int) as __time_t,\n            tv_nsec: -(1 as libc::c_int) as __syscall_slong_t,\n        };\n        init\n    };\n    return t;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn get_stat_mtime(mut st: *const stat) -> timespec {\n    return (*st).st_mtim;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn get_stat_ctime(mut st: *const stat) -> timespec {\n    return (*st).st_ctim;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn get_stat_atime(mut st: *const stat) -> timespec {\n    return (*st).st_atim;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn get_stat_birthtime_ns(mut _st: *const stat) -> libc::c_long {\n    return 0 as libc::c_int as libc::c_long;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn get_stat_mtime_ns(mut st: *const stat) -> libc::c_long {\n    return (*st).st_mtim.tv_nsec;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn get_stat_ctime_ns(mut st: *const stat) -> libc::c_long {\n    return (*st).st_ctim.tv_nsec;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn get_stat_atime_ns(mut st: *const stat) -> libc::c_long {\n    return (*st).st_atim.tv_nsec;\n}",
    "#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut, unused_imports)]\n#![feature(extern_types, label_break_value)]\nuse ::rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    pub type hash_table;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn fwrite_unlocked(\n        __ptr: *const libc::c_void,\n        __size: size_t,\n        __n: size_t,\n        __stream: *mut FILE,\n    ) -> size_t;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn fpurge(gl_stream: *mut FILE) -> libc::c_int;\n    fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;\n    static mut optarg: *mut libc::c_char;\n    static mut optind: libc::c_int;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    fn kill(__pid: __pid_t, __sig: libc::c_int) -> libc::c_int;\n    fn raise(__sig: libc::c_int) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn isatty(__fd: libc::c_int) -> libc::c_int;\n    fn getpagesize() -> libc::c_int;\n    fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn lstat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memchr(\n        _: *const libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn rawmemchr(__s: *const libc::c_void, __c: libc::c_int) -> *mut libc::c_void;\n    fn memrchr(\n        __s: *const libc::c_void,\n        __c: libc::c_int,\n        __n: size_t,\n    ) -> *mut libc::c_void;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn free(_: *mut libc::c_void);\n    fn __errno_location() -> *mut libc::c_int;\n    fn atexit(__func: Option::<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn exit(_: libc::c_int) -> !;\n    static mut Version: *const libc::c_char;\n    fn rpl_fcntl(fd: libc::c_int, action: libc::c_int, _: ...) -> libc::c_int;\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn xalloc_die();\n    fn xmalloc(s: size_t) -> *mut libc::c_void;\n    fn xrealloc(p: *mut libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn last_component(filename: *const libc::c_char) -> *mut libc::c_char;\n    fn dir_len(file: *const libc::c_char) -> size_t;\n    fn close_stdout();\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    static mut program_name: *const libc::c_char;\n    fn set_program_name(argv0: *const libc::c_char);\n    fn offtostr(_: off_t, _: *mut libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn quotearg_n_style_colon(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn xnmalloc(n: size_t, s: size_t) -> *mut libc::c_void;\n    static mut argmatch_die: argmatch_exit_fn;\n    fn __xargmatch_internal(\n        context: *const libc::c_char,\n        arg: *const libc::c_char,\n        arglist: *const *const libc::c_char,\n        vallist: *const libc::c_void,\n        valsize: size_t,\n        exit_fn: argmatch_exit_fn,\n        allow_abbreviation: bool,\n    ) -> ptrdiff_t;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn cl_strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;\n    fn open_safer(_: *const libc::c_char, _: libc::c_int, _: ...) -> libc::c_int;\n    fn iopoll(fdin: libc::c_int, fdout: libc::c_int, block: bool) -> libc::c_int;\n    fn isapipe(fd: libc::c_int) -> libc::c_int;\n    fn posix2_version() -> libc::c_int;\n    fn safe_read(fd: libc::c_int, buf: *mut libc::c_void, count: size_t) -> size_t;\n    fn xdectoumax(\n        n_str: *const libc::c_char,\n        min: uintmax_t,\n        max: uintmax_t,\n        suffixes: *const libc::c_char,\n        err: *const libc::c_char,\n        err_exit: libc::c_int,\n    ) -> uintmax_t;\n    fn xnanosleep(_: libc::c_double) -> libc::c_int;\n    fn xstrtoumax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut uintmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n    fn xstrtod(\n        str: *const libc::c_char,\n        ptr: *mut *const libc::c_char,\n        result: *mut libc::c_double,\n        convert: Option::<\n            unsafe extern \"C\" fn(\n                *const libc::c_char,\n                *mut *mut libc::c_char,\n            ) -> libc::c_double,\n        >,\n    ) -> bool;\n    fn hash_get_n_entries(table: *const Hash_table) -> size_t;\n    fn hash_lookup(\n        table: *const Hash_table,\n        entry: *const libc::c_void,\n    ) -> *mut libc::c_void;\n    fn hash_free(table: *mut Hash_table);\n    fn hash_initialize(\n        candidate: size_t,\n        tuning: *const Hash_tuning,\n        hasher: Hash_hasher,\n        comparator: Hash_comparator,\n        data_freer: Hash_data_freer,\n    ) -> *mut Hash_table;\n    fn hash_insert(\n        table: *mut Hash_table,\n        entry: *const libc::c_void,\n    ) -> *mut libc::c_void;\n    fn hash_remove(\n        table: *mut Hash_table,\n        entry: *const libc::c_void,\n    ) -> *mut libc::c_void;\n    fn poll(__fds: *mut pollfd, __nfds: nfds_t, __timeout: libc::c_int) -> libc::c_int;\n    fn inotify_init() -> libc::c_int;\n    fn inotify_add_watch(\n        __fd: libc::c_int,\n        __name: *const libc::c_char,\n        __mask: uint32_t,\n    ) -> libc::c_int;\n    fn inotify_rm_watch(__fd: libc::c_int, __wd: libc::c_int) -> libc::c_int;\n    fn fstatfs(__fildes: libc::c_int, __buf: *mut statfs) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uintmax_t = libc::c_ulong;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __pid_t = libc::c_int;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __fsid_t {\n    pub __val: [libc::c_int; 2],\n}\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __fsblkcnt_t = libc::c_ulong;\npub type __fsfilcnt_t = libc::c_ulong;\npub type __fsword_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type ptrdiff_t = libc::c_long;\npub type ino_t = __ino_t;\npub type dev_t = __dev_t;\npub type mode_t = __mode_t;\npub type pid_t = __pid_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub type blksize_t = __blksize_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\npub type uint32_t = __uint32_t;\npub type uintmax_t = __uintmax_t;\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type argmatch_exit_fn = Option::<unsafe extern \"C\" fn() -> ()>\n;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct hash_tuning {\n    pub shrink_threshold: libc::c_float,\n    pub shrink_factor: libc::c_float,\n    pub growth_threshold: libc::c_float,\n    pub growth_factor: libc::c_float,\n    pub is_n_buckets: bool,\n}\npub type Hash_tuning = hash_tuning;\npub type Hash_table = hash_table;\npub type Hash_hasher = Option::<\n    unsafe extern \"C\" fn(*const libc::c_void, size_t) -> size_t,\n>\n;\npub type Hash_comparator = Option::<\n    unsafe extern \"C\" fn(*const libc::c_void, *const libc::c_void) -> bool,\n>\n;\npub type Hash_data_freer = Option::<unsafe extern \"C\" fn(*mut libc::c_void) -> ()>\n;\npub type nfds_t = libc::c_ulong;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct pollfd {\n    pub fd: libc::c_int,\n    pub events: libc::c_short,\n    pub revents: libc::c_short,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct inotify_event {\n    pub wd: libc::c_int,\n    pub mask: uint32_t,\n    pub cookie: uint32_t,\n    pub len: uint32_t,\n    pub name: [libc::c_char; 0],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct statfs {\n    pub f_type: __fsword_t,\n    pub f_bsize: __fsword_t,\n    pub f_blocks: __fsblkcnt_t,\n    pub f_bfree: __fsblkcnt_t,\n    pub f_bavail: __fsblkcnt_t,\n    pub f_files: __fsfilcnt_t,\n    pub f_ffree: __fsfilcnt_t,\n    pub f_fsid: __fsid_t,\n    pub f_namelen: __fsword_t,\n    pub f_frsize: __fsword_t,\n    pub f_flags: __fsword_t,\n    pub f_spare: [__fsword_t; 4],\n}\npub type Follow_mode = libc::c_uint;\npub const Follow_descriptor: Follow_mode = 2;\npub const Follow_name: Follow_mode = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct File_spec {\n    pub name: *mut libc::c_char,\n    pub size: off_t,\n    pub mtime: timespec,\n    pub dev: dev_t,\n    pub ino: ino_t,\n    pub mode: mode_t,\n    pub ignore: bool,\n    pub remote: bool,\n    pub tailable: bool,\n    pub fd: libc::c_int,\n    pub errnum: libc::c_int,\n    pub blocking: libc::c_int,\n    pub wd: libc::c_int,\n    pub parent_wd: libc::c_int,\n    pub basename_start: size_t,\n    pub n_unchanged_stats: uintmax_t,\n}\npub type header_mode = libc::c_uint;\npub const never: header_mode = 2;\npub const always: header_mode = 1;\npub const multiple_files: header_mode = 0;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const DISABLE_INOTIFY_OPTION: C2RustUnnamed_0 = 261;\npub const LONG_FOLLOW_OPTION: C2RustUnnamed_0 = 260;\npub const PRESUME_INPUT_PIPE_OPTION: C2RustUnnamed_0 = 259;\npub const PID_OPTION: C2RustUnnamed_0 = 258;\npub const MAX_UNCHANGED_STATS_OPTION: C2RustUnnamed_0 = 257;\npub const RETRY_OPTION: C2RustUnnamed_0 = 256;\npub type LBUFFER = linebuffer;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct linebuffer {\n    pub buffer: [libc::c_char; 8192],\n    pub nbytes: size_t,\n    pub nlines: size_t,\n    pub next: *mut linebuffer,\n}\npub type CBUFFER = charbuffer;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct charbuffer {\n    pub buffer: [libc::c_char; 8192],\n    pub nbytes: size_t,\n    pub next: *mut charbuffer,\n}\n#[inline]\nunsafe extern \"C\" fn timespec_cmp(mut a: timespec, mut b: timespec) -> libc::c_int {\n    return 2 as libc::c_int\n        * ((a.tv_sec > b.tv_sec) as libc::c_int - (a.tv_sec < b.tv_sec) as libc::c_int)\n        + ((a.tv_nsec > b.tv_nsec) as libc::c_int\n            - (a.tv_nsec < b.tv_nsec) as libc::c_int);\n}\n#[inline]\nunsafe extern \"C\" fn emit_stdin_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nWith no FILE, or when FILE is -, read standard input.\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        stdout,\n    );\n}\n#[inline]\nunsafe extern \"C\" fn emit_mandatory_arg_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nMandatory arguments to long options are mandatory for short options too.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}\n#[inline]",
    "unsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}\n#[inline]\nunsafe extern \"C\" fn usable_st_size(mut sb: *const stat) -> bool {\n    return (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        || (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o120000 as libc::c_int as libc::c_uint\n        || ((*sb).st_mode).wrapping_sub((*sb).st_mode) != 0 || 0 as libc::c_int != 0;\n}\n#[inline]\nunsafe extern \"C\" fn write_error() {\n    let mut saved_errno: libc::c_int = *__errno_location();\n    fflush_unlocked(stdout);\n    fpurge(stdout);\n    clearerr_unlocked(stdout);\n    if 0 != 0 {\n        error(\n            1 as libc::c_int,\n            saved_errno,\n            gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n        );\n        if 1 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}\n#[inline]\nunsafe extern \"C\" fn get_stat_mtime(mut st: *const stat) -> timespec {\n    return (*st).st_mtim;\n}\n#[inline]\nunsafe extern \"C\" fn xset_binary_mode_error() {}\n#[inline]\nunsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}\n#[inline]\nunsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}\n#[inline]\nunsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[inline]\nunsafe extern \"C\" fn is_local_fs_type(mut magic: libc::c_ulong) -> libc::c_int {\n    match magic {\n        1513908720 => return 1 as libc::c_int,\n        1633904243 => return 0 as libc::c_int,\n        44533 => return 1 as libc::c_int,\n        44543 => return 1 as libc::c_int,\n        1397113167 => return 0 as libc::c_int,\n        151263540 => return 1 as libc::c_int,\n        1635083891 => return 0 as libc::c_int,\n        391 => return 1 as libc::c_int,\n        325456742 => return 1 as libc::c_int,\n        3393526350 => return 1 as libc::c_int,\n        1111905073 => return 1 as libc::c_int,\n        1650746742 => return 1 as libc::c_int,\n        464386766 => return 1 as libc::c_int,\n        1819242352 => return 1 as libc::c_int,\n        3405662737 => return 1 as libc::c_int,\n        1112100429 => return 1 as libc::c_int,\n        2435016766 => return 1 as libc::c_int,\n        1936880249 => return 1 as libc::c_int,\n        12805120 => return 0 as libc::c_int,\n        2613483 => return 1 as libc::c_int,\n        1667723888 => return 1 as libc::c_int,\n        4283649346 => return 0 as libc::c_int,\n        1937076805 => return 0 as libc::c_int,\n        19920823 => return 1 as libc::c_int,\n        1650812272 => return 1 as libc::c_int,\n        684539205 => return 1 as libc::c_int,\n        1161678120 => return 1 as libc::c_int,\n        1684300152 => return 1 as libc::c_int,\n        1684170528 => return 1 as libc::c_int,\n        4979 => return 1 as libc::c_int,\n        1162691661 => return 1 as libc::c_int,\n        7377 => return 1 as libc::c_int,\n        1145913666 => return 1 as libc::c_int,\n        61791 => return 1 as libc::c_int,\n        3730735588 => return 1 as libc::c_int,\n        4278867 => return 1 as libc::c_int,\n        3774210530 => return 1 as libc::c_int,\n        538032816 => return 1 as libc::c_int,\n        1163413075 => return 1 as libc::c_int,\n        24053 => return 1 as libc::c_int,\n        4989 => return 1 as libc::c_int,\n        61267 => return 1 as libc::c_int,\n        61265 => return 1 as libc::c_int,\n        4076150800 => return 1 as libc::c_int,\n        16390 => return 1 as libc::c_int,\n        428016422 => return 0 as libc::c_int,\n        1702057286 => return 0 as libc::c_int,\n        1702057283 => return 0 as libc::c_int,\n        195894762 => return 1 as libc::c_int,\n        18225520 => return 0 as libc::c_int,\n        1196443219 => return 0 as libc::c_int,\n        16964 => return 1 as libc::c_int,\n        18475 => return 1 as libc::c_int,\n        18520 => return 1 as libc::c_int,\n        12648430 => return 1 as libc::c_int,\n        4187351113 => return 1 as libc::c_int,\n        2508478710 => return 1 as libc::c_int,\n        288389204 => return 1 as libc::c_int,\n        19993000 => return 0 as libc::c_int,\n        732765674 => return 1 as libc::c_int,\n        38496 => return 1 as libc::c_int,\n        16388 => return 1 as libc::c_int,\n        16384 => return 1 as libc::c_int,\n        1984 => return 1 as libc::c_int,\n        29366 => return 1 as libc::c_int,\n        827541066 => return 1 as libc::c_int,\n        1799439955 => return 0 as libc::c_int,\n        3380511080 => return 1 as libc::c_int,\n        198183888 => return 0 as libc::c_int,\n        1397109069 => return 1 as libc::c_int,\n        4991 => return 1 as libc::c_int,\n        5007 => return 1 as libc::c_int,\n        9320 => return 1 as libc::c_int,\n        9336 => return 1 as libc::c_int,\n        19802 => return 1 as libc::c_int,\n        427819522 => return 1 as libc::c_int,\n        19780 => return 1 as libc::c_int,\n        22092 => return 0 as libc::c_int,\n        26985 => return 0 as libc::c_int,\n        1852207972 => return 0 as libc::c_int,\n        13364 => return 1 as libc::c_int,\n        1853056627 => return 1 as libc::c_int,\n        1397118030 => return 1 as libc::c_int,\n        40865 => return 1 as libc::c_int,\n        1952539503 => return 0 as libc::c_int,\n        2035054128 => return 0 as libc::c_int,\n        2866260714 => return 0 as libc::c_int,\n        1346978886 => return 1 as libc::c_int,\n        1346981957 => return 0 as libc::c_int,\n        3344373136 => return 1 as libc::c_int,\n        2088527475 => return 0 as libc::c_int,\n        40864 => return 1 as libc::c_int,\n        1634035564 => return 1 as libc::c_int,\n        47 => return 1 as libc::c_int,\n        1746473250 => return 1 as libc::c_int,\n        2240043254 => return 1 as libc::c_int,\n        124082209 => return 1 as libc::c_int,\n        1382369651 => return 1 as libc::c_int,\n        29301 => return 1 as libc::c_int,\n        1733912937 => return 1 as libc::c_int,\n        1573531125 => return 1 as libc::c_int,\n        1397048141 => return 1 as libc::c_int,\n        1935894131 => return 1 as libc::c_int,\n        4185718668 => return 1 as libc::c_int,\n        1128357203 => return 1 as libc::c_int,\n        20859 => return 0 as libc::c_int,\n        4266872130 => return 0 as libc::c_int,\n        3203391149 => return 0 as libc::c_int,\n        1397703499 => return 1 as libc::c_int,\n        1936814952 => return 1 as libc::c_int,\n        1650812274 => return 1 as libc::c_int,\n        19920822 => return 1 as libc::c_int,\n        19920821 => return 1 as libc::c_int,\n        16914836 => return 1 as libc::c_int,\n        1953653091 => return 1 as libc::c_int,\n        604313861 => return 1 as libc::c_int,\n        352400198 => return 1 as libc::c_int,\n        72020 => return 1 as libc::c_int,\n        1410924800 => return 1 as libc::c_int,\n        40866 => return 1 as libc::c_int,\n        16914839 => return 1 as libc::c_int,\n        2020557398 => return 0 as libc::c_int,\n        3133910204 => return 0 as libc::c_int,\n        2768370933 => return 0 as libc::c_int,\n        1448756819 => return 1 as libc::c_int,\n        1397114950 => return 1 as libc::c_int,\n        2881100148 => return 1 as libc::c_int,\n        19920820 => return 1 as libc::c_int,\n        1481003842 => return 1 as libc::c_int,\n        19911021 => return 1 as libc::c_int,\n        51 => return 1 as libc::c_int,\n        801189825 => return 1 as libc::c_int,\n        1515144787 => return 1 as libc::c_int,\n        1479104553 => return 1 as libc::c_int,\n        _ => return -(1 as libc::c_int),\n    };\n}\nstatic mut follow_mode_string: [*const libc::c_char; 3] = [\n    b\"descriptor\\0\" as *const u8 as *const libc::c_char,\n    b\"name\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\nstatic mut follow_mode_map: [Follow_mode; 2] = [Follow_descriptor, Follow_name];\nstatic mut reopen_inaccessible_files: bool = false;\nstatic mut count_lines: bool = false;\nstatic mut follow_mode: Follow_mode = Follow_descriptor;\nstatic mut forever: bool = false;\nstatic mut monitor_output: bool = false;\nstatic mut from_start: bool = false;\nstatic mut print_headers: bool = false;\nstatic mut line_end: libc::c_char = 0;\nstatic mut max_n_unchanged_stats_between_opens: uintmax_t = 5 as libc::c_int\n    as uintmax_t;\nstatic mut nbpids: libc::c_int = 0 as libc::c_int;\nstatic mut pids: *mut pid_t = 0 as *const pid_t as *mut pid_t;\nstatic mut pids_alloc: idx_t = 0;\nstatic mut page_size: idx_t = 0;\nstatic mut have_read_stdin: bool = false;\nstatic mut presume_input_pipe: bool = false;\nstatic mut disable_inotify: bool = false;\nstatic mut long_options: [option; 16] = [\n    {\n        let mut init = option {\n            name: b\"bytes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'c' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"follow\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 2 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: LONG_FOLLOW_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"lines\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'n' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"max-unchanged-stats\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: MAX_UNCHANGED_STATS_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"-disable-inotify\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: DISABLE_INOTIFY_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"pid\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: PID_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"-presume-input-pipe\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: PRESUME_INPUT_PIPE_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"quiet\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'q' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"retry\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: RETRY_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"silent\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'q' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"sleep-interval\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 's' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"verbose\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'v' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"zero-terminated\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'z' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];",
    "#[no_mangle]\npub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [FILE]...\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        printf(\n            gettext(\n                b\"Print the last %d lines of each FILE to standard output.\\nWith more than one FILE, precede each with a header giving the file name.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            10 as libc::c_int,\n        );\n        emit_stdin_note();\n        emit_mandatory_arg_note();\n        fputs_unlocked(\n            gettext(\n                b\"  -c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\\n                             output starting with byte NUM of each file\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -f, --follow[={name|descriptor}]\\n                           output appended data as the file grows;\\n                             an absent option argument means 'descriptor'\\n  -F                       same as --follow=name --retry\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        printf(\n            gettext(\n                b\"  -n, --lines=[+]NUM       output the last NUM lines, instead of the last %d;\\n                             or use -n +NUM to skip NUM-1 lines at the start\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            10 as libc::c_int,\n        );\n        printf(\n            gettext(\n                b\"      --max-unchanged-stats=N\\n                           with --follow=name, reopen a FILE which has not\\n                             changed size after N (default %d) iterations\\n                             to see if it has been unlinked or renamed\\n                             (this is the usual case of rotated log files);\\n                             with inotify, this option is rarely useful\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            5 as libc::c_int,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --pid=PID            with -f, terminate after process ID, PID dies;\\n                             can be repeated to watch multiple processes\\n  -q, --quiet, --silent    never output headers giving file names\\n      --retry              keep trying to open a file if it is inaccessible\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\\n                             (default 1.0) between iterations;\\n                             with inotify and --pid=P, check process P at\\n                             least once every N seconds\\n  -v, --verbose            always output headers giving file names\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -z, --zero-terminated    line delimiter is NUL, not newline\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"\\nNUM may have a multiplier suffix:\\nb 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\\nGB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"With --follow (-f), tail defaults to following the file descriptor, which\\nmeans that even if a tail'ed file is renamed, tail will continue to track\\nits end.  This default behavior is not desirable when you really want to\\ntrack the actual name of the file, not the file descriptor (e.g., log\\nrotation).  Use --follow=name in that case.  That causes tail to track the\\nnamed file in a way that accommodates renaming, removal and creation.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_ancillary_info(b\"tail\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}\nunsafe extern \"C\" fn die_pipe() {\n    raise(13 as libc::c_int);\n    exit(1 as libc::c_int);\n}\nunsafe extern \"C\" fn check_output_alive() {\n    if !monitor_output {\n        return;\n    }\n    if iopoll(-(1 as libc::c_int), 1 as libc::c_int, 0 as libc::c_int != 0)\n        == -(2 as libc::c_int)\n    {\n        die_pipe();\n    }\n}\nunsafe extern \"C\" fn valid_file_spec(mut f: *const File_spec) -> bool {\n    return ((*f).fd == -(1 as libc::c_int)) as libc::c_int\n        ^ ((*f).errnum == 0 as libc::c_int) as libc::c_int != 0;\n}\nunsafe extern \"C\" fn pretty_name(mut f: *const File_spec) -> *const libc::c_char {\n    return if strcmp((*f).name, b\"-\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        gettext(b\"standard input\\0\" as *const u8 as *const libc::c_char)\n    } else {\n        (*f).name\n    };\n}\nunsafe extern \"C\" fn record_open_fd(\n    mut f: *mut File_spec,\n    mut fd: libc::c_int,\n    mut size: off_t,\n    mut st: *const stat,\n    mut blocking: libc::c_int,\n) {\n    (*f).fd = fd;\n    (*f).size = size;\n    (*f).mtime = get_stat_mtime(st);\n    (*f).dev = (*st).st_dev;\n    (*f).ino = (*st).st_ino;\n    (*f).mode = (*st).st_mode;\n    (*f).blocking = blocking;\n    (*f).n_unchanged_stats = 0 as libc::c_int as uintmax_t;\n    (*f).ignore = 0 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn close_fd(mut fd: libc::c_int, mut filename: *const libc::c_char) {\n    if fd != -(1 as libc::c_int) && fd != 0 as libc::c_int && close(fd) != 0 {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"closing %s (fd=%d)\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, filename),\n                fd,\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"closing %s (fd=%d)\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                    fd,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"closing %s (fd=%d)\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                    fd,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n}\nunsafe extern \"C\" fn write_header(mut pretty_filename: *const libc::c_char) {\n    static mut first_file: bool = 1 as libc::c_int != 0;\n    printf(\n        b\"%s==> %s <==\\n\\0\" as *const u8 as *const libc::c_char,\n        if first_file as libc::c_int != 0 {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\n\\0\" as *const u8 as *const libc::c_char\n        },\n        pretty_filename,\n    );\n    first_file = 0 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn xwrite_stdout(\n    mut buffer: *const libc::c_char,\n    mut n_bytes: size_t,\n) {\n    if n_bytes > 0 as libc::c_int as libc::c_ulong\n        && fwrite_unlocked(\n            buffer as *const libc::c_void,\n            1 as libc::c_int as size_t,\n            n_bytes,\n            stdout,\n        ) < n_bytes\n    {\n        clearerr_unlocked(stdout);\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n}\nunsafe extern \"C\" fn dump_remainder(\n    mut want_header: bool,\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n) -> uintmax_t {\n    let mut n_written: uintmax_t = 0;\n    let mut n_remaining: uintmax_t = n_bytes;\n    n_written = 0 as libc::c_int as uintmax_t;\n    loop {\n        let mut buffer: [libc::c_char; 8192] = [0; 8192];\n        let mut n: size_t = if n_remaining < 8192 as libc::c_int as libc::c_ulong {\n            n_remaining\n        } else {\n            8192 as libc::c_int as libc::c_ulong\n        };\n        let mut bytes_read: size_t = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            n,\n        );\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if *__errno_location() != 11 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_filename,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_filename,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            break;\n        } else {\n            if bytes_read == 0 as libc::c_int as libc::c_ulong {\n                break;\n            }\n            if want_header {\n                write_header(pretty_filename);\n                want_header = 0 as libc::c_int != 0;\n            }\n            xwrite_stdout(buffer.as_mut_ptr(), bytes_read);\n            n_written = (n_written as libc::c_ulong).wrapping_add(bytes_read)\n                as uintmax_t as uintmax_t;\n            if !(n_bytes != 18446744073709551615 as libc::c_ulong) {\n                continue;\n            }\n            n_remaining = (n_remaining as libc::c_ulong).wrapping_sub(bytes_read)\n                as uintmax_t as uintmax_t;\n            if n_remaining == 0 as libc::c_int as libc::c_ulong\n                || n_bytes\n                    == (18446744073709551615 as libc::c_ulong)\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n            {\n                break;\n            }\n        }\n    }\n    return n_written;\n}",
    "unsafe extern \"C\" fn xlseek(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n    mut filename: *const libc::c_char,\n) -> off_t {\n    let mut new_offset: off_t = lseek(fd, offset, whence);\n    let mut buf: [libc::c_char; 21] = [0; 21];\n    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;\n    if 0 as libc::c_int as libc::c_long <= new_offset {\n        return new_offset;\n    }\n    s = offtostr(offset, buf.as_mut_ptr());\n    match whence {\n        0 => {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: cannot seek to offset %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                    s,\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot seek to offset %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                        s,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot seek to offset %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                        s,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        1 => {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                    s,\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                        s,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                        s,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        2 => {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: cannot seek to end-relative offset %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                    s,\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot seek to end-relative offset %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                        s,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot seek to end-relative offset %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                        s,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _ => {\n            unreachable!();\n        }\n    }\n    panic!(\"Reached end of non-void function without returning\");\n}\nunsafe extern \"C\" fn file_lines(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut sb: *const stat,\n    mut n_lines: uintmax_t,\n    mut start_pos: off_t,\n    mut end_pos: off_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    let mut buffer: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut bytes_read: size_t = 0;\n    let mut bufsize: blksize_t = 8192 as libc::c_int;\n    let mut pos: off_t = end_pos;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    if n_lines == 0 as libc::c_int as libc::c_ulong {\n        return 1 as libc::c_int != 0;\n    }\n    if (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n    {} else {\n        __assert_fail(\n            b\"((((sb->st_mode)) & 0170000) == (0100000))\\0\" as *const u8\n                as *const libc::c_char,\n            b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n            543 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 95],\n                &[libc::c_char; 95],\n            >(\n                b\"_Bool file_lines(const char *, int, const struct stat *, uintmax_t, off_t, off_t, uintmax_t *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_10359: {\n        if (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o100000 as libc::c_int as libc::c_uint\n        {} else {\n            __assert_fail(\n                b\"((((sb->st_mode)) & 0170000) == (0100000))\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                543 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 95],\n                    &[libc::c_char; 95],\n                >(\n                    b\"_Bool file_lines(const char *, int, const struct stat *, uintmax_t, off_t, off_t, uintmax_t *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    if (*sb).st_size % page_size == 0 as libc::c_int as libc::c_long {\n        bufsize = (if 8192 as libc::c_int as libc::c_long > page_size {\n            8192 as libc::c_int as libc::c_long\n        } else {\n            page_size\n        }) as blksize_t;\n    }\n    buffer = xmalloc(bufsize as size_t) as *mut libc::c_char;\n    bytes_read = ((pos - start_pos) % bufsize as libc::c_long) as size_t;\n    if bytes_read == 0 as libc::c_int as libc::c_ulong {\n        bytes_read = bufsize as size_t;\n    }\n    pos = (pos as libc::c_ulong).wrapping_sub(bytes_read) as off_t as off_t;\n    xlseek(fd, pos, 0 as libc::c_int, pretty_filename);\n    bytes_read = safe_read(fd, buffer as *mut libc::c_void, bytes_read);\n    if bytes_read == -(1 as libc::c_int) as size_t {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        ok = 0 as libc::c_int != 0;\n    } else {\n        *read_pos = (pos as libc::c_ulong).wrapping_add(bytes_read);\n        if bytes_read != 0\n            && *buffer\n                .offset(\n                    bytes_read.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                ) as libc::c_int != line_end as libc::c_int\n        {\n            n_lines = n_lines.wrapping_sub(1);\n            n_lines;\n        }\n        's_79: loop {\n            let mut n: size_t = bytes_read;\n            while n != 0 {\n                let mut nl: *const libc::c_char = 0 as *const libc::c_char;\n                nl = memrchr(buffer as *const libc::c_void, line_end as libc::c_int, n)\n                    as *const libc::c_char;\n                if nl.is_null() {\n                    break;\n                }\n                n = nl.offset_from(buffer) as libc::c_long as size_t;\n                let fresh0 = n_lines;\n                n_lines = n_lines.wrapping_sub(1);\n                if !(fresh0 == 0 as libc::c_int as libc::c_ulong) {\n                    continue;\n                }\n                xwrite_stdout(\n                    nl.offset(1 as libc::c_int as isize),\n                    bytes_read\n                        .wrapping_sub(n.wrapping_add(1 as libc::c_int as libc::c_ulong)),\n                );\n                *read_pos = (*read_pos as libc::c_ulong)\n                    .wrapping_add(\n                        dump_remainder(\n                            0 as libc::c_int != 0,\n                            pretty_filename,\n                            fd,\n                            (end_pos as libc::c_ulong)\n                                .wrapping_sub(\n                                    (pos as libc::c_ulong).wrapping_add(bytes_read),\n                                ),\n                        ),\n                    ) as uintmax_t as uintmax_t;\n                break 's_79;\n            }\n            if pos == start_pos {\n                xlseek(fd, start_pos, 0 as libc::c_int, pretty_filename);\n                *read_pos = (start_pos as libc::c_ulong)\n                    .wrapping_add(\n                        dump_remainder(\n                            0 as libc::c_int != 0,\n                            pretty_filename,\n                            fd,\n                            end_pos as uintmax_t,\n                        ),\n                    );\n                break;\n            } else {\n                pos -= bufsize as libc::c_long;\n                xlseek(fd, pos, 0 as libc::c_int, pretty_filename);\n                bytes_read = safe_read(\n                    fd,\n                    buffer as *mut libc::c_void,\n                    bufsize as size_t,\n                );\n                if bytes_read == -(1 as libc::c_int) as size_t {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_filename,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    pretty_filename,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    pretty_filename,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                    break;\n                } else {\n                    *read_pos = (pos as libc::c_ulong).wrapping_add(bytes_read);\n                    if !(bytes_read > 0 as libc::c_int as libc::c_ulong) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    free(buffer as *mut libc::c_void);\n    return ok;\n}",
    "unsafe extern \"C\" fn pipe_lines(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_lines: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    let mut first: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut last: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut tmp: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut total_lines: size_t = 0 as libc::c_int as size_t;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut n_read: size_t = 0;\n    last = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong) as *mut LBUFFER;\n    first = last;\n    (*first).nlines = 0 as libc::c_int as size_t;\n    (*first).nbytes = (*first).nlines;\n    (*first).next = 0 as *mut linebuffer;\n    tmp = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong) as *mut LBUFFER;\n    loop {\n        n_read = safe_read(\n            fd,\n            ((*tmp).buffer).as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if n_read == 0 as libc::c_int as libc::c_ulong\n            || n_read == -(1 as libc::c_int) as size_t\n        {\n            break;\n        }\n        (*tmp).nbytes = n_read;\n        *read_pos = (*read_pos as libc::c_ulong).wrapping_add(n_read) as uintmax_t\n            as uintmax_t;\n        (*tmp).nlines = 0 as libc::c_int as size_t;\n        (*tmp).next = 0 as *mut linebuffer;\n        let mut buffer_end: *const libc::c_char = ((*tmp).buffer)\n            .as_mut_ptr()\n            .offset(n_read as isize);\n        let mut p: *const libc::c_char = ((*tmp).buffer).as_mut_ptr();\n        loop {\n            p = memchr(\n                p as *const libc::c_void,\n                line_end as libc::c_int,\n                buffer_end.offset_from(p) as libc::c_long as libc::c_ulong,\n            ) as *const libc::c_char;\n            if p.is_null() {\n                break;\n            }\n            p = p.offset(1);\n            p;\n            (*tmp).nlines = ((*tmp).nlines).wrapping_add(1);\n            (*tmp).nlines;\n        }\n        total_lines = (total_lines as libc::c_ulong).wrapping_add((*tmp).nlines)\n            as size_t as size_t;\n        if ((*tmp).nbytes).wrapping_add((*last).nbytes)\n            < 8192 as libc::c_int as libc::c_ulong\n        {\n            memcpy(\n                &mut *((*last).buffer).as_mut_ptr().offset((*last).nbytes as isize)\n                    as *mut libc::c_char as *mut libc::c_void,\n                ((*tmp).buffer).as_mut_ptr() as *const libc::c_void,\n                (*tmp).nbytes,\n            );\n            (*last)\n                .nbytes = ((*last).nbytes as libc::c_ulong).wrapping_add((*tmp).nbytes)\n                as size_t as size_t;\n            (*last)\n                .nlines = ((*last).nlines as libc::c_ulong).wrapping_add((*tmp).nlines)\n                as size_t as size_t;\n        } else {\n            (*last).next = tmp;\n            last = (*last).next;\n            if total_lines.wrapping_sub((*first).nlines) > n_lines {\n                tmp = first;\n                total_lines = (total_lines as libc::c_ulong)\n                    .wrapping_sub((*first).nlines) as size_t as size_t;\n                first = (*first).next;\n            } else {\n                tmp = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong)\n                    as *mut LBUFFER;\n            }\n        }\n    }\n    free(tmp as *mut libc::c_void);\n    if n_read == -(1 as libc::c_int) as size_t {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        ok = 0 as libc::c_int != 0;\n    } else if !((*last).nbytes == 0 as libc::c_int as libc::c_ulong) {\n        if !(n_lines == 0 as libc::c_int as libc::c_ulong) {\n            if (*last)\n                .buffer[((*last).nbytes).wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                as usize] as libc::c_int != line_end as libc::c_int\n            {\n                (*last).nlines = ((*last).nlines).wrapping_add(1);\n                (*last).nlines;\n                total_lines = total_lines.wrapping_add(1);\n                total_lines;\n            }\n            tmp = first;\n            while total_lines.wrapping_sub((*tmp).nlines) > n_lines {\n                total_lines = (total_lines as libc::c_ulong).wrapping_sub((*tmp).nlines)\n                    as size_t as size_t;\n                tmp = (*tmp).next;\n            }\n            let mut beg: *const libc::c_char = ((*tmp).buffer).as_mut_ptr();\n            let mut buffer_end_0: *const libc::c_char = ((*tmp).buffer)\n                .as_mut_ptr()\n                .offset((*tmp).nbytes as isize);\n            if total_lines > n_lines {\n                let mut j: size_t = 0;\n                j = total_lines.wrapping_sub(n_lines);\n                while j != 0 {\n                    beg = rawmemchr(beg as *const libc::c_void, line_end as libc::c_int)\n                        as *const libc::c_char;\n                    beg = beg.offset(1);\n                    beg;\n                    j = j.wrapping_sub(1);\n                    j;\n                }\n            }\n            xwrite_stdout(beg, buffer_end_0.offset_from(beg) as libc::c_long as size_t);\n            tmp = (*tmp).next;\n            while !tmp.is_null() {\n                xwrite_stdout(((*tmp).buffer).as_mut_ptr(), (*tmp).nbytes);\n                tmp = (*tmp).next;\n            }\n        }\n    }\n    while !first.is_null() {\n        tmp = (*first).next;\n        free(first as *mut libc::c_void);\n        first = tmp;\n    }\n    return ok;\n}\nunsafe extern \"C\" fn pipe_bytes(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    let mut first: *mut CBUFFER = 0 as *mut CBUFFER;\n    let mut last: *mut CBUFFER = 0 as *mut CBUFFER;\n    let mut tmp: *mut CBUFFER = 0 as *mut CBUFFER;\n    let mut i: size_t = 0;\n    let mut total_bytes: size_t = 0 as libc::c_int as size_t;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut n_read: size_t = 0;\n    last = xmalloc(::core::mem::size_of::<CBUFFER>() as libc::c_ulong) as *mut CBUFFER;\n    first = last;\n    (*first).nbytes = 0 as libc::c_int as size_t;\n    (*first).next = 0 as *mut charbuffer;\n    tmp = xmalloc(::core::mem::size_of::<CBUFFER>() as libc::c_ulong) as *mut CBUFFER;\n    loop {\n        n_read = safe_read(\n            fd,\n            ((*tmp).buffer).as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if n_read == 0 as libc::c_int as libc::c_ulong\n            || n_read == -(1 as libc::c_int) as size_t\n        {\n            break;\n        }\n        *read_pos = (*read_pos as libc::c_ulong).wrapping_add(n_read) as uintmax_t\n            as uintmax_t;\n        (*tmp).nbytes = n_read;\n        (*tmp).next = 0 as *mut charbuffer;\n        total_bytes = (total_bytes as libc::c_ulong).wrapping_add((*tmp).nbytes)\n            as size_t as size_t;\n        if ((*tmp).nbytes).wrapping_add((*last).nbytes)\n            < 8192 as libc::c_int as libc::c_ulong\n        {\n            memcpy(\n                &mut *((*last).buffer).as_mut_ptr().offset((*last).nbytes as isize)\n                    as *mut libc::c_char as *mut libc::c_void,\n                ((*tmp).buffer).as_mut_ptr() as *const libc::c_void,\n                (*tmp).nbytes,\n            );\n            (*last)\n                .nbytes = ((*last).nbytes as libc::c_ulong).wrapping_add((*tmp).nbytes)\n                as size_t as size_t;\n        } else {\n            (*last).next = tmp;\n            last = (*last).next;\n            if total_bytes.wrapping_sub((*first).nbytes) > n_bytes {\n                tmp = first;\n                total_bytes = (total_bytes as libc::c_ulong)\n                    .wrapping_sub((*first).nbytes) as size_t as size_t;\n                first = (*first).next;\n            } else {\n                tmp = xmalloc(::core::mem::size_of::<CBUFFER>() as libc::c_ulong)\n                    as *mut CBUFFER;\n            }\n        }\n    }\n    free(tmp as *mut libc::c_void);\n    if n_read == -(1 as libc::c_int) as size_t {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        ok = 0 as libc::c_int != 0;\n    } else {\n        tmp = first;\n        while total_bytes.wrapping_sub((*tmp).nbytes) > n_bytes {\n            total_bytes = (total_bytes as libc::c_ulong).wrapping_sub((*tmp).nbytes)\n                as size_t as size_t;\n            tmp = (*tmp).next;\n        }\n        if total_bytes > n_bytes {\n            i = total_bytes.wrapping_sub(n_bytes);\n        } else {\n            i = 0 as libc::c_int as size_t;\n        }\n        xwrite_stdout(\n            &mut *((*tmp).buffer).as_mut_ptr().offset(i as isize),\n            ((*tmp).nbytes).wrapping_sub(i),\n        );\n        tmp = (*tmp).next;\n        while !tmp.is_null() {\n            xwrite_stdout(((*tmp).buffer).as_mut_ptr(), (*tmp).nbytes);\n            tmp = (*tmp).next;\n        }\n    }\n    while !first.is_null() {\n        tmp = (*first).next;\n        free(first as *mut libc::c_void);\n        first = tmp;\n    }\n    return ok;\n}\nunsafe extern \"C\" fn start_bytes(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> libc::c_int {\n    let mut buffer: [libc::c_char; 8192] = [0; 8192];\n    while (0 as libc::c_int as libc::c_ulong) < n_bytes {\n        let mut bytes_read: size_t = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if bytes_read == 0 as libc::c_int as libc::c_ulong {\n            return -(1 as libc::c_int);\n        }\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 1 as libc::c_int;\n        }\n        *read_pos = (*read_pos as libc::c_ulong).wrapping_add(bytes_read) as uintmax_t\n            as uintmax_t;\n        if bytes_read <= n_bytes {\n            n_bytes = (n_bytes as libc::c_ulong).wrapping_sub(bytes_read) as uintmax_t\n                as uintmax_t;\n        } else {\n            let mut n_remaining: size_t = bytes_read.wrapping_sub(n_bytes);\n            xwrite_stdout(\n                &mut *buffer.as_mut_ptr().offset(n_bytes as isize),\n                n_remaining,\n            );\n            break;\n        }\n    }\n    return 0 as libc::c_int;\n}\nunsafe extern \"C\" fn start_lines(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_lines: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> libc::c_int {\n    if n_lines == 0 as libc::c_int as libc::c_ulong {\n        return 0 as libc::c_int;\n    }\n    loop {\n        let mut buffer: [libc::c_char; 8192] = [0; 8192];\n        let mut bytes_read: size_t = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if bytes_read == 0 as libc::c_int as libc::c_ulong {\n            return -(1 as libc::c_int);\n        }\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 1 as libc::c_int;\n        }\n        let mut buffer_end: *mut libc::c_char = buffer\n            .as_mut_ptr()\n            .offset(bytes_read as isize);\n        *read_pos = (*read_pos as libc::c_ulong).wrapping_add(bytes_read) as uintmax_t\n            as uintmax_t;\n        let mut p: *mut libc::c_char = buffer.as_mut_ptr();\n        loop {\n            p = memchr(\n                p as *const libc::c_void,\n                line_end as libc::c_int,\n                buffer_end.offset_from(p) as libc::c_long as libc::c_ulong,\n            ) as *mut libc::c_char;\n            if p.is_null() {\n                break;\n            }\n            p = p.offset(1);\n            p;\n            n_lines = n_lines.wrapping_sub(1);\n            if n_lines == 0 as libc::c_int as libc::c_ulong {\n                if p < buffer_end {\n                    xwrite_stdout(\n                        p,\n                        buffer_end.offset_from(p) as libc::c_long as size_t,\n                    );\n                }\n                return 0 as libc::c_int;\n            }\n        }\n    };\n}",
    "unsafe extern \"C\" fn fremote(\n    mut fd: libc::c_int,\n    mut name: *const libc::c_char,\n) -> bool {\n    let mut remote: bool = 1 as libc::c_int != 0;\n    let mut buf: statfs = statfs {\n        f_type: 0,\n        f_bsize: 0,\n        f_blocks: 0,\n        f_bfree: 0,\n        f_bavail: 0,\n        f_files: 0,\n        f_ffree: 0,\n        f_fsid: __fsid_t { __val: [0; 2] },\n        f_namelen: 0,\n        f_frsize: 0,\n        f_flags: 0,\n        f_spare: [0; 4],\n    };\n    let mut err: libc::c_int = fstatfs(fd, &mut buf);\n    if err != 0 as libc::c_int {\n        if *__errno_location() != 38 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot determine location of %s. reverting to polling\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, name),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot determine location of %s. reverting to polling\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot determine location of %s. reverting to polling\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    } else {\n        remote = is_local_fs_type(buf.f_type as libc::c_ulong) <= 0 as libc::c_int;\n    }\n    return remote;\n}",
    "unsafe extern \"C\" fn recheck(mut f: *mut File_spec, mut blocking: bool) {\n    let mut new_stats: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut is_stdin: bool = strcmp(\n        (*f).name,\n        b\"-\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int;\n    let mut was_tailable: bool = (*f).tailable;\n    let mut prev_errnum: libc::c_int = (*f).errnum;\n    let mut new_file: bool = false;\n    let mut fd: libc::c_int = if is_stdin as libc::c_int != 0 {\n        0 as libc::c_int\n    } else {\n        open_safer(\n            (*f).name,\n            0 as libc::c_int\n                | (if blocking as libc::c_int != 0 {\n                    0 as libc::c_int\n                } else {\n                    0o4000 as libc::c_int\n                }),\n        )\n    };\n    if valid_file_spec(f) {} else {\n        __assert_fail(\n            b\"valid_file_spec (f)\\0\" as *const u8 as *const libc::c_char,\n            b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n            987 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 40],\n                &[libc::c_char; 40],\n            >(b\"void recheck(struct File_spec *, _Bool)\\0\"))\n                .as_ptr(),\n        );\n    }\n    'c_13353: {\n        if valid_file_spec(f) {} else {\n            __assert_fail(\n                b\"valid_file_spec (f)\\0\" as *const u8 as *const libc::c_char,\n                b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                987 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 40],\n                    &[libc::c_char; 40],\n                >(b\"void recheck(struct File_spec *, _Bool)\\0\"))\n                    .as_ptr(),\n            );\n        }\n    };\n    (*f)\n        .tailable = !(reopen_inaccessible_files as libc::c_int != 0\n        && fd == -(1 as libc::c_int));\n    if !disable_inotify && lstat((*f).name, &mut new_stats) == 0\n        && new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o120000 as libc::c_int as libc::c_uint\n    {\n        ok = 0 as libc::c_int != 0;\n        (*f).errnum = -(1 as libc::c_int);\n        (*f).ignore = 1 as libc::c_int != 0;\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s has been replaced with an untailable symbolic link\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced with an untailable symbolic link\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced with an untailable symbolic link\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    } else if fd == -(1 as libc::c_int) || fstat(fd, &mut new_stats) < 0 as libc::c_int {\n        ok = 0 as libc::c_int != 0;\n        (*f).errnum = *__errno_location();\n        if !(*f).tailable {\n            if was_tailable {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        (*f).errnum,\n                        gettext(\n                            b\"%s has become inaccessible\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            (*f).errnum,\n                            gettext(\n                                b\"%s has become inaccessible\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(f),\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            (*f).errnum,\n                            gettext(\n                                b\"%s has become inaccessible\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(f),\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        } else if prev_errnum != *__errno_location() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        pretty_name(f),\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            pretty_name(f),\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            pretty_name(f),\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    } else if !(new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        || new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o10000 as libc::c_int as libc::c_uint\n        || new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o140000 as libc::c_int as libc::c_uint\n        || new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o20000 as libc::c_int as libc::c_uint)\n    {\n        ok = 0 as libc::c_int != 0;\n        (*f).errnum = -(1 as libc::c_int);\n        (*f).tailable = 0 as libc::c_int != 0;\n        (*f)\n            .ignore = !(reopen_inaccessible_files as libc::c_int != 0\n            && follow_mode as libc::c_uint\n                == Follow_name as libc::c_int as libc::c_uint);\n        if was_tailable as libc::c_int != 0 || prev_errnum != (*f).errnum {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced with an untailable file%s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    if (*f).ignore as libc::c_int != 0 {\n                        gettext(\n                            b\"; giving up on this name\\0\" as *const u8\n                                as *const libc::c_char,\n                        ) as *const libc::c_char\n                    } else {\n                        b\"\\0\" as *const u8 as *const libc::c_char\n                    },\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has been replaced with an untailable file%s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_name(f),\n                        ),\n                        if (*f).ignore as libc::c_int != 0 {\n                            gettext(\n                                b\"; giving up on this name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ) as *const libc::c_char\n                        } else {\n                            b\"\\0\" as *const u8 as *const libc::c_char\n                        },\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has been replaced with an untailable file%s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_name(f),\n                        ),\n                        if (*f).ignore as libc::c_int != 0 {\n                            gettext(\n                                b\"; giving up on this name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ) as *const libc::c_char\n                        } else {\n                            b\"\\0\" as *const u8 as *const libc::c_char\n                        },\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    } else {\n        (*f).remote = fremote(fd, pretty_name(f));\n        if (*f).remote as libc::c_int != 0 && !disable_inotify {\n            ok = 0 as libc::c_int != 0;\n            (*f).errnum = -(1 as libc::c_int);\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced with an untailable remote file\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has been replaced with an untailable remote file\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has been replaced with an untailable remote file\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            (*f).ignore = 1 as libc::c_int != 0;\n            (*f).remote = 1 as libc::c_int != 0;\n        } else {\n            (*f).errnum = 0 as libc::c_int;\n        }\n    }\n    new_file = 0 as libc::c_int != 0;\n    if !ok {\n        close_fd(fd, pretty_name(f));\n        close_fd((*f).fd, pretty_name(f));\n        (*f).fd = -(1 as libc::c_int);\n    } else if prev_errnum != 0 && prev_errnum != 2 as libc::c_int {\n        new_file = 1 as libc::c_int != 0;\n        if (*f).fd == -(1 as libc::c_int) {} else {\n            __assert_fail(\n                b\"f->fd == -1\\0\" as *const u8 as *const libc::c_char,\n                b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                1064 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 40],\n                    &[libc::c_char; 40],\n                >(b\"void recheck(struct File_spec *, _Bool)\\0\"))\n                    .as_ptr(),\n            );\n        }\n        'c_12481: {\n            if (*f).fd == -(1 as libc::c_int) {} else {\n                __assert_fail(\n                    b\"f->fd == -1\\0\" as *const u8 as *const libc::c_char,\n                    b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                    1064 as libc::c_int as libc::c_uint,\n                    (*::core::mem::transmute::<\n                        &[u8; 40],\n                        &[libc::c_char; 40],\n                    >(b\"void recheck(struct File_spec *, _Bool)\\0\"))\n                        .as_ptr(),\n                );\n            }\n        };\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s has become accessible\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has become accessible\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has become accessible\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    } else if (*f).fd == -(1 as libc::c_int) {\n        new_file = 1 as libc::c_int != 0;\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s has appeared;  following new file\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has appeared;  following new file\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,",
    "                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has appeared;  following new file\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    } else if (*f).ino != new_stats.st_ino || (*f).dev != new_stats.st_dev {\n        new_file = 1 as libc::c_int != 0;\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s has been replaced;  following new file\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced;  following new file\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced;  following new file\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        close_fd((*f).fd, pretty_name(f));\n    } else {\n        close_fd(fd, pretty_name(f));\n    }\n    if new_file {\n        record_open_fd(\n            f,\n            fd,\n            0 as libc::c_int as off_t,\n            &mut new_stats,\n            if is_stdin as libc::c_int != 0 {\n                -(1 as libc::c_int)\n            } else {\n                blocking as libc::c_int\n            },\n        );\n        if new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o100000 as libc::c_int as libc::c_uint\n        {\n            xlseek(fd, 0 as libc::c_int as off_t, 0 as libc::c_int, pretty_name(f));\n        }\n    }\n}\nunsafe extern \"C\" fn any_live_files(\n    mut f: *const File_spec,\n    mut n_files: size_t,\n) -> bool {\n    if reopen_inaccessible_files as libc::c_int != 0\n        && follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n    {\n        return 1 as libc::c_int != 0;\n    }\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if 0 as libc::c_int <= (*f.offset(i as isize)).fd {\n            return 1 as libc::c_int != 0\n        } else if !(*f.offset(i as isize)).ignore\n            && reopen_inaccessible_files as libc::c_int != 0\n        {\n            return 1 as libc::c_int != 0\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn writers_are_dead() -> bool {\n    if nbpids == 0 {\n        return 0 as libc::c_int != 0;\n    }\n    let mut i: libc::c_int = 0 as libc::c_int;\n    while i < nbpids {\n        if kill(*pids.offset(i as isize), 0 as libc::c_int) == 0 as libc::c_int\n            || *__errno_location() == 1 as libc::c_int\n        {\n            return 0 as libc::c_int != 0;\n        }\n        i += 1;\n        i;\n    }\n    return 1 as libc::c_int != 0;\n}",
    "unsafe extern \"C\" fn tail_forever(\n    mut f: *mut File_spec,\n    mut n_files: size_t,\n    mut sleep_interval: libc::c_double,\n) {\n    let mut blocking: bool = nbpids == 0\n        && follow_mode as libc::c_uint\n            == Follow_descriptor as libc::c_int as libc::c_uint\n        && n_files == 1 as libc::c_int as libc::c_ulong\n        && (*f.offset(0 as libc::c_int as isize)).fd != -(1 as libc::c_int)\n        && !((*f.offset(0 as libc::c_int as isize)).mode\n            & 0o170000 as libc::c_int as libc::c_uint\n            == 0o100000 as libc::c_int as libc::c_uint);\n    let mut last: size_t = 0;\n    let mut writers_dead: bool = 0 as libc::c_int != 0;\n    last = n_files.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    loop {\n        let mut i: size_t = 0;\n        let mut any_input: bool = 0 as libc::c_int != 0;\n        let mut current_block_47: u64;\n        i = 0 as libc::c_int as size_t;\n        while i < n_files {\n            let mut fd: libc::c_int = 0;\n            let mut name: *const libc::c_char = 0 as *const libc::c_char;\n            let mut mode: mode_t = 0;\n            let mut stats: stat = stat {\n                st_dev: 0,\n                st_ino: 0,\n                st_mode: 0,\n                st_nlink: 0,\n                st_uid: 0,\n                st_gid: 0,\n                st_rdev: 0,\n                __pad1: 0,\n                st_size: 0,\n                st_blksize: 0,\n                __pad2: 0,\n                st_blocks: 0,\n                st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n                st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n                st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n                __glibc_reserved: [0; 2],\n            };\n            let mut bytes_read: uintmax_t = 0;\n            if !(*f.offset(i as isize)).ignore {\n                if (*f.offset(i as isize)).fd < 0 as libc::c_int {\n                    recheck(&mut *f.offset(i as isize), blocking);\n                } else {\n                    fd = (*f.offset(i as isize)).fd;\n                    name = pretty_name(&mut *f.offset(i as isize));\n                    mode = (*f.offset(i as isize)).mode;\n                    if (*f.offset(i as isize)).blocking != blocking as libc::c_int {\n                        let mut old_flags: libc::c_int = rpl_fcntl(fd, 3 as libc::c_int);\n                        let mut new_flags: libc::c_int = old_flags\n                            | (if blocking as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                0o4000 as libc::c_int\n                            });\n                        if old_flags < 0 as libc::c_int\n                            || new_flags != old_flags\n                                && rpl_fcntl(fd, 4 as libc::c_int, new_flags)\n                                    == -(1 as libc::c_int)\n                        {\n                            if !((*f.offset(i as isize)).mode\n                                & 0o170000 as libc::c_int as libc::c_uint\n                                == 0o100000 as libc::c_int as libc::c_uint\n                                && *__errno_location() == 1 as libc::c_int)\n                            {\n                                if 0 != 0 {\n                                    error(\n                                        1 as libc::c_int,\n                                        *__errno_location(),\n                                        gettext(\n                                            b\"%s: cannot change nonblocking mode\\0\" as *const u8\n                                                as *const libc::c_char,\n                                        ),\n                                        quotearg_n_style_colon(\n                                            0 as libc::c_int,\n                                            shell_escape_quoting_style,\n                                            name,\n                                        ),\n                                    );\n                                    if 1 as libc::c_int != 0 as libc::c_int {\n                                        unreachable!();\n                                    } else {};\n                                } else {\n                                    ({\n                                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                                        error(\n                                            __errstatus,\n                                            *__errno_location(),\n                                            gettext(\n                                                b\"%s: cannot change nonblocking mode\\0\" as *const u8\n                                                    as *const libc::c_char,\n                                            ),\n                                            quotearg_n_style_colon(\n                                                0 as libc::c_int,\n                                                shell_escape_quoting_style,\n                                                name,\n                                            ),\n                                        );\n                                        if __errstatus != 0 as libc::c_int {\n                                            unreachable!();\n                                        } else {};\n                                        \n                                    });\n                                    ({\n                                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                                        error(\n                                            __errstatus,\n                                            *__errno_location(),\n                                            gettext(\n                                                b\"%s: cannot change nonblocking mode\\0\" as *const u8\n                                                    as *const libc::c_char,\n                                            ),\n                                            quotearg_n_style_colon(\n                                                0 as libc::c_int,\n                                                shell_escape_quoting_style,\n                                                name,\n                                            ),\n                                        );\n                                        if __errstatus != 0 as libc::c_int {\n                                            unreachable!();\n                                        } else {};\n                                        \n                                    });\n                                };\n                            }\n                        } else {\n                            (*f.offset(i as isize)).blocking = blocking as libc::c_int;\n                        }\n                    }\n                    let mut read_unchanged: bool = 0 as libc::c_int != 0;\n                    if (*f.offset(i as isize)).blocking == 0 {\n                        if fstat(fd, &mut stats) != 0 as libc::c_int {\n                            (*f.offset(i as isize)).fd = -(1 as libc::c_int);\n                            (*f.offset(i as isize)).errnum = *__errno_location();\n                            if 0 != 0 {\n                                error(\n                                    0 as libc::c_int,\n                                    *__errno_location(),\n                                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        name,\n                                    ),\n                                );\n                                if 0 as libc::c_int != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                            } else {\n                                ({\n                                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                                    error(\n                                        __errstatus,\n                                        *__errno_location(),\n                                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                        quotearg_n_style_colon(\n                                            0 as libc::c_int,\n                                            shell_escape_quoting_style,\n                                            name,\n                                        ),\n                                    );\n                                    if __errstatus != 0 as libc::c_int {\n                                        unreachable!();\n                                    } else {};\n                                    \n                                });\n                                ({\n                                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                                    error(\n                                        __errstatus,\n                                        *__errno_location(),\n                                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                        quotearg_n_style_colon(\n                                            0 as libc::c_int,\n                                            shell_escape_quoting_style,\n                                            name,\n                                        ),\n                                    );\n                                    if __errstatus != 0 as libc::c_int {\n                                        unreachable!();\n                                    } else {};\n                                    \n                                });\n                            };\n                            close(fd);\n                            current_block_47 = 17778012151635330486;\n                        } else {\n                            if (*f.offset(i as isize)).mode == stats.st_mode\n                                && (!(stats.st_mode\n                                    & 0o170000 as libc::c_int as libc::c_uint\n                                    == 0o100000 as libc::c_int as libc::c_uint)\n                                    || (*f.offset(i as isize)).size == stats.st_size)\n                                && timespec_cmp(\n                                    (*f.offset(i as isize)).mtime,\n                                    get_stat_mtime(&mut stats),\n                                ) == 0 as libc::c_int\n                            {\n                                let ref mut fresh1 = (*f.offset(i as isize))\n                                    .n_unchanged_stats;\n                                let fresh2 = *fresh1;\n                                *fresh1 = (*fresh1).wrapping_add(1);\n                                if max_n_unchanged_stats_between_opens <= fresh2\n                                    && follow_mode as libc::c_uint\n                                        == Follow_name as libc::c_int as libc::c_uint\n                                {\n                                    recheck(\n                                        &mut *f.offset(i as isize),\n                                        (*f.offset(i as isize)).blocking != 0,\n                                    );\n                                    (*f.offset(i as isize))\n                                        .n_unchanged_stats = 0 as libc::c_int as uintmax_t;\n                                }\n                                if fd != (*f.offset(i as isize)).fd\n                                    || stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                                        == 0o100000 as libc::c_int as libc::c_uint\n                                    || (1 as libc::c_int as libc::c_ulong) < n_files\n                                {\n                                    current_block_47 = 17778012151635330486;\n                                } else {\n                                    read_unchanged = 1 as libc::c_int != 0;\n                                    current_block_47 = 8693738493027456495;\n                                }\n                            } else {\n                                current_block_47 = 8693738493027456495;\n                            }\n                            match current_block_47 {\n                                17778012151635330486 => {}\n                                _ => {\n                                    if fd == (*f.offset(i as isize)).fd {} else {\n                                        __assert_fail(\n                                            b\"fd == f[i].fd\\0\" as *const u8 as *const libc::c_char,\n                                            b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                                            1258 as libc::c_int as libc::c_uint,\n                                            (*::core::mem::transmute::<\n                                                &[u8; 54],\n                                                &[libc::c_char; 54],\n                                            >(\n                                                b\"void tail_forever(struct File_spec *, size_t, double)\\0\",\n                                            ))\n                                                .as_ptr(),\n                                        );\n                                    }\n                                    'c_14118: {\n                                        if fd == (*f.offset(i as isize)).fd {} else {\n                                            __assert_fail(\n                                                b\"fd == f[i].fd\\0\" as *const u8 as *const libc::c_char,\n                                                b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                                                1258 as libc::c_int as libc::c_uint,\n                                                (*::core::mem::transmute::<\n                                                    &[u8; 54],\n                                                    &[libc::c_char; 54],\n                                                >(\n                                                    b\"void tail_forever(struct File_spec *, size_t, double)\\0\",\n                                                ))\n                                                    .as_ptr(),\n                                            );\n                                        }\n                                    };\n                                    (*f.offset(i as isize)).mtime = get_stat_mtime(&mut stats);\n                                    (*f.offset(i as isize)).mode = stats.st_mode;\n                                    if !read_unchanged {\n                                        (*f.offset(i as isize))\n                                            .n_unchanged_stats = 0 as libc::c_int as uintmax_t;\n                                    }\n                                    if mode & 0o170000 as libc::c_int as libc::c_uint\n                                        == 0o100000 as libc::c_int as libc::c_uint\n                                        && stats.st_size < (*f.offset(i as isize)).size\n                                    {\n                                        if 0 != 0 {\n                                            error(\n                                                0 as libc::c_int,\n                                                0 as libc::c_int,\n                                                gettext(\n                                                    b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char,\n                                                ),\n                                                quotearg_n_style_colon(\n                                                    0 as libc::c_int,\n                                                    shell_escape_quoting_style,\n                                                    name,\n                                                ),\n                                            );\n                                            if 0 as libc::c_int != 0 as libc::c_int {\n                                                unreachable!();\n                                            } else {};\n                                        } else {\n                                            ({\n                                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                                error(\n                                                    __errstatus,\n                                                    0 as libc::c_int,\n                                                    gettext(\n                                                        b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char,\n                                                    ),\n                                                    quotearg_n_style_colon(\n                                                        0 as libc::c_int,\n                                                        shell_escape_quoting_style,\n                                                        name,\n                                                    ),\n                                                );\n                                                if __errstatus != 0 as libc::c_int {\n                                                    unreachable!();\n                                                } else {};\n                                                \n                                            });\n                                            ({\n                                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                                error(\n                                                    __errstatus,\n                                                    0 as libc::c_int,\n                                                    gettext(\n                                                        b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char,\n                                                    ),\n                                                    quotearg_n_style_colon(\n                                                        0 as libc::c_int,\n                                                        shell_escape_quoting_style,\n                                                        name,\n                                                    ),\n                                                );\n                                                if __errstatus != 0 as libc::c_int {\n                                                    unreachable!();\n                                                } else {};\n                                                \n                                            });\n                                        };\n                                        xlseek(\n                                            fd,\n                                            0 as libc::c_int as off_t,\n                                            0 as libc::c_int,\n                                            name,\n                                        );\n                                        (*f.offset(i as isize)).size = 0 as libc::c_int as off_t;\n                                    }\n                                    if i != last {\n                                        if print_headers {\n                                            write_header(name);\n                                        }\n                                        last = i;\n                                    }\n                                    current_block_47 = 3222590281903869779;\n                                }\n                            }\n                        }\n                    } else {\n                        current_block_47 = 3222590281903869779;\n                    }\n                    match current_block_47 {\n                        17778012151635330486 => {}\n                        _ => {\n                            let mut bytes_to_read: uintmax_t = 0;\n                            if (*f.offset(i as isize)).blocking != 0 {\n                                bytes_to_read = (18446744073709551615 as libc::c_ulong)\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong);\n                            } else if mode & 0o170000 as libc::c_int as libc::c_uint\n                                == 0o100000 as libc::c_int as libc::c_uint\n                                && (*f.offset(i as isize)).remote as libc::c_int != 0\n                            {\n                                bytes_to_read = (stats.st_size\n                                    - (*f.offset(i as isize)).size) as uintmax_t;\n                            } else {\n                                bytes_to_read = 18446744073709551615 as libc::c_ulong;\n                            }\n                            bytes_read = dump_remainder(\n                                0 as libc::c_int != 0,\n                                name,\n                                fd,\n                                bytes_to_read,\n                            );\n                            if read_unchanged as libc::c_int != 0 && bytes_read != 0 {\n                                (*f.offset(i as isize))\n                                    .n_unchanged_stats = 0 as libc::c_int as uintmax_t;\n                            }\n                            any_input = (any_input as libc::c_int\n                                | (bytes_read != 0 as libc::c_int as libc::c_ulong)\n                                    as libc::c_int) != 0;\n                            let ref mut fresh3 = (*f.offset(i as isize)).size;\n                            *fresh3 = (*fresh3 as libc::c_ulong).wrapping_add(bytes_read)\n                                as off_t as off_t;\n                        }\n                    }\n                }\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if !any_live_files(f, n_files) {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(b\"no files remaining\\0\" as *const u8 as *const libc::c_char),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"no files remaining\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"no files remaining\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            break;\n        } else {\n            if (!any_input || blocking as libc::c_int != 0)\n                && fflush_unlocked(stdout) != 0 as libc::c_int\n            {\n                write_error();\n            }\n            check_output_alive();\n            if any_input {\n                continue;\n            }\n            if writers_dead {\n                break;\n            }\n            writers_dead = writers_are_dead();\n            if !writers_dead && xnanosleep(sleep_interval) != 0 {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot read realtime clock\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot read realtime clock\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot read realtime clock\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        }\n    };\n}",
    "unsafe extern \"C\" fn any_remote_file(\n    mut f: *const File_spec,\n    mut n_files: size_t,\n) -> bool {\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if 0 as libc::c_int <= (*f.offset(i as isize)).fd\n            && (*f.offset(i as isize)).remote as libc::c_int != 0\n        {\n            return 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn any_non_remote_file(\n    mut f: *const File_spec,\n    mut n_files: size_t,\n) -> bool {\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if 0 as libc::c_int <= (*f.offset(i as isize)).fd\n            && !(*f.offset(i as isize)).remote\n        {\n            return 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn any_symlinks(mut f: *const File_spec, mut n_files: size_t) -> bool {\n    let mut st: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if lstat((*f.offset(i as isize)).name, &mut st) == 0 as libc::c_int\n            && st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o120000 as libc::c_int as libc::c_uint\n        {\n            return 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn any_non_regular_fifo(\n    mut f: *const File_spec,\n    mut n_files: size_t,\n) -> bool {\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if 0 as libc::c_int <= (*f.offset(i as isize)).fd\n            && !((*f.offset(i as isize)).mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint)\n            && !((*f.offset(i as isize)).mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o10000 as libc::c_int as libc::c_uint)\n        {\n            return 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn tailable_stdin(\n    mut f: *const File_spec,\n    mut n_files: size_t,\n) -> bool {\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if !(*f.offset(i as isize)).ignore\n            && strcmp(\n                (*f.offset(i as isize)).name,\n                b\"-\\0\" as *const u8 as *const libc::c_char,\n            ) == 0 as libc::c_int\n        {\n            return 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn wd_hasher(\n    mut entry: *const libc::c_void,\n    mut tabsize: size_t,\n) -> size_t {\n    let mut spec: *const File_spec = entry as *const File_spec;\n    return ((*spec).wd as libc::c_ulong).wrapping_rem(tabsize);\n}\nunsafe extern \"C\" fn wd_comparator(\n    mut e1: *const libc::c_void,\n    mut e2: *const libc::c_void,\n) -> bool {\n    let mut spec1: *const File_spec = e1 as *const File_spec;\n    let mut spec2: *const File_spec = e2 as *const File_spec;\n    return (*spec1).wd == (*spec2).wd;\n}\nunsafe extern \"C\" fn check_fspec(\n    mut fspec: *mut File_spec,\n    mut prev_fspec: *mut *mut File_spec,\n) {\n    let mut stats: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut name: *const libc::c_char = 0 as *const libc::c_char;\n    if (*fspec).fd == -(1 as libc::c_int) {\n        return;\n    }\n    name = pretty_name(fspec);\n    if fstat((*fspec).fd, &mut stats) != 0 as libc::c_int {\n        (*fspec).errnum = *__errno_location();\n        close_fd((*fspec).fd, name);\n        (*fspec).fd = -(1 as libc::c_int);\n        return;\n    }\n    if (*fspec).mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint && stats.st_size < (*fspec).size\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char),\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    name,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        xlseek((*fspec).fd, 0 as libc::c_int as off_t, 0 as libc::c_int, name);\n        (*fspec).size = 0 as libc::c_int as off_t;\n    } else if (*fspec).mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint && stats.st_size == (*fspec).size\n        && timespec_cmp((*fspec).mtime, get_stat_mtime(&mut stats)) == 0 as libc::c_int\n    {\n        return\n    }\n    let mut want_header: bool = print_headers as libc::c_int != 0\n        && fspec != *prev_fspec;\n    let mut bytes_read: uintmax_t = dump_remainder(\n        want_header,\n        name,\n        (*fspec).fd,\n        18446744073709551615 as libc::c_ulong,\n    );\n    (*fspec)\n        .size = ((*fspec).size as libc::c_ulong).wrapping_add(bytes_read) as off_t\n        as off_t;\n    if bytes_read != 0 {\n        *prev_fspec = fspec;\n        if fflush_unlocked(stdout) != 0 as libc::c_int {\n            write_error();\n        }\n    }\n}",
    "unsafe extern \"C\" fn tail_forever_inotify(\n    mut wd: libc::c_int,\n    mut f: *mut File_spec,\n    mut n_files: size_t,\n    mut sleep_interval: libc::c_double,\n    mut wd_to_namep: *mut *mut Hash_table,\n) {\n    let mut max_realloc: libc::c_uint = 3 as libc::c_int as libc::c_uint;\n    let mut wd_to_name: *mut Hash_table = 0 as *mut Hash_table;\n    let mut found_watchable_file: bool = 0 as libc::c_int != 0;\n    let mut tailed_but_unwatchable: bool = 0 as libc::c_int != 0;\n    let mut found_unwatchable_dir: bool = 0 as libc::c_int != 0;\n    let mut no_inotify_resources: bool = 0 as libc::c_int != 0;\n    let mut writers_dead: bool = 0 as libc::c_int != 0;\n    let mut prev_fspec: *mut File_spec = 0 as *mut File_spec;\n    let mut evlen: size_t = 0 as libc::c_int as size_t;\n    let mut evbuf: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut evbuf_off: size_t = 0 as libc::c_int as size_t;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    wd_to_name = hash_initialize(\n        n_files,\n        0 as *const Hash_tuning,\n        Some(wd_hasher as unsafe extern \"C\" fn(*const libc::c_void, size_t) -> size_t),\n        Some(\n            wd_comparator\n                as unsafe extern \"C\" fn(*const libc::c_void, *const libc::c_void) -> bool,\n        ),\n        None,\n    );\n    if wd_to_name.is_null() {\n        xalloc_die();\n    }\n    *wd_to_namep = wd_to_name;\n    let mut inotify_wd_mask: uint32_t = 0x2 as libc::c_int as uint32_t;\n    if follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint {\n        inotify_wd_mask\n            |= (0x4 as libc::c_int | 0x400 as libc::c_int | 0x800 as libc::c_int)\n                as libc::c_uint;\n    }\n    let mut i: size_t = 0;\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if !(*f.offset(i as isize)).ignore {\n            let mut fnlen: size_t = strlen((*f.offset(i as isize)).name);\n            if evlen < fnlen {\n                evlen = fnlen;\n            }\n            (*f.offset(i as isize)).wd = -(1 as libc::c_int);\n            if follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n            {\n                let mut dirlen: size_t = dir_len((*f.offset(i as isize)).name);\n                let mut prev: libc::c_char = *((*f.offset(i as isize)).name)\n                    .offset(dirlen as isize);\n                (*f.offset(i as isize))\n                    .basename_start = (last_component((*f.offset(i as isize)).name))\n                    .offset_from((*f.offset(i as isize)).name) as libc::c_long as size_t;\n                *((*f.offset(i as isize)).name)\n                    .offset(dirlen as isize) = '\\0' as i32 as libc::c_char;\n                (*f.offset(i as isize))\n                    .parent_wd = inotify_add_watch(\n                    wd,\n                    if dirlen != 0 {\n                        (*f.offset(i as isize)).name as *const libc::c_char\n                    } else {\n                        b\".\\0\" as *const u8 as *const libc::c_char\n                    },\n                    (0x100 as libc::c_int | 0x200 as libc::c_int | 0x80 as libc::c_int\n                        | 0x4 as libc::c_int | 0x400 as libc::c_int) as uint32_t,\n                );\n                *((*f.offset(i as isize)).name).offset(dirlen as isize) = prev;\n                if (*f.offset(i as isize)).parent_wd < 0 as libc::c_int {\n                    if *__errno_location() != 28 as libc::c_int {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot watch parent directory of %s\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    (*f.offset(i as isize)).name,\n                                ),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    gettext(\n                                        b\"cannot watch parent directory of %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quotearg_style(\n                                        shell_escape_always_quoting_style,\n                                        (*f.offset(i as isize)).name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    gettext(\n                                        b\"cannot watch parent directory of %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quotearg_style(\n                                        shell_escape_always_quoting_style,\n                                        (*f.offset(i as isize)).name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    } else {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"inotify resources exhausted\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"inotify resources exhausted\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"inotify resources exhausted\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    }\n                    found_unwatchable_dir = 1 as libc::c_int != 0;\n                    break;\n                }\n            }\n            (*f.offset(i as isize))\n                .wd = inotify_add_watch(\n                wd,\n                (*f.offset(i as isize)).name,\n                inotify_wd_mask,\n            );\n            if (*f.offset(i as isize)).wd < 0 as libc::c_int {\n                if (*f.offset(i as isize)).fd != -(1 as libc::c_int) {\n                    tailed_but_unwatchable = 1 as libc::c_int != 0;\n                }\n                if *__errno_location() == 28 as libc::c_int\n                    || *__errno_location() == 12 as libc::c_int\n                {\n                    no_inotify_resources = 1 as libc::c_int != 0;\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"inotify resources exhausted\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"inotify resources exhausted\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"inotify resources exhausted\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    break;\n                } else if *__errno_location() != (*f.offset(i as isize)).errnum {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                (*f.offset(i as isize)).name,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    (*f.offset(i as isize)).name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    (*f.offset(i as isize)).name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n            } else {\n                if (hash_insert(\n                    wd_to_name,\n                    &mut *f.offset(i as isize) as *mut File_spec as *const libc::c_void,\n                ))\n                    .is_null()\n                {\n                    xalloc_die();\n                }\n                found_watchable_file = 1 as libc::c_int != 0;\n            }\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    if no_inotify_resources as libc::c_int != 0\n        || found_unwatchable_dir as libc::c_int != 0\n        || follow_mode as libc::c_uint\n            == Follow_descriptor as libc::c_int as libc::c_uint\n            && tailed_but_unwatchable as libc::c_int != 0\n    {\n        return;\n    }\n    if follow_mode as libc::c_uint == Follow_descriptor as libc::c_int as libc::c_uint\n        && !found_watchable_file\n    {\n        exit(1 as libc::c_int);\n    }\n    prev_fspec = &mut *f\n        .offset(n_files.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n        as *mut File_spec;\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if !(*f.offset(i as isize)).ignore {\n            if follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n            {\n                recheck(&mut *f.offset(i as isize), 0 as libc::c_int != 0);\n            } else if (*f.offset(i as isize)).fd != -(1 as libc::c_int) {\n                let mut stats: stat = stat {\n                    st_dev: 0,\n                    st_ino: 0,\n                    st_mode: 0,\n                    st_nlink: 0,\n                    st_uid: 0,\n                    st_gid: 0,\n                    st_rdev: 0,\n                    __pad1: 0,\n                    st_size: 0,\n                    st_blksize: 0,\n                    __pad2: 0,\n                    st_blocks: 0,\n                    st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    __glibc_reserved: [0; 2],\n                };\n                if stat((*f.offset(i as isize)).name, &mut stats) == 0 as libc::c_int\n                    && ((*f.offset(i as isize)).dev != stats.st_dev\n                        || (*f.offset(i as isize)).ino != stats.st_ino)\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"%s was replaced\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(&mut *f.offset(i as isize)),\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"%s was replaced\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    pretty_name(&mut *f.offset(i as isize)),\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"%s was replaced\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    pretty_name(&mut *f.offset(i as isize)),\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    return;\n                }\n            }\n            check_fspec(&mut *f.offset(i as isize), &mut prev_fspec);\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    evlen = (evlen as libc::c_ulong)\n        .wrapping_add(\n            (::core::mem::size_of::<inotify_event>() as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong),\n        ) as size_t as size_t;\n    evbuf = xmalloc(evlen) as *mut libc::c_char;\n    loop {\n        let mut fspec: *mut File_spec = 0 as *mut File_spec;\n        let mut ev: *mut inotify_event = 0 as *mut inotify_event;\n        let mut void_ev: *mut libc::c_void = 0 as *mut libc::c_void;\n        if follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n            && !reopen_inaccessible_files\n            && hash_get_n_entries(wd_to_name) == 0 as libc::c_int as libc::c_ulong\n        {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(b\"no files remaining\\0\" as *const u8 as *const libc::c_char),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"no files remaining\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"no files remaining\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if len <= evbuf_off {\n            let mut file_change: libc::c_int = 0;\n            let mut pfd: [pollfd; 2] = [pollfd {\n                fd: 0,\n                events: 0,\n                revents: 0,\n            }; 2];\n            loop {\n                let mut delay: libc::c_int = -(1 as libc::c_int);\n                if nbpids != 0 {\n                    if writers_dead {\n                        exit(0 as libc::c_int);\n                    }\n                    writers_dead = writers_are_dead();\n                    if writers_dead as libc::c_int != 0\n                        || sleep_interval <= 0 as libc::c_int as libc::c_double\n                    {\n                        delay = 0 as libc::c_int;\n                    } else if sleep_interval\n                        < (2147483647 as libc::c_int / 1000 as libc::c_int\n                            - 1 as libc::c_int) as libc::c_double\n                    {\n                        let mut ddelay: libc::c_double = sleep_interval\n                            * 1000 as libc::c_int as libc::c_double;\n                        delay = ddelay as libc::c_int;\n                        delay += ((delay as libc::c_double) < ddelay) as libc::c_int;\n                    }\n                }\n                pfd[0 as libc::c_int as usize].fd = wd;\n                pfd[0 as libc::c_int as usize]\n                    .events = 0x1 as libc::c_int as libc::c_short;\n                pfd[1 as libc::c_int as usize].fd = 1 as libc::c_int;\n                pfd[1 as libc::c_int as usize]",
    "                    .revents = 0 as libc::c_int as libc::c_short;\n                pfd[1 as libc::c_int as usize]\n                    .events = pfd[1 as libc::c_int as usize].revents;\n                file_change = poll(\n                    pfd.as_mut_ptr(),\n                    (monitor_output as libc::c_int + 1 as libc::c_int) as nfds_t,\n                    delay,\n                );\n                if !(file_change == 0 as libc::c_int) {\n                    break;\n                }\n            }\n            if file_change < 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"error waiting for inotify and output events\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error waiting for inotify and output events\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error waiting for inotify and output events\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            if pfd[1 as libc::c_int as usize].revents != 0 {\n                die_pipe();\n            }\n            len = safe_read(wd, evbuf as *mut libc::c_void, evlen);\n            evbuf_off = 0 as libc::c_int as size_t;\n            if (len == 0 as libc::c_int as libc::c_ulong\n                || len == -(1 as libc::c_int) as size_t\n                    && *__errno_location() == 22 as libc::c_int)\n                && {\n                    let fresh4 = max_realloc;\n                    max_realloc = max_realloc.wrapping_sub(1);\n                    fresh4 != 0\n                }\n            {\n                len = 0 as libc::c_int as size_t;\n                evlen = (evlen as libc::c_ulong)\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong) as size_t as size_t;\n                evbuf = xrealloc(evbuf as *mut libc::c_void, evlen) as *mut libc::c_char;\n                continue;\n            } else if len == 0 as libc::c_int as libc::c_ulong\n                || len == -(1 as libc::c_int) as size_t\n            {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading inotify event\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading inotify event\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading inotify event\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        }\n        void_ev = evbuf.offset(evbuf_off as isize) as *mut libc::c_void;\n        ev = void_ev as *mut inotify_event;\n        evbuf_off = (evbuf_off as libc::c_ulong)\n            .wrapping_add(\n                (::core::mem::size_of::<inotify_event>() as libc::c_ulong)\n                    .wrapping_add((*ev).len as libc::c_ulong),\n            ) as size_t as size_t;\n        if (*ev).mask & 0x400 as libc::c_int as libc::c_uint != 0 && (*ev).len == 0 {\n            i = 0 as libc::c_int as size_t;\n            while i < n_files {\n                if (*ev).wd == (*f.offset(i as isize)).parent_wd {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"directory containing watched file was removed\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"directory containing watched file was removed\\0\"\n                                        as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"directory containing watched file was removed\\0\"\n                                        as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    return;\n                }\n                i = i.wrapping_add(1);\n                i;\n            }\n        }\n        if (*ev).len != 0 {\n            let mut j: size_t = 0;\n            j = 0 as libc::c_int as size_t;\n            while j < n_files {\n                if (*f.offset(j as isize)).parent_wd == (*ev).wd\n                    && strcmp(\n                        ((*ev).name).as_mut_ptr(),\n                        ((*f.offset(j as isize)).name)\n                            .offset((*f.offset(j as isize)).basename_start as isize),\n                    ) == 0 as libc::c_int\n                {\n                    break;\n                }\n                j = j.wrapping_add(1);\n                j;\n            }\n            if j == n_files {\n                continue;\n            }\n            fspec = &mut *f.offset(j as isize) as *mut File_spec;\n            let mut new_wd: libc::c_int = -(1 as libc::c_int);\n            let mut deleting: bool = (*ev).mask & 0x200 as libc::c_int as libc::c_uint\n                != 0;\n            if !deleting {\n                new_wd = inotify_add_watch(\n                    wd,\n                    (*f.offset(j as isize)).name,\n                    inotify_wd_mask,\n                );\n            }\n            if !deleting && new_wd < 0 as libc::c_int {\n                if *__errno_location() == 28 as libc::c_int\n                    || *__errno_location() == 12 as libc::c_int\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"inotify resources exhausted\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"inotify resources exhausted\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"inotify resources exhausted\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    return;\n                } else {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                (*f.offset(j as isize)).name,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    (*f.offset(j as isize)).name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    (*f.offset(j as isize)).name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n            }\n            let mut new_watch: bool = false;\n            new_watch = !deleting\n                && ((*fspec).wd < 0 as libc::c_int || new_wd != (*fspec).wd);\n            if new_watch {\n                if 0 as libc::c_int <= (*fspec).wd {\n                    inotify_rm_watch(wd, (*fspec).wd);\n                    hash_remove(wd_to_name, fspec as *const libc::c_void);\n                }\n                (*fspec).wd = new_wd;\n                if new_wd == -(1 as libc::c_int) {\n                    continue;\n                }\n                let mut prev_0: *mut File_spec = hash_remove(\n                    wd_to_name,\n                    fspec as *const libc::c_void,\n                ) as *mut File_spec;\n                if !prev_0.is_null() && prev_0 != fspec {\n                    if follow_mode as libc::c_uint\n                        == Follow_name as libc::c_int as libc::c_uint\n                    {\n                        recheck(prev_0, 0 as libc::c_int != 0);\n                    }\n                    (*prev_0).wd = -(1 as libc::c_int);\n                    close_fd((*prev_0).fd, pretty_name(prev_0));\n                }\n                if (hash_insert(wd_to_name, fspec as *const libc::c_void)).is_null() {\n                    xalloc_die();\n                }\n            }\n            if follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n            {\n                recheck(fspec, 0 as libc::c_int != 0);\n            }\n        } else {\n            let mut key: File_spec = File_spec {\n                name: 0 as *mut libc::c_char,\n                size: 0,\n                mtime: timespec { tv_sec: 0, tv_nsec: 0 },\n                dev: 0,\n                ino: 0,\n                mode: 0,\n                ignore: false,\n                remote: false,\n                tailable: false,\n                fd: 0,\n                errnum: 0,\n                blocking: 0,\n                wd: 0,\n                parent_wd: 0,\n                basename_start: 0,\n                n_unchanged_stats: 0,\n            };\n            key.wd = (*ev).wd;\n            fspec = hash_lookup(\n                wd_to_name,\n                &mut key as *mut File_spec as *const libc::c_void,\n            ) as *mut File_spec;\n        }\n        if fspec.is_null() {\n            continue;\n        }\n        if (*ev).mask\n            & (0x4 as libc::c_int | 0x200 as libc::c_int | 0x400 as libc::c_int\n                | 0x800 as libc::c_int) as libc::c_uint != 0\n        {\n            if (*ev).mask & 0x400 as libc::c_int as libc::c_uint != 0 {\n                inotify_rm_watch(wd, (*fspec).wd);\n                hash_remove(wd_to_name, fspec as *const libc::c_void);\n            }\n            recheck(fspec, 0 as libc::c_int != 0);\n        } else {\n            check_fspec(fspec, &mut prev_fspec);\n        }\n    };\n}",
    "unsafe extern \"C\" fn tail_bytes(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    let mut stats: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    if fstat(fd, &mut stats) != 0 {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    if from_start {\n        if !presume_input_pipe\n            && n_bytes\n                <= (if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                    -(1 as libc::c_int) as off_t\n                } else {\n                    (((1 as libc::c_int as off_t)\n                        << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long\n                }) as libc::c_ulong\n            && (stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint\n                && xlseek(fd, n_bytes as off_t, 1 as libc::c_int, pretty_filename)\n                    >= 0 as libc::c_int as libc::c_long\n                || lseek(fd, n_bytes as __off_t, 1 as libc::c_int)\n                    != -(1 as libc::c_int) as libc::c_long)\n        {\n            *read_pos = (*read_pos as libc::c_ulong).wrapping_add(n_bytes) as uintmax_t\n                as uintmax_t;\n        } else {\n            let mut t: libc::c_int = start_bytes(pretty_filename, fd, n_bytes, read_pos);\n            if t != 0 {\n                return t < 0 as libc::c_int;\n            }\n        }\n        n_bytes = 18446744073709551615 as libc::c_ulong;\n    } else {\n        let mut end_pos: off_t = -(1 as libc::c_int) as off_t;\n        let mut current_pos: off_t = -(1 as libc::c_int) as off_t;\n        let mut copy_from_current_pos: bool = 0 as libc::c_int != 0;\n        if !presume_input_pipe\n            && n_bytes\n                <= (if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                    -(1 as libc::c_int) as off_t\n                } else {\n                    (((1 as libc::c_int as off_t)\n                        << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long\n                }) as libc::c_ulong\n        {\n            if usable_st_size(&mut stats) {\n                end_pos = stats.st_size;\n                let mut smallish_size: off_t = (if (0 as libc::c_int) < stats.st_blksize\n                    && stats.st_blksize as libc::c_ulong\n                        <= (-(1 as libc::c_int) as size_t)\n                            .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                {\n                    stats.st_blksize\n                } else {\n                    512 as libc::c_int\n                }) as off_t;\n                copy_from_current_pos = smallish_size < end_pos;\n            } else {\n                current_pos = lseek(\n                    fd,\n                    n_bytes.wrapping_neg() as __off_t,\n                    2 as libc::c_int,\n                );\n                copy_from_current_pos = current_pos\n                    != -(1 as libc::c_int) as libc::c_long;\n                if copy_from_current_pos {\n                    end_pos = (current_pos as libc::c_ulong).wrapping_add(n_bytes)\n                        as off_t;\n                }\n            }\n        }\n        if !copy_from_current_pos {\n            return pipe_bytes(pretty_filename, fd, n_bytes, read_pos);\n        }\n        if current_pos == -(1 as libc::c_int) as libc::c_long {\n            current_pos = xlseek(\n                fd,\n                0 as libc::c_int as off_t,\n                1 as libc::c_int,\n                pretty_filename,\n            );\n        }\n        if current_pos < end_pos {\n            let mut bytes_remaining: off_t = end_pos - current_pos;\n            if n_bytes < bytes_remaining as libc::c_ulong {\n                current_pos = (end_pos as libc::c_ulong).wrapping_sub(n_bytes) as off_t;\n                xlseek(fd, current_pos, 0 as libc::c_int, pretty_filename);\n            }\n        }\n        *read_pos = current_pos as uintmax_t;\n    }\n    *read_pos = (*read_pos as libc::c_ulong)\n        .wrapping_add(\n            dump_remainder(0 as libc::c_int != 0, pretty_filename, fd, n_bytes),\n        ) as uintmax_t as uintmax_t;\n    return 1 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn tail_lines(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_lines: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    let mut stats: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    if fstat(fd, &mut stats) != 0 {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    if from_start {\n        let mut t: libc::c_int = start_lines(pretty_filename, fd, n_lines, read_pos);\n        if t != 0 {\n            return t < 0 as libc::c_int;\n        }\n        *read_pos = (*read_pos as libc::c_ulong)\n            .wrapping_add(\n                dump_remainder(\n                    0 as libc::c_int != 0,\n                    pretty_filename,\n                    fd,\n                    18446744073709551615 as libc::c_ulong,\n                ),\n            ) as uintmax_t as uintmax_t;\n    } else {\n        let mut start_pos: off_t = -(1 as libc::c_int) as off_t;\n        let mut end_pos: off_t = 0;\n        if !presume_input_pipe\n            && stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint\n            && {\n                start_pos = lseek(fd, 0 as libc::c_int as __off_t, 1 as libc::c_int);\n                start_pos != -(1 as libc::c_int) as libc::c_long\n            }\n            && {\n                end_pos = lseek(fd, 0 as libc::c_int as __off_t, 2 as libc::c_int);\n                start_pos < end_pos\n            }\n        {\n            *read_pos = end_pos as uintmax_t;\n            if end_pos != 0 as libc::c_int as libc::c_long\n                && !file_lines(\n                    pretty_filename,\n                    fd,\n                    &mut stats,\n                    n_lines,\n                    start_pos,\n                    end_pos,\n                    read_pos,\n                )\n            {\n                return 0 as libc::c_int != 0;\n            }\n        } else {\n            if start_pos != -(1 as libc::c_int) as libc::c_long {\n                xlseek(fd, start_pos, 0 as libc::c_int, pretty_filename);\n            }\n            return pipe_lines(pretty_filename, fd, n_lines, read_pos);\n        }\n    }\n    return 1 as libc::c_int != 0;\n}\nunsafe extern \"C\" fn tail(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_units: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    *read_pos = 0 as libc::c_int as uintmax_t;\n    if count_lines {\n        return tail_lines(filename, fd, n_units, read_pos)\n    } else {\n        return tail_bytes(filename, fd, n_units, read_pos)\n    };\n}",
    "unsafe extern \"C\" fn tail_file(mut f: *mut File_spec, mut n_units: uintmax_t) -> bool {\n    let mut fd: libc::c_int = 0;\n    let mut ok: bool = false;\n    let mut is_stdin: bool = strcmp(\n        (*f).name,\n        b\"-\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int;\n    if is_stdin {\n        have_read_stdin = 1 as libc::c_int != 0;\n        fd = 0 as libc::c_int;\n        xset_binary_mode(0 as libc::c_int, 0 as libc::c_int);\n    } else {\n        fd = open_safer((*f).name, 0 as libc::c_int | 0 as libc::c_int);\n    }\n    (*f)\n        .tailable = !(reopen_inaccessible_files as libc::c_int != 0\n        && fd == -(1 as libc::c_int));\n    if fd == -(1 as libc::c_int) {\n        if forever {\n            (*f).fd = -(1 as libc::c_int);\n            (*f).errnum = *__errno_location();\n            (*f).ignore = !reopen_inaccessible_files;\n            (*f).ino = 0 as libc::c_int as ino_t;\n            (*f).dev = 0 as libc::c_int as dev_t;\n        }\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"cannot open %s for reading\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open %s for reading\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open %s for reading\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        ok = 0 as libc::c_int != 0;\n    } else {\n        let mut read_pos: uintmax_t = 0;\n        if print_headers {\n            write_header(pretty_name(f));\n        }\n        ok = tail(pretty_name(f), fd, n_units, &mut read_pos);\n        if forever {\n            let mut stats: stat = stat {\n                st_dev: 0,\n                st_ino: 0,\n                st_mode: 0,\n                st_nlink: 0,\n                st_uid: 0,\n                st_gid: 0,\n                st_rdev: 0,\n                __pad1: 0,\n                st_size: 0,\n                st_blksize: 0,\n                __pad2: 0,\n                st_blocks: 0,\n                st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n                st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n                st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n                __glibc_reserved: [0; 2],\n            };\n            (*f).errnum = ok as libc::c_int - 1 as libc::c_int;\n            if fstat(fd, &mut stats) < 0 as libc::c_int {\n                ok = 0 as libc::c_int != 0;\n                (*f).errnum = *__errno_location();\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(f),\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(f),\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            } else if !(stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint\n                || stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                    == 0o10000 as libc::c_int as libc::c_uint\n                || stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                    == 0o140000 as libc::c_int as libc::c_uint\n                || stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                    == 0o20000 as libc::c_int as libc::c_uint)\n            {\n                ok = 0 as libc::c_int != 0;\n                (*f).errnum = -(1 as libc::c_int);\n                (*f).tailable = 0 as libc::c_int != 0;\n                (*f).ignore = !reopen_inaccessible_files;\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s: cannot follow end of this type of file%s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            pretty_name(f),\n                        ),\n                        if (*f).ignore as libc::c_int != 0 {\n                            gettext(\n                                b\"; giving up on this name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ) as *const libc::c_char\n                        } else {\n                            b\"\\0\" as *const u8 as *const libc::c_char\n                        },\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s: cannot follow end of this type of file%s\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                pretty_name(f),\n                            ),\n                            if (*f).ignore as libc::c_int != 0 {\n                                gettext(\n                                    b\"; giving up on this name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ) as *const libc::c_char\n                            } else {\n                                b\"\\0\" as *const u8 as *const libc::c_char\n                            },\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s: cannot follow end of this type of file%s\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                pretty_name(f),\n                            ),\n                            if (*f).ignore as libc::c_int != 0 {\n                                gettext(\n                                    b\"; giving up on this name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ) as *const libc::c_char\n                            } else {\n                                b\"\\0\" as *const u8 as *const libc::c_char\n                            },\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            if !ok {\n                (*f).ignore = !reopen_inaccessible_files;\n                close_fd(fd, pretty_name(f));\n                (*f).fd = -(1 as libc::c_int);\n            } else {\n                record_open_fd(\n                    f,\n                    fd,\n                    read_pos as off_t,\n                    &mut stats,\n                    if is_stdin as libc::c_int != 0 {\n                        -(1 as libc::c_int)\n                    } else {\n                        1 as libc::c_int\n                    },\n                );\n                (*f).remote = fremote(fd, pretty_name(f));\n            }\n        } else if !is_stdin && close(fd) != 0 {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            ok = 0 as libc::c_int != 0;\n        }\n    }\n    return ok;\n}\nunsafe extern \"C\" fn parse_obsolete_option(\n    mut argc: libc::c_int,\n    mut argv: *const *mut libc::c_char,\n    mut n_units: *mut uintmax_t,\n) -> bool {\n    let mut p: *const libc::c_char = 0 as *const libc::c_char;\n    let mut n_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut n_string_end: *const libc::c_char = 0 as *const libc::c_char;\n    let mut default_count: libc::c_int = 10 as libc::c_int;\n    let mut t_from_start: bool = false;\n    let mut t_count_lines: bool = 1 as libc::c_int != 0;\n    let mut t_forever: bool = 0 as libc::c_int != 0;\n    if !(argc == 2 as libc::c_int\n        || argc == 3 as libc::c_int\n            && !(*(*argv.offset(2 as libc::c_int as isize))\n                .offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32\n                && *(*argv.offset(2 as libc::c_int as isize))\n                    .offset(1 as libc::c_int as isize) as libc::c_int != 0)\n        || 3 as libc::c_int <= argc && argc <= 4 as libc::c_int\n            && strcmp(\n                *argv.offset(2 as libc::c_int as isize),\n                b\"--\\0\" as *const u8 as *const libc::c_char,\n            ) == 0 as libc::c_int)\n    {\n        return 0 as libc::c_int != 0;\n    }\n    let mut posix_ver: libc::c_int = posix2_version();\n    let mut obsolete_usage: bool = posix_ver < 200112 as libc::c_int;\n    let mut traditional_usage: bool = obsolete_usage as libc::c_int != 0\n        || 200809 as libc::c_int <= posix_ver;\n    p = *argv.offset(1 as libc::c_int as isize);\n    let fresh5 = p;\n    p = p.offset(1);\n    match *fresh5 as libc::c_int {\n        43 => {\n            if !traditional_usage {\n                return 0 as libc::c_int != 0;\n            }\n            t_from_start = 1 as libc::c_int != 0;\n        }\n        45 => {\n            if !obsolete_usage\n                && *p\n                    .offset(\n                        (*p.offset(0 as libc::c_int as isize) as libc::c_int\n                            == 'c' as i32) as libc::c_int as isize,\n                    ) == 0\n            {\n                return 0 as libc::c_int != 0;\n            }\n            t_from_start = 0 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    }\n    n_string = p;\n    while (*p as libc::c_uint).wrapping_sub('0' as i32 as libc::c_uint)\n        <= 9 as libc::c_int as libc::c_uint\n    {\n        p = p.offset(1);\n        p;\n    }\n    n_string_end = p;\n    let mut current_block_19: u64;\n    match *p as libc::c_int {\n        98 => {\n            default_count *= 512 as libc::c_int;\n            current_block_19 = 12856559154846489347;\n        }\n        99 => {\n            current_block_19 = 12856559154846489347;\n        }\n        108 => {\n            current_block_19 = 7044594549367080378;\n        }\n        _ => {\n            current_block_19 = 5783071609795492627;\n        }\n    }\n    match current_block_19 {\n        12856559154846489347 => {\n            t_count_lines = 0 as libc::c_int != 0;\n            current_block_19 = 7044594549367080378;\n        }\n        _ => {}\n    }\n    match current_block_19 {\n        7044594549367080378 => {\n            p = p.offset(1);\n            p;\n        }\n        _ => {}\n    }\n    if *p as libc::c_int == 'f' as i32 {\n        t_forever = 1 as libc::c_int != 0;\n        p = p.offset(1);\n        p;\n    }\n    if *p != 0 {\n        return 0 as libc::c_int != 0;\n    }\n    if n_string == n_string_end {\n        *n_units = default_count as uintmax_t;\n    } else if xstrtoumax(\n        n_string,\n        0 as *mut *mut libc::c_char,\n        10 as libc::c_int,\n        n_units,\n        b\"b\\0\" as *const u8 as *const libc::c_char,\n    ) as libc::c_uint & !(LONGINT_INVALID_SUFFIX_CHAR as libc::c_int) as libc::c_uint\n        != LONGINT_OK as libc::c_int as libc::c_uint\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"invalid number\\0\" as *const u8 as *const libc::c_char),\n                quote(*argv.offset(1 as libc::c_int as isize)),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(b\"invalid number\\0\" as *const u8 as *const libc::c_char),\n                    quote(*argv.offset(1 as libc::c_int as isize)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(b\"invalid number\\0\" as *const u8 as *const libc::c_char),\n                    quote(*argv.offset(1 as libc::c_int as isize)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    from_start = t_from_start;\n    count_lines = t_count_lines;\n    forever = t_forever;\n    return 1 as libc::c_int != 0;\n}",
    "unsafe extern \"C\" fn parse_options(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n    mut n_units: *mut uintmax_t,\n    mut header_mode: *mut header_mode,\n    mut sleep_interval: *mut libc::c_double,\n) {\n    let mut c: libc::c_int = 0;\n    loop {\n        c = getopt_long(\n            argc,\n            argv,\n            b\"c:n:fFqs:vz0123456789\\0\" as *const u8 as *const libc::c_char,\n            long_options.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if !(c != -(1 as libc::c_int)) {\n            break;\n        }\n        let mut current_block_33: u64;\n        match c {\n            70 => {\n                forever = 1 as libc::c_int != 0;\n                follow_mode = Follow_name;\n                reopen_inaccessible_files = 1 as libc::c_int != 0;\n                current_block_33 = 4567019141635105728;\n            }\n            99 | 110 => {\n                count_lines = c == 'n' as i32;\n                if *optarg as libc::c_int == '+' as i32 {\n                    from_start = 1 as libc::c_int != 0;\n                } else if *optarg as libc::c_int == '-' as i32 {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                *n_units = xdectoumax(\n                    optarg,\n                    0 as libc::c_int as uintmax_t,\n                    18446744073709551615 as libc::c_ulong,\n                    b\"bkKmMGTPEZYRQ0\\0\" as *const u8 as *const libc::c_char,\n                    if count_lines as libc::c_int != 0 {\n                        gettext(\n                            b\"invalid number of lines\\0\" as *const u8\n                                as *const libc::c_char,\n                        )\n                    } else {\n                        gettext(\n                            b\"invalid number of bytes\\0\" as *const u8\n                                as *const libc::c_char,\n                        )\n                    },\n                    0 as libc::c_int,\n                );\n                current_block_33 = 4567019141635105728;\n            }\n            102 | 260 => {\n                forever = 1 as libc::c_int != 0;\n                if optarg.is_null() {\n                    follow_mode = Follow_descriptor;\n                } else {\n                    follow_mode = follow_mode_map[__xargmatch_internal(\n                        b\"--follow\\0\" as *const u8 as *const libc::c_char,\n                        optarg,\n                        follow_mode_string.as_ptr(),\n                        follow_mode_map.as_ptr() as *const libc::c_void,\n                        ::core::mem::size_of::<Follow_mode>() as libc::c_ulong,\n                        argmatch_die,\n                        1 as libc::c_int != 0,\n                    ) as usize];\n                }\n                current_block_33 = 4567019141635105728;\n            }\n            256 => {\n                reopen_inaccessible_files = 1 as libc::c_int != 0;\n                current_block_33 = 4567019141635105728;\n            }\n            257 => {\n                max_n_unchanged_stats_between_opens = xdectoumax(\n                    optarg,\n                    0 as libc::c_int as uintmax_t,\n                    18446744073709551615 as libc::c_ulong,\n                    b\"\\0\" as *const u8 as *const libc::c_char,\n                    gettext(\n                        b\"invalid maximum number of unchanged stats between opens\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    0 as libc::c_int,\n                );\n                current_block_33 = 4567019141635105728;\n            }\n            261 => {\n                disable_inotify = 1 as libc::c_int != 0;\n                current_block_33 = 4567019141635105728;\n            }\n            258 => {\n                if nbpids as libc::c_long == pids_alloc {\n                    pids = xpalloc(\n                        pids as *mut libc::c_void,\n                        &mut pids_alloc,\n                        1 as libc::c_int as idx_t,\n                        if (2147483647 as libc::c_int as libc::c_long)\n                            < 9223372036854775807 as libc::c_long\n                        {\n                            2147483647 as libc::c_int as libc::c_long\n                        } else {\n                            9223372036854775807 as libc::c_long\n                        },\n                        ::core::mem::size_of::<pid_t>() as libc::c_ulong as idx_t,\n                    ) as *mut pid_t;\n                }\n                let fresh6 = nbpids;\n                nbpids = nbpids + 1;\n                *pids\n                    .offset(\n                        fresh6 as isize,\n                    ) = xdectoumax(\n                    optarg,\n                    0 as libc::c_int as uintmax_t,\n                    (if (0 as libc::c_int) < -(1 as libc::c_int) {\n                        -(1 as libc::c_int)\n                    } else {\n                        (((1 as libc::c_int)\n                            << (::core::mem::size_of::<pid_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                    }) as uintmax_t,\n                    b\"\\0\" as *const u8 as *const libc::c_char,\n                    gettext(b\"invalid PID\\0\" as *const u8 as *const libc::c_char),\n                    0 as libc::c_int,\n                ) as pid_t;\n                current_block_33 = 4567019141635105728;\n            }\n            259 => {\n                presume_input_pipe = 1 as libc::c_int != 0;\n                current_block_33 = 4567019141635105728;\n            }\n            113 => {\n                *header_mode = never;\n                current_block_33 = 4567019141635105728;\n            }\n            115 => {\n                let mut s: libc::c_double = 0.;\n                if !(xstrtod(\n                    optarg,\n                    0 as *mut *const libc::c_char,\n                    &mut s,\n                    Some(\n                        cl_strtod\n                            as unsafe extern \"C\" fn(\n                                *const libc::c_char,\n                                *mut *mut libc::c_char,\n                            ) -> libc::c_double,\n                    ),\n                ) as libc::c_int != 0 && 0 as libc::c_int as libc::c_double <= s)\n                {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"invalid number of seconds: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quote(optarg),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid number of seconds: %s\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid number of seconds: %s\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                *sleep_interval = s;\n                current_block_33 = 4567019141635105728;\n            }\n            118 => {\n                *header_mode = always;\n                current_block_33 = 4567019141635105728;\n            }\n            122 => {\n                line_end = '\\0' as i32 as libc::c_char;\n                current_block_33 = 4567019141635105728;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n                current_block_33 = 4567019141635105728;\n            }\n            -3 => {\n                version_etc(\n                    stdout,\n                    b\"tail\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Paul Rubin\\0\" as *const u8 as *const libc::c_char,\n                        b\"Paul Rubin\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                        b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"Ian Lance Taylor\\0\" as *const u8 as *const libc::c_char,\n                        b\"Ian Lance Taylor\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);\n            }\n            48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"option used in invalid context -- %c\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        c,\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"option used in invalid context -- %c\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            c,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"option used in invalid context -- %c\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            c,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                current_block_33 = 17156019370052222107;\n            }\n            _ => {\n                current_block_33 = 17156019370052222107;\n            }\n        }\n        match current_block_33 {\n            17156019370052222107 => {\n                usage(1 as libc::c_int);\n            }\n            _ => {}\n        }\n    }\n    if reopen_inaccessible_files {\n        if !forever {\n            reopen_inaccessible_files = 0 as libc::c_int != 0;\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: --retry ignored; --retry is useful only when following\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: --retry ignored; --retry is useful only when following\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: --retry ignored; --retry is useful only when following\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else if follow_mode as libc::c_uint\n            == Follow_descriptor as libc::c_int as libc::c_uint\n        {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: --retry only effective for the initial open\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: --retry only effective for the initial open\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: --retry only effective for the initial open\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    }\n    if nbpids != 0 && !forever {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"warning: PID ignored; --pid=PID is useful only when following\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: PID ignored; --pid=PID is useful only when following\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: PID ignored; --pid=PID is useful only when following\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    } else if nbpids != 0\n        && kill(*pids.offset(0 as libc::c_int as isize), 0 as libc::c_int)\n            != 0 as libc::c_int && *__errno_location() == 38 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"warning: --pid=PID is not supported on this system\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: --pid=PID is not supported on this system\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: --pid=PID is not supported on this system\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        nbpids = 0 as libc::c_int;\n        free(pids as *mut libc::c_void);\n    }\n}",
    "unsafe extern \"C\" fn ignore_fifo_and_pipe(\n    mut f: *mut File_spec,\n    mut n_files: size_t,\n) -> size_t {\n    let mut n_viable: size_t = 0 as libc::c_int as size_t;\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        let mut is_a_fifo_or_pipe: bool = strcmp(\n            (*f.offset(i as isize)).name,\n            b\"-\\0\" as *const u8 as *const libc::c_char,\n        ) == 0 as libc::c_int && !(*f.offset(i as isize)).ignore\n            && 0 as libc::c_int <= (*f.offset(i as isize)).fd\n            && ((*f.offset(i as isize)).mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o10000 as libc::c_int as libc::c_uint\n                || 1 as libc::c_int != 1 as libc::c_int\n                    && isapipe((*f.offset(i as isize)).fd) != 0);\n        if is_a_fifo_or_pipe {\n            (*f.offset(i as isize)).fd = -(1 as libc::c_int);\n            (*f.offset(i as isize)).ignore = 1 as libc::c_int != 0;\n        } else {\n            n_viable = n_viable.wrapping_add(1);\n            n_viable;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return n_viable;\n}\nunsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut header_mode: header_mode = multiple_files;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut n_units: uintmax_t = 10 as libc::c_int as uintmax_t;\n    let mut n_files: size_t = 0;\n    let mut file: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut F: *mut File_spec = 0 as *mut File_spec;\n    let mut i: size_t = 0;\n    let mut obsolete_option: bool = false;\n    let mut sleep_interval: libc::c_double = 1.0f64;\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    page_size = getpagesize() as idx_t;\n    have_read_stdin = 0 as libc::c_int != 0;\n    count_lines = 1 as libc::c_int != 0;\n    print_headers = 0 as libc::c_int != 0;\n    from_start = print_headers;\n    forever = from_start;\n    line_end = '\\n' as i32 as libc::c_char;\n    obsolete_option = parse_obsolete_option(argc, argv, &mut n_units);\n    argc -= obsolete_option as libc::c_int;\n    argv = argv.offset(obsolete_option as libc::c_int as isize);\n    parse_options(argc, argv, &mut n_units, &mut header_mode, &mut sleep_interval);\n    if from_start {\n        if n_units != 0 {\n            n_units = n_units.wrapping_sub(1);\n            n_units;\n        }\n    }\n    if optind < argc {\n        n_files = (argc - optind) as size_t;\n        file = argv.offset(optind as isize);\n    } else {\n        static mut dummy_stdin: *mut libc::c_char = b\"-\\0\" as *const u8\n            as *const libc::c_char as *mut libc::c_char;\n        n_files = 1 as libc::c_int as size_t;\n        file = &mut dummy_stdin;\n    }\n    let mut found_hyphen: bool = 0 as libc::c_int != 0;\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if strcmp(*file.offset(i as isize), b\"-\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int\n        {\n            found_hyphen = 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    if found_hyphen as libc::c_int != 0\n        && follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"cannot follow %s by name\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"cannot follow %s by name\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"-\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"cannot follow %s by name\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"-\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if forever as libc::c_int != 0 && found_hyphen as libc::c_int != 0 {\n        let mut in_stat: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        let mut blocking_stdin: bool = false;\n        blocking_stdin = nbpids == 0\n            && follow_mode as libc::c_uint\n                == Follow_descriptor as libc::c_int as libc::c_uint\n            && n_files == 1 as libc::c_int as libc::c_ulong\n            && fstat(0 as libc::c_int, &mut in_stat) == 0\n            && !(in_stat.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint);\n        if !blocking_stdin && isatty(0 as libc::c_int) != 0 {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: following standard input indefinitely is ineffective\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: following standard input indefinitely is ineffective\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: following standard input indefinitely is ineffective\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    }\n    if n_units == 0 && !forever && !from_start {\n        return 0 as libc::c_int;\n    }\n    F = xnmalloc(n_files, ::core::mem::size_of::<File_spec>() as libc::c_ulong)\n        as *mut File_spec;\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        let ref mut fresh7 = (*F.offset(i as isize)).name;\n        *fresh7 = *file.offset(i as isize);\n        i = i.wrapping_add(1);\n        i;\n    }\n    if header_mode as libc::c_uint == always as libc::c_int as libc::c_uint\n        || header_mode as libc::c_uint == multiple_files as libc::c_int as libc::c_uint\n            && n_files > 1 as libc::c_int as libc::c_ulong\n    {\n        print_headers = 1 as libc::c_int != 0;\n    }\n    xset_binary_mode(1 as libc::c_int, 0 as libc::c_int);\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        ok = (ok as libc::c_int\n            & tail_file(&mut *F.offset(i as isize), n_units) as libc::c_int) != 0;\n        i = i.wrapping_add(1);\n        i;\n    }\n    if forever as libc::c_int != 0 && ignore_fifo_and_pipe(F, n_files) != 0 {\n        let mut out_stat: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        if fstat(1 as libc::c_int, &mut out_stat) < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        monitor_output = out_stat.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o10000 as libc::c_int as libc::c_uint\n            || 1 as libc::c_int != 1 as libc::c_int && isapipe(1 as libc::c_int) != 0;\n        if !disable_inotify\n            && (tailable_stdin(F, n_files) as libc::c_int != 0\n                || any_remote_file(F, n_files) as libc::c_int != 0\n                || !any_non_remote_file(F, n_files)\n                || any_symlinks(F, n_files) as libc::c_int != 0\n                || any_non_regular_fifo(F, n_files) as libc::c_int != 0\n                || !ok\n                    && follow_mode as libc::c_uint\n                        == Follow_descriptor as libc::c_int as libc::c_uint)\n        {\n            disable_inotify = 1 as libc::c_int != 0;\n        }\n        if !disable_inotify {\n            let mut wd: libc::c_int = inotify_init();\n            if 0 as libc::c_int <= wd {\n                if fflush_unlocked(stdout) != 0 as libc::c_int {\n                    write_error();\n                }\n                let mut ht: *mut Hash_table = 0 as *mut Hash_table;\n                tail_forever_inotify(wd, F, n_files, sleep_interval, &mut ht);\n                hash_free(ht);\n                close(wd);\n                *__errno_location() = 0 as libc::c_int;\n            }\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"inotify cannot be used, reverting to polling\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"inotify cannot be used, reverting to polling\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"inotify cannot be used, reverting to polling\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        disable_inotify = 1 as libc::c_int != 0;\n        tail_forever(F, n_files, sleep_interval);\n    }\n    if have_read_stdin as libc::c_int != 0 && close(0 as libc::c_int) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"-\\0\" as *const u8 as *const libc::c_char,\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    exit(if ok as libc::c_int != 0 { 0 as libc::c_int } else { 1 as libc::c_int });\n}\npub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "use ::libc;\npub type __time_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\npub type time_t = __time_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn make_timespec(mut s: time_t, mut ns: libc::c_long) -> timespec {\n    return {\n        let mut init = timespec { tv_sec: s, tv_nsec: ns };\n        init\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn timespec_cmp(mut a: timespec, mut b: timespec) -> libc::c_int {\n    return 2 as libc::c_int\n        * ((a.tv_sec > b.tv_sec) as libc::c_int - (a.tv_sec < b.tv_sec) as libc::c_int)\n        + ((a.tv_nsec > b.tv_nsec) as libc::c_int\n            - (a.tv_nsec < b.tv_nsec) as libc::c_int);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn timespec_sign(mut a: timespec) -> libc::c_int {\n    return (a.tv_sec > 0 as libc::c_int as libc::c_long) as libc::c_int\n        - (a.tv_sec < 0 as libc::c_int as libc::c_long) as libc::c_int\n        + ((a.tv_sec == 0) as libc::c_int & (a.tv_nsec != 0) as libc::c_int);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn timespectod(mut a: timespec) -> libc::c_double {\n    return a.tv_sec as libc::c_double + a.tv_nsec as libc::c_double / 1e9f64;\n}",
    "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
    "use ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn xset_binary_mode_error() {}\n#[inline]\nunsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}\n#[inline]\nunsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn xstrtoumax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut uintmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n}\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\npub const LONGINT_OK: strtol_error = 0;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\n#[no_mangle]\npub unsafe extern \"C\" fn xdectoumax(\n    mut n_str: *const libc::c_char,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    return xnumtoumax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnumtoumax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: uintmax_t = 0;\n    s_err = xstrtoumax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_ulong {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}",
    "use ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nunsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[inline]\nunsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[inline]\nunsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[cold]\n#[inline]\nunsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}\n#[inline]\nunsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\nunsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t",
    "                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    fn dtotimespec(_: libc::c_double) -> timespec;\n    fn rpl_nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn pause() -> libc::c_int;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\npub type __syscall_slong_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type time_t = __time_t;\n#[no_mangle]\npub unsafe extern \"C\" fn xnanosleep(mut seconds: libc::c_double) -> libc::c_int {\n    if 1.0f64\n        + (if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n            -(1 as libc::c_int) as time_t\n        } else {\n            (((1 as libc::c_int as time_t)\n                << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        }) as libc::c_double <= seconds\n    {\n        loop {\n            pause();\n            if !(*__errno_location() == 4 as libc::c_int) {\n                break;\n            }\n        }\n    }\n    let mut ts_sleep: timespec = dtotimespec(seconds);\n    loop {\n        *__errno_location() = 0 as libc::c_int;\n        if rpl_nanosleep(&mut ts_sleep, &mut ts_sleep) == 0 as libc::c_int {\n            break;\n        }\n        if *__errno_location() != 4 as libc::c_int\n            && *__errno_location() != 0 as libc::c_int\n        {\n            return -(1 as libc::c_int);\n        }\n    }\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrtod(\n    mut str: *const libc::c_char,\n    mut ptr: *mut *const libc::c_char,\n    mut result: *mut libc::c_double,\n    mut convert: Option::<\n        unsafe extern \"C\" fn(\n            *const libc::c_char,\n            *mut *mut libc::c_char,\n        ) -> libc::c_double,\n    >,\n) -> bool {\n    let mut val: libc::c_double = 0.;\n    let mut terminator: *mut libc::c_char = 0 as *mut libc::c_char;\nlet mut ok: bool = 1 as libc::c_int != 0;\n*__errno_location() = 0 as libc::c_int;\nval = convert.expect(\"non-null function pointer\")(str, &mut terminator);\nif terminator == str as *mut libc::c_char\n        || ptr.is_null() && *terminator as libc::c_int != '\\0' as i32\n    {\n        ok = 0 as libc::c_int != 0;\n    } else if val != 0 as libc::c_int as libc::c_double\n        && *__errno_location() == 34 as libc::c_int\n    {\n        ok = 0 as libc::c_int != 0;\n    }\nif !ptr.is_null() {\n        *ptr = terminator;\n    }\n*result = val;\nreturn ok;\n}",
    "use ::libc;\nextern \"C\" {\n    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtoumax(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __base: libc::c_int,\n    ) -> uintmax_t;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n}\npub type __uintmax_t = libc::c_ulong;\npub type uintmax_t = __uintmax_t;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub const _ISspace: C2RustUnnamed = 8192;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;\nunsafe extern \"C\" fn bkm_scale(\n    mut x: *mut uintmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: uintmax_t = 0;\n    if if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t\n        && (if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_ulong } else { *x })\n            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n            < 0 as libc::c_int as libc::c_ulong\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_ulong {\n                if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        -(1 as libc::c_int) as uintmax_t\n                    })\n                        .wrapping_add(scale_factor as libc::c_ulong)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    (*x\n                        < (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(scale_factor as libc::c_ulong)) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(-(1 as libc::c_int) as uintmax_t)\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(-scale_factor as libc::c_ulong)\n                    }) <= (-(1 as libc::c_int) as libc::c_ulong).wrapping_sub(*x))\n                        as libc::c_int\n                }\n            } else {\n                if (if (if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    !((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                }) < 0 as libc::c_int as libc::c_ulong\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                        < (if (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_ulong)\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            < 0 as libc::c_int as libc::c_ulong\n                        {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                << (::core::mem::size_of::<libc::c_ulong>()\n                                    as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        })\n                            .wrapping_neg()) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_ulong)\n                        < ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        *x\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (*x).wrapping_add(0 as libc::c_int as uintmax_t))\n                            as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong) < *x\n                            && (-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (*x).wrapping_sub(1 as libc::c_int as libc::c_ulong))\n                            as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }\n            }\n        } else {\n            if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_ulong {\n                    if (if (if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        !((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                    }) < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                            < (if (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    *x\n                                })\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                < 0 as libc::c_int as libc::c_ulong\n                            {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                    << (::core::mem::size_of::<libc::c_ulong>()\n                                        as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            })\n                                .wrapping_neg()) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_ulong\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_ulong)\n                                < (scale_factor as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_ulong)\n                                as libc::c_int\n                        }\n                    } else {\n                        ((0 as libc::c_int as uintmax_t).wrapping_div(*x)\n                            < scale_factor as libc::c_ulong) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_ulong {\n            !if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n                -(1 as libc::c_int) as uintmax_t\n            } else {\n                ((1 as libc::c_int as uintmax_t)\n                    << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            }\n        } else if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n            -(1 as libc::c_int) as uintmax_t\n        } else {\n            ((1 as libc::c_int as uintmax_t)\n                << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}\nunsafe extern \"C\" fn bkm_scale_by_power(\n    mut x: *mut uintmax_t,\n    mut base: libc::c_int,\n    mut power: libc::c_int,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    loop {\n        let fresh8 = power;\n        power = power - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);\n    }\n    return err;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn xstrtoumax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut uintmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: uintmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 79],\n                &[libc::c_char; 79],\n            >(\n                b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2256: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 79],\n                    &[libc::c_char; 79],\n                >(\n                    b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoumax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as uintmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if **p as libc::c_int != '\\0' as i32 {\n        let mut base: libc::c_int = 1024 as libc::c_int;\n        let mut suffixes: libc::c_int = 1 as libc::c_int;\n        let mut overflow: strtol_error = LONGINT_OK;\n        if (strchr(valid_suffixes, **p as libc::c_int)).is_null() {\n            *val = tmp;\n            return (err as libc::c_uint\n                | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                as strtol_error;\n        }\n        match **p as libc::c_int {\n            69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n                if !(strchr(valid_suffixes, '0' as i32)).is_null() {\n                    match *(*p.offset(0 as libc::c_int as isize))\n                        .offset(1 as libc::c_int as isize) as libc::c_int\n                    {\n                        105 => {\n                            if *(*p.offset(0 as libc::c_int as isize))\n                                .offset(2 as libc::c_int as isize) as libc::c_int\n                                == 'B' as i32\n                            {\n                                suffixes += 2 as libc::c_int;\n                            }\n                        }\n                        66 | 68 => {\n                            base = 1000 as libc::c_int;\n                            suffixes += 1;\n                            suffixes;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n            _ => {}\n        }\n        match **p as libc::c_int {\n            98 => {\n                overflow = bkm_scale(&mut tmp, 512 as libc::c_int);\n            }\n            66 => {\n                overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);\n            }\n            99 => {\n                overflow = LONGINT_OK;\n            }\n            69 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);\n            }\n            71 | 103 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);\n            }\n            107 | 75 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);\n            }\n            77 | 109 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);\n            }\n            80 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);\n            }\n            81 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);\n            }\n            82 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);\n            }\n            84 | 116 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);\n            }\n            119 => {\n                overflow = bkm_scale(&mut tmp, 2 as libc::c_int);\n            }\n            89 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);\n            }\n            90 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);\n            }\n            _ => {\n                *val = tmp;\n                return (err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                    as strtol_error;\n            }\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | overflow as libc::c_uint);\n        *p = (*p).offset(suffixes as isize);\n        if **p != 0 {\n            err = ::core::mem::transmute::<\n                libc::c_uint,\n                strtol_error,\n            >(\n                err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint,\n            );\n        }\n    }\n    *val = tmp;\n    return err;\n}"
  ],
  "truncate": [
    "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
    "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(label_break_value)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod close_stream;\npub mod closeout;\npub mod exitfail;\npub mod fclose;\npub mod fflush;\npub mod fseeko;\npub mod hard_locale;\npub mod ialloc;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalloc_die;\npub mod xdectoimax;\npub mod xmalloc;\npub mod xstrtoimax;\n}\n// mod src",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "use ::libc;\n#[inline]\nunsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nunsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "use ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;\npub const _NL_WAM_STR: C2RustUnnamed = 131162;\npub const _NL_WMON_12: C2RustUnnamed = 131161;\npub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nunsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}\nunsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}\nunsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;",
    "                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};",
    "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut, unused_imports)]\n#![feature(extern_types)]\nuse ::rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static mut optarg: *mut libc::c_char;\n    static mut optind: libc::c_int;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;\n    fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;\n    fn ftruncate(__fd: libc::c_int, __length: __off_t) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut Version: *const libc::c_char;\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn close_stdout();\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    static mut program_name: *const libc::c_char;\n    fn set_program_name(argv0: *const libc::c_char);\n    fn exit(_: libc::c_int) -> !;\n    fn atexit(__func: Option::<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn quote_n(n: libc::c_int, arg: *const libc::c_char) -> *const libc::c_char;\n    fn xdectoimax(\n        n_str: *const libc::c_char,\n        min: intmax_t,\n        max: intmax_t,\n        suffixes: *const libc::c_char,\n        err: *const libc::c_char,\n        err_exit: libc::c_int,\n    ) -> intmax_t;\n}\npub type __intmax_t = libc::c_long;\npub type __dev_t = libc::c_ulong;\npub type __uid_t = libc::c_uint;\npub type __gid_t = libc::c_uint;\npub type __ino_t = libc::c_ulong;\npub type __mode_t = libc::c_uint;\npub type __nlink_t = libc::c_uint;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type __time_t = libc::c_long;\npub type __blksize_t = libc::c_int;\npub type __blkcnt_t = libc::c_long;\npub type __syscall_slong_t = libc::c_long;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISspace: C2RustUnnamed = 8192;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;\npub type size_t = libc::c_ulong;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type ptrdiff_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct timespec {\n    pub tv_sec: __time_t,\n    pub tv_nsec: __syscall_slong_t,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct stat {\n    pub st_dev: __dev_t,\n    pub st_ino: __ino_t,\n    pub st_mode: __mode_t,\n    pub st_nlink: __nlink_t,\n    pub st_uid: __uid_t,\n    pub st_gid: __gid_t,\n    pub st_rdev: __dev_t,\n    pub __pad1: __dev_t,\n    pub st_size: __off_t,\n    pub st_blksize: __blksize_t,\n    pub __pad2: libc::c_int,\n    pub st_blocks: __blkcnt_t,\n    pub st_atim: timespec,\n    pub st_mtim: timespec,\n    pub st_ctim: timespec,\n    pub __glibc_reserved: [libc::c_int; 2],\n}\npub type intmax_t = __intmax_t;\npub type C2RustUnnamed_0 = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed_0 = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed_0 = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type rel_mode_t = libc::c_uint;\npub const rm_rup: rel_mode_t = 5;\npub const rm_rdn: rel_mode_t = 4;\npub const rm_max: rel_mode_t = 3;\npub const rm_min: rel_mode_t = 2;\npub const rm_rel: rel_mode_t = 1;\npub const rm_abs: rel_mode_t = 0;\n#[inline]\nunsafe extern \"C\" fn usable_st_size(mut sb: *const stat) -> bool {\n    return (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        || (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o120000 as libc::c_int as libc::c_uint\n        || ((*sb).st_mode).wrapping_sub((*sb).st_mode) != 0 || 0 as libc::c_int != 0;\n}\n#[inline]\nunsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}\n#[inline]\nunsafe extern \"C\" fn to_uchar(mut ch: libc::c_char) -> libc::c_uchar {\n    return ch as libc::c_uchar;\n}\n#[inline]\nunsafe extern \"C\" fn emit_mandatory_arg_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nMandatory arguments to long options are mandatory for short options too.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}\n#[inline]\nunsafe extern \"C\" fn emit_size_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\\nUnits are K,M,G,T,P,E,Z,Y,R,Q (powers of 1024) or KB,MB,... (powers of 1000).\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}\nstatic mut no_create: bool = false;\nstatic mut block_mode: bool = false;\nstatic mut ref_file: *const libc::c_char = 0 as *const libc::c_char;\nstatic mut longopts: [option; 7] = [\n    {\n        let mut init = option {\n            name: b\"no-create\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'c' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"io-blocks\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'o' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"reference\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'r' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"size\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 's' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];\n#[no_mangle]\npub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s OPTION... FILE...\\n\\0\" as *const u8 as *const libc::c_char,\n            ),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Shrink or extend the size of each FILE to the specified size\\n\\nA FILE argument that does not exist is created.\\n\\nIf a FILE is larger than the specified size, the extra data is lost.\\nIf a FILE is shorter, it is extended and the sparse extended part (hole)\\nreads as zero bytes.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_mandatory_arg_note();\n        fputs_unlocked(\n            gettext(\n                b\"  -c, --no-create        do not create any files\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -r, --reference=RFILE  base size on RFILE\\n  -s, --size=SIZE        set or adjust the file size by SIZE bytes\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_size_note();\n        fputs_unlocked(\n            gettext(\n                b\"\\nSIZE may also be prefixed by one of the following modifying characters:\\n'+' extend by, '-' reduce by, '<' at most, '>' at least,\\n'/' round down to multiple of, '%' round up to multiple of.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_ancillary_info(b\"truncate\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}",
    "unsafe extern \"C\" fn do_ftruncate(\n    mut fd: libc::c_int,\n    mut fname: *const libc::c_char,\n    mut ssize: off_t,\n    mut rsize: off_t,\n    mut rel_mode: rel_mode_t,\n) -> bool {\n    let mut sb: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut nsize: off_t = 0;\n    if (block_mode as libc::c_int != 0\n        || rel_mode as libc::c_uint != 0 && rsize < 0 as libc::c_int as libc::c_long)\n        && fstat(fd, &mut sb) != 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, fname),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    if block_mode {\n        let mut blksize: ptrdiff_t = (if (0 as libc::c_int) < sb.st_blksize\n            && sb.st_blksize as libc::c_ulong\n                <= (-(1 as libc::c_int) as size_t)\n                    .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        {\n            sb.st_blksize\n        } else {\n            512 as libc::c_int\n        }) as ptrdiff_t;\n        let mut ssize0: intmax_t = ssize;\n        if if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t\n            && ((if 1 as libc::c_int != 0 {\n                0 as libc::c_int as libc::c_long\n            } else {\n                ssize\n            }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n            && ((if 1 as libc::c_int != 0 {\n                0 as libc::c_int as libc::c_long\n            } else {\n                blksize\n            }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n            && (if blksize < 0 as libc::c_int as libc::c_long {\n                if ssize < 0 as libc::c_int as libc::c_long {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            -(1 as libc::c_int) as off_t\n                        }) + blksize\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        (ssize < -(1 as libc::c_int) as off_t / blksize) as libc::c_int\n                    } else {\n                        ((if (if (if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            blksize\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            !(((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<ptrdiff_t>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as libc::c_long\n                        }) < 0 as libc::c_int as libc::c_long\n                        {\n                            (blksize\n                                < -(if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    blksize\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<ptrdiff_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) - 1 as libc::c_int as libc::c_long\n                                })) as libc::c_int\n                        } else {\n                            ((0 as libc::c_int as libc::c_long) < blksize) as libc::c_int\n                        }) != 0\n                        {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + -(1 as libc::c_int) as off_t\n                                >> (::core::mem::size_of::<ptrdiff_t>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        } else {\n                            -(1 as libc::c_int) as off_t / -blksize\n                        }) <= -(1 as libc::c_int) as libc::c_long - ssize) as libc::c_int\n                    }\n                } else {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            blksize\n                        }) + 0 as libc::c_int as off_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as off_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as off_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            blksize\n                        }) + 0 as libc::c_int as off_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    blksize\n                                }) + 0 as libc::c_int as off_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) + 0 as libc::c_int as off_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) + 0 as libc::c_int as off_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as off_t) as libc::c_int\n                    }) != 0 && blksize == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            ssize\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < ssize + 0 as libc::c_int as off_t) as libc::c_int\n                        } else {\n                            ((0 as libc::c_int as libc::c_long) < ssize\n                                && (-(1 as libc::c_int) as libc::c_long\n                                    - 0 as libc::c_int as off_t)\n                                    < ssize - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as off_t / blksize < ssize) as libc::c_int\n                    }\n                }\n            } else {\n                if blksize == 0 as libc::c_int as libc::c_long {\n                    0 as libc::c_int\n                } else {\n                    if ssize < 0 as libc::c_int as libc::c_long {\n                        if (if (if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                ssize\n                            }) + 0 as libc::c_int as off_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            !(((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    ssize\n                                }) + 0 as libc::c_int as off_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    ssize\n                                }) + 0 as libc::c_int as off_t\n                            }) + 0 as libc::c_int as libc::c_long\n                        }) < 0 as libc::c_int as libc::c_long\n                        {\n                            (((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                ssize\n                            }) + 0 as libc::c_int as off_t)\n                                < -(if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        ssize\n                                    }) + 0 as libc::c_int as off_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            ssize\n                                        }) + 0 as libc::c_int as off_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            ssize\n                                        }) + 0 as libc::c_int as off_t\n                                    }) - 1 as libc::c_int as libc::c_long\n                                })) as libc::c_int\n                        } else {\n                            ((0 as libc::c_int as libc::c_long)\n                                < (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    ssize\n                                }) + 0 as libc::c_int as off_t) as libc::c_int\n                        }) != 0 && ssize == -(1 as libc::c_int) as libc::c_long\n                        {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < blksize + 0 as libc::c_int as off_t) as libc::c_int\n                            } else {\n                                ((-(1 as libc::c_int) as libc::c_long\n                                    - 0 as libc::c_int as off_t)\n                                    < blksize - 1 as libc::c_int as libc::c_long) as libc::c_int\n                            }\n                        } else {\n                            (0 as libc::c_int as off_t / ssize < blksize) as libc::c_int\n                        }\n                    } else {\n                        (-(1 as libc::c_int) as off_t / blksize < ssize) as libc::c_int\n                    }\n                }\n            }) != 0\n        {\n            let (fresh4, _fresh5) = ssize.overflowing_mul(blksize);\n            *(&mut ssize as *mut off_t) = fresh4;\n            1 as libc::c_int\n        } else {\n            let (fresh6, fresh7) = ssize.overflowing_mul(blksize);\n            *(&mut ssize as *mut off_t) = fresh6;\n            fresh7 as libc::c_int\n        } != 0\n        {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"overflow in %jd * %td byte blocks for file %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    ssize0,\n                    blksize,\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"overflow in %jd * %td byte blocks for file %s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        ssize0,\n                        blksize,\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"overflow in %jd * %td byte blocks for file %s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        ssize0,\n                        blksize,\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n    }\n    if rel_mode as u64 != 0 {\n        let mut fsize: off_t = 0;\n        if 0 as libc::c_int as libc::c_long <= rsize {\n            fsize = rsize;\n        } else if usable_st_size(&mut sb) {\n            fsize = sb.st_size;\n            if fsize < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has unusable, apparently negative size\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s has unusable, apparently negative size\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {",
    "                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s has unusable, apparently negative size\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                return 0 as libc::c_int != 0;\n            }\n        } else {\n            fsize = lseek(fd, 0 as libc::c_int as __off_t, 2 as libc::c_int);\n            if fsize < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot get the size of %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot get the size of %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot get the size of %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                return 0 as libc::c_int != 0;\n            }\n        }\n        if rel_mode as libc::c_uint == rm_min as libc::c_int as libc::c_uint {\n            nsize = if fsize > ssize { fsize } else { ssize };\n        } else if rel_mode as libc::c_uint == rm_max as libc::c_int as libc::c_uint {\n            nsize = if fsize < ssize { fsize } else { ssize };\n        } else if rel_mode as libc::c_uint == rm_rdn as libc::c_int as libc::c_uint {\n            nsize = fsize - fsize % ssize;\n        } else {\n            if rel_mode as libc::c_uint == rm_rup as libc::c_int as libc::c_uint {\n                let mut r: off_t = fsize % ssize;\n                ssize = if r == 0 as libc::c_int as libc::c_long {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    ssize - r\n                };\n            }\n            let (fresh8, fresh9) = fsize.overflowing_add(ssize);\n            *(&mut nsize as *mut off_t) = fresh8;\n            if fresh9 {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"overflow extending size of file %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"overflow extending size of file %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"overflow extending size of file %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                return 0 as libc::c_int != 0;\n            }\n        }\n    } else {\n        nsize = ssize;\n    }\n    if nsize < 0 as libc::c_int as libc::c_long {\n        nsize = 0 as libc::c_int as off_t;\n    }\n    if ftruncate(fd, nsize) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"failed to truncate %s at %jd bytes\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, fname),\n                nsize,\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to truncate %s at %jd bytes\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                    nsize,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to truncate %s at %jd bytes\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                    nsize,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    return 1 as libc::c_int != 0;\n}",
    "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut got_size: bool = 0 as libc::c_int != 0;\n    let mut size: off_t = 0 as libc::c_int as off_t;\n    let mut rsize: off_t = -(1 as libc::c_int) as off_t;\n    let mut rel_mode: rel_mode_t = rm_abs;\n    let mut c: libc::c_int = 0;\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    loop {\n        c = getopt_long(\n            argc,\n            argv,\n            b\"cor:s:\\0\" as *const u8 as *const libc::c_char,\n            longopts.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if !(c != -(1 as libc::c_int)) {\n            break;\n        }\n        match c {\n            99 => {\n                no_create = 1 as libc::c_int != 0;\n            }\n            111 => {\n                block_mode = 1 as libc::c_int != 0;\n            }\n            114 => {\n                ref_file = optarg;\n            }\n            115 => {\n                while *(*__ctype_b_loc())\n                    .offset(to_uchar(*optarg) as libc::c_int as isize) as libc::c_int\n                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n                {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                match *optarg as libc::c_int {\n                    60 => {\n                        rel_mode = rm_max;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    62 => {\n                        rel_mode = rm_min;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    47 => {\n                        rel_mode = rm_rdn;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    37 => {\n                        rel_mode = rm_rup;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    _ => {}\n                }\n                while *(*__ctype_b_loc())\n                    .offset(to_uchar(*optarg) as libc::c_int as isize) as libc::c_int\n                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n                {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                if *optarg as libc::c_int == '+' as i32\n                    || *optarg as libc::c_int == '-' as i32\n                {\n                    if rel_mode as u64 != 0 {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"multiple relative modifiers specified\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"multiple relative modifiers specified\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"multiple relative modifiers specified\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                        usage(1 as libc::c_int);\n                    }\n                    rel_mode = rm_rel;\n                }\n                size = xdectoimax(\n                    optarg,\n                    !if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                        -(1 as libc::c_int) as off_t\n                    } else {\n                        (((1 as libc::c_int as off_t)\n                            << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long\n                    },\n                    if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                        -(1 as libc::c_int) as off_t\n                    } else {\n                        (((1 as libc::c_int as off_t)\n                            << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long\n                    },\n                    b\"EgGkKmMPQRtTYZ0\\0\" as *const u8 as *const libc::c_char,\n                    gettext(b\"Invalid number\\0\" as *const u8 as *const libc::c_char),\n                    0 as libc::c_int,\n                );\n                if (rel_mode as libc::c_uint == rm_rup as libc::c_int as libc::c_uint\n                    || rel_mode as libc::c_uint == rm_rdn as libc::c_int as libc::c_uint)\n                    && size == 0 as libc::c_int as libc::c_long\n                {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"division by zero\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"division by zero\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"division by zero\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                got_size = 1 as libc::c_int != 0;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n            }\n            -3 => {\n                version_etc(\n                    stdout,\n                    b\"truncate\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Padraig Brady\\0\" as *const u8 as *const libc::c_char,\n                        b\"P\\xC3\\xA1draig Brady\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);\n            }\n            _ => {\n                usage(1 as libc::c_int);\n            }\n        }\n    }\n    argv = argv.offset(optind as isize);\n    argc -= optind;\n    if ref_file.is_null() && !got_size {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"you must specify either %s or %s\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quote_n(\n                    0 as libc::c_int,\n                    b\"--size\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote_n(\n                    1 as libc::c_int,\n                    b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify either %s or %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify either %s or %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if !ref_file.is_null() && got_size as libc::c_int != 0 && rel_mode as u64 == 0 {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"you must specify a relative %s with %s\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quote_n(\n                    0 as libc::c_int,\n                    b\"--size\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote_n(\n                    1 as libc::c_int,\n                    b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify a relative %s with %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify a relative %s with %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if block_mode as libc::c_int != 0 && !got_size {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s was specified but %s was not\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quote_n(\n                    0 as libc::c_int,\n                    b\"--io-blocks\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote_n(\n                    1 as libc::c_int,\n                    b\"--size\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s was specified but %s was not\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--io-blocks\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s was specified but %s was not\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--io-blocks\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if argc < 1 as libc::c_int {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(b\"missing file operand\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"missing file operand\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"missing file operand\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if !ref_file.is_null() {\n        let mut sb: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },",
    "            __glibc_reserved: [0; 2],\n        };\n        let mut file_size: off_t = -(1 as libc::c_int) as off_t;\n        if stat(ref_file, &mut sb) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"cannot stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, ref_file),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(b\"cannot stat %s\\0\" as *const u8 as *const libc::c_char),\n                        quotearg_style(shell_escape_always_quoting_style, ref_file),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(b\"cannot stat %s\\0\" as *const u8 as *const libc::c_char),\n                        quotearg_style(shell_escape_always_quoting_style, ref_file),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if usable_st_size(&mut sb) {\n            file_size = sb.st_size;\n        } else {\n            let mut ref_fd: libc::c_int = open(ref_file, 0 as libc::c_int);\n            if 0 as libc::c_int <= ref_fd {\n                let mut file_end: off_t = lseek(\n                    ref_fd,\n                    0 as libc::c_int as __off_t,\n                    2 as libc::c_int,\n                );\n                let mut saved_errno: libc::c_int = *__errno_location();\n                close(ref_fd);\n                if 0 as libc::c_int as libc::c_long <= file_end {\n                    file_size = file_end;\n                } else {\n                    *__errno_location() = saved_errno;\n                }\n            }\n        }\n        if file_size < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot get the size of %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, ref_file),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot get the size of %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, ref_file),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot get the size of %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, ref_file),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if !got_size {\n            size = file_size;\n        } else {\n            rsize = file_size;\n        }\n    }\n    let mut oflags: libc::c_int = 0o1 as libc::c_int\n        | (if no_create as libc::c_int != 0 {\n            0 as libc::c_int\n        } else {\n            0o100 as libc::c_int\n        }) | 0o4000 as libc::c_int;\n    let mut errors: bool = 0 as libc::c_int != 0;\n    let mut fname: *const libc::c_char = 0 as *const libc::c_char;\n    loop {\n        fname = *argv;\n        if fname.is_null() {\n            break;\n        }\n        let mut fd: libc::c_int = open(\n            fname,\n            oflags,\n            0o400 as libc::c_int | 0o200 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int,\n        );\n        if fd < 0 as libc::c_int {\n            if !(no_create as libc::c_int != 0\n                && *__errno_location() == 2 as libc::c_int)\n            {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot open %s for writing\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot open %s for writing\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot open %s for writing\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                errors = 1 as libc::c_int != 0;\n            }\n        } else {\n            errors = (errors as libc::c_int\n                | !do_ftruncate(fd, fname, size, rsize, rel_mode) as libc::c_int) != 0;\n            if close(fd) != 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to close %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to close %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to close %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                errors = 1 as libc::c_int != 0;\n            }\n        }\n        argv = argv.offset(1);\n        argv;\n    }\n    return if errors as libc::c_int != 0 { 1 as libc::c_int } else { 0 as libc::c_int };\n}\npub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
    "use ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "use ::libc;\nextern \"C\" {\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn xstrtoimax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut intmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n}\npub type __intmax_t = libc::c_long;\npub type intmax_t = __intmax_t;\npub const LONGINT_OK: strtol_error = 0;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\n#[no_mangle]\npub unsafe extern \"C\" fn xnumtoimax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: intmax_t = 0;\n    s_err = xstrtoimax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_long {\n                *__errno_location() = 75 as libc::c_int;\n            } else if tnum\n                < ((-(2147483647 as libc::c_int) - 1 as libc::c_int) / 2 as libc::c_int)\n                    as libc::c_long\n            {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xdectoimax(\n    mut n_str: *const libc::c_char,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    return xnumtoimax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}",
    "use ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nunsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[inline]\nunsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[inline]\nunsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[cold]\n#[inline]\nunsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}\n#[inline]\nunsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\nunsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t",
    "                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtoimax(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __base: libc::c_int,\n    ) -> intmax_t;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n}\npub type __intmax_t = libc::c_long;\npub type intmax_t = __intmax_t;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub const _ISspace: C2RustUnnamed = 8192;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;\nunsafe extern \"C\" fn bkm_scale(\n    mut x: *mut intmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: intmax_t = 0;\n    if if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { *x })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as intmax_t\n                    }) + scale_factor as libc::c_long\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (*x < -(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + -(1 as libc::c_int) as intmax_t\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as intmax_t / -scale_factor as libc::c_long\n                    }) <= -(1 as libc::c_int) as libc::c_long - *x) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n                        as libc::c_long + 0 as libc::c_int as intmax_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        *x\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < *x + 0 as libc::c_int as intmax_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < *x\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < *x - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as intmax_t / scale_factor as libc::c_long) < *x)\n                        as libc::c_int\n                }\n            }\n        } else {\n            if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    *x\n                                }) + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < scale_factor as libc::c_long\n                                    + 0 as libc::c_int as intmax_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_long)\n                                as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as intmax_t / *x\n                            < scale_factor as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        < *x) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_long {\n            !if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n                -(1 as libc::c_int) as intmax_t\n            } else {\n                (((1 as libc::c_int as intmax_t)\n                    << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            }\n        } else if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n            -(1 as libc::c_int) as intmax_t\n        } else {\n            (((1 as libc::c_int as intmax_t)\n                << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}\nunsafe extern \"C\" fn bkm_scale_by_power(\n    mut x: *mut intmax_t,\n    mut base: libc::c_int,\n    mut power: libc::c_int,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    loop {\n        let fresh8 = power;\n        power = power - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);\n    }\n    return err;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn xstrtoimax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut intmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: intmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 78],\n                &[libc::c_char; 78],\n            >(\n                b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2247: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 78],\n                    &[libc::c_char; 78],\n                >(\n                    b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoimax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as intmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if **p as libc::c_int != '\\0' as i32 {\n        let mut base: libc::c_int = 1024 as libc::c_int;\n        let mut suffixes: libc::c_int = 1 as libc::c_int;\n        let mut overflow: strtol_error = LONGINT_OK;\n        if (strchr(valid_suffixes, **p as libc::c_int)).is_null() {\n            *val = tmp;\n            return (err as libc::c_uint\n                | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                as strtol_error;\n        }\n        match **p as libc::c_int {\n            69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n                if !(strchr(valid_suffixes, '0' as i32)).is_null() {\n                    match *(*p.offset(0 as libc::c_int as isize))\n                        .offset(1 as libc::c_int as isize) as libc::c_int\n                    {\n                        105 => {\n                            if *(*p.offset(0 as libc::c_int as isize))\n                                .offset(2 as libc::c_int as isize) as libc::c_int\n                                == 'B' as i32\n                            {\n                                suffixes += 2 as libc::c_int;\n                            }\n                        }\n                        66 | 68 => {\n                            base = 1000 as libc::c_int;\n                            suffixes += 1;\n                            suffixes;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n            _ => {}\n        }\n        match **p as libc::c_int {\n            98 => {\n                overflow = bkm_scale(&mut tmp, 512 as libc::c_int);\n            }\n            66 => {\n                overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);\n            }\n            99 => {\n                overflow = LONGINT_OK;\n            }\n            69 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);\n            }\n            71 | 103 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);\n            }\n            107 | 75 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);\n            }\n            77 | 109 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);\n            }\n            80 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);\n            }\n            81 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);\n            }\n            82 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);\n            }\n            84 | 116 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);\n            }\n            119 => {\n                overflow = bkm_scale(&mut tmp, 2 as libc::c_int);\n            }\n            89 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);\n            }\n            90 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);\n            }\n            _ => {\n                *val = tmp;\n                return (err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                    as strtol_error;\n            }\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | overflow as libc::c_uint);\n        *p = (*p).offset(suffixes as isize);\n        if **p != 0 {\n            err = ::core::mem::transmute::<\n                libc::c_uint,\n                strtol_error,\n            >(\n                err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint,\n            );\n        }\n    }\n    *val = tmp;\n    return err;\n}"
  ],
  "uniq": [
    "#[cfg(all(unix, not(target_os = \"macos\")))]\nfn main() {\n    // add unix dependencies below\n    // println!(\"cargo:rustc-flags=-l readline\");\n}\n#[cfg(target_os = \"macos\")]\nfn main() {\n    // add macos dependencies below\n    // println!(\"cargo:rustc-flags=-l edit\");\n}",
    "#![allow(dead_code)]\n#![allow(mutable_transmutes)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n#![allow(unused_assignments)]\n#![allow(unused_mut)]\n#![feature(c_variadic)]\n#![feature(extern_types)]\n#![feature(label_break_value)]\n#![feature(linkage)]\nextern crate libc;\npub mod src {\npub mod argmatch;\npub mod c32isblank;\npub mod c32isprint;\npub mod c_ctype;\npub mod c_strcasecmp;\npub mod close_stream;\npub mod closeout;\npub mod exitfail;\npub mod fadvise;\npub mod fclose;\npub mod fflush;\npub mod fpurge;\npub mod freopen_safer;\npub mod fseeko;\npub mod hard_locale;\npub mod ialloc;\npub mod linebuffer;\npub mod localcharset;\npub mod mbrtoc32;\npub mod mbszero;\npub mod mcel;\npub mod memcasecmp;\npub mod posixver;\npub mod progname;\npub mod propername_lite;\npub mod quotearg;\npub mod setlocale_null;\npub mod setlocale_null_unlocked;\npub mod skipchars;\npub mod version;\npub mod version_etc;\npub mod version_etc_fsf;\npub mod xalloc_die;\npub mod xmalloc;\npub mod xstrtoimax;\n}\n// mod src",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stderr: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn putc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn quote_n(n: libc::c_int, arg: *const libc::c_char) -> *const libc::c_char;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn quotearg_n_style(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn usage(_e: libc::c_int);\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type argmatch_exit_fn = Option::<unsafe extern \"C\" fn() -> ()>\n;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\nunsafe extern \"C\" fn __argmatch_die() {\n    usage(1 as libc::c_int);\n}\n#[no_mangle]\npub static mut argmatch_die: argmatch_exit_fn = unsafe {\n    Some(__argmatch_die as unsafe extern \"C\" fn() -> ())\n};\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch(\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) -> ptrdiff_t {\n    let mut i: size_t = 0;\n    let mut arglen: size_t = 0;\n    let mut matchind: ptrdiff_t = -(1 as libc::c_int) as ptrdiff_t;\n    let mut ambiguous: bool = 0 as libc::c_int != 0;\n    arglen = strlen(arg);\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if strncmp(*arglist.offset(i as isize), arg, arglen) == 0 {\n            if strlen(*arglist.offset(i as isize)) == arglen {\n                return i as ptrdiff_t\n            } else if matchind == -(1 as libc::c_int) as libc::c_long {\n                matchind = i as ptrdiff_t;\n            } else if vallist.is_null()\n                || memcmp(\n                    (vallist as *const libc::c_char)\n                        .offset(valsize.wrapping_mul(matchind as libc::c_ulong) as isize)\n                        as *const libc::c_void,\n                    (vallist as *const libc::c_char)\n                        .offset(valsize.wrapping_mul(i) as isize) as *const libc::c_void,\n                    valsize,\n                ) != 0\n            {\n                ambiguous = 1 as libc::c_int != 0;\n            }\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    if ambiguous { return -(2 as libc::c_int) as ptrdiff_t } else { return matchind };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch_exact(\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n) -> ptrdiff_t {\n    let mut i: size_t = 0;\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if strcmp(*arglist.offset(i as isize), arg) == 0 {\n            return i as ptrdiff_t;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return -(1 as libc::c_int) as ptrdiff_t;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch_invalid(\n    mut context: *const libc::c_char,\n    mut value: *const libc::c_char,\n    mut problem: ptrdiff_t,\n) {\n    let mut format: *const libc::c_char = if problem\n        == -(1 as libc::c_int) as libc::c_long\n    {\n        gettext(b\"invalid argument %s for %s\\0\" as *const u8 as *const libc::c_char)\n    } else {\n        gettext(b\"ambiguous argument %s for %s\\0\" as *const u8 as *const libc::c_char)\n    };\n    if 0 != 0 {\n        error(\n            0 as libc::c_int,\n            0 as libc::c_int,\n            format,\n            quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n            quote_n(1 as libc::c_int, context),\n        );\n        if 0 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 0 as libc::c_int;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                format,\n                quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n                quote_n(1 as libc::c_int, context),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 0 as libc::c_int;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                format,\n                quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n                quote_n(1 as libc::c_int, context),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch_valid(\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) {\n    let mut i: size_t = 0;\n    let mut last_val: *const libc::c_char = 0 as *const libc::c_char;\n    fputs_unlocked(\n        gettext(b\"Valid arguments are:\\0\" as *const u8 as *const libc::c_char),\n        stderr,\n    );\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if i == 0 as libc::c_int as libc::c_ulong\n            || memcmp(\n                last_val as *const libc::c_void,\n                (vallist as *const libc::c_char).offset(valsize.wrapping_mul(i) as isize)\n                    as *const libc::c_void,\n                valsize,\n            ) != 0\n        {\n            fprintf(\n                stderr,\n                b\"\\n  - %s\\0\" as *const u8 as *const libc::c_char,\n                quote(*arglist.offset(i as isize)),\n            );\n            last_val = (vallist as *const libc::c_char)\n                .offset(valsize.wrapping_mul(i) as isize);\n        } else {\n            fprintf(\n                stderr,\n                b\", %s\\0\" as *const u8 as *const libc::c_char,\n                quote(*arglist.offset(i as isize)),\n            );\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    putc_unlocked('\\n' as i32, stderr);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn __xargmatch_internal(\n    mut context: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n    mut exit_fn: argmatch_exit_fn,\n    mut allow_abbreviation: bool,\n) -> ptrdiff_t {\n    let mut res: ptrdiff_t = 0;\n    if allow_abbreviation {\n        res = argmatch(arg, arglist, vallist, valsize);\n    } else {\n        res = argmatch_exact(arg, arglist);\n    }\n    if res >= 0 as libc::c_int as libc::c_long {\n        return res;\n    }\n    argmatch_invalid(context, arg, res);\n    argmatch_valid(arglist, vallist, valsize);\n    (Some(exit_fn.expect(\"non-null function pointer\")))\n        .expect(\"non-null function pointer\")();\n    return -(1 as libc::c_int) as ptrdiff_t;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn argmatch_to_argument(\n    mut value: *const libc::c_void,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) -> *const libc::c_char {\n    let mut i: size_t = 0;\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if memcmp(\n            value,\n            (vallist as *const libc::c_char).offset(valsize.wrapping_mul(i) as isize)\n                as *const libc::c_void,\n            valsize,\n        ) == 0\n        {\n            return *arglist.offset(i as isize);\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as *const libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __errno_location() -> *mut libc::c_int;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn _exit(_: libc::c_int) -> !;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn close_stream(stream: *mut FILE) -> libc::c_int;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn quotearg_colon(arg: *const libc::c_char) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\npub const SANITIZE_ADDRESS: C2RustUnnamed = 0;\npub type C2RustUnnamed = libc::c_uint;\nstatic mut file_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}\nstatic mut ignore_EPIPE: bool = false;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn __fpending(__fp: *mut FILE) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "use ::libc;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "use ::libc;\n#[inline]\nunsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "use ::libc;\n#[no_mangle]\npub static mut exit_failure: libc::c_int = 1 as libc::c_int;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn posix_fadvise(\n        __fd: libc::c_int,\n        __offset: off_t,\n        __len: off_t,\n        __advise: libc::c_int,\n    ) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\npub type fadvice_t = libc::c_uint;\npub const FADVISE_RANDOM: fadvice_t = 1;\npub const FADVISE_WILLNEED: fadvice_t = 3;\npub const FADVISE_DONTNEED: fadvice_t = 4;\npub const FADVISE_NOREUSE: fadvice_t = 5;\npub const FADVISE_SEQUENTIAL: fadvice_t = 2;\npub const FADVISE_NORMAL: fadvice_t = 0;\n#[no_mangle]\npub unsafe extern \"C\" fn fdadvise(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut len: off_t,\n    mut advice: fadvice_t,\n) {\n    posix_fadvise(fd, offset, len, advice as libc::c_int);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn fadvise(mut fp: *mut FILE, mut advice: fadvice_t) {\n    if !fp.is_null() {\n        fdadvise(\n            fileno(fp),\n            0 as libc::c_int as off_t,\n            0 as libc::c_int as off_t,\n            advice,\n        );\n    }\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fclose(__stream: *mut FILE) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fflush(gl_stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fflush(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fseeko(fp: *mut FILE, offset: off_t, whence: libc::c_int) -> libc::c_int;\n    fn __freading(__fp: *mut FILE) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\nunsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn __fpurge(__fp: *mut FILE);\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\n#[no_mangle]\npub unsafe extern \"C\" fn fpurge(mut fp: *mut FILE) -> libc::c_int {\n    __fpurge(fp);\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn freopen(\n        __filename: *const libc::c_char,\n        __modes: *const libc::c_char,\n        __stream: *mut FILE,\n    ) -> *mut FILE;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn __errno_location() -> *mut libc::c_int;\n    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;\n    fn close(__fd: libc::c_int) -> libc::c_int;\n    fn dup2(__fd: libc::c_int, __fd2: libc::c_int) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\nunsafe extern \"C\" fn protect_fd(mut fd: libc::c_int) -> bool {\n    let mut value: libc::c_int = open(\n        b\"/dev/null\\0\" as *const u8 as *const libc::c_char,\n        0 as libc::c_int,\n    );\n    if value != fd {\n        if 0 as libc::c_int <= value {\n            close(value);\n            *__errno_location() = 9 as libc::c_int;\n        }\n        return 0 as libc::c_int != 0;\n    }\n    return 1 as libc::c_int != 0;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn freopen_safer(\n    mut name: *const libc::c_char,\n    mut mode: *const libc::c_char,\n    mut f: *mut FILE,\n) -> *mut FILE {\n    let mut protect_in: bool = 0 as libc::c_int != 0;\n    let mut protect_out: bool = 0 as libc::c_int != 0;\n    let mut protect_err: bool = 0 as libc::c_int != 0;\n    let mut saved_errno: libc::c_int = 0;\n    let mut current_block_8: u64;\n    match fileno(f) {\n        2 => {\n            current_block_8 = 8409498848974359248;\n        }\n        1 => {\n            current_block_8 = 878006807312935268;\n        }\n        0 => {\n            current_block_8 = 2868539653012386629;\n        }\n        _ => {\n            if dup2(2 as libc::c_int, 2 as libc::c_int) != 2 as libc::c_int {\n                protect_err = 1 as libc::c_int != 0;\n            }\n            current_block_8 = 8409498848974359248;\n        }\n    }\n    match current_block_8 {\n        8409498848974359248 => {\n            if dup2(1 as libc::c_int, 1 as libc::c_int) != 1 as libc::c_int {\n                protect_out = 1 as libc::c_int != 0;\n            }\n            current_block_8 = 878006807312935268;\n        }\n        _ => {}\n    }\n    match current_block_8 {\n        878006807312935268 => {\n            if dup2(0 as libc::c_int, 0 as libc::c_int) != 0 as libc::c_int {\n                protect_in = 1 as libc::c_int != 0;\n            }\n        }\n        _ => {}\n    }\n    if protect_in as libc::c_int != 0 && !protect_fd(0 as libc::c_int) {\n        f = 0 as *mut FILE;\n    } else if protect_out as libc::c_int != 0 && !protect_fd(1 as libc::c_int) {\n        f = 0 as *mut FILE;\n    } else if protect_err as libc::c_int != 0 && !protect_fd(2 as libc::c_int) {\n        f = 0 as *mut FILE;\n    } else {\n        f = freopen(name, mode, f);\n    }\n    saved_errno = *__errno_location();\n    if protect_err {\n        close(2 as libc::c_int);\n    }\n    if protect_out {\n        close(1 as libc::c_int);\n    }\n    if protect_in {\n        close(0 as libc::c_int);\n    }\n    if f.is_null() {\n        *__errno_location() = saved_errno;\n    }\n    return f;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;\n    fn fileno(__stream: *mut FILE) -> libc::c_int;\n    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type off_t = __off_t;\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "use ::libc;\nextern \"C\" {\n    fn __errno_location() -> *mut libc::c_int;\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\n#[no_mangle]\n#[cold]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    fn getc_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn feof_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn free(_: *mut libc::c_void);\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n}\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type ptrdiff_t = libc::c_long;\npub type idx_t = ptrdiff_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct linebuffer {\n    pub size: idx_t,\n    pub length: idx_t,\n    pub buffer: *mut libc::c_char,\n}\n#[no_mangle]\npub unsafe extern \"C\" fn initbuffer(mut linebuffer: *mut linebuffer) {\n    memset(\n        linebuffer as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<linebuffer>() as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn readlinebuffer(\n    mut linebuffer: *mut linebuffer,\n    mut stream: *mut FILE,\n) -> *mut linebuffer {\n    return readlinebuffer_delim(linebuffer, stream, '\\n' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn readlinebuffer_delim(\n    mut linebuffer: *mut linebuffer,\n    mut stream: *mut FILE,\n    mut delimiter: libc::c_char,\n) -> *mut linebuffer {\n    let mut c: libc::c_int = 0;\n    let mut buffer: *mut libc::c_char = (*linebuffer).buffer;\n    let mut p: *mut libc::c_char = (*linebuffer).buffer;\n    let mut end: *mut libc::c_char = buffer.offset((*linebuffer).size as isize);\n    if feof_unlocked(stream) != 0 {\n        return 0 as *mut linebuffer;\n    }\n    loop {\n        c = getc_unlocked(stream);\n        if c == -(1 as libc::c_int) {\n            if p == buffer || ferror_unlocked(stream) != 0 {\n                return 0 as *mut linebuffer;\n            }\n            if *p.offset(-(1 as libc::c_int) as isize) as libc::c_int\n                == delimiter as libc::c_int\n            {\n                break;\n            }\n            c = delimiter as libc::c_int;\n        }\n        if p == end {\n            let mut oldsize: idx_t = (*linebuffer).size;\n            buffer = xpalloc(\n                buffer as *mut libc::c_void,\n                &mut (*linebuffer).size,\n                1 as libc::c_int as idx_t,\n                -(1 as libc::c_int) as ptrdiff_t,\n                1 as libc::c_int as idx_t,\n            ) as *mut libc::c_char;\n            p = buffer.offset(oldsize as isize);\n            (*linebuffer).buffer = buffer;\n            end = buffer.offset((*linebuffer).size as isize);\n        }\n        let fresh0 = p;\n        p = p.offset(1);\n        *fresh0 = c as libc::c_char;\n        if !(c != delimiter as libc::c_int) {\n            break;\n        }\n    }\n    (*linebuffer).length = p.offset_from(buffer) as libc::c_long;\n    return linebuffer;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn freebuffer(mut linebuffer: *mut linebuffer) {\n    free((*linebuffer).buffer as *mut libc::c_void);\n}",
    "use ::libc;\nextern \"C\" {\n    fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;\n}\npub const CODESET: C2RustUnnamed = 14;\npub type nl_item = libc::c_int;\npub type C2RustUnnamed = libc::c_uint;\npub const _NL_NUM: C2RustUnnamed = 786449;\npub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed = 786448;\npub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed = 786447;\npub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed = 786446;\npub const _NL_IDENTIFICATION_DATE: C2RustUnnamed = 786445;\npub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed = 786444;\npub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed = 786443;\npub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed = 786442;\npub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed = 786441;\npub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed = 786440;\npub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed = 786439;\npub const _NL_IDENTIFICATION_FAX: C2RustUnnamed = 786438;\npub const _NL_IDENTIFICATION_TEL: C2RustUnnamed = 786437;\npub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed = 786436;\npub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed = 786435;\npub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed = 786434;\npub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed = 786433;\npub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed = 786432;\npub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed = 720898;\npub const _NL_MEASUREMENT_CODESET: C2RustUnnamed = 720897;\npub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed = 720896;\npub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed = 655365;\npub const _NL_TELEPHONE_CODESET: C2RustUnnamed = 655364;\npub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed = 655363;\npub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed = 655362;\npub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed = 655361;\npub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed = 655360;\npub const _NL_NUM_LC_ADDRESS: C2RustUnnamed = 589837;\npub const _NL_ADDRESS_CODESET: C2RustUnnamed = 589836;\npub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed = 589835;\npub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed = 589834;\npub const _NL_ADDRESS_LANG_AB: C2RustUnnamed = 589833;\npub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed = 589832;\npub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed = 589831;\npub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed = 589830;\npub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed = 589829;\npub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed = 589828;\npub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed = 589827;\npub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed = 589826;\npub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed = 589825;\npub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed = 589824;\npub const _NL_NUM_LC_NAME: C2RustUnnamed = 524295;\npub const _NL_NAME_CODESET: C2RustUnnamed = 524294;\npub const _NL_NAME_NAME_MS: C2RustUnnamed = 524293;\npub const _NL_NAME_NAME_MISS: C2RustUnnamed = 524292;\npub const _NL_NAME_NAME_MRS: C2RustUnnamed = 524291;\npub const _NL_NAME_NAME_MR: C2RustUnnamed = 524290;\npub const _NL_NAME_NAME_GEN: C2RustUnnamed = 524289;\npub const _NL_NAME_NAME_FMT: C2RustUnnamed = 524288;\npub const _NL_NUM_LC_PAPER: C2RustUnnamed = 458755;\npub const _NL_PAPER_CODESET: C2RustUnnamed = 458754;\npub const _NL_PAPER_WIDTH: C2RustUnnamed = 458753;\npub const _NL_PAPER_HEIGHT: C2RustUnnamed = 458752;\npub const _NL_NUM_LC_MESSAGES: C2RustUnnamed = 327685;\npub const _NL_MESSAGES_CODESET: C2RustUnnamed = 327684;\npub const __NOSTR: C2RustUnnamed = 327683;\npub const __YESSTR: C2RustUnnamed = 327682;\npub const __NOEXPR: C2RustUnnamed = 327681;\npub const __YESEXPR: C2RustUnnamed = 327680;\npub const _NL_NUM_LC_NUMERIC: C2RustUnnamed = 65542;\npub const _NL_NUMERIC_CODESET: C2RustUnnamed = 65541;\npub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed = 65540;\npub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed = 65539;\npub const __GROUPING: C2RustUnnamed = 65538;\npub const THOUSEP: C2RustUnnamed = 65537;\npub const __THOUSANDS_SEP: C2RustUnnamed = 65537;\npub const RADIXCHAR: C2RustUnnamed = 65536;\npub const __DECIMAL_POINT: C2RustUnnamed = 65536;\npub const _NL_NUM_LC_MONETARY: C2RustUnnamed = 262190;\npub const _NL_MONETARY_CODESET: C2RustUnnamed = 262189;\npub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed = 262188;\npub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed = 262187;\npub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed = 262186;\npub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed = 262185;\npub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed = 262184;\npub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed = 262183;\npub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed = 262182;\npub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed = 262181;\npub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed = 262180;\npub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed = 262179;\npub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed = 262178;\npub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed = 262177;\npub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed = 262176;\npub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed = 262175;\npub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed = 262174;\npub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed = 262173;\npub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed = 262172;\npub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed = 262171;\npub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed = 262170;\npub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed = 262169;\npub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed = 262168;\npub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed = 262167;\npub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed = 262166;\npub const __INT_N_SIGN_POSN: C2RustUnnamed = 262165;\npub const __INT_P_SIGN_POSN: C2RustUnnamed = 262164;\npub const __INT_N_SEP_BY_SPACE: C2RustUnnamed = 262163;\npub const __INT_N_CS_PRECEDES: C2RustUnnamed = 262162;\npub const __INT_P_SEP_BY_SPACE: C2RustUnnamed = 262161;\npub const __INT_P_CS_PRECEDES: C2RustUnnamed = 262160;\npub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed = 262159;\npub const __N_SIGN_POSN: C2RustUnnamed = 262158;\npub const __P_SIGN_POSN: C2RustUnnamed = 262157;\npub const __N_SEP_BY_SPACE: C2RustUnnamed = 262156;\npub const __N_CS_PRECEDES: C2RustUnnamed = 262155;\npub const __P_SEP_BY_SPACE: C2RustUnnamed = 262154;\npub const __P_CS_PRECEDES: C2RustUnnamed = 262153;\npub const __FRAC_DIGITS: C2RustUnnamed = 262152;\npub const __INT_FRAC_DIGITS: C2RustUnnamed = 262151;\npub const __NEGATIVE_SIGN: C2RustUnnamed = 262150;\npub const __POSITIVE_SIGN: C2RustUnnamed = 262149;\npub const __MON_GROUPING: C2RustUnnamed = 262148;\npub const __MON_THOUSANDS_SEP: C2RustUnnamed = 262147;\npub const __MON_DECIMAL_POINT: C2RustUnnamed = 262146;\npub const __CURRENCY_SYMBOL: C2RustUnnamed = 262145;\npub const __INT_CURR_SYMBOL: C2RustUnnamed = 262144;\npub const _NL_NUM_LC_CTYPE: C2RustUnnamed = 86;\npub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed = 85;\npub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed = 84;\npub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed = 83;\npub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed = 82;\npub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed = 81;\npub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed = 80;\npub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed = 79;\npub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed = 78;\npub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed = 77;\npub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed = 76;\npub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed = 75;\npub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed = 74;\npub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed = 73;\npub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed = 72;\npub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed = 71;\npub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed = 70;\npub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed = 69;\npub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed = 68;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed = 67;\npub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed = 66;\npub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed = 65;\npub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed = 64;\npub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed = 63;\npub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed = 62;\npub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed = 61;\npub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed = 60;\npub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed = 59;\npub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed = 58;\npub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed = 57;\npub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed = 56;\npub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed = 55;\npub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed = 54;\npub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed = 53;\npub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed = 52;\npub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed = 51;\npub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed = 50;\npub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed = 49;\npub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed = 48;\npub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed = 47;\npub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed = 46;\npub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed = 45;\npub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed = 44;\npub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed = 43;\npub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed = 42;\npub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed = 41;\npub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed = 40;\npub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed = 39;\npub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed = 38;\npub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed = 37;\npub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed = 36;\npub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed = 35;\npub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed = 34;\npub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed = 33;\npub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed = 32;\npub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed = 31;\npub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed = 30;\npub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed = 29;\npub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed = 28;\npub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed = 27;\npub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed = 26;\npub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed = 25;\npub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed = 24;\npub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed = 23;\npub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed = 22;\npub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed = 21;\npub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed = 20;\npub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed = 19;\npub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed = 18;\npub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed = 17;\npub const _NL_CTYPE_TOLOWER32: C2RustUnnamed = 16;\npub const _NL_CTYPE_TOUPPER32: C2RustUnnamed = 15;\npub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed = 14;\npub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed = 13;\npub const _NL_CTYPE_WIDTH: C2RustUnnamed = 12;\npub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed = 11;\npub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed = 10;\npub const _NL_CTYPE_GAP6: C2RustUnnamed = 9;\npub const _NL_CTYPE_GAP5: C2RustUnnamed = 8;\npub const _NL_CTYPE_GAP4: C2RustUnnamed = 7;\npub const _NL_CTYPE_GAP3: C2RustUnnamed = 6;\npub const _NL_CTYPE_CLASS32: C2RustUnnamed = 5;\npub const _NL_CTYPE_GAP2: C2RustUnnamed = 4;\npub const _NL_CTYPE_TOLOWER: C2RustUnnamed = 3;\npub const _NL_CTYPE_GAP1: C2RustUnnamed = 2;\npub const _NL_CTYPE_TOUPPER: C2RustUnnamed = 1;\npub const _NL_CTYPE_CLASS: C2RustUnnamed = 0;\npub const _NL_NUM_LC_COLLATE: C2RustUnnamed = 196627;\npub const _NL_COLLATE_CODESET: C2RustUnnamed = 196626;\npub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed = 196625;\npub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed = 196624;\npub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed = 196623;\npub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed = 196622;\npub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed = 196621;\npub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed = 196620;\npub const _NL_COLLATE_EXTRAWC: C2RustUnnamed = 196619;\npub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed = 196618;\npub const _NL_COLLATE_TABLEWC: C2RustUnnamed = 196617;\npub const _NL_COLLATE_GAP3: C2RustUnnamed = 196616;\npub const _NL_COLLATE_GAP2: C2RustUnnamed = 196615;\npub const _NL_COLLATE_GAP1: C2RustUnnamed = 196614;\npub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed = 196613;\npub const _NL_COLLATE_EXTRAMB: C2RustUnnamed = 196612;\npub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed = 196611;\npub const _NL_COLLATE_TABLEMB: C2RustUnnamed = 196610;\npub const _NL_COLLATE_RULESETS: C2RustUnnamed = 196609;\npub const _NL_COLLATE_NRULES: C2RustUnnamed = 196608;\npub const _NL_NUM_LC_TIME: C2RustUnnamed = 131231;\npub const _NL_WABALTMON_12: C2RustUnnamed = 131230;\npub const _NL_WABALTMON_11: C2RustUnnamed = 131229;\npub const _NL_WABALTMON_10: C2RustUnnamed = 131228;\npub const _NL_WABALTMON_9: C2RustUnnamed = 131227;\npub const _NL_WABALTMON_8: C2RustUnnamed = 131226;\npub const _NL_WABALTMON_7: C2RustUnnamed = 131225;\npub const _NL_WABALTMON_6: C2RustUnnamed = 131224;\npub const _NL_WABALTMON_5: C2RustUnnamed = 131223;\npub const _NL_WABALTMON_4: C2RustUnnamed = 131222;\npub const _NL_WABALTMON_3: C2RustUnnamed = 131221;\npub const _NL_WABALTMON_2: C2RustUnnamed = 131220;\npub const _NL_WABALTMON_1: C2RustUnnamed = 131219;\npub const _NL_ABALTMON_12: C2RustUnnamed = 131218;\npub const _NL_ABALTMON_11: C2RustUnnamed = 131217;\npub const _NL_ABALTMON_10: C2RustUnnamed = 131216;\npub const _NL_ABALTMON_9: C2RustUnnamed = 131215;\npub const _NL_ABALTMON_8: C2RustUnnamed = 131214;\npub const _NL_ABALTMON_7: C2RustUnnamed = 131213;\npub const _NL_ABALTMON_6: C2RustUnnamed = 131212;\npub const _NL_ABALTMON_5: C2RustUnnamed = 131211;\npub const _NL_ABALTMON_4: C2RustUnnamed = 131210;\npub const _NL_ABALTMON_3: C2RustUnnamed = 131209;\npub const _NL_ABALTMON_2: C2RustUnnamed = 131208;\npub const _NL_ABALTMON_1: C2RustUnnamed = 131207;\npub const _NL_WALTMON_12: C2RustUnnamed = 131206;\npub const _NL_WALTMON_11: C2RustUnnamed = 131205;\npub const _NL_WALTMON_10: C2RustUnnamed = 131204;\npub const _NL_WALTMON_9: C2RustUnnamed = 131203;\npub const _NL_WALTMON_8: C2RustUnnamed = 131202;\npub const _NL_WALTMON_7: C2RustUnnamed = 131201;\npub const _NL_WALTMON_6: C2RustUnnamed = 131200;\npub const _NL_WALTMON_5: C2RustUnnamed = 131199;\npub const _NL_WALTMON_4: C2RustUnnamed = 131198;\npub const _NL_WALTMON_3: C2RustUnnamed = 131197;\npub const _NL_WALTMON_2: C2RustUnnamed = 131196;\npub const _NL_WALTMON_1: C2RustUnnamed = 131195;\npub const __ALTMON_12: C2RustUnnamed = 131194;\npub const __ALTMON_11: C2RustUnnamed = 131193;\npub const __ALTMON_10: C2RustUnnamed = 131192;\npub const __ALTMON_9: C2RustUnnamed = 131191;\npub const __ALTMON_8: C2RustUnnamed = 131190;\npub const __ALTMON_7: C2RustUnnamed = 131189;\npub const __ALTMON_6: C2RustUnnamed = 131188;\npub const __ALTMON_5: C2RustUnnamed = 131187;\npub const __ALTMON_4: C2RustUnnamed = 131186;\npub const __ALTMON_3: C2RustUnnamed = 131185;\npub const __ALTMON_2: C2RustUnnamed = 131184;\npub const __ALTMON_1: C2RustUnnamed = 131183;\npub const _NL_TIME_CODESET: C2RustUnnamed = 131182;\npub const _NL_W_DATE_FMT: C2RustUnnamed = 131181;\npub const _DATE_FMT: C2RustUnnamed = 131180;\npub const _NL_TIME_TIMEZONE: C2RustUnnamed = 131179;\npub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed = 131178;\npub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed = 131177;\npub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed = 131176;\npub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed = 131175;\npub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed = 131174;\npub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed = 131173;\npub const _NL_WERA_T_FMT: C2RustUnnamed = 131172;\npub const _NL_WERA_D_T_FMT: C2RustUnnamed = 131171;\npub const _NL_WALT_DIGITS: C2RustUnnamed = 131170;\npub const _NL_WERA_D_FMT: C2RustUnnamed = 131169;\npub const _NL_WERA_YEAR: C2RustUnnamed = 131168;\npub const _NL_WT_FMT_AMPM: C2RustUnnamed = 131167;\npub const _NL_WT_FMT: C2RustUnnamed = 131166;\npub const _NL_WD_FMT: C2RustUnnamed = 131165;\npub const _NL_WD_T_FMT: C2RustUnnamed = 131164;\npub const _NL_WPM_STR: C2RustUnnamed = 131163;\npub const _NL_WAM_STR: C2RustUnnamed = 131162;\npub const _NL_WMON_12: C2RustUnnamed = 131161;\npub const _NL_WMON_11: C2RustUnnamed = 131160;\npub const _NL_WMON_10: C2RustUnnamed = 131159;\npub const _NL_WMON_9: C2RustUnnamed = 131158;\npub const _NL_WMON_8: C2RustUnnamed = 131157;\npub const _NL_WMON_7: C2RustUnnamed = 131156;\npub const _NL_WMON_6: C2RustUnnamed = 131155;\npub const _NL_WMON_5: C2RustUnnamed = 131154;\npub const _NL_WMON_4: C2RustUnnamed = 131153;\npub const _NL_WMON_3: C2RustUnnamed = 131152;\npub const _NL_WMON_2: C2RustUnnamed = 131151;\npub const _NL_WMON_1: C2RustUnnamed = 131150;\npub const _NL_WABMON_12: C2RustUnnamed = 131149;\npub const _NL_WABMON_11: C2RustUnnamed = 131148;\npub const _NL_WABMON_10: C2RustUnnamed = 131147;\npub const _NL_WABMON_9: C2RustUnnamed = 131146;\npub const _NL_WABMON_8: C2RustUnnamed = 131145;\npub const _NL_WABMON_7: C2RustUnnamed = 131144;\npub const _NL_WABMON_6: C2RustUnnamed = 131143;\npub const _NL_WABMON_5: C2RustUnnamed = 131142;\npub const _NL_WABMON_4: C2RustUnnamed = 131141;\npub const _NL_WABMON_3: C2RustUnnamed = 131140;\npub const _NL_WABMON_2: C2RustUnnamed = 131139;\npub const _NL_WABMON_1: C2RustUnnamed = 131138;\npub const _NL_WDAY_7: C2RustUnnamed = 131137;\npub const _NL_WDAY_6: C2RustUnnamed = 131136;\npub const _NL_WDAY_5: C2RustUnnamed = 131135;\npub const _NL_WDAY_4: C2RustUnnamed = 131134;\npub const _NL_WDAY_3: C2RustUnnamed = 131133;\npub const _NL_WDAY_2: C2RustUnnamed = 131132;\npub const _NL_WDAY_1: C2RustUnnamed = 131131;\npub const _NL_WABDAY_7: C2RustUnnamed = 131130;\npub const _NL_WABDAY_6: C2RustUnnamed = 131129;\npub const _NL_WABDAY_5: C2RustUnnamed = 131128;\npub const _NL_WABDAY_4: C2RustUnnamed = 131127;\npub const _NL_WABDAY_3: C2RustUnnamed = 131126;\npub const _NL_WABDAY_2: C2RustUnnamed = 131125;\npub const _NL_WABDAY_1: C2RustUnnamed = 131124;\npub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed = 131123;\npub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed = 131122;\npub const ERA_T_FMT: C2RustUnnamed = 131121;\npub const ERA_D_T_FMT: C2RustUnnamed = 131120;\npub const ALT_DIGITS: C2RustUnnamed = 131119;\npub const ERA_D_FMT: C2RustUnnamed = 131118;\npub const __ERA_YEAR: C2RustUnnamed = 131117;\npub const ERA: C2RustUnnamed = 131116;\npub const T_FMT_AMPM: C2RustUnnamed = 131115;\npub const T_FMT: C2RustUnnamed = 131114;\npub const D_FMT: C2RustUnnamed = 131113;\npub const D_T_FMT: C2RustUnnamed = 131112;\npub const PM_STR: C2RustUnnamed = 131111;\npub const AM_STR: C2RustUnnamed = 131110;\npub const MON_12: C2RustUnnamed = 131109;\npub const MON_11: C2RustUnnamed = 131108;\npub const MON_10: C2RustUnnamed = 131107;\npub const MON_9: C2RustUnnamed = 131106;\npub const MON_8: C2RustUnnamed = 131105;\npub const MON_7: C2RustUnnamed = 131104;\npub const MON_6: C2RustUnnamed = 131103;\npub const MON_5: C2RustUnnamed = 131102;\npub const MON_4: C2RustUnnamed = 131101;\npub const MON_3: C2RustUnnamed = 131100;\npub const MON_2: C2RustUnnamed = 131099;\npub const MON_1: C2RustUnnamed = 131098;\npub const ABMON_12: C2RustUnnamed = 131097;\npub const ABMON_11: C2RustUnnamed = 131096;\npub const ABMON_10: C2RustUnnamed = 131095;\npub const ABMON_9: C2RustUnnamed = 131094;\npub const ABMON_8: C2RustUnnamed = 131093;\npub const ABMON_7: C2RustUnnamed = 131092;\npub const ABMON_6: C2RustUnnamed = 131091;\npub const ABMON_5: C2RustUnnamed = 131090;\npub const ABMON_4: C2RustUnnamed = 131089;\npub const ABMON_3: C2RustUnnamed = 131088;\npub const ABMON_2: C2RustUnnamed = 131087;\npub const ABMON_1: C2RustUnnamed = 131086;\npub const DAY_7: C2RustUnnamed = 131085;\npub const DAY_6: C2RustUnnamed = 131084;\npub const DAY_5: C2RustUnnamed = 131083;\npub const DAY_4: C2RustUnnamed = 131082;\npub const DAY_3: C2RustUnnamed = 131081;\npub const DAY_2: C2RustUnnamed = 131080;\npub const DAY_1: C2RustUnnamed = 131079;\npub const ABDAY_7: C2RustUnnamed = 131078;\npub const ABDAY_6: C2RustUnnamed = 131077;\npub const ABDAY_5: C2RustUnnamed = 131076;\npub const ABDAY_4: C2RustUnnamed = 131075;\npub const ABDAY_3: C2RustUnnamed = 131074;\npub const ABDAY_2: C2RustUnnamed = 131073;\npub const ABDAY_1: C2RustUnnamed = 131072;\n#[no_mangle]\npub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;\n    fn abort() -> !;\n    fn hard_locale(category: libc::c_int) -> bool;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\nstatic mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};\n#[no_mangle]\npub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "use ::libc;\nextern \"C\" {\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "use ::libc;\nextern \"C\" {\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const MCEL_LEN_MAX: C2RustUnnamed_0 = 4;\npub type C2RustUnnamed_1 = libc::c_uint;\npub const MCEL_CHAR_MAX: C2RustUnnamed_1 = 1114111;\npub type C2RustUnnamed_2 = libc::c_uint;\npub const MCEL_ERR_MIN: C2RustUnnamed_2 = 128;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mcel_t {\n    pub ch: char32_t,\n    pub err: libc::c_uchar,\n    pub len: libc::c_uchar,\n}\npub type C2RustUnnamed_3 = libc::c_uint;\npub const MCEL_ERR_SHIFT: C2RustUnnamed_3 = 14;\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mcel_scanz(mut p: *const libc::c_char) -> mcel_t {\n    return mcel_scant(p, '\\0' as i32 as libc::c_char);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mcel_scant(\n    mut p: *const libc::c_char,\n    mut terminator: libc::c_char,\n) -> mcel_t {\n    if mcel_isbasic(*p) {\n        return mcel_ch(*p as char32_t, 1 as libc::c_int as size_t);\n    }\n    let mut lim: *const libc::c_char = p.offset(1 as libc::c_int as isize);\n    let mut i: libc::c_int = 0 as libc::c_int;\n    while i < MCEL_LEN_MAX as libc::c_int - 1 as libc::c_int {\n        lim = lim\n            .offset(\n                (*lim as libc::c_int != terminator as libc::c_int) as libc::c_int\n                    as isize,\n            );\n        i += 1;\n        i;\n    }\n    return mcel_scan(p, lim);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mcel_scan(\n    mut p: *const libc::c_char,\n    mut lim: *const libc::c_char,\n) -> mcel_t {\n    let mut c: libc::c_char = *p;\n    if mcel_isbasic(c) {\n        return mcel_ch(c as char32_t, 1 as libc::c_int as size_t);\n    }\n    let mut mbs: mbstate_t = mbstate_t {\n        __count: 0,\n        __value: C2RustUnnamed { __wch: 0 },\n    };\n    mbs.__count = 0 as libc::c_int;\n    let mut ch: char32_t = 0;\n    let mut len: size_t = mbrtoc32(\n        &mut ch,\n        p,\n        lim.offset_from(p) as libc::c_long as size_t,\n        &mut mbs,\n    );\n    if ((-(1 as libc::c_int) as size_t).wrapping_div(2 as libc::c_int as libc::c_ulong)\n        < len) as libc::c_int as libc::c_long != 0\n    {\n        return mcel_err(c as libc::c_uchar);\n    }\n    return mcel_ch(ch, len);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mcel_isbasic(mut c: libc::c_char) -> bool {\n    return (0 as libc::c_int <= c as libc::c_int\n        && (c as libc::c_int) < MCEL_ERR_MIN as libc::c_int) as libc::c_int\n        as libc::c_long != 0;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mcel_tocmp(\n    mut to: Option::<unsafe extern \"C\" fn(wint_t) -> wint_t>,\n    mut c1: mcel_t,\n    mut c2: mcel_t,\n) -> libc::c_int {\n    let mut cmp: libc::c_int = mcel_cmp(c1, c2);\n    if (c1.err as libc::c_int - c2.err as libc::c_int | (cmp == 0) as libc::c_int)\n        as libc::c_long != 0\n    {\n        return cmp;\n    }\n    let mut ch1: libc::c_int = to.expect(\"non-null function pointer\")(c1.ch)\n        as libc::c_int;\n    let mut ch2: libc::c_int = to.expect(\"non-null function pointer\")(c2.ch)\n        as libc::c_int;\n    return ch1 - ch2;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mcel_cmp(mut c1: mcel_t, mut c2: mcel_t) -> libc::c_int {\n    let mut ch1: libc::c_int = c1.ch as libc::c_int;\n    let mut ch2: libc::c_int = c2.ch as libc::c_int;\n    return (c1.err as libc::c_int - c2.err as libc::c_int)\n        * ((1 as libc::c_int) << MCEL_ERR_SHIFT as libc::c_int) + (ch1 - ch2);\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mcel_err(mut err: libc::c_uchar) -> mcel_t {\n    if MCEL_ERR_MIN as libc::c_int <= err as libc::c_int {} else {\n        unreachable!();\n    };\n    return {\n        let mut init = mcel_t {\n            ch: 0,\n            err: err,\n            len: 1 as libc::c_int as libc::c_uchar,\n        };\n        init\n    };\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn mcel_ch(mut ch: char32_t, mut len: size_t) -> mcel_t {\n    if (0 as libc::c_int as libc::c_ulong) < len {} else {\n        unreachable!();\n    };\n    if len <= MCEL_LEN_MAX as libc::c_int as libc::c_ulong {} else {\n        unreachable!();\n    };\n    if ch <= MCEL_CHAR_MAX as libc::c_int as libc::c_uint {} else {\n        unreachable!();\n    };\n    return {\n        let mut init = mcel_t {\n            ch: ch,\n            err: 0,\n            len: len as libc::c_uchar,\n        };\n        init\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn toupper(_: libc::c_int) -> libc::c_int;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn memcasecmp(\n    mut vs1: *const libc::c_void,\n    mut vs2: *const libc::c_void,\n    mut n: size_t,\n) -> libc::c_int {\n    let mut i: size_t = 0;\n    let mut s1: *const libc::c_char = vs1 as *const libc::c_char;\n    let mut s2: *const libc::c_char = vs2 as *const libc::c_char;\n    i = 0 as libc::c_int as size_t;\n    while i < n {\n        let mut u1: libc::c_uchar = *s1.offset(i as isize) as libc::c_uchar;\n        let mut u2: libc::c_uchar = *s2.offset(i as isize) as libc::c_uchar;\n        let mut U1: libc::c_int = toupper(u1 as libc::c_int);\n        let mut U2: libc::c_int = toupper(u2 as libc::c_int);\n        let mut diff: libc::c_int = if 127 as libc::c_int * 2 as libc::c_int\n            + 1 as libc::c_int <= 2147483647 as libc::c_int\n        {\n            U1 - U2\n        } else {\n            (U1 > U2) as libc::c_int - (U1 < U2) as libc::c_int\n        };\n        if diff != 0 {\n            return diff;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    fn strtol(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n    ) -> libc::c_long;\n    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn posix2_version() -> libc::c_int {\n    let mut v: libc::c_long = 200809 as libc::c_long;\n    let mut s: *const libc::c_char = getenv(\n        b\"_POSIX2_VERSION\\0\" as *const u8 as *const libc::c_char,\n    );\n    if !s.is_null() && *s as libc::c_int != 0 {\n        let mut e: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut i: libc::c_long = strtol(s, &mut e, 10 as libc::c_int);\n        if *e == 0 {\n            v = i;\n        }\n    }\n    return (if v < (-(2147483647 as libc::c_int) - 1 as libc::c_int) as libc::c_long {\n        (-(2147483647 as libc::c_int) - 1 as libc::c_int) as libc::c_long\n    } else if v < 2147483647 as libc::c_int as libc::c_long {\n        v\n    } else {\n        2147483647 as libc::c_int as libc::c_long\n    }) as libc::c_int;\n}",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut program_invocation_name: *mut libc::c_char;\n    static mut program_invocation_short_name: *mut libc::c_char;\n    static mut stderr: *mut FILE;\n    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn abort() -> !;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n}\npub type FILE = _IO_FILE;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type size_t = libc::c_ulong;\npub type __off64_t = libc::c_long;\npub type _IO_lock_t = ();\npub type __off_t = libc::c_long;\n#[no_mangle]\npub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;\n#[no_mangle]\npub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn locale_charset() -> *const libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn free(_: *mut libc::c_void);\n    fn abort() -> !;\n    fn xpalloc(\n        pa: *mut libc::c_void,\n        pn: *mut idx_t,\n        n_incr_min: idx_t,\n        n_max: ptrdiff_t,\n        s: idx_t,\n    ) -> *mut libc::c_void;\n    fn xmemdup(p: *const libc::c_void, s: size_t) -> *mut libc::c_void;\n    fn xcharalloc(n: size_t) -> *mut libc::c_char;\n    fn c_strcasecmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;\n    fn locale_charset() -> *const libc::c_char;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __errno_location() -> *mut libc::c_int;\n    fn memset(\n        _: *mut libc::c_void,\n        _: libc::c_int,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n    fn rpl_mbrtoc32(\n        pc: *mut char32_t,\n        s: *const libc::c_char,\n        n: size_t,\n        ps: *mut mbstate_t,\n    ) -> size_t;\n    fn iswprint(__wc: wint_t) -> libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type ptrdiff_t = libc::c_long;\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type quoting_flags = libc::c_uint;\npub const QA_SPLIT_TRIGRAPHS: quoting_flags = 4;\npub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;\npub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct quoting_options {\n    pub style: quoting_style,\n    pub flags: libc::c_int,\n    pub quote_these_too: [libc::c_uint; 8],\n    pub left_quote: *const libc::c_char,\n    pub right_quote: *const libc::c_char,\n}\npub type __mbstate_t = mbstate_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub const _ISprint: C2RustUnnamed_0 = 16384;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct slotvec {\n    pub size: size_t,\n    pub val: *mut libc::c_char,\n}\npub type idx_t = ptrdiff_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const _ISalnum: C2RustUnnamed_0 = 8;\npub const _ISpunct: C2RustUnnamed_0 = 4;\npub const _IScntrl: C2RustUnnamed_0 = 2;\npub const _ISblank: C2RustUnnamed_0 = 1;\npub const _ISgraph: C2RustUnnamed_0 = 32768;\npub const _ISspace: C2RustUnnamed_0 = 8192;\npub const _ISxdigit: C2RustUnnamed_0 = 4096;\npub const _ISdigit: C2RustUnnamed_0 = 2048;\npub const _ISalpha: C2RustUnnamed_0 = 1024;\npub const _ISlower: C2RustUnnamed_0 = 512;\npub const _ISupper: C2RustUnnamed_0 = 256;\n#[inline]\nunsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}\n#[inline]\nunsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub static mut quoting_style_args: [*const libc::c_char; 11] = [\n    b\"literal\\0\" as *const u8 as *const libc::c_char,\n    b\"shell\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-always\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape\\0\" as *const u8 as *const libc::c_char,\n    b\"shell-escape-always\\0\" as *const u8 as *const libc::c_char,\n    b\"c\\0\" as *const u8 as *const libc::c_char,\n    b\"c-maybe\\0\" as *const u8 as *const libc::c_char,\n    b\"escape\\0\" as *const u8 as *const libc::c_char,\n    b\"locale\\0\" as *const u8 as *const libc::c_char,\n    b\"clocale\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\n#[no_mangle]\npub static mut quoting_style_vals: [quoting_style; 10] = [\n    literal_quoting_style,\n    shell_quoting_style,\n    shell_always_quoting_style,\n    shell_escape_quoting_style,\n    shell_escape_always_quoting_style,\n    c_quoting_style,\n    c_maybe_quoting_style,\n    escape_quoting_style,\n    locale_quoting_style,\n    clocale_quoting_style,\n];\nstatic mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};\n#[no_mangle]\npub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}\nunsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}\nunsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;",
    "                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}\nstatic mut slot0: [libc::c_char; 256] = [0; 256];\nstatic mut nslots: libc::c_int = 1 as libc::c_int;\nstatic mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};",
    "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}\nunsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}\n#[no_mangle]\npub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale_null_r_unlocked(\n        category: libc::c_int,\n        buf: *mut libc::c_char,\n        bufsize: size_t,\n    ) -> libc::c_int;\n    fn setlocale_null_unlocked(category: libc::c_int) -> *const libc::c_char;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "use ::libc;\nextern \"C\" {\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type size_t = libc::c_ulong;\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "use ::libc;\nextern \"C\" {\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n}\npub type size_t = libc::c_ulong;\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\npub type C2RustUnnamed_0 = libc::c_uint;\npub const MCEL_LEN_MAX: C2RustUnnamed_0 = 4;\npub type C2RustUnnamed_1 = libc::c_uint;\npub const MCEL_CHAR_MAX: C2RustUnnamed_1 = 1114111;\npub type C2RustUnnamed_2 = libc::c_uint;\npub const MCEL_ERR_MIN: C2RustUnnamed_2 = 128;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mcel_t {\n    pub ch: char32_t,\n    pub err: libc::c_uchar,\n    pub len: libc::c_uchar,\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn skip_buf_matching(\n    mut buf: *const libc::c_char,\n    mut lim: *const libc::c_char,\n    mut predicate: Option::<unsafe extern \"C\" fn(mcel_t) -> bool>,\n    mut ok: bool,\n) -> *mut libc::c_char {\n    let mut s: *const libc::c_char = buf;\n    let mut g: mcel_t = mcel_t { ch: 0, err: 0, len: 0 };\n    while s < lim\n        && {\n            g = mcel_scan(s, lim);\n            predicate.expect(\"non-null function pointer\")(g) as libc::c_int\n                == ok as libc::c_int\n        }\n    {\n        s = s.offset(g.len as libc::c_int as isize);\n    }\n    return s as *mut libc::c_char;\n}\n#[no_mangle]\n#[inline]\n#[linkage = \"external\"]\npub unsafe extern \"C\" fn skip_str_matching(\n    mut str: *const libc::c_char,\n    mut predicate: Option::<unsafe extern \"C\" fn(mcel_t) -> bool>,\n    mut ok: bool,\n) -> *mut libc::c_char {\n    let mut s: *const libc::c_char = str;\n    let mut g: mcel_t = mcel_t { ch: 0, err: 0, len: 0 };\n    while *s as libc::c_int != 0\n        && {\n            g = mcel_scanz(s);\n            predicate.expect(\"non-null function pointer\")(g) as libc::c_int\n                == ok as libc::c_int\n        }\n    {\n        s = s.offset(g.len as libc::c_int as isize);\n    }\n    return s as *mut libc::c_char;\n}\n#[inline]\nunsafe extern \"C\" fn mcel_scanz(mut p: *const libc::c_char) -> mcel_t {\n    return mcel_scant(p, '\\0' as i32 as libc::c_char);\n}\n#[inline]\nunsafe extern \"C\" fn mcel_scant(\n    mut p: *const libc::c_char,\n    mut terminator: libc::c_char,\n) -> mcel_t {\n    if mcel_isbasic(*p) {\n        return mcel_ch(*p as char32_t, 1 as libc::c_int as size_t);\n    }\n    let mut lim: *const libc::c_char = p.offset(1 as libc::c_int as isize);\n    let mut i: libc::c_int = 0 as libc::c_int;\n    while i < MCEL_LEN_MAX as libc::c_int - 1 as libc::c_int {\n        lim = lim\n            .offset(\n                (*lim as libc::c_int != terminator as libc::c_int) as libc::c_int\n                    as isize,\n            );\n        i += 1;\n        i;\n    }\n    return mcel_scan(p, lim);\n}\n#[inline]\nunsafe extern \"C\" fn mcel_scan(\n    mut p: *const libc::c_char,\n    mut lim: *const libc::c_char,\n) -> mcel_t {\n    let mut c: libc::c_char = *p;\n    if mcel_isbasic(c) {\n        return mcel_ch(c as char32_t, 1 as libc::c_int as size_t);\n    }\n    let mut mbs: mbstate_t = mbstate_t {\n        __count: 0,\n        __value: C2RustUnnamed { __wch: 0 },\n    };\n    mbs.__count = 0 as libc::c_int;\n    let mut ch: char32_t = 0;\n    let mut len: size_t = mbrtoc32(\n        &mut ch,\n        p,\n        lim.offset_from(p) as libc::c_long as size_t,\n        &mut mbs,\n    );\n    if ((-(1 as libc::c_int) as size_t).wrapping_div(2 as libc::c_int as libc::c_ulong)\n        < len) as libc::c_int as libc::c_long != 0\n    {\n        return mcel_err(c as libc::c_uchar);\n    }\n    return mcel_ch(ch, len);\n}\n#[inline]\nunsafe extern \"C\" fn mcel_isbasic(mut c: libc::c_char) -> bool {\n    return (0 as libc::c_int <= c as libc::c_int\n        && (c as libc::c_int) < MCEL_ERR_MIN as libc::c_int) as libc::c_int\n        as libc::c_long != 0;\n}\n#[inline]\nunsafe extern \"C\" fn mcel_err(mut err: libc::c_uchar) -> mcel_t {\n    if MCEL_ERR_MIN as libc::c_int <= err as libc::c_int {} else {\n        unreachable!();\n    };\n    return {\n        let mut init = mcel_t {\n            ch: 0,\n            err: err,\n            len: 1 as libc::c_int as libc::c_uchar,\n        };\n        init\n    };\n}\n#[inline]\nunsafe extern \"C\" fn mcel_ch(mut ch: char32_t, mut len: size_t) -> mcel_t {\n    if (0 as libc::c_int as libc::c_ulong) < len {} else {\n        unreachable!();\n    };\n    if len <= MCEL_LEN_MAX as libc::c_int as libc::c_ulong {} else {\n        unreachable!();\n    };\n    if ch <= MCEL_CHAR_MAX as libc::c_int as libc::c_uint {} else {\n        unreachable!();\n    };\n    return {\n        let mut init = mcel_t {\n            ch: ch,\n            err: 0,\n            len: len as libc::c_uchar,\n        };\n        init\n    };\n}",
    "#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut, unused_imports)]\n#![feature(extern_types)]\nuse ::rust::*;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut optarg: *mut libc::c_char;\n    fn getopt_long(\n        ___argc: libc::c_int,\n        ___argv: *const *mut libc::c_char,\n        __shortopts: *const libc::c_char,\n        __longopts: *const option,\n        __longind: *mut libc::c_int,\n    ) -> libc::c_int;\n    static mut optind: libc::c_int;\n    fn __ctype_get_mb_cur_max() -> size_t;\n    fn atexit(__func: Option::<unsafe extern \"C\" fn() -> ()>) -> libc::c_int;\n    fn memcmp(\n        _: *const libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;\n    fn strncmp(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: libc::c_ulong,\n    ) -> libc::c_int;\n    fn free(_: *mut libc::c_void);\n    fn __errno_location() -> *mut libc::c_int;\n    fn exit(_: libc::c_int) -> !;\n    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;\n    static mut Version: *const libc::c_char;\n    fn setlocale(\n        __category: libc::c_int,\n        __locale: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;\n    fn bindtextdomain(\n        __domainname: *const libc::c_char,\n        __dirname: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    static mut stdin: *mut FILE;\n    static mut stdout: *mut FILE;\n    static mut stderr: *mut FILE;\n    fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn putchar_unlocked(__c: libc::c_int) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    fn fwrite_unlocked(\n        __ptr: *const libc::c_void,\n        __size: size_t,\n        __n: size_t,\n        __stream: *mut FILE,\n    ) -> size_t;\n    fn clearerr_unlocked(__stream: *mut FILE);\n    fn feof_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;\n    fn rpl_fclose(stream: *mut FILE) -> libc::c_int;\n    fn fpurge(gl_stream: *mut FILE) -> libc::c_int;\n    fn close_stdout();\n    fn version_etc(\n        stream: *mut FILE,\n        command_name: *const libc::c_char,\n        package: *const libc::c_char,\n        version: *const libc::c_char,\n        _: ...\n    );\n    fn proper_name_lite(\n        name_ascii: *const libc::c_char,\n        name_utf8: *const libc::c_char,\n    ) -> *const libc::c_char;\n    static mut program_name: *const libc::c_char;\n    fn set_program_name(argv0: *const libc::c_char);\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    fn quotearg_style(s: quoting_style, arg: *const libc::c_char) -> *mut libc::c_char;\n    fn quotearg_n_style_colon(\n        n: libc::c_int,\n        s: quoting_style,\n        arg: *const libc::c_char,\n    ) -> *mut libc::c_char;\n    static mut argmatch_die: argmatch_exit_fn;\n    fn __xargmatch_internal(\n        context: *const libc::c_char,\n        arg: *const libc::c_char,\n        arglist: *const *const libc::c_char,\n        vallist: *const libc::c_void,\n        valsize: size_t,\n        exit_fn: argmatch_exit_fn,\n        allow_abbreviation: bool,\n    ) -> ptrdiff_t;\n    fn quote(arg: *const libc::c_char) -> *const libc::c_char;\n    fn initbuffer(linebuffer: *mut linebuffer);\n    fn readlinebuffer_delim(\n        linebuffer: *mut linebuffer,\n        stream: *mut FILE,\n        delimiter: libc::c_char,\n    ) -> *mut linebuffer;\n    fn fadvise(fp: *mut FILE, advice: fadvice_t);\n    fn iswblank(__wc: wint_t) -> libc::c_int;\n    fn mbrtoc32(\n        __pc32: *mut char32_t,\n        __s: *const libc::c_char,\n        __n: size_t,\n        __p: *mut mbstate_t,\n    ) -> size_t;\n    fn posix2_version() -> libc::c_int;\n    fn freopen_safer(\n        _: *const libc::c_char,\n        _: *const libc::c_char,\n        _: *mut FILE,\n    ) -> *mut FILE;\n    fn xstrtoimax(\n        _: *const libc::c_char,\n        _: *mut *mut libc::c_char,\n        _: libc::c_int,\n        _: *mut intmax_t,\n        _: *const libc::c_char,\n    ) -> strtol_error;\n    fn memcasecmp(\n        vs1: *const libc::c_void,\n        vs2: *const libc::c_void,\n        n: size_t,\n    ) -> libc::c_int;\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct option {\n    pub name: *const libc::c_char,\n    pub has_arg: libc::c_int,\n    pub flag: *mut libc::c_int,\n    pub val: libc::c_int,\n}\npub type __uint32_t = libc::c_uint;\npub type __uint_least32_t = __uint32_t;\npub type __intmax_t = libc::c_long;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type ptrdiff_t = libc::c_long;\npub type intmax_t = __intmax_t;\npub type idx_t = ptrdiff_t;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __mbstate_t {\n    pub __count: libc::c_int,\n    pub __value: C2RustUnnamed,\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub union C2RustUnnamed {\n    pub __wch: libc::c_uint,\n    pub __wchb: [libc::c_char; 4],\n}\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub type C2RustUnnamed_0 = libc::c_int;\npub const GETOPT_VERSION_CHAR: C2RustUnnamed_0 = -3;\npub const GETOPT_HELP_CHAR: C2RustUnnamed_0 = -2;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct infomap {\n    pub program: *const libc::c_char,\n    pub node: *const libc::c_char,\n}\npub type quoting_style = libc::c_uint;\npub const custom_quoting_style: quoting_style = 10;\npub const clocale_quoting_style: quoting_style = 9;\npub const locale_quoting_style: quoting_style = 8;\npub const escape_quoting_style: quoting_style = 7;\npub const c_maybe_quoting_style: quoting_style = 6;\npub const c_quoting_style: quoting_style = 5;\npub const shell_escape_always_quoting_style: quoting_style = 4;\npub const shell_escape_quoting_style: quoting_style = 3;\npub const shell_always_quoting_style: quoting_style = 2;\npub const shell_quoting_style: quoting_style = 1;\npub const literal_quoting_style: quoting_style = 0;\npub type argmatch_exit_fn = Option::<unsafe extern \"C\" fn() -> ()>;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct linebuffer {\n    pub size: idx_t,\n    pub length: idx_t,\n    pub buffer: *mut libc::c_char,\n}\npub type fadvice_t = libc::c_uint;\npub const FADVISE_RANDOM: fadvice_t = 1;\npub const FADVISE_WILLNEED: fadvice_t = 3;\npub const FADVISE_DONTNEED: fadvice_t = 4;\npub const FADVISE_NOREUSE: fadvice_t = 5;\npub const FADVISE_SEQUENTIAL: fadvice_t = 2;\npub const FADVISE_NORMAL: fadvice_t = 0;\npub type mbstate_t = __mbstate_t;\npub type char32_t = __uint_least32_t;\npub type wint_t = libc::c_uint;\npub type C2RustUnnamed_1 = libc::c_uint;\npub const MCEL_LEN_MAX: C2RustUnnamed_1 = 4;\npub type C2RustUnnamed_2 = libc::c_uint;\npub const MCEL_CHAR_MAX: C2RustUnnamed_2 = 1114111;\npub type C2RustUnnamed_3 = libc::c_uint;\npub const MCEL_ERR_MIN: C2RustUnnamed_3 = 128;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct mcel_t {\n    pub ch: char32_t,\n    pub err: libc::c_uchar,\n    pub len: libc::c_uchar,\n}\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub type delimit_method = libc::c_uint;\npub const DM_SEPARATE: delimit_method = 2;\npub const DM_PREPEND: delimit_method = 1;\npub const DM_NONE: delimit_method = 0;\npub type grouping_method = libc::c_uint;\npub const GM_BOTH: grouping_method = 4;\npub const GM_SEPARATE: grouping_method = 3;\npub const GM_APPEND: grouping_method = 2;\npub const GM_PREPEND: grouping_method = 1;\npub const GM_NONE: grouping_method = 0;\npub type C2RustUnnamed_4 = libc::c_uint;\npub const GROUP_OPTION: C2RustUnnamed_4 = 256;\npub type Skip_field_option_type = libc::c_uint;\npub const SFO_NEW: Skip_field_option_type = 2;\npub const SFO_OBSOLETE: Skip_field_option_type = 1;\npub const SFO_NONE: Skip_field_option_type = 0;\n#[inline]\nunsafe extern \"C\" fn emit_mandatory_arg_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nMandatory arguments to long options are mandatory for short options too.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}\n#[inline]\nunsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}\n#[inline]\nunsafe extern \"C\" fn write_error() {\n    let mut saved_errno: libc::c_int = *__errno_location();\n    fflush_unlocked(stdout);\n    fpurge(stdout);\n    clearerr_unlocked(stdout);\n    if 0 != 0 {\n        error(\n            1 as libc::c_int,\n            saved_errno,\n            gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n        );\n        if 1 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}\n#[inline]\nunsafe extern \"C\" fn c32isblank(mut wc: wint_t) -> libc::c_int {\n    return iswblank(wc);\n}\n#[inline]\nunsafe extern \"C\" fn mcel_ch(mut ch: char32_t, mut len: size_t) -> mcel_t {\n    if (0 as libc::c_int as libc::c_ulong) < len {} else {\n        unreachable!();\n    };\n    if len <= MCEL_LEN_MAX as libc::c_int as libc::c_ulong {} else {\n        unreachable!();\n    };\n    if ch <= MCEL_CHAR_MAX as libc::c_int as libc::c_uint {} else {\n        unreachable!();\n    };\n    return {\n        let mut init = mcel_t {\n            ch: ch,\n            err: 0,\n            len: len as libc::c_uchar,\n        };\n        init\n    };\n}\n#[inline]\nunsafe extern \"C\" fn mcel_err(mut err: libc::c_uchar) -> mcel_t {\n    if MCEL_ERR_MIN as libc::c_int <= err as libc::c_int {} else {\n        unreachable!();\n    };\n    return {\n        let mut init = mcel_t {\n            ch: 0,\n            err: err,\n            len: 1 as libc::c_int as libc::c_uchar,\n        };\n        init\n    };\n}\n#[inline]\nunsafe extern \"C\" fn mcel_isbasic(mut c: libc::c_char) -> bool {\n    return (0 as libc::c_int <= c as libc::c_int\n        && (c as libc::c_int) < MCEL_ERR_MIN as libc::c_int) as libc::c_int\n        as libc::c_long != 0;\n}\n#[inline]",
    "unsafe extern \"C\" fn mcel_scan(\n    mut p: *const libc::c_char,\n    mut lim: *const libc::c_char,\n) -> mcel_t {\n    let mut c: libc::c_char = *p;\n    if mcel_isbasic(c) {\n        return mcel_ch(c as char32_t, 1 as libc::c_int as size_t);\n    }\n    let mut mbs: mbstate_t = mbstate_t {\n        __count: 0,\n        __value: C2RustUnnamed { __wch: 0 },\n    };\n    mbs.__count = 0 as libc::c_int;\n    let mut ch: char32_t = 0;\n    let mut len: size_t = mbrtoc32(\n        &mut ch,\n        p,\n        lim.offset_from(p) as libc::c_long as size_t,\n        &mut mbs,\n    );\n    if ((-(1 as libc::c_int) as size_t).wrapping_div(2 as libc::c_int as libc::c_ulong)\n        < len) as libc::c_int as libc::c_long != 0\n    {\n        return mcel_err(c as libc::c_uchar);\n    }\n    return mcel_ch(ch, len);\n}\n#[inline]\nunsafe extern \"C\" fn skip_buf_matching(\n    mut buf: *const libc::c_char,\n    mut lim: *const libc::c_char,\n    mut predicate: Option::<unsafe extern \"C\" fn(mcel_t) -> bool>,\n    mut ok: bool,\n) -> *mut libc::c_char {\n    let mut s: *const libc::c_char = buf;\n    let mut g: mcel_t = mcel_t { ch: 0, err: 0, len: 0 };\n    while s < lim\n        && {\n            g = mcel_scan(s, lim);\n            predicate.expect(\"non-null function pointer\")(g) as libc::c_int\n                == ok as libc::c_int\n        }\n    {\n        s = s.offset(g.len as libc::c_int as isize);\n    }\n    return s as *mut libc::c_char;\n}\nunsafe extern \"C\" fn swap_lines(\n    mut a: *mut *mut linebuffer,\n    mut b: *mut *mut linebuffer,\n) {\n    let mut tmp: *mut linebuffer = *a;\n    *a = *b;\n    *b = tmp;\n}\nstatic mut skip_fields: idx_t = 0 as libc::c_int as idx_t;\nstatic mut skip_chars: idx_t = 0 as libc::c_int as idx_t;\nstatic mut check_chars: idx_t = 9223372036854775807 as libc::c_long;\nstatic mut count_occurrences: bool = 0 as libc::c_int != 0;\nstatic mut output_unique: bool = 1 as libc::c_int != 0;\nstatic mut output_first_repeated: bool = 1 as libc::c_int != 0;\nstatic mut output_later_repeated: bool = 0 as libc::c_int != 0;\nstatic mut ignore_case: bool = false;\nstatic mut delimit_method_string: [*const libc::c_char; 4] = [\n    b\"none\\0\" as *const u8 as *const libc::c_char,\n    b\"prepend\\0\" as *const u8 as *const libc::c_char,\n    b\"separate\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\nstatic mut delimit_method_map: [delimit_method; 3] = [DM_NONE, DM_PREPEND, DM_SEPARATE];\nstatic mut delimit_groups: delimit_method = DM_NONE;\nstatic mut grouping_method_string: [*const libc::c_char; 5] = [\n    b\"prepend\\0\" as *const u8 as *const libc::c_char,\n    b\"append\\0\" as *const u8 as *const libc::c_char,\n    b\"separate\\0\" as *const u8 as *const libc::c_char,\n    b\"both\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];\nstatic mut grouping_method_map: [grouping_method; 4] = [\n    GM_PREPEND,\n    GM_APPEND,\n    GM_SEPARATE,\n    GM_BOTH,\n];\nstatic mut grouping: grouping_method = GM_NONE;\nstatic mut longopts: [option; 13] = [\n    {\n        let mut init = option {\n            name: b\"count\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'c' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"repeated\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'd' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"all-repeated\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 2 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'D' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"group\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 2 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GROUP_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"ignore-case\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'i' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"unique\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'u' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"skip-fields\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'f' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"skip-chars\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 's' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"check-chars\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'w' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"zero-terminated\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'z' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];\n#[no_mangle]\npub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [INPUT [OUTPUT]]\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Filter adjacent matching lines from INPUT (or standard input),\\nwriting to OUTPUT (or standard output).\\n\\nWith no options, matching lines are merged to the first occurrence.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_mandatory_arg_note();\n        fputs_unlocked(\n            gettext(\n                b\"  -c, --count           prefix lines by the number of occurrences\\n  -d, --repeated        only print duplicate lines, one for each group\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -D                    print all duplicate lines\\n      --all-repeated[=METHOD]  like -D, but allow separating groups\\n                                 with an empty line;\\n                                 METHOD={none(default),prepend,separate}\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -f, --skip-fields=N   avoid comparing the first N fields\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --group[=METHOD]  show all items, separating groups with an empty line;\\n                          METHOD={separate(default),prepend,append,both}\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -i, --ignore-case     ignore differences in case when comparing\\n  -s, --skip-chars=N    avoid comparing the first N characters\\n  -u, --unique          only print unique lines\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -z, --zero-terminated     line delimiter is NUL, not newline\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -w, --check-chars=N   compare no more than N characters in lines\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"\\nA field is a run of blanks (usually spaces and/or TABs), then non-blank\\ncharacters.  Fields are skipped before chars.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"\\n'uniq' does not detect repeated lines unless they are adjacent.\\nYou may want to sort the input first, or use 'sort -u' without 'uniq'.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_ancillary_info(b\"uniq\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}\nunsafe extern \"C\" fn strict_posix2() -> bool {\n    let mut posix_ver: libc::c_int = posix2_version();\n    return 200112 as libc::c_int <= posix_ver && posix_ver < 200809 as libc::c_int;\n}\nunsafe extern \"C\" fn size_opt(\n    mut opt: *const libc::c_char,\n    mut msgid: *const libc::c_char,\n) -> idx_t {\n    let mut size: intmax_t = 0;\n    if (LONGINT_OVERFLOW as libc::c_int as libc::c_uint)\n        < xstrtoimax(\n            opt,\n            0 as *mut *mut libc::c_char,\n            10 as libc::c_int,\n            &mut size,\n            b\"\\0\" as *const u8 as *const libc::c_char,\n        ) as libc::c_uint || size < 0 as libc::c_int as libc::c_long\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                0 as libc::c_int,\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                opt,\n                gettext(msgid),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    opt,\n                    gettext(msgid),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    opt,\n                    gettext(msgid),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    return if size < 9223372036854775807 as libc::c_long {\n        size\n    } else {\n        9223372036854775807 as libc::c_long\n    };\n}\nunsafe extern \"C\" fn newline_or_blank(mut g: mcel_t) -> bool {\n    return g.ch == '\\n' as i32 as libc::c_uint || c32isblank(g.ch) != 0;\n}\nunsafe extern \"C\" fn find_field(\n    mut line: *const linebuffer,\n    mut plen: *mut idx_t,\n) -> *mut libc::c_char {\n    let mut lp: *mut libc::c_char = (*line).buffer;\n    let mut lim: *const libc::c_char = lp\n        .offset((*line).length as isize)\n        .offset(-(1 as libc::c_int as isize));\n    let mut i: idx_t = skip_fields;\n    while (0 as libc::c_int as libc::c_long) < i && lp < lim as *mut libc::c_char {\n        lp = skip_buf_matching(\n            lp,\n            lim,\n            Some(newline_or_blank as unsafe extern \"C\" fn(mcel_t) -> bool),\n            1 as libc::c_int != 0,\n        );\n        lp = skip_buf_matching(\n            lp,\n            lim,\n            Some(newline_or_blank as unsafe extern \"C\" fn(mcel_t) -> bool),\n            0 as libc::c_int != 0,\n        );\n        i -= 1;\n        i;\n    }\n    let mut i_0: idx_t = skip_chars;\n    while (0 as libc::c_int as libc::c_long) < i_0 && lp < lim as *mut libc::c_char {\n        lp = lp.offset((mcel_scan(lp, lim)).len as libc::c_int as isize);\n        i_0 -= 1;\n        i_0;\n    }\n    let mut len: idx_t = 0;\n    if lim.offset_from(lp) as libc::c_long <= check_chars {\n        len = lim.offset_from(lp) as libc::c_long;\n    } else if __ctype_get_mb_cur_max() <= 1 as libc::c_int as libc::c_ulong {\n        len = check_chars;\n    } else {\n        let mut ep: *mut libc::c_char = lp;\n        let mut i_1: idx_t = check_chars;\n        while (0 as libc::c_int as libc::c_long) < i_1 && lp < lim as *mut libc::c_char {\n            ep = ep.offset((mcel_scan(lp, lim)).len as libc::c_int as isize);\n            i_1 -= 1;\n            i_1;\n        }\n        len = ep.offset_from(lp) as libc::c_long;\n    }\n    *plen = len;\n    return lp;\n}\nunsafe extern \"C\" fn different(\n    mut old: *mut libc::c_char,\n    mut new: *mut libc::c_char,\n    mut oldlen: idx_t,\n    mut newlen: idx_t,\n) -> bool {\n    if ignore_case {\n        return oldlen != newlen\n            || memcasecmp(\n                old as *const libc::c_void,\n                new as *const libc::c_void,\n                oldlen as size_t,\n            ) != 0\n    } else {\n        return oldlen != newlen\n            || memcmp(\n                old as *const libc::c_void,\n                new as *const libc::c_void,\n                oldlen as libc::c_ulong,\n            ) != 0\n    };\n}\nunsafe extern \"C\" fn writeline(\n    mut line: *const linebuffer,\n    mut match_0: bool,\n    mut linecount: intmax_t,\n) {\n    if if linecount == 0 as libc::c_int as libc::c_long {\n        output_unique as libc::c_int\n    } else if !match_0 {\n        output_first_repeated as libc::c_int\n    } else {\n        output_later_repeated as libc::c_int\n    } == 0\n    {\n        return;\n    }\n    if count_occurrences {\n        printf(\n            b\"%7jd \\0\" as *const u8 as *const libc::c_char,\n            linecount + 1 as libc::c_int as libc::c_long,\n        );\n    }\n    if fwrite_unlocked(\n        (*line).buffer as *const libc::c_void,\n        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,\n        (*line).length as size_t,\n        stdout,\n    ) != (*line).length as libc::c_ulong\n    {\n        write_error();\n    }\n}",
    "unsafe extern \"C\" fn check_file(\n    mut infile: *const libc::c_char,\n    mut outfile: *const libc::c_char,\n    mut delimiter: libc::c_char,\n) {\n    let mut current_block: u64;\n    let mut lb1: linebuffer = linebuffer {\n        size: 0,\n        length: 0,\n        buffer: 0 as *mut libc::c_char,\n    };\n    let mut lb2: linebuffer = linebuffer {\n        size: 0,\n        length: 0,\n        buffer: 0 as *mut libc::c_char,\n    };\n    let mut thisline: *mut linebuffer = 0 as *mut linebuffer;\n    let mut prevline: *mut linebuffer = 0 as *mut linebuffer;\n    if !(strcmp(infile, b\"-\\0\" as *const u8 as *const libc::c_char) == 0 as libc::c_int\n        || !(freopen_safer(infile, b\"r\\0\" as *const u8 as *const libc::c_char, stdin))\n            .is_null())\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    infile,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if !(strcmp(outfile, b\"-\\0\" as *const u8 as *const libc::c_char) == 0 as libc::c_int\n        || !(freopen_safer(outfile, b\"w\\0\" as *const u8 as *const libc::c_char, stdout))\n            .is_null())\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    outfile,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        outfile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        outfile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    fadvise(stdin, FADVISE_SEQUENTIAL);\n    thisline = &mut lb1;\n    prevline = &mut lb2;\n    initbuffer(thisline);\n    initbuffer(prevline);\n    if output_unique as libc::c_int != 0 && output_first_repeated as libc::c_int != 0\n        && !count_occurrences\n    {\n        let mut prevfield: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut prevlen: idx_t = 0;\n        let mut first_group_printed: bool = 0 as libc::c_int != 0;\n        while feof_unlocked(stdin) == 0\n            && !(readlinebuffer_delim(thisline, stdin, delimiter)).is_null()\n        {\n            let mut thislen: idx_t = 0;\n            let mut thisfield: *mut libc::c_char = find_field(thisline, &mut thislen);\n            let mut new_group: bool = prevfield.is_null()\n                || different(thisfield, prevfield, thislen, prevlen) as libc::c_int != 0;\n            if new_group as libc::c_int != 0\n                && grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint\n                && (grouping as libc::c_uint == GM_PREPEND as libc::c_int as libc::c_uint\n                    || grouping as libc::c_uint == GM_BOTH as libc::c_int as libc::c_uint\n                    || first_group_printed as libc::c_int != 0\n                        && (grouping as libc::c_uint\n                            == GM_APPEND as libc::c_int as libc::c_uint\n                            || grouping as libc::c_uint\n                                == GM_SEPARATE as libc::c_int as libc::c_uint))\n            {\n                putchar_unlocked(delimiter as libc::c_int);\n            }\n            if new_group as libc::c_int != 0\n                || grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint\n            {\n                if fwrite_unlocked(\n                    (*thisline).buffer as *const libc::c_void,\n                    ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,\n                    (*thisline).length as size_t,\n                    stdout,\n                ) != (*thisline).length as libc::c_ulong\n                {\n                    write_error();\n                }\n                swap_lines(&mut prevline, &mut thisline);\n                prevfield = thisfield;\n                prevlen = thislen;\n                first_group_printed = 1 as libc::c_int != 0;\n            }\n        }\n        if (grouping as libc::c_uint == GM_BOTH as libc::c_int as libc::c_uint\n            || grouping as libc::c_uint == GM_APPEND as libc::c_int as libc::c_uint)\n            && first_group_printed as libc::c_int != 0\n        {\n            putchar_unlocked(delimiter as libc::c_int);\n        }\n    } else if !(readlinebuffer_delim(prevline, stdin, delimiter)).is_null() {\n        let mut prevlen_0: idx_t = 0;\n        let mut prevfield_0: *mut libc::c_char = find_field(prevline, &mut prevlen_0);\n        let mut match_count: intmax_t = 0 as libc::c_int as intmax_t;\n        let mut first_delimiter: bool = 1 as libc::c_int != 0;\n        loop {\n            if !(feof_unlocked(stdin) == 0) {\n                current_block = 6476622998065200121;\n                break;\n            }\n            if (readlinebuffer_delim(thisline, stdin, delimiter)).is_null() {\n                if ferror_unlocked(stdin) != 0 {\n                    current_block = 6469497169255231809;\n                    break;\n                } else {\n                    current_block = 6476622998065200121;\n                    break;\n                }\n            } else {\n                let mut thislen_0: idx_t = 0;\n                let mut thisfield_0: *mut libc::c_char = find_field(\n                    thisline,\n                    &mut thislen_0,\n                );\n                let mut match_0: bool = !different(\n                    thisfield_0,\n                    prevfield_0,\n                    thislen_0,\n                    prevlen_0,\n                );\n                match_count += match_0 as libc::c_long;\n                if match_count == 9223372036854775807 as libc::c_long {\n                    if count_occurrences {\n                        if 0 != 0 {\n                            error(\n                                1 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"too many repeated lines\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if 1 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"too many repeated lines\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"too many repeated lines\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    }\n                    match_count -= 1;\n                    match_count;\n                }\n                if delimit_groups as libc::c_uint\n                    != DM_NONE as libc::c_int as libc::c_uint\n                {\n                    if !match_0 {\n                        if match_count != 0 {\n                            first_delimiter = 0 as libc::c_int != 0;\n                        }\n                    } else if match_count == 1 as libc::c_int as libc::c_long {\n                        if delimit_groups as libc::c_uint\n                            == DM_PREPEND as libc::c_int as libc::c_uint\n                            || delimit_groups as libc::c_uint\n                                == DM_SEPARATE as libc::c_int as libc::c_uint\n                                && !first_delimiter\n                        {\n                            putchar_unlocked(delimiter as libc::c_int);\n                        }\n                    }\n                }\n                if !match_0 || output_later_repeated as libc::c_int != 0 {\n                    writeline(prevline, match_0, match_count);\n                    swap_lines(&mut prevline, &mut thisline);\n                    prevfield_0 = thisfield_0;\n                    prevlen_0 = thislen_0;\n                    if !match_0 {\n                        match_count = 0 as libc::c_int as intmax_t;\n                    }\n                }\n            }\n        }\n        match current_block {\n            6469497169255231809 => {}\n            _ => {\n                writeline(prevline, 0 as libc::c_int != 0, match_count);\n            }\n        }\n    }\n    if ferror_unlocked(stdin) != 0 || rpl_fclose(stdin) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, infile),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, infile),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, infile),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    free(lb1.buffer as *mut libc::c_void);\n    free(lb2.buffer as *mut libc::c_void);\n}",
    "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut optc: libc::c_int = 0 as libc::c_int;\n    let mut posixly_correct: bool = !(getenv(\n        b\"POSIXLY_CORRECT\\0\" as *const u8 as *const libc::c_char,\n    ))\n        .is_null();\n    let mut skip_field_option_type: Skip_field_option_type = SFO_NONE;\n    let mut nfiles: libc::c_int = 0 as libc::c_int;\n    let mut file: [*const libc::c_char; 2] = [0 as *const libc::c_char; 2];\n    let mut delimiter: libc::c_char = '\\n' as i32 as libc::c_char;\n    let mut output_option_used: bool = 0 as libc::c_int != 0;\n    file[1 as libc::c_int as usize] = b\"-\\0\" as *const u8 as *const libc::c_char;\n    file[0 as libc::c_int as usize] = file[1 as libc::c_int as usize];\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    loop {\n        if optc == -(1 as libc::c_int)\n            || posixly_correct as libc::c_int != 0 && nfiles != 0 as libc::c_int\n            || {\n                optc = getopt_long(\n                    argc,\n                    argv,\n                    b\"-0123456789Dcdf:is:uw:z\\0\" as *const u8 as *const libc::c_char,\n                    longopts.as_ptr(),\n                    0 as *mut libc::c_int,\n                );\n                optc == -(1 as libc::c_int)\n            }\n        {\n            if argc <= optind {\n                break;\n            }\n            if nfiles == 2 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quote(*argv.offset(optind as isize)),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quote(*argv.offset(optind as isize)),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quote(*argv.offset(optind as isize)),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                usage(1 as libc::c_int);\n            }\n            let fresh0 = optind;\n            optind = optind + 1;\n            let fresh1 = nfiles;\n            nfiles = nfiles + 1;\n            file[fresh1 as usize] = *argv.offset(fresh0 as isize);\n        } else {\n            match optc {\n                1 => {\n                    let mut size: intmax_t = 0;\n                    if *optarg.offset(0 as libc::c_int as isize) as libc::c_int\n                        == '+' as i32 && !strict_posix2()\n                        && xstrtoimax(\n                            optarg,\n                            0 as *mut *mut libc::c_char,\n                            10 as libc::c_int,\n                            &mut size,\n                            b\"\\0\" as *const u8 as *const libc::c_char,\n                        ) as libc::c_uint\n                            <= LONGINT_OVERFLOW as libc::c_int as libc::c_uint\n                    {\n                        skip_chars = if size < 9223372036854775807 as libc::c_long {\n                            size\n                        } else {\n                            9223372036854775807 as libc::c_long\n                        };\n                    } else if nfiles == 2 as libc::c_int {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                                    ),\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                                    ),\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                        usage(1 as libc::c_int);\n                    } else {\n                        let fresh2 = nfiles;\n                        nfiles = nfiles + 1;\n                        file[fresh2 as usize] = optarg;\n                    }\n                }\n                48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => {\n                    if skip_field_option_type as libc::c_uint\n                        == SFO_NEW as libc::c_int as libc::c_uint\n                    {\n                        skip_fields = 0 as libc::c_int as idx_t;\n                    }\n                    if !(!((if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                        && ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            skip_fields\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        && ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            10 as libc::c_int\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        && (if (10 as libc::c_int) < 0 as libc::c_int {\n                            if skip_fields < 0 as libc::c_int as libc::c_long {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        -(1 as libc::c_int) as idx_t\n                                    }) + 10 as libc::c_int as libc::c_long\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    (skip_fields\n                                        < -(1 as libc::c_int) as idx_t\n                                            / 10 as libc::c_int as libc::c_long) as libc::c_int\n                                } else {\n                                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                                    {\n                                        !(((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) + 1 as libc::c_int)\n                                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) + 0 as libc::c_int\n                                    }) < 0 as libc::c_int\n                                    {\n                                        ((10 as libc::c_int)\n                                            < -(if ((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                                            {\n                                                ((((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    10 as libc::c_int\n                                                }) + 1 as libc::c_int)\n                                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    10 as libc::c_int\n                                                }) - 1 as libc::c_int\n                                            })) as libc::c_int\n                                    } else {\n                                        ((0 as libc::c_int) < 10 as libc::c_int) as libc::c_int\n                                    }) != 0\n                                    {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + -(1 as libc::c_int) as idx_t\n                                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                    } else {\n                                        -(1 as libc::c_int) as idx_t\n                                            / -(10 as libc::c_int) as libc::c_long\n                                    }) <= -(1 as libc::c_int) as libc::c_long - skip_fields)\n                                        as libc::c_int\n                                }\n                            } else {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) as libc::c_long + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    10 as libc::c_int\n                                                }) as libc::c_long + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    10 as libc::c_int\n                                                }) as libc::c_long + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + 0 as libc::c_int as idx_t)\n                                        as libc::c_int\n                                }) != 0 && 10 as libc::c_int == -(1 as libc::c_int)\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        skip_fields\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < skip_fields + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((0 as libc::c_int as libc::c_long) < skip_fields\n                                            && (-(1 as libc::c_int) as libc::c_long\n                                                - 0 as libc::c_int as idx_t)\n                                                < skip_fields - 1 as libc::c_int as libc::c_long)\n                                            as libc::c_int\n                                    }\n                                } else {\n                                    ((0 as libc::c_int as idx_t\n                                        / 10 as libc::c_int as libc::c_long) < skip_fields)\n                                        as libc::c_int\n                                }\n                            }\n                        } else {\n                            if 10 as libc::c_int == 0 as libc::c_int {\n                                0 as libc::c_int\n                            } else {\n                                if skip_fields < 0 as libc::c_int as libc::c_long {\n                                    if (if (if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            skip_fields\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        !(((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                skip_fields\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long)\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                skip_fields\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 0 as libc::c_int as libc::c_long\n                                    }) < 0 as libc::c_int as libc::c_long\n                                    {\n                                        (((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            skip_fields\n                                        }) + 0 as libc::c_int as idx_t)\n                                            < -(if ((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    skip_fields\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long)\n                                                < 0 as libc::c_int as libc::c_long\n                                            {\n                                                ((((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        skip_fields\n                                                    }) + 0 as libc::c_int as idx_t\n                                                }) + 1 as libc::c_int as libc::c_long)\n                                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                    - 1 as libc::c_int as libc::c_long)\n                                                    * 2 as libc::c_int as libc::c_long\n                                                    + 1 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        skip_fields\n                                                    }) + 0 as libc::c_int as idx_t\n                                                }) - 1 as libc::c_int as libc::c_long\n                                            })) as libc::c_int\n                                    } else {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                skip_fields\n                                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                    }) != 0\n                                        && skip_fields == -(1 as libc::c_int) as libc::c_long\n                                    {\n                                        if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                                        {\n                                            ((0 as libc::c_int as libc::c_long)\n                                                < 10 as libc::c_int as libc::c_long\n                                                    + 0 as libc::c_int as idx_t) as libc::c_int\n                                        } else {\n                                            ((-(1 as libc::c_int) as libc::c_long\n                                                - 0 as libc::c_int as idx_t)\n                                                < (10 as libc::c_int - 1 as libc::c_int) as libc::c_long)\n                                                as libc::c_int\n                                        }\n                                    } else {\n                                        (0 as libc::c_int as idx_t / skip_fields\n                                            < 10 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    ((-(1 as libc::c_int) as idx_t\n                                        / 10 as libc::c_int as libc::c_long) < skip_fields)\n                                        as libc::c_int\n                                }\n                            }\n                        }) != 0\n                    {\n                        let (fresh7, _fresh8) = skip_fields",
    "                            .overflowing_mul((10 as libc::c_int).into());\n                        *(&mut skip_fields as *mut idx_t) = fresh7;\n                        1 as libc::c_int\n                    } else {\n                        let (fresh9, fresh10) = skip_fields\n                            .overflowing_mul((10 as libc::c_int).into());\n                        *(&mut skip_fields as *mut idx_t) = fresh9;\n                        fresh10 as libc::c_int\n                    }) != 0)\n                        && {\n                            let (fresh11, fresh12) = skip_fields\n                                .overflowing_add((optc - '0' as i32).into());\n                            *(&mut skip_fields as *mut idx_t) = fresh11;\n                            !fresh12\n                        })\n                    {\n                        skip_fields = 9223372036854775807 as libc::c_long;\n                    }\n                    skip_field_option_type = SFO_OBSOLETE;\n                }\n                99 => {\n                    count_occurrences = 1 as libc::c_int != 0;\n                    output_option_used = 1 as libc::c_int != 0;\n                }\n                100 => {\n                    output_unique = 0 as libc::c_int != 0;\n                    output_option_used = 1 as libc::c_int != 0;\n                }\n                68 => {\n                    output_unique = 0 as libc::c_int != 0;\n                    output_later_repeated = 1 as libc::c_int != 0;\n                    if optarg.is_null() {\n                        delimit_groups = DM_NONE;\n                    } else {\n                        delimit_groups = delimit_method_map[__xargmatch_internal(\n                            b\"--all-repeated\\0\" as *const u8 as *const libc::c_char,\n                            optarg,\n                            delimit_method_string.as_ptr(),\n                            delimit_method_map.as_ptr() as *const libc::c_void,\n                            ::core::mem::size_of::<delimit_method>() as libc::c_ulong,\n                            argmatch_die,\n                            1 as libc::c_int != 0,\n                        ) as usize];\n                    }\n                    output_option_used = 1 as libc::c_int != 0;\n                }\n                256 => {\n                    if optarg.is_null() {\n                        grouping = GM_SEPARATE;\n                    } else {\n                        grouping = grouping_method_map[__xargmatch_internal(\n                            b\"--group\\0\" as *const u8 as *const libc::c_char,\n                            optarg,\n                            grouping_method_string.as_ptr(),\n                            grouping_method_map.as_ptr() as *const libc::c_void,\n                            ::core::mem::size_of::<grouping_method>() as libc::c_ulong,\n                            argmatch_die,\n                            1 as libc::c_int != 0,\n                        ) as usize];\n                    }\n                }\n                102 => {\n                    skip_field_option_type = SFO_NEW;\n                    skip_fields = size_opt(\n                        optarg,\n                        b\"invalid number of fields to skip\\0\" as *const u8\n                            as *const libc::c_char,\n                    );\n                }\n                105 => {\n                    ignore_case = 1 as libc::c_int != 0;\n                }\n                115 => {\n                    skip_chars = size_opt(\n                        optarg,\n                        b\"invalid number of bytes to skip\\0\" as *const u8\n                            as *const libc::c_char,\n                    );\n                }\n                117 => {\n                    output_first_repeated = 0 as libc::c_int != 0;\n                    output_option_used = 1 as libc::c_int != 0;\n                }\n                119 => {\n                    check_chars = size_opt(\n                        optarg,\n                        b\"invalid number of bytes to compare\\0\" as *const u8\n                            as *const libc::c_char,\n                    );\n                }\n                122 => {\n                    delimiter = '\\0' as i32 as libc::c_char;\n                }\n                -2 => {\n                    usage(0 as libc::c_int);\n                }\n                -3 => {\n                    version_etc(\n                        stdout,\n                        b\"uniq\\0\" as *const u8 as *const libc::c_char,\n                        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                        Version,\n                        proper_name_lite(\n                            b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                            b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        proper_name_lite(\n                            b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                            b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        0 as *mut libc::c_void as *mut libc::c_char,\n                    );\n                    exit(0 as libc::c_int);\n                }\n                _ => {\n                    usage(1 as libc::c_int);\n                }\n            }\n        }\n    }\n    if grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint\n        && output_option_used as libc::c_int != 0\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"--group is mutually exclusive with -c/-d/-D/-u\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"--group is mutually exclusive with -c/-d/-D/-u\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"--group is mutually exclusive with -c/-d/-D/-u\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint\n        && count_occurrences as libc::c_int != 0\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"grouping and printing repeat counts is meaningless\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"grouping and printing repeat counts is meaningless\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"grouping and printing repeat counts is meaningless\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if count_occurrences as libc::c_int != 0 && output_later_repeated as libc::c_int != 0\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"printing all duplicated lines and repeat counts is meaningless\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"printing all duplicated lines and repeat counts is meaningless\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"printing all duplicated lines and repeat counts is meaningless\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    check_file(\n        file[0 as libc::c_int as usize],\n        file[1 as libc::c_int as usize],\n        delimiter,\n    );\n    return 0 as libc::c_int;\n}\npub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "use ::libc;\n#[no_mangle]\npub static mut Version: *const libc::c_char = b\"9.5.42-bbc97\\0\" as *const u8\n    as *const libc::c_char;",
    "use ::libc;\nextern \"C\" {\n    pub type _IO_wide_data;\n    pub type _IO_codecvt;\n    pub type _IO_marker;\n    static mut stdout: *mut FILE;\n    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;\n    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;\n    fn fputs_unlocked(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;\n    static version_etc_copyright: [libc::c_char; 0];\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\npub type __builtin_va_list = __va_list;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct __va_list {\n    pub __stack: *mut libc::c_void,\n    pub __gr_top: *mut libc::c_void,\n    pub __vr_top: *mut libc::c_void,\n    pub __gr_offs: libc::c_int,\n    pub __vr_offs: libc::c_int,\n}\npub type va_list = __builtin_va_list;\npub type size_t = libc::c_ulong;\npub type __off_t = libc::c_long;\npub type __off64_t = libc::c_long;\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}\npub type _IO_lock_t = ();\npub type FILE = _IO_FILE;\npub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;\npub type C2RustUnnamed = libc::c_uint;\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}\n#[no_mangle]\npub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}\n#[no_mangle]\npub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "use ::libc;\n#[no_mangle]\npub static mut version_etc_copyright: [libc::c_char; 47] = unsafe {\n    *::core::mem::transmute::<\n        &[u8; 47],\n        &[libc::c_char; 47],\n    >(b\"Copyright %s %d Free Software Foundation, Inc.\\0\")\n};",
    "use ::libc;\nextern \"C\" {\n    fn abort() -> !;\n    fn error(\n        __status: libc::c_int,\n        __errnum: libc::c_int,\n        __format: *const libc::c_char,\n        _: ...\n    );\n    static mut exit_failure: libc::c_int;\n    fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "use ::libc;\nextern \"C\" {\n    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;\n    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;\n    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;\n    fn reallocarray(\n        __ptr: *mut libc::c_void,\n        __nmemb: size_t,\n        __size: size_t,\n    ) -> *mut libc::c_void;\n    fn xalloc_die();\n    fn __errno_location() -> *mut libc::c_int;\n    fn memcpy(\n        _: *mut libc::c_void,\n        _: *const libc::c_void,\n        _: libc::c_ulong,\n    ) -> *mut libc::c_void;\n    fn strlen(_: *const libc::c_char) -> libc::c_ulong;\n}\npub type ptrdiff_t = libc::c_long;\npub type size_t = libc::c_ulong;\npub type idx_t = ptrdiff_t;\npub const DEFAULT_MXFAST: C2RustUnnamed = 128;\npub type C2RustUnnamed = libc::c_uint;\npub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;\npub type C2RustUnnamed_0 = libc::c_uint;\n#[inline]\nunsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[inline]\nunsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}\n#[inline]\nunsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}\n#[cold]\n#[inline]\nunsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}\n#[inline]\nunsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}\nunsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t",
    "                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}\n#[no_mangle]\npub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}\n#[no_mangle]\npub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "use ::libc;\nextern \"C\" {\n    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;\n    fn __errno_location() -> *mut libc::c_int;\n    fn strtoimax(\n        __nptr: *const libc::c_char,\n        __endptr: *mut *mut libc::c_char,\n        __base: libc::c_int,\n    ) -> intmax_t;\n    fn __ctype_b_loc() -> *mut *const libc::c_ushort;\n    fn __assert_fail(\n        __assertion: *const libc::c_char,\n        __file: *const libc::c_char,\n        __line: libc::c_uint,\n        __function: *const libc::c_char,\n    ) -> !;\n}\npub type __intmax_t = libc::c_long;\npub type intmax_t = __intmax_t;\npub type strtol_error = libc::c_uint;\npub const LONGINT_INVALID: strtol_error = 4;\npub const LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW: strtol_error = 3;\npub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;\npub const LONGINT_OVERFLOW: strtol_error = 1;\npub const LONGINT_OK: strtol_error = 0;\npub const _ISspace: C2RustUnnamed = 8192;\npub type C2RustUnnamed = libc::c_uint;\npub const _ISalnum: C2RustUnnamed = 8;\npub const _ISpunct: C2RustUnnamed = 4;\npub const _IScntrl: C2RustUnnamed = 2;\npub const _ISblank: C2RustUnnamed = 1;\npub const _ISgraph: C2RustUnnamed = 32768;\npub const _ISprint: C2RustUnnamed = 16384;\npub const _ISxdigit: C2RustUnnamed = 4096;\npub const _ISdigit: C2RustUnnamed = 2048;\npub const _ISalpha: C2RustUnnamed = 1024;\npub const _ISlower: C2RustUnnamed = 512;\npub const _ISupper: C2RustUnnamed = 256;\nunsafe extern \"C\" fn bkm_scale(\n    mut x: *mut intmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: intmax_t = 0;\n    if if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { *x })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as intmax_t\n                    }) + scale_factor as libc::c_long\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (*x < -(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + -(1 as libc::c_int) as intmax_t\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as intmax_t / -scale_factor as libc::c_long\n                    }) <= -(1 as libc::c_int) as libc::c_long - *x) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n                        as libc::c_long + 0 as libc::c_int as intmax_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        *x\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < *x + 0 as libc::c_int as intmax_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < *x\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < *x - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as intmax_t / scale_factor as libc::c_long) < *x)\n                        as libc::c_int\n                }\n            }\n        } else {\n            if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    *x\n                                }) + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < scale_factor as libc::c_long\n                                    + 0 as libc::c_int as intmax_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_long)\n                                as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as intmax_t / *x\n                            < scale_factor as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        < *x) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_long {\n            !if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n                -(1 as libc::c_int) as intmax_t\n            } else {\n                (((1 as libc::c_int as intmax_t)\n                    << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            }\n        } else if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n            -(1 as libc::c_int) as intmax_t\n        } else {\n            (((1 as libc::c_int as intmax_t)\n                << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}\nunsafe extern \"C\" fn bkm_scale_by_power(\n    mut x: *mut intmax_t,\n    mut base: libc::c_int,\n    mut power: libc::c_int,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    loop {\n        let fresh8 = power;\n        power = power - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);\n    }\n    return err;\n}\n#[no_mangle]",
    "pub unsafe extern \"C\" fn xstrtoimax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut intmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: intmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 78],\n                &[libc::c_char; 78],\n            >(\n                b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2247: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 78],\n                    &[libc::c_char; 78],\n                >(\n                    b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoimax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as intmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if **p as libc::c_int != '\\0' as i32 {\n        let mut base: libc::c_int = 1024 as libc::c_int;\n        let mut suffixes: libc::c_int = 1 as libc::c_int;\n        let mut overflow: strtol_error = LONGINT_OK;\n        if (strchr(valid_suffixes, **p as libc::c_int)).is_null() {\n            *val = tmp;\n            return (err as libc::c_uint\n                | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                as strtol_error;\n        }\n        match **p as libc::c_int {\n            69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n                if !(strchr(valid_suffixes, '0' as i32)).is_null() {\n                    match *(*p.offset(0 as libc::c_int as isize))\n                        .offset(1 as libc::c_int as isize) as libc::c_int\n                    {\n                        105 => {\n                            if *(*p.offset(0 as libc::c_int as isize))\n                                .offset(2 as libc::c_int as isize) as libc::c_int\n                                == 'B' as i32\n                            {\n                                suffixes += 2 as libc::c_int;\n                            }\n                        }\n                        66 | 68 => {\n                            base = 1000 as libc::c_int;\n                            suffixes += 1;\n                            suffixes;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n            _ => {}\n        }\n        match **p as libc::c_int {\n            98 => {\n                overflow = bkm_scale(&mut tmp, 512 as libc::c_int);\n            }\n            66 => {\n                overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);\n            }\n            99 => {\n                overflow = LONGINT_OK;\n            }\n            69 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);\n            }\n            71 | 103 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);\n            }\n            107 | 75 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);\n            }\n            77 | 109 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);\n            }\n            80 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);\n            }\n            81 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);\n            }\n            82 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);\n            }\n            84 | 116 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);\n            }\n            119 => {\n                overflow = bkm_scale(&mut tmp, 2 as libc::c_int);\n            }\n            89 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);\n            }\n            90 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);\n            }\n            _ => {\n                *val = tmp;\n                return (err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                    as strtol_error;\n            }\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | overflow as libc::c_uint);\n        *p = (*p).offset(suffixes as isize);\n        if **p != 0 {\n            err = ::core::mem::transmute::<\n                libc::c_uint,\n                strtol_error,\n            >(\n                err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint,\n            );\n        }\n    }\n    *val = tmp;\n    return err;\n}"
  ]
}