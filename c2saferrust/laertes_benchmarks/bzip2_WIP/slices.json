[
  {
    "func_defid": "DefId(0:280 ~ c2rust_out[3c70]::bzip2::addFlagsFromEnvVar)",
    "span": "bzip2.rs:2600:1: 2616:2 (#0)",
    "pieces": [
      "bzip2.rs:2600:1: 2616:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "unsafe extern \"C\" fn addFlagsFromEnvVar(mut argList: *mut *mut Cell,\n                                        mut varName: *mut Char) {\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut k: Int32 = 0;\n    let mut envbase: *mut Char = 0 as *mut Char;\n    let mut p: *mut Char = 0 as *mut Char;\n    envbase = getenv(varName);\n    if !envbase.is_null() {\n        p = envbase;\n        i = 0 as std::os::raw::c_int;\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            if *p.offset(i as isize) as std::os::raw::c_int == 0 as std::os::raw::c_int {\n                break ;\n            }\n            p = p.offset(i as isize);\n            i = 0 as std::os::raw::c_int;\n            while isspace(*p.offset(0 as std::os::raw::c_int as isize) as Int32) != 0\n                  {\n                p = p.offset(1)\n            }\n            while *p.offset(i as isize) as std::os::raw::c_int != 0 as std::os::raw::c_int &&\n                      isspace(*p.offset(i as isize) as Int32) == 0 {\n                i += 1\n            }\n            if i > 0 as std::os::raw::c_int {\n                k = i;\n                if k > 1034 as std::os::raw::c_int - 10 as std::os::raw::c_int {\n                    k = 1034 as std::os::raw::c_int - 10 as std::os::raw::c_int\n                }\n                j = 0 as std::os::raw::c_int;\n                while j < k {\n                    tmpName[j as usize] = *p.offset(j as isize);\n                    j += 1\n                }\n                tmpName[k as usize] = 0 as std::os::raw::c_int as Char;\n                *argList = snocString(*argList, tmpName.as_mut_ptr())\n            }\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:330 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2690:1: 2690:45 (#0)",
        "source": "addFlagsFromEnvVar(&mut argList, var_name2);"
      },
      {
        "caller": "DefId(0:330 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2692:1: 2692:45 (#0)",
        "source": "addFlagsFromEnvVar(&mut argList, var_name1);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:422 ~ c2rust_out[3c70]::bzlib::init_RL)",
    "span": "bzlib.rs:314:1: 317:2 (#0)",
    "pieces": [
      "bzlib.rs:314:1: 317:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn init_RL(mut s: *mut EState) {\n    (*s).state_in_ch = 256 as std::os::raw::c_int as UInt32;\n    (*s).state_in_len = 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:508 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompressInit)",
        "span": "bzlib.rs:457:1: 457:16 (#0)",
        "source": "init_RL(s_ref);"
      },
      {
        "caller": "DefId(0:510 ~ c2rust_out[3c70]::bzlib::flush_RL)",
        "span": "bzlib.rs:517:9: 517:24 (#0)",
        "source": "init_RL(s_ref);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:425 ~ c2rust_out[3c70]::bzlib::add_pair_to_block)",
    "span": "bzlib.rs:462:1: 509:2 (#0)",
    "pieces": [
      "bzlib.rs:462:1: 509:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "unsafe extern \"C\" fn add_pair_to_block(mut s: *mut EState) {\n    let mut i: Int32 = 0;\n    let mut ch: UChar = (*s).state_in_ch as UChar;\n    i = 0 as std::os::raw::c_int;\n    while i < (*s).state_in_len {\n        (*s).blockCRC =\n            (*s).blockCRC << 8 as std::os::raw::c_int ^\n                BZ2_crc32Table[((*s).blockCRC >> 24 as std::os::raw::c_int ^\n                                    ch as std::os::raw::c_uint) as usize];\n        i += 1\n    }\n    (*s).inUse[(*s).state_in_ch as usize] = 1 as std::os::raw::c_int as Bool;\n    match (*s).state_in_len {\n        1 => {\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1\n        }\n        2 => {\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1\n        }\n        3 => {\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1\n        }\n        _ => {\n            (*s).inUse[((*s).state_in_len - 4 as std::os::raw::c_int) as usize] =\n                1 as std::os::raw::c_int as Bool;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) =\n                ((*s).state_in_len - 4 as std::os::raw::c_int) as UChar;\n            (*s).nblock += 1\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:510 ~ c2rust_out[3c70]::bzlib::flush_RL)",
        "span": "bzlib.rs:515:13: 515:38 (#0)",
        "source": "add_pair_to_block(s_ref);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:426 ~ c2rust_out[3c70]::bzlib::flush_RL)",
    "span": "bzlib.rs:511:1: 519:2 (#0)",
    "pieces": [
      "bzlib.rs:511:1: 519:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn flush_RL(mut s: *mut EState) {\n    if (*s).state_in_ch < 256 as std::os::raw::c_int as std::os::raw::c_uint {\n        add_pair_to_block(s);\n    }\n    init_RL(s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:254 ~ c2rust_out[3c70]::bzip2::countHardLinks)",
    "span": "bzip2.rs:1739:1: 1763:2 (#0)",
    "pieces": [
      "bzip2.rs:1739:1: 1763:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 25,
    "source": "unsafe extern \"C\" fn countHardLinks(mut name: *mut Char) -> Int32 {\n    let mut i: IntNative = 0;\n    let mut statBuf: stat =\n        stat{st_dev: 0,\n             st_mode: 0,\n             st_nlink: 0,\n             st_ino: 0,\n             st_uid: 0,\n             st_gid: 0,\n             st_rdev: 0,\n             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_size: 0,\n             st_blocks: 0,\n             st_blksize: 0,\n             st_flags: 0,\n             st_gen: 0,\n             st_lspare: 0,\n             st_qspare: [0; 2],};\n    i = lstat(name, &mut statBuf);\n    if i != 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }\n    return statBuf.st_nlink as std::os::raw::c_int - 1 as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:432 ~ c2rust_out[3c70]::bzlib::BZ2_bzDecompressInit)",
    "span": "bzlib.rs:783:1: 822:2 (#0)",
    "pieces": [
      "bzlib.rs:783:1: 822:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 53,
    "source": "pub unsafe extern \"C\" fn BZ2_bzDecompressInit(mut strm: *mut bz_stream,\n                                              mut verbosity: std::os::raw::c_int,\n                                              mut small: std::os::raw::c_int)\n -> std::os::raw::c_int {\n    let mut s: *mut DState = 0 as *mut DState;\n    if bz_config_ok() == 0 { return -(9 as std::os::raw::c_int) }\n    if strm.is_null() { return -(2 as std::os::raw::c_int) }\n    if small != 0 as std::os::raw::c_int && small != 1 as std::os::raw::c_int {\n        return -(2 as std::os::raw::c_int)\n    }\n    if verbosity < 0 as std::os::raw::c_int || verbosity > 4 as std::os::raw::c_int {\n        return -(2 as std::os::raw::c_int)\n    }\n    if (*strm).bzalloc.is_none() {\n        (*strm).bzalloc =\n            Some(default_bzalloc as\n                     unsafe extern \"C\" fn(_: *mut std::os::raw::c_void, _: Int32,\n                                          _: Int32) -> *mut std::os::raw::c_void)\n    }\n    if (*strm).bzfree.is_none() {\n        (*strm).bzfree =\n            Some(default_bzfree as\n                     unsafe extern \"C\" fn(_: *mut std::os::raw::c_void,\n                                          _: *mut std::os::raw::c_void) -> ())\n    }\n    s =\n        (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                            ::std::mem::size_of::<DState>()\n                                                                as\n                                                                std::os::raw::c_ulong\n                                                                as\n                                                                std::os::raw::c_int,\n                                                            1 as std::os::raw::c_int)\n            as *mut DState;\n    if s.is_null() { return -(3 as std::os::raw::c_int) }\n    (*s).strm = strm;\n    (*strm).state = s as *mut std::os::raw::c_void;\n    (*s).state = 10 as std::os::raw::c_int;\n    (*s).bsLive = 0 as std::os::raw::c_int;\n    (*s).bsBuff = 0 as std::os::raw::c_int as UInt32;\n    (*s).calculatedCombinedCRC = 0 as std::os::raw::c_int as UInt32;\n    (*strm).total_in_lo32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*strm).total_in_hi32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*strm).total_out_lo32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*strm).total_out_hi32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*s).smallDecompress = small as Bool;\n    (*s).ll4 = 0 as *mut UChar;\n    (*s).ll16 = 0 as *mut UInt16;\n    (*s).tt = 0 as *mut UInt32;\n    (*s).currBlockNo = 0 as std::os::raw::c_int;\n    (*s).verbosity = verbosity;\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:533 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
        "span": "bzlib.rs:2160:5: 2160:65 (#0)",
        "source": "let ret = BZ2_bzDecompressInit(&mut strm, verbosity, small);"
      },
      {
        "caller": "DefId(0:527 ~ c2rust_out[3c70]::bzlib::BZ2_bzReadOpen)",
        "span": "bzlib.rs:1935:5: 1935:76 (#0)",
        "source": "let mut ret = BZ2_bzDecompressInit(&mut (*bzf).strm, verbosity, small);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:443 ~ c2rust_out[3c70]::bzlib::BZ2_bzReadOpen)",
    "span": "bzlib.rs:1885:1: 1946:2 (#0)",
    "pieces": [
      "bzlib.rs:1885:1: 1946:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 62,
    "source": "pub unsafe extern \"C\" fn BZ2_bzReadOpen(mut bzerror: *mut std::os::raw::c_int,\n                                        mut f: *mut FILE,\n                                        mut verbosity: std::os::raw::c_int,\n                                        mut small: std::os::raw::c_int,\n                                        mut unused: *mut std::os::raw::c_void,\n                                        mut nUnused: std::os::raw::c_int)\n -> *mut std::os::raw::c_void {\n    let mut bzf: *mut bzFile = 0 as *mut bzFile;\n    let mut ret: std::os::raw::c_int = 0;\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    if f.is_null() || small != 0 as std::os::raw::c_int && small != 1 as std::os::raw::c_int\n           || (verbosity < 0 as std::os::raw::c_int || verbosity > 4 as std::os::raw::c_int)\n           || unused.is_null() && nUnused != 0 as std::os::raw::c_int ||\n           !unused.is_null() &&\n               (nUnused < 0 as std::os::raw::c_int || nUnused > 5000 as std::os::raw::c_int) {\n        if !bzerror.is_null() { *bzerror = -(2 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(2 as std::os::raw::c_int) }\n        return 0 as *mut std::os::raw::c_void\n    }\n    if ferror(f) != 0 {\n        if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n        return 0 as *mut std::os::raw::c_void\n    }\n    bzf =\n        malloc(::std::mem::size_of::<bzFile>() as std::os::raw::c_ulong) as\n            *mut bzFile;\n    if bzf.is_null() {\n        if !bzerror.is_null() { *bzerror = -(3 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(3 as std::os::raw::c_int) }\n        return 0 as *mut std::os::raw::c_void\n    }\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    (*bzf).initialisedOk = 0 as std::os::raw::c_int as Bool;\n    (*bzf).handle = f;\n    (*bzf).bufN = 0 as std::os::raw::c_int;\n    (*bzf).writing = 0 as std::os::raw::c_int as Bool;\n    (*bzf).strm.bzalloc = None;\n    (*bzf).strm.bzfree = None;\n    (*bzf).strm.opaque = 0 as *mut std::os::raw::c_void;\n    while nUnused > 0 as std::os::raw::c_int {\n        (*bzf).buf[(*bzf).bufN as usize] = *(unused as *mut UChar) as Char;\n        (*bzf).bufN += 1;\n        unused =\n            (unused as *mut UChar).offset(1 as std::os::raw::c_int as isize) as\n                *mut std::os::raw::c_void;\n        nUnused -= 1\n    }\n    ret = BZ2_bzDecompressInit(&mut (*bzf).strm, verbosity, small);\n    if ret != 0 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = ret }\n        if !bzf.is_null() { (*bzf).lastErr = ret }\n        free(bzf as *mut std::os::raw::c_void);\n        return 0 as *mut std::os::raw::c_void\n    }\n    (*bzf).strm.avail_in = (*bzf).bufN as std::os::raw::c_uint;\n    (*bzf).strm.next_in = (*bzf).buf.as_mut_ptr();\n    (*bzf).initialisedOk = 1 as std::os::raw::c_int as Bool;\n    return bzf as *mut std::os::raw::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:535 ~ c2rust_out[3c70]::bzlib::bzopen_or_bzdopen)",
        "span": "bzlib.rs:2263:12: 2267:6 (#0)",
        "source": "{\n        bzfp =\n            BZ2_bzReadOpen(&mut bzerr, fp, verbosity, smallMode,\n                           unused.as_mut_ptr() as *mut std::os::raw::c_void, nUnused)\n    }"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1160:5: 1163:39 (#0)",
        "source": "let bzf = BZ2_bzReadOpen(&mut bzerr, zStream, verbosity,\n                             smallMode as i32,\n                             unused.as_mut_ptr() as *mut std::ffi::c_void,\n                             nUnused);"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:728:5: 728:121 (#0)",
        "source": "let mut bzf = BZ2_bzReadOpen(&mut bzerr, zStream, verbosity, smallMode as i32, unused.as_mut_ptr().cast(), nUnused);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:431 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompressEnd)",
    "span": "bzlib.rs:751:1: 777:2 (#0)",
    "pieces": [
      "bzlib.rs:751:1: 777:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn BZ2_bzCompressEnd(mut strm: *mut bz_stream)\n -> std::os::raw::c_int {\n    let mut s: *mut EState = 0 as *mut EState;\n    if strm.is_null() { return -(2 as std::os::raw::c_int) }\n    s = (*strm).state as *mut EState;\n    if s.is_null() { return -(2 as std::os::raw::c_int) }\n    if (*s).strm != strm { return -(2 as std::os::raw::c_int) }\n    if !(*s).arr1.is_null() {\n        (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                           (*s).arr1 as\n                                                               *mut std::os::raw::c_void);\n    }\n    if !(*s).arr2.is_null() {\n        (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                           (*s).arr2 as\n                                                               *mut std::os::raw::c_void);\n    }\n    if !(*s).ftab.is_null() {\n        (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                           (*s).ftab as\n                                                               *mut std::os::raw::c_void);\n    }\n    (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                       (*strm).state);\n    (*strm).state = 0 as *mut std::os::raw::c_void;\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:526 ~ c2rust_out[3c70]::bzlib::BZ2_bzWriteClose64)",
        "span": "bzlib.rs:1880:5: 1880:41 (#0)",
        "source": "BZ2_bzCompressEnd(&mut (*bzf).strm);"
      },
      {
        "caller": "DefId(0:532 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffCompress)",
        "span": "bzlib.rs:2122:13: 2122:42 (#0)",
        "source": "BZ2_bzCompressEnd(&mut strm);"
      },
      {
        "caller": "DefId(0:532 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffCompress)",
        "span": "bzlib.rs:2119:13: 2119:42 (#0)",
        "source": "BZ2_bzCompressEnd(&mut strm);"
      },
      {
        "caller": "DefId(0:532 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffCompress)",
        "span": "bzlib.rs:2127:13: 2127:42 (#0)",
        "source": "BZ2_bzCompressEnd(&mut strm);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:429 ~ c2rust_out[3c70]::bzlib::handle_compress)",
    "span": "bzlib.rs:645:1: 688:2 (#0)",
    "pieces": [
      "bzlib.rs:645:1: 688:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 44,
    "source": "unsafe extern \"C\" fn handle_compress(mut strm: *mut bz_stream) -> Bool {\n    let mut progress_in: Bool = 0 as std::os::raw::c_int as Bool;\n    let mut progress_out: Bool = 0 as std::os::raw::c_int as Bool;\n    let mut s: *mut EState = (*strm).state as *mut EState;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        if (*s).state == 1 as std::os::raw::c_int {\n            progress_out =\n                (progress_out as std::os::raw::c_int |\n                     copy_output_until_stop(s) as std::os::raw::c_int) as Bool;\n            if (*s).state_out_pos < (*s).numZ { break ; }\n            if (*s).mode == 4 as std::os::raw::c_int &&\n                   (*s).avail_in_expect == 0 as std::os::raw::c_int as std::os::raw::c_uint &&\n                   isempty_RL(s) as std::os::raw::c_int != 0 {\n                break ;\n            }\n            prepare_new_block(s);\n            (*s).state = 2 as std::os::raw::c_int;\n            if (*s).mode == 3 as std::os::raw::c_int &&\n                   (*s).avail_in_expect == 0 as std::os::raw::c_int as std::os::raw::c_uint &&\n                   isempty_RL(s) as std::os::raw::c_int != 0 {\n                break ;\n            }\n        }\n        if !((*s).state == 2 as std::os::raw::c_int) { continue ; }\n        progress_in =\n            (progress_in as std::os::raw::c_int |\n                 copy_input_until_stop(s) as std::os::raw::c_int) as Bool;\n        if (*s).mode != 2 as std::os::raw::c_int &&\n               (*s).avail_in_expect == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            flush_RL(s);\n            BZ2_compressBlock(s,\n                              ((*s).mode == 4 as std::os::raw::c_int) as std::os::raw::c_int\n                                  as Bool);\n            (*s).state = 1 as std::os::raw::c_int\n        } else if (*s).nblock >= (*s).nblockMAX {\n            BZ2_compressBlock(s, 0 as std::os::raw::c_int as Bool);\n            (*s).state = 1 as std::os::raw::c_int\n        } else if (*(*s).strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            break ;\n        }\n    }\n    return (progress_in as std::os::raw::c_int != 0 ||\n                progress_out as std::os::raw::c_int != 0) as std::os::raw::c_int as Bool;\n}",
    "calls": [
      {
        "caller": "DefId(0:514 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompress)",
        "span": "bzlib.rs:705:21: 705:54 (#0)",
        "source": "progress = handle_compress(strm);"
      },
      {
        "caller": "DefId(0:514 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompress)",
        "span": "bzlib.rs:722:17: 722:50 (#0)",
        "source": "progress = handle_compress(strm);"
      },
      {
        "caller": "DefId(0:514 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompress)",
        "span": "bzlib.rs:735:17: 735:50 (#0)",
        "source": "progress = handle_compress(strm);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:430 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompress)",
    "span": "bzlib.rs:691:1: 748:2 (#0)",
    "pieces": [
      "bzlib.rs:691:1: 748:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 58,
    "source": "pub unsafe extern \"C\" fn BZ2_bzCompress(mut strm: *mut bz_stream,\n                                        mut action: std::os::raw::c_int)\n -> std::os::raw::c_int {\n    let mut progress: Bool = 0;\n    let mut s: *mut EState = 0 as *mut EState;\n    if strm.is_null() { return -(2 as std::os::raw::c_int) }\n    s = (*strm).state as *mut EState;\n    if s.is_null() { return -(2 as std::os::raw::c_int) }\n    if (*s).strm != strm { return -(2 as std::os::raw::c_int) }\n    loop  {\n        match (*s).mode {\n            1 => { return -(1 as std::os::raw::c_int) }\n            2 => {\n                if action == 0 as std::os::raw::c_int {\n                    progress = handle_compress(strm);\n                    return if progress as std::os::raw::c_int != 0 {\n                               1 as std::os::raw::c_int\n                           } else { -(2 as std::os::raw::c_int) }\n                } else if action == 1 as std::os::raw::c_int {\n                    (*s).avail_in_expect = (*strm).avail_in;\n                    (*s).mode = 3 as std::os::raw::c_int\n                } else if action == 2 as std::os::raw::c_int {\n                    (*s).avail_in_expect = (*strm).avail_in;\n                    (*s).mode = 4 as std::os::raw::c_int\n                } else { return -(2 as std::os::raw::c_int) }\n            }\n            3 => {\n                if action != 1 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }\n                if (*s).avail_in_expect != (*(*s).strm).avail_in {\n                    return -(1 as std::os::raw::c_int)\n                }\n                progress = handle_compress(strm);\n                if (*s).avail_in_expect > 0 as std::os::raw::c_int as std::os::raw::c_uint ||\n                       isempty_RL(s) == 0 || (*s).state_out_pos < (*s).numZ {\n                    return 2 as std::os::raw::c_int\n                }\n                (*s).mode = 2 as std::os::raw::c_int;\n                return 1 as std::os::raw::c_int\n            }\n            4 => {\n                if action != 2 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }\n                if (*s).avail_in_expect != (*(*s).strm).avail_in {\n                    return -(1 as std::os::raw::c_int)\n                }\n                progress = handle_compress(strm);\n                if progress == 0 { return -(1 as std::os::raw::c_int) }\n                if (*s).avail_in_expect > 0 as std::os::raw::c_int as std::os::raw::c_uint ||\n                       isempty_RL(s) == 0 || (*s).state_out_pos < (*s).numZ {\n                    return 3 as std::os::raw::c_int\n                }\n                (*s).mode = 1 as std::os::raw::c_int;\n                return 4 as std::os::raw::c_int\n            }\n            _ => { return 0 as std::os::raw::c_int }\n        }\n    };\n    /*--not reached--*/\n}",
    "calls": [
      {
        "caller": "DefId(0:532 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffCompress)",
        "span": "bzlib.rs:2117:9: 2117:48 (#0)",
        "source": "let ret = BZ2_bzCompress(&mut strm, 2);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:421 ~ c2rust_out[3c70]::bzlib::prepare_new_block)",
    "span": "bzlib.rs:300:1: 312:2 (#0)",
    "pieces": [
      "bzlib.rs:300:1: 312:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn prepare_new_block(mut s: *mut EState) {\n    let mut i: Int32 = 0;\n    (*s).nblock = 0 as std::os::raw::c_int;\n    (*s).numZ = 0 as std::os::raw::c_int;\n    (*s).state_out_pos = 0 as std::os::raw::c_int;\n    (*s).blockCRC = 0xffffffff as std::os::raw::c_long as UInt32;\n    i = 0 as std::os::raw::c_int;\n    while i < 256 as std::os::raw::c_int {\n        (*s).inUse[i as usize] = 0 as std::os::raw::c_int as Bool;\n        i += 1\n    }\n    (*s).blockNo += 1;\n}",
    "calls": [
      {
        "caller": "DefId(0:508 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompressInit)",
        "span": "bzlib.rs:458:5: 458:26 (#0)",
        "source": "prepare_new_block(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:424 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompressInit)",
    "span": "bzlib.rs:330:1: 460:2 (#0)",
    "pieces": [
      "bzlib.rs:330:1: 460:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 130,
    "source": "pub unsafe extern \"C\" fn BZ2_bzCompressInit(mut strm: *mut bz_stream,\n                                            mut blockSize100k: std::os::raw::c_int,\n                                            mut verbosity: std::os::raw::c_int,\n                                            mut workFactor: std::os::raw::c_int)\n -> std::os::raw::c_int {\n    let mut n: Int32 = 0;\n    let mut s: *mut EState = 0 as *mut EState;\n    if bz_config_ok() == 0 { return -(9 as std::os::raw::c_int) }\n    if strm.is_null() || blockSize100k < 1 as std::os::raw::c_int ||\n           blockSize100k > 9 as std::os::raw::c_int || workFactor < 0 as std::os::raw::c_int\n           || workFactor > 250 as std::os::raw::c_int {\n        return -(2 as std::os::raw::c_int)\n    }\n    if workFactor == 0 as std::os::raw::c_int { workFactor = 30 as std::os::raw::c_int }\n    if (*strm).bzalloc.is_none() {\n        (*strm).bzalloc =\n            Some(default_bzalloc as\n                     unsafe extern \"C\" fn(_: *mut std::os::raw::c_void, _: Int32,\n                                          _: Int32) -> *mut std::os::raw::c_void)\n    }\n    if (*strm).bzfree.is_none() {\n        (*strm).bzfree =\n            Some(default_bzfree as\n                     unsafe extern \"C\" fn(_: *mut std::os::raw::c_void,\n                                          _: *mut std::os::raw::c_void) -> ())\n    }\n    s =\n        (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                            ::std::mem::size_of::<EState>()\n                                                                as\n                                                                std::os::raw::c_ulong\n                                                                as\n                                                                std::os::raw::c_int,\n                                                            1 as std::os::raw::c_int)\n            as *mut EState;\n    if s.is_null() { return -(3 as std::os::raw::c_int) }\n    (*s).strm = strm;\n    (*s).arr1 = 0 as *mut UInt32;\n    (*s).arr2 = 0 as *mut UInt32;\n    (*s).ftab = 0 as *mut UInt32;\n    n = 100000 as std::os::raw::c_int * blockSize100k;\n    (*s).arr1 =\n        (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                            (n as\n                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UInt32>()\n                                                                                                 as\n                                                                                                 std::os::raw::c_ulong)\n                                                                as\n                                                                std::os::raw::c_int,\n                                                            1 as std::os::raw::c_int)\n            as *mut UInt32;\n    (*s).arr2 =\n        (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                            ((n +\n                                                                  (2 as\n                                                                       std::os::raw::c_int\n                                                                       +\n                                                                       12 as\n                                                                           std::os::raw::c_int\n                                                                       +\n                                                                       18 as\n                                                                           std::os::raw::c_int\n                                                                       +\n                                                                       2 as\n                                                                           std::os::raw::c_int))\n                                                                 as\n                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UInt32>()\n                                                                                                 as\n                                                                                                 std::os::raw::c_ulong)\n                                                                as\n                                                                std::os::raw::c_int,\n                                                            1 as std::os::raw::c_int)\n            as *mut UInt32;\n    (*s).ftab =\n        (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                            (65537 as\n                                                                 std::os::raw::c_int\n                                                                 as\n                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UInt32>()\n                                                                                                 as\n                                                                                                 std::os::raw::c_ulong)\n                                                                as\n                                                                std::os::raw::c_int,\n                                                            1 as std::os::raw::c_int)\n            as *mut UInt32;\n    if (*s).arr1.is_null() || (*s).arr2.is_null() || (*s).ftab.is_null() {\n        if !(*s).arr1.is_null() {\n            (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                               (*s).arr1 as\n                                                                   *mut std::os::raw::c_void);\n        }\n        if !(*s).arr2.is_null() {\n            (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                               (*s).arr2 as\n                                                                   *mut std::os::raw::c_void);\n        }\n        if !(*s).ftab.is_null() {\n            (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                               (*s).ftab as\n                                                                   *mut std::os::raw::c_void);\n        }\n        if !s.is_null() {\n            (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                               s as\n                                                                   *mut std::os::raw::c_void);\n        }\n        return -(3 as std::os::raw::c_int)\n    }\n    (*s).blockNo = 0 as std::os::raw::c_int;\n    (*s).state = 2 as std::os::raw::c_int;\n    (*s).mode = 2 as std::os::raw::c_int;\n    (*s).combinedCRC = 0 as std::os::raw::c_int as UInt32;\n    (*s).blockSize100k = blockSize100k;\n    (*s).nblockMAX =\n        100000 as std::os::raw::c_int * blockSize100k - 19 as std::os::raw::c_int;\n    (*s).verbosity = verbosity;\n    (*s).workFactor = workFactor;\n    (*s).block = (*s).arr2 as *mut UChar;\n    (*s).mtfv = (*s).arr1 as *mut UInt16;\n    (*s).zbits = 0 as *mut UChar;\n    (*s).ptr = (*s).arr1;\n    (*strm).state = s as *mut std::os::raw::c_void;\n    (*strm).total_in_lo32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*strm).total_in_hi32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*strm).total_out_lo32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*strm).total_out_hi32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    init_RL(s);\n    prepare_new_block(s);\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:523 ~ c2rust_out[3c70]::bzlib::BZ2_bzWriteOpen)",
        "span": "bzlib.rs:1699:5: 1701:40 (#0)",
        "source": "ret =\n        BZ2_bzCompressInit(&mut (*bzf).strm, blockSize100k, verbosity,\n                           workFactor);"
      },
      {
        "caller": "DefId(0:532 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffCompress)",
        "span": "bzlib.rs:2107:9: 2107:87 (#0)",
        "source": "let ret = BZ2_bzCompressInit(&mut strm, blockSize100k, verbosity, workFactor);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:447 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffCompress)",
    "span": "bzlib.rs:2085:1: 2131:2 (#0)",
    "pieces": [
      "bzlib.rs:2085:1: 2131:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 56,
    "source": "pub unsafe extern \"C\" fn BZ2_bzBuffToBuffCompress(mut dest: *mut std::os::raw::c_char,\n                                                  mut destLen:\n                                                      *mut std::os::raw::c_uint,\n                                                  mut source:\n                                                      *mut std::os::raw::c_char,\n                                                  mut sourceLen: std::os::raw::c_uint,\n                                                  mut blockSize100k:\n                                                      std::os::raw::c_int,\n                                                  mut verbosity: std::os::raw::c_int,\n                                                  mut workFactor: std::os::raw::c_int)\n -> std::os::raw::c_int {\n    let mut strm: bz_stream =\n        bz_stream{next_in: 0 as *mut std::os::raw::c_char,\n                  avail_in: 0,\n                  total_in_lo32: 0,\n                  total_in_hi32: 0,\n                  next_out: 0 as *mut std::os::raw::c_char,\n                  avail_out: 0,\n                  total_out_lo32: 0,\n                  total_out_hi32: 0,\n                  state: 0 as *mut std::os::raw::c_void,\n                  bzalloc: None,\n                  bzfree: None,\n                  opaque: 0 as *mut std::os::raw::c_void,};\n    let mut ret: std::os::raw::c_int = 0;\n    if dest.is_null() || destLen.is_null() || source.is_null() ||\n           blockSize100k < 1 as std::os::raw::c_int ||\n           blockSize100k > 9 as std::os::raw::c_int || verbosity < 0 as std::os::raw::c_int ||\n           verbosity > 4 as std::os::raw::c_int || workFactor < 0 as std::os::raw::c_int ||\n           workFactor > 250 as std::os::raw::c_int {\n        return -(2 as std::os::raw::c_int)\n    }\n    if workFactor == 0 as std::os::raw::c_int { workFactor = 30 as std::os::raw::c_int }\n    strm.bzalloc = None;\n    strm.bzfree = None;\n    strm.opaque = 0 as *mut std::os::raw::c_void;\n    ret = BZ2_bzCompressInit(&mut strm, blockSize100k, verbosity, workFactor);\n    if ret != 0 as std::os::raw::c_int { return ret }\n    strm.next_in = source;\n    strm.next_out = dest;\n    strm.avail_in = sourceLen;\n    strm.avail_out = *destLen;\n    ret = BZ2_bzCompress(&mut strm, 2 as std::os::raw::c_int);\n    if ret == 3 as std::os::raw::c_int {\n        BZ2_bzCompressEnd(&mut strm);\n        return -(8 as std::os::raw::c_int)\n    } else if ret != 4 as std::os::raw::c_int {\n        BZ2_bzCompressEnd(&mut strm);\n        return ret\n    } else {\n        /* normal termination */\n        *destLen = (*destLen).wrapping_sub(strm.avail_out);\n        BZ2_bzCompressEnd(&mut strm);\n        return 0 as std::os::raw::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:208 ~ c2rust_out[3c70]::bzip2::uInt64_from_UInt32s)",
    "span": "bzip2.rs:430:1: 439:2 (#0)",
    "pieces": [
      "bzip2.rs:430:1: 439:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 25,
    "source": "unsafe extern \"C\" fn uInt64_from_UInt32s(mut n: *mut UInt64, mut lo32: UInt32,\n                                         mut hi32: UInt32) {\n    (*n).b[7 as std::os::raw::c_int as usize] =\n        (hi32 >> 24 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n            UChar;\n    (*n).b[6 as std::os::raw::c_int as usize] =\n        (hi32 >> 16 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n            UChar;\n    (*n).b[5 as std::os::raw::c_int as usize] =\n        (hi32 >> 8 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n            UChar;\n    (*n).b[4 as std::os::raw::c_int as usize] =\n        (hi32 & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as UChar;\n    (*n).b[3 as std::os::raw::c_int as usize] =\n        (lo32 >> 24 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n            UChar;\n    (*n).b[2 as std::os::raw::c_int as usize] =\n        (lo32 >> 16 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n            UChar;\n    (*n).b[1 as std::os::raw::c_int as usize] =\n        (lo32 >> 8 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n            UChar;\n    (*n).b[0 as std::os::raw::c_int as usize] =\n        (lo32 & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as UChar;\n}",
    "calls": [
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:623:41: 623:109 (#0)",
        "source": "uInt64_from_UInt32s(&mut nbytes_in, nbytes_in_lo32, nbytes_in_hi32);"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:624:41: 624:112 (#0)",
        "source": "uInt64_from_UInt32s(&mut nbytes_out, nbytes_out_lo32, nbytes_out_hi32);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:235 ~ c2rust_out[3c70]::bzip2::setExit)",
    "span": "bzip2.rs:1437:1: 1441:2 (#0)",
    "pieces": [
      "bzip2.rs:1437:1: 1441:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn setExit(mut v: Int32) {\n    if v > exitValue { exitValue = v };\n}",
    "calls": [
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2362:17: 2362:28 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2244:9: 2244:20 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2236:9: 2236:20 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2266:9: 2266:20 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2091:17: 2091:28 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2065:17: 2065:28 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:1983:9: 1983:20 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:330 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2943:9: 2943:20 (#0)",
        "source": "setExit(2);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2044:9: 2044:20 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:284 ~ c2rust_out[3c70]::bzip2::cleanUpAndFail)",
        "span": "bzip2.rs:1530:5: 1530:17 (#0)",
        "source": "setExit(ec);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2353:17: 2353:28 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:291 ~ c2rust_out[3c70]::bzip2::mySIGSEGVorSIGBUScatcher)",
        "span": "bzip2.rs:1608:9: 1608:20 (#0)",
        "source": "setExit(3);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2254:13: 2254:24 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2335:17: 2335:28 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2083:17: 2083:28 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:321 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2486:13: 2486:24 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:321 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2500:17: 2500:28 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2031:13: 2031:24 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2118:17: 2118:28 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:321 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2514:17: 2514:28 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:291 ~ c2rust_out[3c70]::bzip2::mySIGSEGVorSIGBUScatcher)",
        "span": "bzip2.rs:1609:14: 1609:25 (#0)",
        "source": "setExit(2);"
      },
      {
        "caller": "DefId(0:330 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2967:9: 2967:20 (#0)",
        "source": "setExit(2);"
      },
      {
        "caller": "DefId(0:321 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2468:9: 2468:20 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2408:9: 2408:20 (#0)",
        "source": "setExit(2);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:1975:9: 1975:20 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:297 ~ c2rust_out[3c70]::bzip2::copyFileName)",
        "span": "bzip2.rs:1661:9: 1661:20 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2320:17: 2320:28 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2007:13: 2007:24 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2287:13: 2287:24 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2300:9: 2300:20 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2109:17: 2109:28 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:321 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2476:9: 2476:20 (#0)",
        "source": "setExit(1);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2019:9: 2019:20 (#0)",
        "source": "setExit(1);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:408:1: 408:37 (#0)",
        "source": "pub static mut exitValue: Int32 = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:238 ~ c2rust_out[3c70]::bzip2::cleanUpAndFail)",
    "span": "bzip2.rs:1463:1: 1532:2 (#0)",
    "pieces": [
      "bzip2.rs:1463:1: 1532:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 70,
    "source": "unsafe extern \"C\" fn cleanUpAndFail(mut ec: Int32) -> ! {\n    let mut retVal: IntNative = 0;\n    let mut statBuf: stat =\n        stat{st_dev: 0,\n             st_mode: 0,\n             st_nlink: 0,\n             st_ino: 0,\n             st_uid: 0,\n             st_gid: 0,\n             st_rdev: 0,\n             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_size: 0,\n             st_blocks: 0,\n             st_blksize: 0,\n             st_flags: 0,\n             st_gen: 0,\n             st_lspare: 0,\n             st_qspare: [0; 2],};\n    if srcMode == 3 as std::os::raw::c_int && opMode != 3 as std::os::raw::c_int &&\n           deleteOutputOnInterrupt as std::os::raw::c_int != 0 {\n        /* Check whether input file still exists.  Delete output file\n         only if input exists to avoid loss of data.  Joerg Prante, 5\n         January 2002.  (JRS 06-Jan-2002: other changes in 1.0.2 mean\n         this is less likely to happen.  But to be ultra-paranoid, we\n         do the check anyway.)  */\n        retVal = stat(inName.as_mut_ptr(), &mut statBuf);\n        if retVal == 0 as std::os::raw::c_int {\n            if noisy != 0 {\n                fprintf(__stderrp,\n                        b\"%s: Deleting output file %s, if it exists.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        outName.as_mut_ptr());\n            }\n            if !outputHandleJustInCase.is_null() {\n                fclose(outputHandleJustInCase);\n            }\n            retVal = remove(outName.as_mut_ptr());\n            if retVal != 0 as std::os::raw::c_int {\n                fprintf(__stderrp,\n                        b\"%s: WARNING: deletion of output file (apparently) failed.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char, progName);\n            }\n        } else {\n            fprintf(__stderrp,\n                    b\"%s: WARNING: deletion of output file suppressed\\n\\x00\"\n                        as *const u8 as *const std::os::raw::c_char, progName);\n            fprintf(__stderrp,\n                    b\"%s:    since input file no longer exists.  Output file\\n\\x00\"\n                        as *const u8 as *const std::os::raw::c_char, progName);\n            fprintf(__stderrp,\n                    b\"%s:    `%s\\' may be incomplete.\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, progName, outName.as_mut_ptr());\n            fprintf(__stderrp,\n                    b\"%s:    I suggest doing an integrity test (bzip2 -tv) of it.\\n\\x00\"\n                        as *const u8 as *const std::os::raw::c_char, progName);\n        }\n    }\n    if noisy as std::os::raw::c_int != 0 && numFileNames > 0 as std::os::raw::c_int &&\n           numFilesProcessed < numFileNames {\n        fprintf(__stderrp,\n                b\"%s: WARNING: some files have not been processed:\\n%s:    %d specified on command line, %d not processed yet.\\n\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char, progName, progName,\n                numFileNames, numFileNames - numFilesProcessed);\n    }\n    setExit(ec);\n    exit(exitValue);\n}",
    "calls": [
      {
        "caller": "DefId(0:286 ~ c2rust_out[3c70]::bzip2::panic)",
        "span": "bzip2.rs:1537:14: 1537:32 (#0)",
        "source": "cleanUpAndFail(3);"
      },
      {
        "caller": "DefId(0:287 ~ c2rust_out[3c70]::bzip2::crcError)",
        "span": "bzip2.rs:1545:14: 1545:32 (#0)",
        "source": "cleanUpAndFail(2);"
      },
      {
        "caller": "DefId(0:292 ~ c2rust_out[3c70]::bzip2::outOfMemory)",
        "span": "bzip2.rs:1617:9: 1617:27 (#0)",
        "source": "cleanUpAndFail(1);"
      },
      {
        "caller": "DefId(0:290 ~ c2rust_out[3c70]::bzip2::mySignalCatcher)",
        "span": "bzip2.rs:1570:5: 1570:23 (#0)",
        "source": "cleanUpAndFail(1);"
      },
      {
        "caller": "DefId(0:288 ~ c2rust_out[3c70]::bzip2::compressedStreamEOF)",
        "span": "bzip2.rs:1557:9: 1557:27 (#0)",
        "source": "cleanUpAndFail(2);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:426:1: 427:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      },
      {
        "span": "bzip2.rs:402:1: 402:40 (#0)",
        "source": "pub static mut numFileNames: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:404:1: 404:45 (#0)",
        "source": "pub static mut numFilesProcessed: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:408:1: 408:37 (#0)",
        "source": "pub static mut exitValue: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:416:1: 416:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:422:1: 422:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      },
      {
        "span": "bzip2.rs:418:1: 418:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:237 ~ c2rust_out[3c70]::bzip2::showFileNames)",
    "span": "bzip2.rs:1454:1: 1460:2 (#0)",
    "pieces": [
      "bzip2.rs:1454:1: 1460:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn showFileNames() {\n    if noisy != 0 {\n        fprintf(__stderrp,\n                b\"\\tInput file = %s, output file = %s\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, inName.as_mut_ptr(),\n                outName.as_mut_ptr());\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:288 ~ c2rust_out[3c70]::bzip2::compressedStreamEOF)",
        "span": "bzip2.rs:1554:13: 1554:29 (#0)",
        "source": "showFileNames();"
      },
      {
        "caller": "DefId(0:287 ~ c2rust_out[3c70]::bzip2::crcError)",
        "span": "bzip2.rs:1543:5: 1543:21 (#0)",
        "source": "showFileNames();"
      },
      {
        "caller": "DefId(0:286 ~ c2rust_out[3c70]::bzip2::panic)",
        "span": "bzip2.rs:1536:5: 1536:21 (#0)",
        "source": "showFileNames();"
      },
      {
        "caller": "DefId(0:292 ~ c2rust_out[3c70]::bzip2::outOfMemory)",
        "span": "bzip2.rs:1615:5: 1615:21 (#0)",
        "source": "showFileNames();"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:416:1: 416:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:418:1: 418:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:243 ~ c2rust_out[3c70]::bzip2::ioError)",
    "span": "bzip2.rs:1562:1: 1565:2 (#0)",
    "pieces": [
      "bzip2.rs:1562:1: 1565:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn ioError() -> ! {\n    fprintf(__stderrp,\n            b\"\\n%s: I/O or other error, bailing out.  Possible reason follows.\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, progName);\n    perror(progName);\n    showFileNames();\n    cleanUpAndFail(1 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:306 ~ c2rust_out[3c70]::bzip2::saveInputFileMetaInfo)",
        "span": "bzip2.rs:1831:13: 1831:23 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2390:57: 2390:67 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2398:55: 2398:65 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:308 ~ c2rust_out[3c70]::bzip2::applySavedTimeInfoToOutputFile)",
        "span": "bzip2.rs:1844:9: 1844:31 (#0)",
        "source": "return Err(ioError());"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1430:5: 1430:15 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2145:53: 2145:63 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:309 ~ c2rust_out[3c70]::bzip2::applySavedFileAttrToOutputFile)",
        "span": "bzip2.rs:1857:9: 1857:19 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:703:5: 703:15 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1133:5: 1133:15 (#0)",
        "source": "ioError();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:260 ~ c2rust_out[3c70]::bzip2::applySavedFileAttrToOutputFile)",
    "span": "bzip2.rs:1849:1: 1871:2 (#0)",
    "pieces": [
      "bzip2.rs:1849:1: 1871:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn applySavedFileAttrToOutputFile(mut fd: IntNative) {\n    let mut retVal: IntNative = 0;\n    retVal = fchmod(fd, fileMetaInfo.st_mode);\n    if retVal != 0 as std::os::raw::c_int { ioError(); }\n    fchown(fd, fileMetaInfo.st_uid, fileMetaInfo.st_gid);\n    /* chown() will in many cases return with EPERM, which can\n      be safely ignored.\n   */\n}",
    "calls": [
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1097:13: 1097:48 (#0)",
        "source": "applySavedFileAttrToOutputFile(fd);"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:590:25: 590:60 (#0)",
        "source": "applySavedFileAttrToOutputFile(fd);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:1787:1: 1805:30 (#0)",
        "source": "static mut fileMetaInfo: stat =\n    stat{st_dev: 0,\n         st_mode: 0,\n         st_nlink: 0,\n         st_ino: 0,\n         st_uid: 0,\n         st_gid: 0,\n         st_rdev: 0,\n         st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_size: 0,\n         st_blocks: 0,\n         st_blksize: 0,\n         st_flags: 0,\n         st_gen: 0,\n         st_lspare: 0,\n         st_qspare: [0; 2],};"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:339 ~ c2rust_out[3c70]::bzip2recover::bsPutUInt32)",
    "span": "bzip2recover.rs:264:1: 271:2 (#0)",
    "pieces": [
      "bzip2recover.rs:264:1: 271:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn bsPutUInt32(mut bs: *mut BitStream, mut c: UInt32) {\n    let mut i: Int32 = 0;\n    i = 31 as std::os::raw::c_int;\n    while i >= 0 as std::os::raw::c_int {\n        bsPutBit(bs, (c >> i & 0x1 as std::os::raw::c_int as std::os::raw::c_uint) as Int32);\n        i -= 1\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:499 ~ c2rust_out[3c70]::compress::bsW)",
    "span": "compress.rs:112:1: 122:2 (#0)",
    "pieces": [
      "compress.rs:112:1: 122:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn bsW(mut s: *mut EState, mut n: Int32, mut v: UInt32) {\n    while (*s).bsLive >= 8 as std::os::raw::c_int {\n        *(*s).zbits.offset((*s).numZ as isize) =\n            ((*s).bsBuff >> 24 as std::os::raw::c_int) as UChar;\n        (*s).numZ += 1;\n        (*s).bsBuff <<= 8 as std::os::raw::c_int;\n        (*s).bsLive -= 8 as std::os::raw::c_int\n    }\n    (*s).bsBuff |= v << 32 as std::os::raw::c_int - (*s).bsLive - n;\n    (*s).bsLive += n;\n}",
    "calls": [
      {
        "caller": "DefId(0:594 ~ c2rust_out[3c70]::compress::sendMTFValues)",
        "span": "compress.rs:1013:1: 1013:31 (#0)",
        "source": "bsW(s, 15, nSelectors as u32);"
      },
      {
        "caller": "DefId(0:589 ~ c2rust_out[3c70]::compress::bsPutUChar)",
        "span": "compress.rs:141:9: 141:32 (#0)",
        "source": "bsW(s, 8, c as UInt32);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1334:9: 1334:67 (#0)",
        "source": "bsW(s, 24 as std::os::raw::c_int, (*s).origPtr as UInt32);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1333:9: 1333:78 (#0)",
        "source": "bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);"
      },
      {
        "caller": "DefId(0:594 ~ c2rust_out[3c70]::compress::sendMTFValues)",
        "span": "compress.rs:1012:1: 1012:27 (#0)",
        "source": "bsW(s, 3, nGroups as u32);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "compress.rs:43:1: 43:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:39:1: 39:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:40:1: 40:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:41:1: 41:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:42:1: 42:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:435 ~ c2rust_out[3c70]::bzlib::unRLE_obuf_to_output_SMALL)",
    "span": "bzlib.rs:1183:1: 1561:2 (#0)",
    "pieces": [
      "bzlib.rs:1183:1: 1188:12 (#0)",
      "bzlib.rs:1256:1: 1256:12 (#0)",
      "bzlib.rs:1403:1: 1407:12 (#0)",
      "bzlib.rs:1462:1: 1462:12 (#0)",
      "bzlib.rs:1558:1: 1561:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1,
      2,
      3
    ],
    "num_lines": 17,
    "source": "unsafe extern \"C\" fn unRLE_obuf_to_output_SMALL(mut s: *mut DState) -> Bool {\n    let mut k1: UChar = 0;\n    if (*s).blockRandomised != 0 {\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /* try to finish existing run */\n           <<chunk 0>>           <<chunk 1>>        }\n    } else {\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /* try to finish existing run */\n           <<chunk 2>>           <<chunk 3>>        }\n    }\n    panic!(\"Reached end of non-void function without returning\");\n}",
    "calls": [
      {
        "caller": "DefId(0:520 ~ c2rust_out[3c70]::bzlib::BZ2_bzDecompress)",
        "span": "bzlib.rs:1579:17: 1579:57 (#0)",
        "source": "unsafe { unRLE_obuf_to_output_SMALL(s) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "bzlib.rs:1188:13: 1255:14 (#0)",
        "pieces": [
          "bzlib.rs:1188:13: 1255:14 (#0)"
        ],
        "num_lines": 68,
        "source": "while 1 as std::os::raw::c_int as Bool != 0 {\n                if (*(*s).strm).avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint\n                   {\n                    return 0 as std::os::raw::c_int as Bool\n                }\n                if (*s).state_out_len == 0 as std::os::raw::c_int { break ; }\n                *((*(*s).strm).next_out as *mut UChar) = (*s).state_out_ch;\n                (*s).calculatedBlockCRC =\n                    (*s).calculatedBlockCRC << 8 as std::os::raw::c_int ^\n                        BZ2_crc32Table[((*s).calculatedBlockCRC >>\n                                            24 as std::os::raw::c_int ^\n                                            (*s).state_out_ch as std::os::raw::c_uint)\n                                           as usize];\n                (*s).state_out_len -= 1;\n                (*(*s).strm).next_out = (*(*s).strm).next_out.offset(1);\n                (*(*s).strm).avail_out =\n                    (*(*s).strm).avail_out.wrapping_sub(1);\n                (*(*s).strm).total_out_lo32 =\n                    (*(*s).strm).total_out_lo32.wrapping_add(1);\n                if (*(*s).strm).total_out_lo32 ==\n                       0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    (*(*s).strm).total_out_hi32 =\n                        (*(*s).strm).total_out_hi32.wrapping_add(1)\n                }\n            }\n            /* can a new run be started? */\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                return 0 as std::os::raw::c_int as Bool\n            }\n            /* Only caused by corrupt data stream? */\n            if (*s).nblock_used > (*s).save_nblock + 1 as std::os::raw::c_int {\n                return 1 as std::os::raw::c_int as Bool\n            }\n            (*s).state_out_len = 1 as std::os::raw::c_int;\n            (*s).state_out_ch = (*s).k0 as UChar;\n            if (*s).tPos >=\n                   (100000 as std::os::raw::c_int as\n                        UInt32).wrapping_mul((*s).blockSize100k as UInt32) {\n                return 1 as std::os::raw::c_int as Bool\n            }\n            k1 =\n                BZ2_indexIntoF((*s).tPos as Int32, (*s).cftab.as_mut_ptr()) as\n                    UChar;\n            (*s).tPos =\n                *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                    (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int) as\n                                          isize) as UInt32 >>\n                         ((*s).tPos << 2 as std::os::raw::c_int &\n                              0x4 as std::os::raw::c_int as std::os::raw::c_uint) &\n                         0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                        16 as std::os::raw::c_int;\n            if (*s).rNToGo == 0 as std::os::raw::c_int {\n                (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                (*s).rTPos += 1;\n                if (*s).rTPos == 512 as std::os::raw::c_int {\n                    (*s).rTPos = 0 as std::os::raw::c_int\n                }\n            }\n            (*s).rNToGo -= 1;\n            k1 =\n                (k1 as std::os::raw::c_int ^\n                     if (*s).rNToGo == 1 as std::os::raw::c_int {\n                         1 as std::os::raw::c_int\n                     } else { 0 as std::os::raw::c_int }) as UChar;\n            (*s).nblock_used += 1;\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                continue ;\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut k1: u8"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut k1: u8"
        ]
      },
      {
        "chunk_id": 1,
        "span": "bzlib.rs:1256:13: 1402:14 (#0)",
        "pieces": [
          "bzlib.rs:1256:13: 1402:14 (#0)"
        ],
        "num_lines": 147,
        "source": "if k1 as std::os::raw::c_int != (*s).k0 {\n                (*s).k0 = k1 as Int32\n            } else {\n                (*s).state_out_len = 2 as std::os::raw::c_int;\n                if (*s).tPos >=\n                       (100000 as std::os::raw::c_int as\n                            UInt32).wrapping_mul((*s).blockSize100k as UInt32)\n                   {\n                    return 1 as std::os::raw::c_int as Bool\n                }\n                k1 =\n                    BZ2_indexIntoF((*s).tPos as Int32,\n                                   (*s).cftab.as_mut_ptr()) as UChar;\n                (*s).tPos =\n                    *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                        (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int) as\n                                              isize) as UInt32 >>\n                             ((*s).tPos << 2 as std::os::raw::c_int &\n                                  0x4 as std::os::raw::c_int as std::os::raw::c_uint) &\n                             0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                            16 as std::os::raw::c_int;\n                if (*s).rNToGo == 0 as std::os::raw::c_int {\n                    (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                    (*s).rTPos += 1;\n                    if (*s).rTPos == 512 as std::os::raw::c_int {\n                        (*s).rTPos = 0 as std::os::raw::c_int\n                    }\n                }\n                (*s).rNToGo -= 1;\n                k1 =\n                    (k1 as std::os::raw::c_int ^\n                         if (*s).rNToGo == 1 as std::os::raw::c_int {\n                             1 as std::os::raw::c_int\n                         } else { 0 as std::os::raw::c_int }) as UChar;\n                (*s).nblock_used += 1;\n                if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                    continue ;\n                }\n                if k1 as std::os::raw::c_int != (*s).k0 {\n                    (*s).k0 = k1 as Int32\n                } else {\n                    (*s).state_out_len = 3 as std::os::raw::c_int;\n                    if (*s).tPos >=\n                           (100000 as std::os::raw::c_int as\n                                UInt32).wrapping_mul((*s).blockSize100k as\n                                                         UInt32) {\n                        return 1 as std::os::raw::c_int as Bool\n                    }\n                    k1 =\n                        BZ2_indexIntoF((*s).tPos as Int32,\n                                       (*s).cftab.as_mut_ptr()) as UChar;\n                    (*s).tPos =\n                        *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                            (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int)\n                                                  as isize) as UInt32 >>\n                                 ((*s).tPos << 2 as std::os::raw::c_int &\n                                      0x4 as std::os::raw::c_int as std::os::raw::c_uint) &\n                                 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                                16 as std::os::raw::c_int;\n                    if (*s).rNToGo == 0 as std::os::raw::c_int {\n                        (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                        (*s).rTPos += 1;\n                        if (*s).rTPos == 512 as std::os::raw::c_int {\n                            (*s).rTPos = 0 as std::os::raw::c_int\n                        }\n                    }\n                    (*s).rNToGo -= 1;\n                    k1 =\n                        (k1 as std::os::raw::c_int ^\n                             if (*s).rNToGo == 1 as std::os::raw::c_int {\n                                 1 as std::os::raw::c_int\n                             } else { 0 as std::os::raw::c_int }) as UChar;\n                    (*s).nblock_used += 1;\n                    if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int\n                       {\n                        continue ;\n                    }\n                    if k1 as std::os::raw::c_int != (*s).k0 {\n                        (*s).k0 = k1 as Int32\n                    } else {\n                        if (*s).tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul((*s).blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        k1 =\n                            BZ2_indexIntoF((*s).tPos as Int32,\n                                           (*s).cftab.as_mut_ptr()) as UChar;\n                        (*s).tPos =\n                            *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                                (*(*s).ll4.offset(((*s).tPos >>\n                                                       1 as std::os::raw::c_int) as\n                                                      isize) as UInt32 >>\n                                     ((*s).tPos << 2 as std::os::raw::c_int &\n                                          0x4 as std::os::raw::c_int as std::os::raw::c_uint)\n                                     & 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                                    16 as std::os::raw::c_int;\n                        if (*s).rNToGo == 0 as std::os::raw::c_int {\n                            (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                            (*s).rTPos += 1;\n                            if (*s).rTPos == 512 as std::os::raw::c_int {\n                                (*s).rTPos = 0 as std::os::raw::c_int\n                            }\n                        }\n                        (*s).rNToGo -= 1;\n                        k1 =\n                            (k1 as std::os::raw::c_int ^\n                                 if (*s).rNToGo == 1 as std::os::raw::c_int {\n                                     1 as std::os::raw::c_int\n                                 } else { 0 as std::os::raw::c_int }) as UChar;\n                        (*s).nblock_used += 1;\n                        (*s).state_out_len = k1 as Int32 + 4 as std::os::raw::c_int;\n                        if (*s).tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul((*s).blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        (*s).k0 =\n                            BZ2_indexIntoF((*s).tPos as Int32,\n                                           (*s).cftab.as_mut_ptr());\n                        (*s).tPos =\n                            *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                                (*(*s).ll4.offset(((*s).tPos >>\n                                                       1 as std::os::raw::c_int) as\n                                                      isize) as UInt32 >>\n                                     ((*s).tPos << 2 as std::os::raw::c_int &\n                                          0x4 as std::os::raw::c_int as std::os::raw::c_uint)\n                                     & 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                                    16 as std::os::raw::c_int;\n                        if (*s).rNToGo == 0 as std::os::raw::c_int {\n                            (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                            (*s).rTPos += 1;\n                            if (*s).rTPos == 512 as std::os::raw::c_int {\n                                (*s).rTPos = 0 as std::os::raw::c_int\n                            }\n                        }\n                        (*s).rNToGo -= 1;\n                        (*s).k0 ^=\n                            if (*s).rNToGo == 1 as std::os::raw::c_int {\n                                1 as std::os::raw::c_int\n                            } else { 0 as std::os::raw::c_int };\n                        (*s).nblock_used += 1\n                    }\n                }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut k1: u8"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut k1: u8"
        ]
      },
      {
        "chunk_id": 2,
        "span": "bzlib.rs:1407:13: 1461:14 (#0)",
        "pieces": [
          "bzlib.rs:1407:13: 1461:14 (#0)"
        ],
        "num_lines": 55,
        "source": "while 1 as std::os::raw::c_int as Bool != 0 {\n                if (*(*s).strm).avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint\n                   {\n                    return 0 as std::os::raw::c_int as Bool\n                }\n                if (*s).state_out_len == 0 as std::os::raw::c_int { break ; }\n                *((*(*s).strm).next_out as *mut UChar) = (*s).state_out_ch;\n                (*s).calculatedBlockCRC =\n                    (*s).calculatedBlockCRC << 8 as std::os::raw::c_int ^\n                        BZ2_crc32Table[((*s).calculatedBlockCRC >>\n                                            24 as std::os::raw::c_int ^\n                                            (*s).state_out_ch as std::os::raw::c_uint)\n                                           as usize];\n                (*s).state_out_len -= 1;\n                (*(*s).strm).next_out = (*(*s).strm).next_out.offset(1);\n                (*(*s).strm).avail_out =\n                    (*(*s).strm).avail_out.wrapping_sub(1);\n                (*(*s).strm).total_out_lo32 =\n                    (*(*s).strm).total_out_lo32.wrapping_add(1);\n                if (*(*s).strm).total_out_lo32 ==\n                       0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    (*(*s).strm).total_out_hi32 =\n                        (*(*s).strm).total_out_hi32.wrapping_add(1)\n                }\n            }\n            /* can a new run be started? */\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                return 0 as std::os::raw::c_int as Bool\n            }\n            /* Only caused by corrupt data stream? */\n            if (*s).nblock_used > (*s).save_nblock + 1 as std::os::raw::c_int {\n                return 1 as std::os::raw::c_int as Bool\n            }\n            (*s).state_out_len = 1 as std::os::raw::c_int;\n            (*s).state_out_ch = (*s).k0 as UChar;\n            if (*s).tPos >=\n                   (100000 as std::os::raw::c_int as\n                        UInt32).wrapping_mul((*s).blockSize100k as UInt32) {\n                return 1 as std::os::raw::c_int as Bool\n            }\n            k1 =\n                BZ2_indexIntoF((*s).tPos as Int32, (*s).cftab.as_mut_ptr()) as\n                    UChar;\n            (*s).tPos =\n                *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                    (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int) as\n                                          isize) as UInt32 >>\n                         ((*s).tPos << 2 as std::os::raw::c_int &\n                              0x4 as std::os::raw::c_int as std::os::raw::c_uint) &\n                         0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                        16 as std::os::raw::c_int;\n            (*s).nblock_used += 1;\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                continue ;\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut k1: u8"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut k1: u8"
        ]
      },
      {
        "chunk_id": 3,
        "span": "bzlib.rs:1462:13: 1557:14 (#0)",
        "pieces": [
          "bzlib.rs:1462:13: 1557:14 (#0)"
        ],
        "num_lines": 96,
        "source": "if k1 as std::os::raw::c_int != (*s).k0 {\n                (*s).k0 = k1 as Int32\n            } else {\n                (*s).state_out_len = 2 as std::os::raw::c_int;\n                if (*s).tPos >=\n                       (100000 as std::os::raw::c_int as\n                            UInt32).wrapping_mul((*s).blockSize100k as UInt32)\n                   {\n                    return 1 as std::os::raw::c_int as Bool\n                }\n                k1 =\n                    BZ2_indexIntoF((*s).tPos as Int32,\n                                   (*s).cftab.as_mut_ptr()) as UChar;\n                (*s).tPos =\n                    *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                        (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int) as\n                                              isize) as UInt32 >>\n                             ((*s).tPos << 2 as std::os::raw::c_int &\n                                  0x4 as std::os::raw::c_int as std::os::raw::c_uint) &\n                             0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                            16 as std::os::raw::c_int;\n                (*s).nblock_used += 1;\n                if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                    continue ;\n                }\n                if k1 as std::os::raw::c_int != (*s).k0 {\n                    (*s).k0 = k1 as Int32\n                } else {\n                    (*s).state_out_len = 3 as std::os::raw::c_int;\n                    if (*s).tPos >=\n                           (100000 as std::os::raw::c_int as\n                                UInt32).wrapping_mul((*s).blockSize100k as\n                                                         UInt32) {\n                        return 1 as std::os::raw::c_int as Bool\n                    }\n                    k1 =\n                        BZ2_indexIntoF((*s).tPos as Int32,\n                                       (*s).cftab.as_mut_ptr()) as UChar;\n                    (*s).tPos =\n                        *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                            (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int)\n                                                  as isize) as UInt32 >>\n                                 ((*s).tPos << 2 as std::os::raw::c_int &\n                                      0x4 as std::os::raw::c_int as std::os::raw::c_uint) &\n                                 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                                16 as std::os::raw::c_int;\n                    (*s).nblock_used += 1;\n                    if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int\n                       {\n                        continue ;\n                    }\n                    if k1 as std::os::raw::c_int != (*s).k0 {\n                        (*s).k0 = k1 as Int32\n                    } else {\n                        if (*s).tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul((*s).blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        k1 =\n                            BZ2_indexIntoF((*s).tPos as Int32,\n                                           (*s).cftab.as_mut_ptr()) as UChar;\n                        (*s).tPos =\n                            *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                                (*(*s).ll4.offset(((*s).tPos >>\n                                                       1 as std::os::raw::c_int) as\n                                                      isize) as UInt32 >>\n                                     ((*s).tPos << 2 as std::os::raw::c_int &\n                                          0x4 as std::os::raw::c_int as std::os::raw::c_uint)\n                                     & 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                                    16 as std::os::raw::c_int;\n                        (*s).nblock_used += 1;\n                        (*s).state_out_len = k1 as Int32 + 4 as std::os::raw::c_int;\n                        if (*s).tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul((*s).blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        (*s).k0 =\n                            BZ2_indexIntoF((*s).tPos as Int32,\n                                           (*s).cftab.as_mut_ptr());\n                        (*s).tPos =\n                            *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                                (*(*s).ll4.offset(((*s).tPos >>\n                                                       1 as std::os::raw::c_int) as\n                                                      isize) as UInt32 >>\n                                     ((*s).tPos << 2 as std::os::raw::c_int &\n                                          0x4 as std::os::raw::c_int as std::os::raw::c_uint)\n                                     & 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                                    16 as std::os::raw::c_int;\n                        (*s).nblock_used += 1\n                    }\n                }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut k1: u8"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut k1: u8"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::redundant)",
    "span": "bzip2.rs:2555:1: 2559:2 (#0)",
    "pieces": [
      "bzip2.rs:2555:1: 2559:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn redundant(mut flag: *mut Char) {\n    fprintf(__stderrp,\n            b\"%s: %s is redundant in versions 0.9.5 and above\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName, flag);\n}",
    "calls": [],
    "globals": [
      {
        "span": "bzip2.rs:422:1: 422:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:437 ~ c2rust_out[3c70]::bzlib::BZ2_bzDecompressEnd)",
    "span": "bzlib.rs:1625:1: 1646:2 (#0)",
    "pieces": [
      "bzlib.rs:1625:1: 1646:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn BZ2_bzDecompressEnd(mut strm: *mut bz_stream)\n -> std::os::raw::c_int {\n    let mut s: *mut DState = 0 as *mut DState;\n    if strm.is_null() { return -(2 as std::os::raw::c_int) }\n    s = (*strm).state as *mut DState;\n    if s.is_null() { return -(2 as std::os::raw::c_int) }\n    if (*s).strm != strm { return -(2 as std::os::raw::c_int) }\n    if !(*s).tt.is_null() {\n        (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                           (*s).tt as\n                                                               *mut std::os::raw::c_void);\n    }\n    if !(*s).ll16.is_null() {\n        (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                           (*s).ll16 as\n                                                               *mut std::os::raw::c_void);\n    }\n    if !(*s).ll4.is_null() {\n        (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                           (*s).ll4 as\n                                                               *mut std::os::raw::c_void);\n    }\n    (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                       (*strm).state);\n    (*strm).state = 0 as *mut std::os::raw::c_void;\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:533 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
        "span": "bzlib.rs:2171:13: 2171:44 (#0)",
        "source": "BZ2_bzDecompressEnd(&mut strm);"
      },
      {
        "caller": "DefId(0:533 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
        "span": "bzlib.rs:2180:9: 2180:40 (#0)",
        "source": "BZ2_bzDecompressEnd(&mut strm);"
      },
      {
        "caller": "DefId(0:533 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
        "span": "bzlib.rs:2168:13: 2168:44 (#0)",
        "source": "BZ2_bzDecompressEnd(&mut strm);"
      },
      {
        "caller": "DefId(0:533 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
        "span": "bzlib.rs:2175:9: 2175:40 (#0)",
        "source": "BZ2_bzDecompressEnd(&mut strm);"
      },
      {
        "caller": "DefId(0:528 ~ c2rust_out[3c70]::bzlib::BZ2_bzReadClose)",
        "span": "bzlib.rs:1967:9: 1967:67 (#0)",
        "source": "BZ2_bzDecompressEnd(&mut unsafe { (*bzf.unwrap()).strm });"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:444 ~ c2rust_out[3c70]::bzlib::BZ2_bzReadClose)",
    "span": "bzlib.rs:1949:1: 1971:2 (#0)",
    "pieces": [
      "bzlib.rs:1949:1: 1971:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn BZ2_bzReadClose(mut bzerror: *mut std::os::raw::c_int,\n                                         mut b: *mut std::os::raw::c_void) {\n    let mut bzf: *mut bzFile = b as *mut bzFile;\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    if bzf.is_null() {\n        if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n        if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n        return\n    }\n    if (*bzf).writing != 0 {\n        if !bzerror.is_null() { *bzerror = -(1 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(1 as std::os::raw::c_int) }\n        return\n    }\n    if (*bzf).initialisedOk != 0 { BZ2_bzDecompressEnd(&mut (*bzf).strm); }\n    free(bzf as *mut std::os::raw::c_void);\n}",
    "calls": [
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1189:5: 1189:59 (#0)",
        "source": "BZ2_bzReadClose(&mut bzerr, Some(Box::from_raw(bzf)));"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1214:1: 1214:56 (#0)",
        "source": "BZ2_bzReadClose(&mut bzerr_dummy, Some(Box::new(bzf)));"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:826:1: 826:99 (#0)",
        "source": "let result = BZ2_bzReadClose(&mut bzerr_dummy, Some(Box::from_raw(bzf as *mut std::ffi::c_void)));"
      },
      {
        "caller": "DefId(0:546 ~ c2rust_out[3c70]::bzlib::BZ2_bzclose)",
        "span": "bzlib.rs:2364:1: 2364:48 (#0)",
        "source": "BZ2_bzReadClose(&mut bzerr, Some(Box::new(b)));"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:762:5: 762:59 (#0)",
        "source": "BZ2_bzReadClose(&mut bzerr, Some(Box::from_raw(bzf)));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:445 ~ c2rust_out[3c70]::bzlib::BZ2_bzRead)",
    "span": "bzlib.rs:1975:1: 2051:2 (#0)",
    "pieces": [
      "bzlib.rs:1975:1: 2051:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 77,
    "source": "pub unsafe extern \"C\" fn BZ2_bzRead(mut bzerror: *mut std::os::raw::c_int,\n                                    mut b: *mut std::os::raw::c_void,\n                                    mut buf: *mut std::os::raw::c_void,\n                                    mut len: std::os::raw::c_int) -> std::os::raw::c_int {\n    let mut n: Int32 = 0;\n    let mut ret: Int32 = 0;\n    let mut bzf: *mut bzFile = b as *mut bzFile;\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    if bzf.is_null() || buf.is_null() || len < 0 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = -(2 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(2 as std::os::raw::c_int) }\n        return 0 as std::os::raw::c_int\n    }\n    if (*bzf).writing != 0 {\n        if !bzerror.is_null() { *bzerror = -(1 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(1 as std::os::raw::c_int) }\n        return 0 as std::os::raw::c_int\n    }\n    if len == 0 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n        if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n        return 0 as std::os::raw::c_int\n    }\n    (*bzf).strm.avail_out = len as std::os::raw::c_uint;\n    (*bzf).strm.next_out = buf as *mut std::os::raw::c_char;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        if ferror((*bzf).handle) != 0 {\n            if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n            if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n            return 0 as std::os::raw::c_int\n        }\n        if (*bzf).strm.avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint &&\n               myfeof((*bzf).handle) == 0 {\n            n =\n                fread((*bzf).buf.as_mut_ptr() as *mut std::os::raw::c_void,\n                      ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong,\n                      5000 as std::os::raw::c_int as std::os::raw::c_ulong, (*bzf).handle) as\n                    Int32;\n            if ferror((*bzf).handle) != 0 {\n                if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n                if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n                return 0 as std::os::raw::c_int\n            }\n            (*bzf).bufN = n;\n            (*bzf).strm.avail_in = (*bzf).bufN as std::os::raw::c_uint;\n            (*bzf).strm.next_in = (*bzf).buf.as_mut_ptr()\n        }\n        ret = BZ2_bzDecompress(&mut (*bzf).strm);\n        if ret != 0 as std::os::raw::c_int && ret != 4 as std::os::raw::c_int {\n            if !bzerror.is_null() { *bzerror = ret }\n            if !bzf.is_null() { (*bzf).lastErr = ret }\n            return 0 as std::os::raw::c_int\n        }\n        if ret == 0 as std::os::raw::c_int &&\n               myfeof((*bzf).handle) as std::os::raw::c_int != 0 &&\n               (*bzf).strm.avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint &&\n               (*bzf).strm.avail_out > 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            if !bzerror.is_null() { *bzerror = -(7 as std::os::raw::c_int) }\n            if !bzf.is_null() { (*bzf).lastErr = -(7 as std::os::raw::c_int) }\n            return 0 as std::os::raw::c_int\n        }\n        if ret == 4 as std::os::raw::c_int {\n            if !bzerror.is_null() { *bzerror = 4 as std::os::raw::c_int }\n            if !bzf.is_null() { (*bzf).lastErr = 4 as std::os::raw::c_int }\n            return (len as std::os::raw::c_uint).wrapping_sub((*bzf).strm.avail_out)\n                       as std::os::raw::c_int\n        }\n        if (*bzf).strm.avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n            if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n            return len\n        }\n    }\n    return 0 as std::os::raw::c_int;\n    /*not reached*/\n}",
    "calls": [
      {
        "caller": "DefId(0:543 ~ c2rust_out[3c70]::bzlib::BZ2_bzread)",
        "span": "bzlib.rs:2318:13: 2320:6 (#0)",
        "source": "unsafe {\n        BZ2_bzRead(&mut bzerr, b as *mut bzFile as *mut std::os::raw::c_void, buf.as_mut_ptr() as *mut std::os::raw::c_void, len)\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:458 ~ c2rust_out[3c70]::bzlib::BZ2_bzread)",
    "span": "bzlib.rs:2310:1: 2327:2 (#0)",
    "pieces": [
      "bzlib.rs:2310:1: 2327:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "pub unsafe extern \"C\" fn BZ2_bzread(mut b: *mut std::os::raw::c_void,\n                                    mut buf: *mut std::os::raw::c_void,\n                                    mut len: std::os::raw::c_int) -> std::os::raw::c_int {\n    let mut bzerr: std::os::raw::c_int = 0;\n    let mut nread: std::os::raw::c_int = 0;\n    if (*(b as *mut bzFile)).lastErr == 4 as std::os::raw::c_int {\n        return 0 as std::os::raw::c_int\n    }\n    nread = BZ2_bzRead(&mut bzerr, b, buf, len);\n    if bzerr == 0 as std::os::raw::c_int || bzerr == 4 as std::os::raw::c_int {\n        return nread\n    } else { return -(1 as std::os::raw::c_int) };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:249 ~ c2rust_out[3c70]::bzip2::copyFileName)",
    "span": "bzip2.rs:1654:1: 1668:2 (#0)",
    "pieces": [
      "bzip2.rs:1654:1: 1668:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn copyFileName(mut to: *mut Char, mut from: *mut Char) {\n    if strlen(from) >\n           (1034 as std::os::raw::c_int - 10 as std::os::raw::c_int) as std::os::raw::c_ulong {\n        fprintf(__stderrp,\n                b\"bzip2: file name\\n`%s\\'\\nis suspiciously (more than %d chars) long.\\nTry using a reasonable file name instead.  Sorry! :-)\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char, from,\n                1034 as std::os::raw::c_int - 10 as std::os::raw::c_int);\n        setExit(1 as std::os::raw::c_int);\n        exit(exitValue);\n    }\n    strncpy(to, from,\n            (1034 as std::os::raw::c_int - 10 as std::os::raw::c_int) as std::os::raw::c_ulong);\n    *to.offset((1034 as std::os::raw::c_int - 10 as std::os::raw::c_int) as isize) =\n        '\\u{0}' as i32 as Char;\n}",
    "calls": [
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2222:13: 2224:44 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:1961:13: 1963:44 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2188:13: 2190:41 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(),\n                         b\"(stdin)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                             *mut Char);"
      },
      {
        "caller": "DefId(0:321 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2456:16: 2456:56 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:330 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2665:5: 2667:33 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(),\n                 b\"(none)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                     *mut Char);"
      },
      {
        "caller": "DefId(0:330 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2668:5: 2670:33 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(),\n                 b\"(none)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                     *mut Char);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:1955:13: 1955:54 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:321 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2457:16: 2457:56 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2196:13: 2196:53 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2221:13: 2221:53 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:1949:13: 1951:44 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:1960:13: 1960:53 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:1954:13: 1954:53 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:321 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2452:13: 2454:41 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(),\n                         b\"(stdin)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                             *mut Char);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2197:13: 2197:54 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2191:13: 2193:44 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);"
      },
      {
        "caller": "DefId(0:321 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2447:5: 2449:33 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(),\n                 b\"(none)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                     *mut Char);"
      },
      {
        "caller": "DefId(0:330 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2671:5: 2672:67 (#0)",
        "source": "copyFileName(progNameReally.as_mut_ptr(),\n                 *argv.offset(0 as std::os::raw::c_int as isize));"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:1946:13: 1948:41 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(),\n                         b\"(stdin)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                             *mut Char);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:408:1: 408:37 (#0)",
        "source": "pub static mut exitValue: Int32 = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:261 ~ c2rust_out[3c70]::bzip2::containsDubiousChars)",
    "span": "bzip2.rs:1874:2: 1880:2 (#0)",
    "pieces": [
      "bzip2.rs:1874:2: 1880:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "extern \"C\" fn containsDubiousChars(mut name: *mut Char) -> Bool {\n    /* On unix, files can contain any characters and the file expansion\n    * is performed by the shell.\n    */\n    return 0 as std::os::raw::c_int as Bool;\n    /* ! BZ_UNIX */\n    /* BZ_UNIX */\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:259 ~ c2rust_out[3c70]::bzip2::applySavedTimeInfoToOutputFile)",
    "span": "bzip2.rs:1836:1: 1847:2 (#0)",
    "pieces": [
      "bzip2.rs:1836:1: 1847:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn applySavedTimeInfoToOutputFile(mut dstName: *mut Char) {\n    let mut retVal: IntNative = 0;\n    let mut uTimBuf: utimbuf = utimbuf{actime: 0, modtime: 0,};\n    uTimBuf.actime = fileMetaInfo.st_atimespec.tv_sec;\n    uTimBuf.modtime = fileMetaInfo.st_mtimespec.tv_sec;\n    retVal = utime(dstName, &mut uTimBuf);\n    if retVal != 0 as std::os::raw::c_int { ioError(); };\n}",
    "calls": [
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2384:13: 2386:2 (#0)",
        "source": "if let Err(e) = applySavedTimeInfoToOutputFile(unsafe { CStr::from_ptr(outName.as_mut_ptr()) }) {\n    eprintln!(\"Error applying time info: {}\", e);\n}"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2139:9: 2141:2 (#0)",
        "source": "if let Err(e) = applySavedTimeInfoToOutputFile(unsafe { CStr::from_ptr(outName.as_mut_ptr()) }) {\n    eprintln!(\"Error applying time info: {}\", e);\n}"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:1787:1: 1805:30 (#0)",
        "source": "static mut fileMetaInfo: stat =\n    stat{st_dev: 0,\n         st_mode: 0,\n         st_nlink: 0,\n         st_ino: 0,\n         st_uid: 0,\n         st_gid: 0,\n         st_rdev: 0,\n         st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_size: 0,\n         st_blocks: 0,\n         st_blksize: 0,\n         st_flags: 0,\n         st_gen: 0,\n         st_lspare: 0,\n         st_qspare: [0; 2],};"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:236 ~ c2rust_out[3c70]::bzip2::cadvise)",
    "span": "bzip2.rs:1444:1: 1451:2 (#0)",
    "pieces": [
      "bzip2.rs:1444:1: 1451:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn cadvise() {\n    if noisy != 0 {\n        fprintf(__stderrp,\n                b\"\\nIt is possible that the compressed file(s) have become corrupted.\\nYou can use the -tvv option to test integrity of such files.\\n\\nYou can use the `bzip2recover\\' program to attempt to recover\\ndata from undamaged sections of corrupted files.\\n\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char);\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:288 ~ c2rust_out[3c70]::bzip2::compressedStreamEOF)",
        "span": "bzip2.rs:1555:13: 1555:23 (#0)",
        "source": "cadvise();"
      },
      {
        "caller": "DefId(0:287 ~ c2rust_out[3c70]::bzip2::crcError)",
        "span": "bzip2.rs:1544:5: 1544:15 (#0)",
        "source": "cadvise();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:242 ~ c2rust_out[3c70]::bzip2::compressedStreamEOF)",
    "span": "bzip2.rs:1549:1: 1559:2 (#0)",
    "pieces": [
      "bzip2.rs:1549:1: 1559:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn compressedStreamEOF() -> ! {\n    if noisy != 0 {\n        fprintf(__stderrp,\n                b\"\\n%s: Compressed file ends unexpectedly;\\n\\tperhaps it is corrupted?  *Possible* reason follows.\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char, progName);\n        perror(progName);\n        showFileNames();\n        cadvise();\n    }\n    cleanUpAndFail(2 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:844:9: 844:31 (#0)",
        "source": "compressedStreamEOF();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:972:9: 972:31 (#0)",
        "source": "compressedStreamEOF();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:929:9: 929:31 (#0)",
        "source": "compressedStreamEOF();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:887:9: 887:31 (#0)",
        "source": "compressedStreamEOF();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1057:9: 1057:31 (#0)",
        "source": "compressedStreamEOF();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1014:9: 1014:31 (#0)",
        "source": "compressedStreamEOF();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:246 ~ c2rust_out[3c70]::bzip2::outOfMemory)",
    "span": "bzip2.rs:1613:1: 1619:2 (#0)",
    "pieces": [
      "bzip2.rs:1613:1: 1619:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn outOfMemory() -> ! {\n    fprintf(__stderrp,\n            b\"\\n%s: couldn\\'t allocate enough memory\\n\\x00\" as *const u8 as\n                *const std::os::raw::c_char, progName);\n    showFileNames();\n    cleanUpAndFail(1 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:969:9: 969:23 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1317:31: 1317:45 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1054:9: 1054:23 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:675:25: 675:39 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:661:25: 661:39 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:690:25: 690:39 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1011:9: 1011:23 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:884:9: 884:23 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1416:31: 1416:45 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:841:9: 841:23 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1284:31: 1284:45 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1249:9: 1249:23 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:926:9: 926:23 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1383:31: 1383:45 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:326 ~ c2rust_out[3c70]::bzip2::myMalloc)",
        "span": "bzip2.rs:2566:9: 2566:23 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1350:31: 1350:45 (#0)",
        "source": "outOfMemory();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:241 ~ c2rust_out[3c70]::bzip2::crcError)",
    "span": "bzip2.rs:1541:1: 1546:2 (#0)",
    "pieces": [
      "bzip2.rs:1541:1: 1546:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn crcError() -> ! {\n    fprintf(__stderrp,\n            b\"\\n%s: Data integrity error when decompressing.\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName);\n    showFileNames();\n    cadvise();\n    cleanUpAndFail(2 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1051:9: 1051:20 (#0)",
        "source": "crcError();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:881:9: 881:20 (#0)",
        "source": "crcError();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1008:9: 1008:20 (#0)",
        "source": "crcError();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:966:9: 966:20 (#0)",
        "source": "crcError();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:923:9: 923:20 (#0)",
        "source": "crcError();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:838:9: 838:20 (#0)",
        "source": "crcError();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:247 ~ c2rust_out[3c70]::bzip2::configError)",
    "span": "bzip2.rs:1622:1: 1633:2 (#0)",
    "pieces": [
      "bzip2.rs:1622:1: 1633:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn configError() -> ! {\n    fprintf(__stderrp,\n            b\"bzip2: I\\'m not configured correctly for this platform!\\n\\tI require Int32, Int16 and Char to have sizes\\n\\tof 4, 2 and 1 bytes to run properly, and they don\\'t.\\n\\tProbably you can fix this by defining them correctly,\\n\\tand recompiling.  Bye!\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char);\n    setExit(3 as std::os::raw::c_int);\n    exit(exitValue);\n}",
    "calls": [
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1246:9: 1246:23 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:963:9: 963:23 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1005:9: 1005:23 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1415:31: 1415:45 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:693:25: 693:39 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1316:31: 1316:45 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1048:9: 1048:23 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1283:31: 1283:45 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1382:31: 1382:45 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:678:25: 678:39 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:330 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2638:9: 2638:23 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:878:9: 878:23 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:920:9: 920:23 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:664:25: 664:39 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:835:9: 835:23 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1349:31: 1349:45 (#0)",
        "source": "configError();"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:408:1: 408:37 (#0)",
        "source": "pub static mut exitValue: Int32 = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:240 ~ c2rust_out[3c70]::bzip2::panic)",
    "span": "bzip2.rs:1534:1: 1538:2 (#0)",
    "pieces": [
      "bzip2.rs:1534:1: 1538:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn panic(mut s: *const Char) -> ! {\n    fprintf(__stderrp,\n            b\"\\n%s: PANIC -- internal consistency error:\\n\\t%s\\n\\tThis is a BUG.  Please report it to:\\n\\tbzip2-devel@sourceware.org\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, progName, s);\n    showFileNames();\n    cleanUpAndFail(3 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2123:13: 2123:44 (#0)",
        "source": "panic(\"compress: bad srcMode\");"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2183:9: 2183:42 (#0)",
        "source": "panic(\"uncompress: bad modes\\n\");"
      },
      {
        "caller": "DefId(0:321 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2445:9: 2445:37 (#0)",
        "source": "panic(\"testf: bad modes\\n\");"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2367:13: 2367:46 (#0)",
        "source": "panic(\"uncompress: bad srcMode\");"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:764:9: 764:45 (#0)",
        "source": "panic(\"decompress:bzReadGetUnused\");"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:672:25: 672:60 (#0)",
        "source": "panic(\"compress:unexpected error\");"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:658:25: 658:60 (#0)",
        "source": "panic(\"compress:unexpected error\");"
      },
      {
        "caller": "DefId(0:321 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2519:13: 2519:41 (#0)",
        "source": "panic(\"testf: bad srcMode\");"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:1942:9: 1942:40 (#0)",
        "source": "panic(\"compress: bad modes\\n\");"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:687:25: 687:60 (#0)",
        "source": "panic(\"compress:unexpected error\");"
      },
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:756:9: 756:45 (#0)",
        "source": "panic(\"decompress:bzReadGetUnused\");"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:446 ~ c2rust_out[3c70]::bzlib::BZ2_bzReadGetUnused)",
    "span": "bzlib.rs:2054:1: 2079:2 (#0)",
    "pieces": [
      "bzlib.rs:2054:1: 2079:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 26,
    "source": "pub unsafe extern \"C\" fn BZ2_bzReadGetUnused(mut bzerror: *mut std::os::raw::c_int,\n                                             mut b: *mut std::os::raw::c_void,\n                                             mut unused:\n                                                 *mut *mut std::os::raw::c_void,\n                                             mut nUnused: *mut std::os::raw::c_int) {\n    let mut bzf: *mut bzFile = b as *mut bzFile;\n    if bzf.is_null() {\n        if !bzerror.is_null() { *bzerror = -(2 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(2 as std::os::raw::c_int) }\n        return\n    }\n    if (*bzf).lastErr != 4 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = -(1 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(1 as std::os::raw::c_int) }\n        return\n    }\n    if unused.is_null() || nUnused.is_null() {\n        if !bzerror.is_null() { *bzerror = -(2 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(2 as std::os::raw::c_int) }\n        return\n    }\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    *nUnused = (*bzf).strm.avail_in as std::os::raw::c_int;\n    *unused = (*bzf).strm.next_in as *mut std::os::raw::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:271 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:754:5: 754:73 (#0)",
        "source": "BZ2_bzReadGetUnused(&mut bzerr, bzf, &mut unusedTmpV, &mut nUnused);"
      },
      {
        "caller": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1182:5: 1183:39 (#0)",
        "source": "BZ2_bzReadGetUnused(&mut bzerr, bzf, &mut unusedTmpV,\n                        &mut nUnused);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
    "span": "bzip2.rs:707:1: 1136:2 (#0)",
    "pieces": [
      "bzip2.rs:707:1: 709:8 (#0)",
      "bzip2.rs:1134:1: 1136:2 (#0)"
    ],
    "sub_chunks": [
      10
    ],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn uncompressStream(mut zStream: *mut FILE,\n                                      mut stream: *mut FILE) -> Bool {\n   <<chunk 10>>    /*notreached*/\n}",
    "calls": [
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2379:5: 2379:57 (#0)",
        "source": "let magicNumberOK = uncompressStream(inStr, outStr);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:426:1: 427:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      },
      {
        "span": "bzip2.rs:386:1: 386:37 (#0)",
        "source": "pub static mut verbosity: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:390:1: 390:36 (#0)",
        "source": "pub static mut smallMode: Bool = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "bzip2.rs:829:9: 866:2 (#0)",
        "pieces": [
          "bzip2.rs:829:9: 866:2 (#0)"
        ],
        "num_lines": 49,
        "source": "current_block =\n                                                3642457097893642164;\n                                            match current_block {\n                                                6455255476181645667 => {\n                                                    panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);\n                                                }\n                                                3642457097893642164 => {\n                                                    configError();\n                                                }\n                                                10766414566319669440 => {\n                                                    crcError();\n                                                }\n                                                16178635849926953562 => {\n                                                    outOfMemory();\n                                                }\n                                                5517467152645906530 => {\n                                                    compressedStreamEOF();\n                                                }\n                                                _ => {\n                                                    if zStream != __stdinp {\n                                                        fclose(zStream);\n                                                    }\n                                                    if stream != __stdoutp {\n                                                        fclose(stream);\n                                                    }\n                                                    if streamNo ==\n                                                           1 as std::os::raw::c_int {\n                                                        return 0 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    } else {\n                                                        if noisy != 0 {\n                                                            fprintf(__stderrp,\n                                                                    b\"\\n%s: %s: trailing garbage after EOF ignored\\n\\x00\"\n                                                                        as\n                                                                        *const u8\n                                                                        as\n                                                                        *const std::os::raw::c_char,\n                                                                    progName,\n                                                                    inName.as_mut_ptr());\n                                                        }\n                                                        return 1 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    }\n                                                }\n                                            }",
        "sub_chunks": [],
        "live_in": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32",
          "mut current_block: u64"
        ],
        "live_out": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32",
          "mut current_block: u64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "bzip2.rs:872:9: 909:2 (#0)",
        "pieces": [
          "bzip2.rs:872:9: 909:2 (#0)"
        ],
        "num_lines": 49,
        "source": "current_block =\n                                                10766414566319669440;\n                                            match current_block {\n                                                6455255476181645667 => {\n                                                    panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);\n                                                }\n                                                3642457097893642164 => {\n                                                    configError();\n                                                }\n                                                10766414566319669440 => {\n                                                    crcError();\n                                                }\n                                                16178635849926953562 => {\n                                                    outOfMemory();\n                                                }\n                                                5517467152645906530 => {\n                                                    compressedStreamEOF();\n                                                }\n                                                _ => {\n                                                    if zStream != __stdinp {\n                                                        fclose(zStream);\n                                                    }\n                                                    if stream != __stdoutp {\n                                                        fclose(stream);\n                                                    }\n                                                    if streamNo ==\n                                                           1 as std::os::raw::c_int {\n                                                        return 0 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    } else {\n                                                        if noisy != 0 {\n                                                            fprintf(__stderrp,\n                                                                    b\"\\n%s: %s: trailing garbage after EOF ignored\\n\\x00\"\n                                                                        as\n                                                                        *const u8\n                                                                        as\n                                                                        *const std::os::raw::c_char,\n                                                                    progName,\n                                                                    inName.as_mut_ptr());\n                                                        }\n                                                        return 1 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    }\n                                                }\n                                            }",
        "sub_chunks": [],
        "live_in": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32",
          "mut current_block: u64"
        ],
        "live_out": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32",
          "mut current_block: u64"
        ]
      },
      {
        "chunk_id": 2,
        "span": "bzip2.rs:914:9: 951:2 (#0)",
        "pieces": [
          "bzip2.rs:914:9: 951:2 (#0)"
        ],
        "num_lines": 49,
        "source": "current_block =\n                                                16178635849926953562;\n                                            match current_block {\n                                                6455255476181645667 => {\n                                                    panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);\n                                                }\n                                                3642457097893642164 => {\n                                                    configError();\n                                                }\n                                                10766414566319669440 => {\n                                                    crcError();\n                                                }\n                                                16178635849926953562 => {\n                                                    outOfMemory();\n                                                }\n                                                5517467152645906530 => {\n                                                    compressedStreamEOF();\n                                                }\n                                                _ => {\n                                                    if zStream != __stdinp {\n                                                        fclose(zStream);\n                                                    }\n                                                    if stream != __stdoutp {\n                                                        fclose(stream);\n                                                    }\n                                                    if streamNo ==\n                                                           1 as std::os::raw::c_int {\n                                                        return 0 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    } else {\n                                                        if noisy != 0 {\n                                                            fprintf(__stderrp,\n                                                                    b\"\\n%s: %s: trailing garbage after EOF ignored\\n\\x00\"\n                                                                        as\n                                                                        *const u8\n                                                                        as\n                                                                        *const std::os::raw::c_char,\n                                                                    progName,\n                                                                    inName.as_mut_ptr());\n                                                        }\n                                                        return 1 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    }\n                                                }\n                                            }",
        "sub_chunks": [],
        "live_in": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32",
          "mut current_block: u64"
        ],
        "live_out": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32",
          "mut current_block: u64"
        ]
      },
      {
        "chunk_id": 3,
        "span": "bzip2.rs:956:9: 994:2 (#0)",
        "pieces": [
          "bzip2.rs:956:9: 994:2 (#0)"
        ],
        "num_lines": 49,
        "source": "current_block =\n                                                5517467152645906530;\n                                            match current_block {\n                                                6455255476181645667 => {\n                                                    panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);\n                                                }\n                                                3642457097893642164 => {\n                                                    configError();\n                                                }\n                                                10766414566319669440 => {\n                                                    crcError();\n                                                }\n                                                16178635849926953562 => {\n                                                    outOfMemory();\n                                                }\n                                                5517467152645906530 => {\n                                                    compressedStreamEOF();\n                                                }\n                                                _ => {\n                                                    if zStream != __stdinp {\n                                                        fclose(zStream);\n                                                    }\n                                                    if stream != __stdoutp {\n                                                        fclose(stream);\n                                                    }\n                                                    if streamNo ==\n                                                           1 as std::os::raw::c_int {\n                                                        return 0 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    } else {\n                                                        if noisy != 0 {\n                                                            fprintf(__stderrp,\n                                                                    b\"\\n%s: %s: trailing garbage after EOF ignored\\n\\x00\"\n                                                                        as\n                                                                        *const u8\n                                                                        as\n                                                                        *const std::os::raw::c_char,\n                                                                    progName,\n                                                                    inName.as_mut_ptr());\n                                                        }\n                                                        return 1 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    }\n                                                }\n                                            }",
        "sub_chunks": [],
        "live_in": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32",
          "mut current_block: u64"
        ],
        "live_out": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32",
          "mut current_block: u64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "bzip2.rs:999:9: 1036:2 (#0)",
        "pieces": [
          "bzip2.rs:999:9: 1036:2 (#0)"
        ],
        "num_lines": 49,
        "source": "current_block =\n                                                7372986856480808103;\n                                            match current_block {\n                                                6455255476181645667 => {\n                                                    panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);\n                                                }\n                                                3642457097893642164 => {\n                                                    configError();\n                                                }\n                                                10766414566319669440 => {\n                                                    crcError();\n                                                }\n                                                16178635849926953562 => {\n                                                    outOfMemory();\n                                                }\n                                                5517467152645906530 => {\n                                                    compressedStreamEOF();\n                                                }\n                                                _ => {\n                                                    if zStream != __stdinp {\n                                                        fclose(zStream);\n                                                    }\n                                                    if stream != __stdoutp {\n                                                        fclose(stream);\n                                                    }\n                                                    if streamNo ==\n                                                           1 as std::os::raw::c_int {\n                                                        return 0 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    } else {\n                                                        if noisy != 0 {\n                                                            fprintf(__stderrp,\n                                                                    b\"\\n%s: %s: trailing garbage after EOF ignored\\n\\x00\"\n                                                                        as\n                                                                        *const u8\n                                                                        as\n                                                                        *const std::os::raw::c_char,\n                                                                    progName,\n                                                                    inName.as_mut_ptr());\n                                                        }\n                                                        return 1 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    }\n                                                }\n                                            }",
        "sub_chunks": [],
        "live_in": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32",
          "mut current_block: u64"
        ],
        "live_out": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32",
          "mut current_block: u64"
        ]
      },
      {
        "chunk_id": 5,
        "span": "bzip2.rs:1041:9: 1079:2 (#0)",
        "pieces": [
          "bzip2.rs:1041:9: 1079:2 (#0)"
        ],
        "num_lines": 49,
        "source": "current_block =\n                                                6455255476181645667;\n                                            match current_block {\n                                                6455255476181645667 => {\n                                                    panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);\n                                                }\n                                                3642457097893642164 => {\n                                                    configError();\n                                                }\n                                                10766414566319669440 => {\n                                                    crcError();\n                                                }\n                                                16178635849926953562 => {\n                                                    outOfMemory();\n                                                }\n                                                5517467152645906530 => {\n                                                    compressedStreamEOF();\n                                                }\n                                                _ => {\n                                                    if zStream != __stdinp {\n                                                        fclose(zStream);\n                                                    }\n                                                    if stream != __stdoutp {\n                                                        fclose(stream);\n                                                    }\n                                                    if streamNo ==\n                                                           1 as std::os::raw::c_int {\n                                                        return 0 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    } else {\n                                                        if noisy != 0 {\n                                                            fprintf(__stderrp,\n                                                                    b\"\\n%s: %s: trailing garbage after EOF ignored\\n\\x00\"\n                                                                        as\n                                                                        *const u8\n                                                                        as\n                                                                        *const std::os::raw::c_char,\n                                                                    progName,\n                                                                    inName.as_mut_ptr());\n                                                        }\n                                                        return 1 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    }\n                                                }\n                                            }",
        "sub_chunks": [],
        "live_in": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32",
          "mut current_block: u64"
        ],
        "live_out": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32",
          "mut current_block: u64"
        ]
      },
      {
        "chunk_id": 6,
        "span": "bzip2.rs:822:37: 1087:3 (#0)",
        "pieces": [
          "bzip2.rs:822:37: 829:8 (#0)",
          "bzip2.rs:868:1: 872:8 (#0)",
          "bzip2.rs:911:1: 914:8 (#0)",
          "bzip2.rs:953:1: 956:8 (#0)",
          "bzip2.rs:996:1: 999:8 (#0)",
          "bzip2.rs:1038:1: 1041:8 (#0)",
          "bzip2.rs:1081:1: 1087:3 (#0)"
        ],
        "num_lines": 22,
        "source": "BZ2_bzReadClose(&mut bzerr_dummy, bzf);\n                                    match bzerr {\n                                        -9 => {\n                                           <<chunk 0>>                                        }\n                                        -6 => { }\n                                        -4 => {\n                                           <<chunk 1>>                                        }\n                                        -3 => {\n                                           <<chunk 2>>                                        }\n                                        -7 => {\n                                           <<chunk 3>>                                        }\n                                        -5 => {\n                                           <<chunk 4>>                                        }\n                                        _ => {\n                                           <<chunk 5>>                                        }\n                                    }",
        "sub_chunks": [
          0,
          1,
          2,
          3,
          4,
          5
        ],
        "live_in": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut streamNo: i32",
          "mut current_block: u64"
        ],
        "live_out": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut streamNo: i32",
          "mut current_block: u64",
          "result: ()"
        ]
      },
      {
        "chunk_id": 7,
        "span": "bzip2.rs:1091:37: 1121:2 (#0)",
        "pieces": [
          "bzip2.rs:1091:37: 1121:2 (#0)"
        ],
        "num_lines": 91,
        "source": "if !(ferror(zStream) != 0) {\n                                        if stream != __stdoutp {\n                                            let mut fd: Int32 =\n                                                fileno(stream);\n                                            if fd < 0 as std::os::raw::c_int {\n                                                current_block =\n                                                    5049394217699438129;\n                                            } else {\n                                                applySavedFileAttrToOutputFile(fd);\n                                                current_block =\n                                                    14832935472441733737;\n                                            }\n                                        } else {\n                                            current_block =\n                                                14832935472441733737;\n                                        }\n                                        match current_block {\n                                            5049394217699438129 => { }\n                                            _ => {\n                                                ret = fclose(zStream);\n                                                if !(ret ==\n                                                         -(1 as std::os::raw::c_int))\n                                                   {\n                                                    if !(ferror(stream) != 0)\n                                                       {\n                                                        ret = fflush(stream);\n                                                        if !(ret !=\n                                                                 0 as\n                                                                     std::os::raw::c_int)\n                                                           {\n                                                            if stream !=\n                                                                   __stdoutp {\n                                                                ret =\n                                                                    fclose(stream);\n                                                                outputHandleJustInCase\n                                                                    =\n                                                                    0 as\n                                                                        *mut FILE;\n                                                                if ret ==\n                                                                       -(1 as\n                                                                             std::os::raw::c_int)\n                                                                   {\n                                                                    current_block\n                                                                        =\n                                                                        5049394217699438129;\n                                                                } else {\n                                                                    current_block\n                                                                        =\n                                                                        14775119014532381840;\n                                                                }\n                                                            } else {\n                                                                current_block\n                                                                    =\n                                                                    14775119014532381840;\n                                                            }\n                                                            match current_block\n                                                                {\n                                                                5049394217699438129\n                                                                => {\n                                                                }\n                                                                _ => {\n                                                                    outputHandleJustInCase\n                                                                        =\n                                                                        0 as\n                                                                            *mut FILE;\n                                                                    if verbosity\n                                                                           >=\n                                                                           2\n                                                                               as\n                                                                               std::os::raw::c_int\n                                                                       {\n                                                                        fprintf(__stderrp,\n                                                                                b\"\\n    \\x00\"\n                                                                                    as\n                                                                                    *const u8\n                                                                                    as\n                                                                                    *const std::os::raw::c_char);\n                                                                    }\n                                                                    return 1\n                                                                               as\n                                                                               std::os::raw::c_int\n                                                                               as\n                                                                               Bool\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }",
        "sub_chunks": [],
        "live_in": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut ret: i32"
        ],
        "live_out": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut ret: i32",
          "ret: i32"
        ]
      },
      {
        "chunk_id": 8,
        "span": "bzip2.rs:775:9: 1126:22 (#0)",
        "pieces": [
          "bzip2.rs:775:9: 822:36 (#0)",
          "bzip2.rs:1089:1: 1091:36 (#0)",
          "bzip2.rs:1123:1: 1126:22 (#0)"
        ],
        "num_lines": 55,
        "source": "match current_block {\n                        18063049917807660484 => {\n                            if forceOverwrite != 0 {\n                                rewind(zStream);\n                                loop  {\n                                    if !(1 as std::os::raw::c_int as Bool != 0) {\n                                        current_block = 926243229934402080;\n                                        break ;\n                                    }\n                                    if myfeof(zStream) != 0 {\n                                        current_block = 926243229934402080;\n                                        break ;\n                                    }\n                                    nread =\n                                        fread(obuf.as_mut_ptr() as\n                                                  *mut std::os::raw::c_void,\n                                              ::std::mem::size_of::<UChar>()\n                                                  as std::os::raw::c_ulong,\n                                              5000 as std::os::raw::c_int as\n                                                  std::os::raw::c_ulong, zStream) as\n                                            Int32;\n                                    if ferror(zStream) != 0 {\n                                        current_block = 5049394217699438129;\n                                        break ;\n                                    }\n                                    if nread > 0 as std::os::raw::c_int {\n                                        fwrite(obuf.as_mut_ptr() as\n                                                   *const std::os::raw::c_void,\n                                               ::std::mem::size_of::<UChar>()\n                                                   as std::os::raw::c_ulong,\n                                               nread as std::os::raw::c_ulong,\n                                               stream);\n                                    }\n                                    if ferror(stream) != 0 {\n                                        current_block = 5049394217699438129;\n                                        break ;\n                                    }\n                                }\n                            } else { current_block = 673979509383251364; }\n                        }\n                        _ => { }\n                    }\n                    match current_block {\n                        5049394217699438129 => { }\n                        _ => {\n                            match current_block {\n                                673979509383251364 => {\n                                   <<chunk 6>>                                }\n                                _ => {\n                                   <<chunk 7>>                                }\n                            }\n                        }\n                    }",
        "sub_chunks": [
          6,
          7
        ],
        "live_in": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut ret: i32",
          "mut nread: i32",
          "mut streamNo: i32",
          "mut obuf: [u8; 5000]",
          "mut current_block: u64"
        ],
        "live_out": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut ret: i32",
          "mut nread: i32",
          "mut streamNo: i32",
          "mut obuf: [u8; 5000]",
          "mut current_block: u64"
        ]
      },
      {
        "chunk_id": 9,
        "span": "bzip2.rs:726:13: 1129:2 (#0)",
        "pieces": [
          "bzip2.rs:726:13: 775:8 (#0)",
          "bzip2.rs:1127:1: 1129:2 (#0)"
        ],
        "num_lines": 71,
        "source": "'s_51:\n                loop  {\n                    if !(1 as std::os::raw::c_int as Bool != 0) {\n                        current_block = 926243229934402080;\n                        break ;\n                    }\n                    bzf =\n                        BZ2_bzReadOpen(&mut bzerr, zStream, verbosity,\n                                       smallMode as std::os::raw::c_int,\n                                       unused.as_mut_ptr() as\n                                           *mut std::os::raw::c_void, nUnused);\n                    if bzf.is_null() || bzerr != 0 as std::os::raw::c_int {\n                        current_block = 673979509383251364;\n                        break ;\n                    }\n                    streamNo += 1;\n                    while bzerr == 0 as std::os::raw::c_int {\n                        nread =\n                            BZ2_bzRead(&mut bzerr, bzf,\n                                       obuf.as_mut_ptr() as *mut std::os::raw::c_void,\n                                       5000 as std::os::raw::c_int);\n                        if bzerr == -(5 as std::os::raw::c_int) {\n                            current_block = 18063049917807660484;\n                            break 's_51 ;\n                        }\n                        if (bzerr == 0 as std::os::raw::c_int ||\n                                bzerr == 4 as std::os::raw::c_int) &&\n                               nread > 0 as std::os::raw::c_int {\n                            fwrite(obuf.as_mut_ptr() as *const std::os::raw::c_void,\n                                   ::std::mem::size_of::<UChar>() as\n                                       std::os::raw::c_ulong, nread as std::os::raw::c_ulong,\n                                   stream);\n                        }\n                        if ferror(stream) != 0 {\n                            current_block = 5049394217699438129;\n                            break 's_51 ;\n                        }\n                    }\n                    if bzerr != 4 as std::os::raw::c_int {\n                        current_block = 673979509383251364;\n                        break ;\n                    }\n                    BZ2_bzReadGetUnused(&mut bzerr, bzf, &mut unusedTmpV,\n                                        &mut nUnused);\n                    if bzerr != 0 as std::os::raw::c_int {\n                        panic(b\"decompress:bzReadGetUnused\\x00\" as *const u8\n                                  as *const std::os::raw::c_char);\n                    }\n                    unusedTmp = unusedTmpV as *mut UChar;\n                    i = 0 as std::os::raw::c_int;\n                    while i < nUnused {\n                        unused[i as usize] = *unusedTmp.offset(i as isize);\n                        i += 1\n                    }\n                    BZ2_bzReadClose(&mut bzerr, bzf);\n                    if bzerr != 0 as std::os::raw::c_int {\n                        panic(b\"decompress:bzReadGetUnused\\x00\" as *const u8\n                                  as *const std::os::raw::c_char);\n                    }\n                    if nUnused == 0 as std::os::raw::c_int &&\n                           myfeof(zStream) as std::os::raw::c_int != 0 {\n                        current_block = 926243229934402080;\n                        break ;\n                    }\n                }\n            match current_block {\n                5049394217699438129 => { }\n                _ => {\n                   <<chunk 8>>                }\n            }",
        "sub_chunks": [
          8
        ],
        "live_in": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut ret: i32",
          "mut nread: i32",
          "mut streamNo: i32",
          "mut obuf: [u8; 5000]",
          "mut unused: [u8; 5000]",
          "mut nUnused: i32",
          "mut unusedTmpV: *mut std::ffi::c_void"
        ],
        "live_out": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut ret: i32",
          "mut nread: i32",
          "mut streamNo: i32",
          "mut obuf: [u8; 5000]",
          "mut unused: [u8; 5000]",
          "mut nUnused: i32",
          "mut unusedTmpV: *mut std::ffi::c_void",
          "mut current_block: u64"
        ]
      },
      {
        "chunk_id": 10,
        "span": "bzip2.rs:709:9: 1133:10 (#0)",
        "pieces": [
          "bzip2.rs:709:9: 726:12 (#0)",
          "bzip2.rs:1131:1: 1133:10 (#0)"
        ],
        "num_lines": 21,
        "source": "let mut current_block: u64;\n    let mut bzf: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    let mut bzerr: Int32 = 0;\n    let mut bzerr_dummy: Int32 = 0;\n    let mut ret: Int32 = 0;\n    let mut nread: Int32 = 0;\n    let mut streamNo: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut obuf: [UChar; 5000] = [0; 5000];\n    let mut unused: [UChar; 5000] = [0; 5000];\n    let mut nUnused: Int32 = 0;\n    let mut unusedTmpV: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    let mut unusedTmp: *mut UChar = 0 as *mut UChar;\n    nUnused = 0 as std::os::raw::c_int;\n    streamNo = 0 as std::os::raw::c_int;\n    if !(ferror(stream) != 0) {\n        if !(ferror(zStream) != 0) {\n           <<chunk 9>>        }\n    }\n    ioError();",
        "sub_chunks": [
          9
        ],
        "live_in": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE"
        ],
        "live_out": [
          "zStream: *mut blocksort::__sFILE",
          "stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut ret: i32",
          "mut nread: i32",
          "mut streamNo: i32",
          "mut i: i32",
          "mut obuf: [u8; 5000]",
          "mut unused: [u8; 5000]",
          "mut nUnused: i32",
          "mut unusedTmpV: *mut std::ffi::c_void",
          "mut unusedTmp: *mut u8"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:248 ~ c2rust_out[3c70]::bzip2::pad)",
    "span": "bzip2.rs:1643:1: 1651:2 (#0)",
    "pieces": [
      "bzip2.rs:1643:1: 1651:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn pad(mut s: *mut Char) {\n    let mut i: Int32 = 0;\n    if strlen(s) as Int32 >= longestFileName { return }\n    i = 1 as std::os::raw::c_int;\n    while i <= longestFileName - strlen(s) as Int32 {\n        fprintf(__stderrp, b\" \\x00\" as *const u8 as *const std::os::raw::c_char);\n        i += 1\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:321 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2525:9: 2525:43 (#0)",
        "source": "pad(&mut inName, longestFileName);"
      },
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2129:9: 2129:43 (#0)",
        "source": "pad(&mut inName, longestFileName);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2373:9: 2373:43 (#0)",
        "source": "pad(&mut inName, longestFileName);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:251 ~ c2rust_out[3c70]::bzip2::fopen_output_safely)",
    "span": "bzip2.rs:1688:1: 1701:2 (#0)",
    "pieces": [
      "bzip2.rs:1688:1: 1701:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "unsafe extern \"C\" fn fopen_output_safely(mut name: *mut Char,\n                                         mut mode: *const std::os::raw::c_char)\n -> *mut FILE {\n    let mut fp: *mut FILE = 0 as *mut FILE;\n    let mut fh: IntNative = 0;\n    fh =\n        open(name,\n             0x1 as std::os::raw::c_int | 0x200 as std::os::raw::c_int | 0x800 as std::os::raw::c_int,\n             0o200 as std::os::raw::c_int | 0o400 as std::os::raw::c_int);\n    if fh == -(1 as std::os::raw::c_int) { return 0 as *mut FILE }\n    fp = fdopen(fh, mode);\n    if fp.is_null() { close(fh); }\n    return fp;\n}",
    "calls": [
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2099:13: 2102:70 (#0)",
        "source": "outStr =\n                fopen_output_safely(outName.as_mut_ptr(),\n                                    b\"wb\\x00\" as *const u8 as\n                                        *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2343:13: 2346:70 (#0)",
        "source": "outStr =\n                fopen_output_safely(outName.as_mut_ptr(),\n                                    b\"wb\\x00\" as *const u8 as\n                                        *const std::os::raw::c_char);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:258 ~ c2rust_out[3c70]::bzip2::saveInputFileMetaInfo)",
    "span": "bzip2.rs:1806:1: 1834:2 (#0)",
    "pieces": [
      "bzip2.rs:1806:1: 1834:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn saveInputFileMetaInfo(mut srcName: *mut Char) {\n    let mut retVal: IntNative = 0;\n    /* Note use of stat here, not lstat. */\n    retVal = stat(srcName, &mut fileMetaInfo);\n    if retVal != 0 as std::os::raw::c_int { ioError(); };\n}",
    "calls": [
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2050:9: 2050:48 (#0)",
        "source": "saveInputFileMetaInfo(inName.as_ptr());"
      },
      {
        "caller": "DefId(0:319 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2306:9: 2306:48 (#0)",
        "source": "saveInputFileMetaInfo(inName.as_ptr());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
    "span": "bzip2.rs:2154:1: 2419:2 (#0)",
    "pieces": [
      "bzip2.rs:2154:1: 2155:4 (#0)",
      "bzip2.rs:2303:1: 2303:4 (#0)",
      "bzip2.rs:2419:1: 2419:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn uncompress(mut name: *mut Char) {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:330 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2928:9: 2928:42 (#0)",
        "source": "uncompress(std::ptr::null_mut());"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:418:1: 418:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:426:1: 427:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      },
      {
        "span": "bzip2.rs:422:1: 422:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      },
      {
        "span": "bzip2.rs:392:1: 392:50 (#0)",
        "source": "pub static mut deleteOutputOnInterrupt: Bool = 0;"
      },
      {
        "span": "bzip2.rs:414:1: 414:43 (#0)",
        "source": "pub static mut longestFileName: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:412:1: 412:35 (#0)",
        "source": "pub static mut srcMode: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:416:1: 416:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:398:1: 398:40 (#0)",
        "source": "pub static mut unzFailsExist: Bool = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "bzip2.rs:2155:5: 2302:6 (#0)",
        "pieces": [
          "bzip2.rs:2155:5: 2302:6 (#0)"
        ],
        "num_lines": 149,
        "source": "let mut current_block: u64;\n    let mut inStr: *mut FILE = 0 as *mut FILE;\n    let mut outStr: *mut FILE = 0 as *mut FILE;\n    let mut n: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut magicNumberOK: Bool = 0;\n    let mut cantGuess: Bool = 0;\n    let mut statBuf: stat =\n        stat{st_dev: 0,\n             st_mode: 0,\n             st_nlink: 0,\n             st_ino: 0,\n             st_uid: 0,\n             st_gid: 0,\n             st_rdev: 0,\n             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_size: 0,\n             st_blocks: 0,\n             st_blksize: 0,\n             st_flags: 0,\n             st_gen: 0,\n             st_lspare: 0,\n             st_qspare: [0; 2],};\n    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n    if name.is_null() && srcMode != 1 as std::os::raw::c_int {\n        panic(b\"uncompress: bad modes\\n\\x00\" as *const u8 as\n                  *const std::os::raw::c_char);\n    }\n    cantGuess = 0 as std::os::raw::c_int as Bool;\n    match srcMode {\n        1 => {\n            copyFileName(inName.as_mut_ptr(),\n                         b\"(stdin)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                             *mut Char);\n            copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);\n        }\n        3 => {\n            copyFileName(inName.as_mut_ptr(), name);\n            copyFileName(outName.as_mut_ptr(), name);\n            i = 0 as std::os::raw::c_int;\n            loop  {\n                if !(i < 4 as std::os::raw::c_int) {\n                    current_block = 17860125682698302841;\n                    break ;\n                }\n                if mapSuffix(outName.as_mut_ptr(), zSuffix[i as usize],\n                             unzSuffix[i as usize]) != 0 {\n                    current_block = 15314513098708193206;\n                    break ;\n                }\n                i += 1\n            }\n            match current_block {\n                15314513098708193206 => { }\n                _ => {\n                    cantGuess = 1 as std::os::raw::c_int as Bool;\n                    strcat(outName.as_mut_ptr(),\n                           b\".out\\x00\" as *const u8 as *const std::os::raw::c_char);\n                }\n            }\n        }\n        2 => {\n            copyFileName(inName.as_mut_ptr(), name);\n            copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);\n        }\n        _ => { }\n    }\n    if srcMode != 1 as std::os::raw::c_int &&\n           containsDubiousChars(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if noisy != 0 {\n            fprintf(__stderrp,\n                    b\"%s: There are no files matching `%s\\'.\\n\\x00\" as\n                        *const u8 as *const std::os::raw::c_char, progName,\n                    inName.as_mut_ptr());\n        }\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode != 1 as std::os::raw::c_int && fileExists(inName.as_mut_ptr()) == 0 {\n        fprintf(__stderrp,\n                b\"%s: Can\\'t open input file %s: %s.\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, progName, inName.as_mut_ptr(),\n                strerror(*__error()));\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode == 3 as std::os::raw::c_int || srcMode == 2 as std::os::raw::c_int {\n        stat(inName.as_mut_ptr(), &mut statBuf);\n        if statBuf.st_mode as std::os::raw::c_int & 0o170000 as std::os::raw::c_int ==\n               0o40000 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"%s: Input file %s is a directory.\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, progName, inName.as_mut_ptr());\n            setExit(1 as std::os::raw::c_int);\n            return\n        }\n    }\n    if srcMode == 3 as std::os::raw::c_int && forceOverwrite == 0 &&\n           notAStandardFile(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if noisy != 0 {\n            fprintf(__stderrp,\n                    b\"%s: Input file %s is not a normal file.\\n\\x00\" as\n                        *const u8 as *const std::os::raw::c_char, progName,\n                    inName.as_mut_ptr());\n        }\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if cantGuess != 0 {\n        if noisy != 0 {\n            fprintf(__stderrp,\n                    b\"%s: Can\\'t guess original name for %s -- using %s\\n\\x00\"\n                        as *const u8 as *const std::os::raw::c_char, progName,\n                    inName.as_mut_ptr(), outName.as_mut_ptr());\n        }\n        /* just a warning, no return */\n    }\n    if srcMode == 3 as std::os::raw::c_int &&\n           fileExists(outName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if forceOverwrite != 0 {\n            remove(outName.as_mut_ptr());\n        } else {\n            fprintf(__stderrp,\n                    b\"%s: Output file %s already exists.\\n\\x00\" as *const u8\n                        as *const std::os::raw::c_char, progName,\n                    outName.as_mut_ptr());\n            setExit(1 as std::os::raw::c_int);\n            return\n        }\n    }\n    if srcMode == 3 as std::os::raw::c_int && forceOverwrite == 0 &&\n           { n = countHardLinks(inName.as_mut_ptr()); (n) > 0 as std::os::raw::c_int }\n       {\n        fprintf(__stderrp,\n                b\"%s: Input file %s has %d other link%s.\\n\\x00\" as *const u8\n                    as *const std::os::raw::c_char, progName, inName.as_mut_ptr(), n,\n                if n > 1 as std::os::raw::c_int {\n                    b\"s\\x00\" as *const u8 as *const std::os::raw::c_char\n                } else { b\"\\x00\" as *const u8 as *const std::os::raw::c_char });\n        setExit(1 as std::os::raw::c_int);\n        return\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut name: *mut i8"
        ],
        "live_out": [
          "mut name: *mut i8",
          "mut current_block: u64",
          "mut inStr: *mut blocksort::__sFILE",
          "mut outStr: *mut blocksort::__sFILE",
          "mut n: i32",
          "mut i: i32",
          "mut magicNumberOK: u8",
          "mut cantGuess: u8",
          "mut statBuf: bzip2::stat"
        ]
      },
      {
        "chunk_id": 1,
        "span": "bzip2.rs:2303:5: 2418:7 (#0)",
        "pieces": [
          "bzip2.rs:2303:5: 2418:7 (#0)"
        ],
        "num_lines": 115,
        "source": "if srcMode == 3 as std::os::raw::c_int {\n        /* Save the file's meta-info before we open it.  Doing it later\n         means we mess up the access times. */\n        saveInputFileMetaInfo(inName.as_mut_ptr());\n    }\n    match srcMode {\n        1 => {\n            inStr = __stdinp;\n            outStr = __stdoutp;\n            if isatty(fileno(__stdinp)) != 0 {\n                fprintf(__stderrp,\n                        b\"%s: I won\\'t read compressed data from a terminal.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char, progName);\n                fprintf(__stderrp,\n                        b\"%s: For help, type: `%s --help\\'.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        progName);\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        2 => {\n            inStr =\n                fopen(inName.as_mut_ptr(),\n                      b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n            outStr = __stdoutp;\n            if inStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t open input file %s:%s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        inName.as_mut_ptr(), strerror(*__error()));\n                if !inStr.is_null() { fclose(inStr); }\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        3 => {\n            inStr =\n                fopen(inName.as_mut_ptr(),\n                      b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n            outStr =\n                fopen_output_safely(outName.as_mut_ptr(),\n                                    b\"wb\\x00\" as *const u8 as\n                                        *const std::os::raw::c_char);\n            if outStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t create output file %s: %s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        outName.as_mut_ptr(), strerror(*__error()));\n                if !inStr.is_null() { fclose(inStr); }\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n            if inStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t open input file %s: %s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        inName.as_mut_ptr(), strerror(*__error()));\n                if !outStr.is_null() { fclose(outStr); }\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        _ => {\n            panic(b\"uncompress: bad srcMode\\x00\" as *const u8 as\n                      *const std::os::raw::c_char);\n        }\n    }\n    if verbosity >= 1 as std::os::raw::c_int {\n        fprintf(__stderrp, b\"  %s: \\x00\" as *const u8 as *const std::os::raw::c_char,\n                inName.as_mut_ptr());\n        pad(inName.as_mut_ptr());\n        fflush(__stderrp);\n    }\n    /*--- Now the input and output handles are sane.  Do the Biz. ---*/\n    outputHandleJustInCase = outStr;\n    deleteOutputOnInterrupt = 1 as std::os::raw::c_int as Bool;\n    magicNumberOK = uncompressStream(inStr, outStr);\n    outputHandleJustInCase = 0 as *mut FILE;\n    /*--- If there was an I/O error, we won't get here. ---*/\n    if magicNumberOK != 0 {\n        if srcMode == 3 as std::os::raw::c_int {\n            applySavedTimeInfoToOutputFile(outName.as_mut_ptr());\n            deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n            if keepInputFiles == 0 {\n                let mut retVal: IntNative = remove(inName.as_mut_ptr());\n                if retVal != 0 as std::os::raw::c_int { ioError(); }\n            }\n        }\n    } else {\n        unzFailsExist = 1 as std::os::raw::c_int as Bool;\n        deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n        if srcMode == 3 as std::os::raw::c_int {\n            let mut retVal_0: IntNative = remove(outName.as_mut_ptr());\n            if retVal_0 != 0 as std::os::raw::c_int { ioError(); }\n        }\n    }\n    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n    if magicNumberOK != 0 {\n        if verbosity >= 1 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"done\\n\\x00\" as *const u8 as *const std::os::raw::c_char);\n        }\n    } else {\n        setExit(2 as std::os::raw::c_int);\n        if verbosity >= 1 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"not a bzip2 file.\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char);\n        } else {\n            fprintf(__stderrp,\n                    b\"%s: %s is not a bzip2 file.\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, progName, inName.as_mut_ptr());\n        }\n    };",
        "sub_chunks": [],
        "live_in": [
          "mut inStr: *mut blocksort::__sFILE",
          "mut outStr: *mut blocksort::__sFILE",
          "mut n: i32",
          "mut magicNumberOK: u8"
        ],
        "live_out": []
      }
    ]
  },
  {
    "func_defid": "DefId(0:419 ~ c2rust_out[3c70]::bzlib::default_bzalloc)",
    "span": "bzlib.rs:287:1: 291:2 (#0)",
    "pieces": [
      "bzlib.rs:287:1: 291:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn default_bzalloc(mut opaque: *mut std::os::raw::c_void,\n                                     mut items: Int32, mut size: Int32)\n -> *mut std::os::raw::c_void {\n    let mut v: *mut std::os::raw::c_void = malloc((items * size) as std::os::raw::c_ulong);\n    return v;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:449 ~ c2rust_out[3c70]::bzlib::BZ2_bzlibVersion)",
    "span": "bzlib.rs:2200:1: 2202:2 (#0)",
    "pieces": [
      "bzlib.rs:2200:1: 2202:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub extern \"C\" fn BZ2_bzlibVersion() -> *const std::os::raw::c_char {\n    return b\"1.0.8, 13-Jul-2019\\x00\" as *const u8 as *const std::os::raw::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:274 ~ c2rust_out[3c70]::bzip2::license)",
    "span": "bzip2.rs:2537:1: 2542:2 (#0)",
    "pieces": [
      "bzip2.rs:2537:1: 2542:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn license() {\n    fprintf(__stderrp,\n            b\"bzip2, a block-sorting file compressor.  Version %s.\\n   \\n   Copyright (C) 1996-2019 by Julian Seward.\\n   \\n   This program is free software; you can redistribute it and/or modify\\n   it under the terms set out in the LICENSE file, which is included\\n   in the bzip2 source distribution.\\n   \\n   This program is distributed in the hope that it will be useful,\\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n   LICENSE file for more details.\\n   \\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, BZ2_bzlibVersion());\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:442 ~ c2rust_out[3c70]::bzlib::BZ2_bzWriteClose64)",
    "span": "bzlib.rs:1788:1: 1882:2 (#0)",
    "pieces": [
      "bzlib.rs:1788:1: 1882:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 95,
    "source": "pub unsafe extern \"C\" fn BZ2_bzWriteClose64(mut bzerror: *mut std::os::raw::c_int,\n                                            mut b: *mut std::os::raw::c_void,\n                                            mut abandon: std::os::raw::c_int,\n                                            mut nbytes_in_lo32:\n                                                *mut std::os::raw::c_uint,\n                                            mut nbytes_in_hi32:\n                                                *mut std::os::raw::c_uint,\n                                            mut nbytes_out_lo32:\n                                                *mut std::os::raw::c_uint,\n                                            mut nbytes_out_hi32:\n                                                *mut std::os::raw::c_uint) {\n    let mut n: Int32 = 0;\n    let mut n2: Int32 = 0;\n    let mut ret: Int32 = 0;\n    let mut bzf: *mut bzFile = b as *mut bzFile;\n    if bzf.is_null() {\n        if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n        if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n        return\n    }\n    if (*bzf).writing == 0 {\n        if !bzerror.is_null() { *bzerror = -(1 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(1 as std::os::raw::c_int) }\n        return\n    }\n    if ferror((*bzf).handle) != 0 {\n        if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n        return\n    }\n    if !nbytes_in_lo32.is_null() {\n        *nbytes_in_lo32 = 0 as std::os::raw::c_int as std::os::raw::c_uint\n    }\n    if !nbytes_in_hi32.is_null() {\n        *nbytes_in_hi32 = 0 as std::os::raw::c_int as std::os::raw::c_uint\n    }\n    if !nbytes_out_lo32.is_null() {\n        *nbytes_out_lo32 = 0 as std::os::raw::c_int as std::os::raw::c_uint\n    }\n    if !nbytes_out_hi32.is_null() {\n        *nbytes_out_hi32 = 0 as std::os::raw::c_int as std::os::raw::c_uint\n    }\n    if abandon == 0 && (*bzf).lastErr == 0 as std::os::raw::c_int {\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            (*bzf).strm.avail_out = 5000 as std::os::raw::c_int as std::os::raw::c_uint;\n            (*bzf).strm.next_out = (*bzf).buf.as_mut_ptr();\n            ret = BZ2_bzCompress(&mut (*bzf).strm, 2 as std::os::raw::c_int);\n            if ret != 3 as std::os::raw::c_int && ret != 4 as std::os::raw::c_int {\n                if !bzerror.is_null() { *bzerror = ret }\n                if !bzf.is_null() { (*bzf).lastErr = ret }\n                return\n            }\n            if (*bzf).strm.avail_out < 5000 as std::os::raw::c_int as std::os::raw::c_uint {\n                n =\n                    (5000 as std::os::raw::c_int as\n                         std::os::raw::c_uint).wrapping_sub((*bzf).strm.avail_out) as\n                        Int32;\n                n2 =\n                    fwrite((*bzf).buf.as_mut_ptr() as *mut std::os::raw::c_void,\n                           ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong,\n                           n as std::os::raw::c_ulong, (*bzf).handle) as Int32;\n                if n != n2 || ferror((*bzf).handle) != 0 {\n                    if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n                    if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n                    return\n                }\n            }\n            if ret == 4 as std::os::raw::c_int { break ; }\n        }\n    }\n    if abandon == 0 && ferror((*bzf).handle) == 0 {\n        fflush((*bzf).handle);\n        if ferror((*bzf).handle) != 0 {\n            if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n            if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n            return\n        }\n    }\n    if !nbytes_in_lo32.is_null() {\n        *nbytes_in_lo32 = (*bzf).strm.total_in_lo32\n    }\n    if !nbytes_in_hi32.is_null() {\n        *nbytes_in_hi32 = (*bzf).strm.total_in_hi32\n    }\n    if !nbytes_out_lo32.is_null() {\n        *nbytes_out_lo32 = (*bzf).strm.total_out_lo32\n    }\n    if !nbytes_out_hi32.is_null() {\n        *nbytes_out_hi32 = (*bzf).strm.total_out_hi32\n    }\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    BZ2_bzCompressEnd(&mut (*bzf).strm);\n    free(bzf as *mut std::os::raw::c_void);\n}",
    "calls": [
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:652:9: 652:140 (#0)",
        "source": "BZ2_bzWriteClose64(&mut bzerr_dummy, bzf, 1, &mut nbytes_in_lo32, &mut nbytes_in_hi32, &mut nbytes_out_lo32, &mut nbytes_out_hi32);"
      },
      {
        "caller": "DefId(0:525 ~ c2rust_out[3c70]::bzlib::BZ2_bzWriteClose)",
        "span": "bzlib.rs:1783:9: 1783:124 (#0)",
        "source": "BZ2_bzWriteClose64(bzerror, b, abandon, nbytes_in_ptr, std::ptr::null_mut(), nbytes_out_ptr, std::ptr::null_mut());"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:571:9: 575:50 (#0)",
        "source": "BZ2_bzWriteClose64(&mut bzerr, bzf, 0, \n                           &mut nbytes_in_lo32, \n                           &mut nbytes_in_hi32, \n                           &mut nbytes_out_lo32, \n                           &mut nbytes_out_hi32);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:441 ~ c2rust_out[3c70]::bzlib::BZ2_bzWriteClose)",
    "span": "bzlib.rs:1779:1: 1785:2 (#0)",
    "pieces": [
      "bzlib.rs:1779:1: 1785:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn BZ2_bzWriteClose(mut bzerror: *mut std::os::raw::c_int,\n                                          mut b: *mut std::os::raw::c_void,\n                                          mut abandon: std::os::raw::c_int,\n                                          mut nbytes_in: *mut std::os::raw::c_uint,\n                                          mut nbytes_out: *mut std::os::raw::c_uint) {\n    BZ2_bzWriteClose64(bzerror, b, abandon, nbytes_in, 0 as *mut std::os::raw::c_uint,\n                       nbytes_out, 0 as *mut std::os::raw::c_uint);\n}",
    "calls": [
      {
        "caller": "DefId(0:546 ~ c2rust_out[3c70]::bzlib::BZ2_bzclose)",
        "span": "bzlib.rs:2358:9: 2358:60 (#0)",
        "source": "BZ2_bzWriteClose(&mut bzerr, b, 0, &mut 0, &mut 0);"
      },
      {
        "caller": "DefId(0:546 ~ c2rust_out[3c70]::bzlib::BZ2_bzclose)",
        "span": "bzlib.rs:2361:1: 2361:52 (#0)",
        "source": "BZ2_bzWriteClose(&mut bzerr, b, 1, &mut 0, &mut 0);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:439 ~ c2rust_out[3c70]::bzlib::BZ2_bzWriteOpen)",
    "span": "bzlib.rs:1657:1: 1711:2 (#0)",
    "pieces": [
      "bzlib.rs:1657:1: 1711:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 55,
    "source": "pub unsafe extern \"C\" fn BZ2_bzWriteOpen(mut bzerror: *mut std::os::raw::c_int,\n                                         mut f: *mut FILE,\n                                         mut blockSize100k: std::os::raw::c_int,\n                                         mut verbosity: std::os::raw::c_int,\n                                         mut workFactor: std::os::raw::c_int)\n -> *mut std::os::raw::c_void {\n    let mut ret: Int32 = 0;\n    let mut bzf: *mut bzFile = 0 as *mut bzFile;\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    if f.is_null() ||\n           (blockSize100k < 1 as std::os::raw::c_int ||\n                blockSize100k > 9 as std::os::raw::c_int) ||\n           (workFactor < 0 as std::os::raw::c_int || workFactor > 250 as std::os::raw::c_int)\n           || (verbosity < 0 as std::os::raw::c_int || verbosity > 4 as std::os::raw::c_int) {\n        if !bzerror.is_null() { *bzerror = -(2 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(2 as std::os::raw::c_int) }\n        return 0 as *mut std::os::raw::c_void\n    }\n    if ferror(f) != 0 {\n        if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n        return 0 as *mut std::os::raw::c_void\n    }\n    bzf =\n        malloc(::std::mem::size_of::<bzFile>() as std::os::raw::c_ulong) as\n            *mut bzFile;\n    if bzf.is_null() {\n        if !bzerror.is_null() { *bzerror = -(3 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(3 as std::os::raw::c_int) }\n        return 0 as *mut std::os::raw::c_void\n    }\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    (*bzf).initialisedOk = 0 as std::os::raw::c_int as Bool;\n    (*bzf).bufN = 0 as std::os::raw::c_int;\n    (*bzf).handle = f;\n    (*bzf).writing = 1 as std::os::raw::c_int as Bool;\n    (*bzf).strm.bzalloc = None;\n    (*bzf).strm.bzfree = None;\n    (*bzf).strm.opaque = 0 as *mut std::os::raw::c_void;\n    if workFactor == 0 as std::os::raw::c_int { workFactor = 30 as std::os::raw::c_int }\n    ret =\n        BZ2_bzCompressInit(&mut (*bzf).strm, blockSize100k, verbosity,\n                           workFactor);\n    if ret != 0 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = ret }\n        if !bzf.is_null() { (*bzf).lastErr = ret }\n        free(bzf as *mut std::os::raw::c_void);\n        return 0 as *mut std::os::raw::c_void\n    }\n    (*bzf).strm.avail_in = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*bzf).initialisedOk = 1 as std::os::raw::c_int as Bool;\n    return bzf as *mut std::os::raw::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:535 ~ c2rust_out[3c70]::bzlib::bzopen_or_bzdopen)",
        "span": "bzlib.rs:2252:21: 2263:6 (#0)",
        "source": "{\n        /* Guard against total chaos and anarchy -- JRS */\n        if blockSize100k < 1 as std::os::raw::c_int {\n            blockSize100k = 1 as std::os::raw::c_int\n        }\n        if blockSize100k > 9 as std::os::raw::c_int {\n            blockSize100k = 9 as std::os::raw::c_int\n        }\n        bzfp =\n            BZ2_bzWriteOpen(&mut bzerr, fp, blockSize100k, verbosity,\n                            workFactor)\n    }"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:530:1: 530:86 (#0)",
        "source": "let bzf = BZ2_bzWriteOpen(&mut bzerr, zStream, blockSize100k, verbosity, workFactor);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:450 ~ c2rust_out[3c70]::bzlib::bzopen_or_bzdopen)",
    "span": "bzlib.rs:2205:1: 2273:2 (#0)",
    "pieces": [
      "bzlib.rs:2205:1: 2273:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 69,
    "source": "unsafe extern \"C\" fn bzopen_or_bzdopen(mut path: *const std::os::raw::c_char,\n                                       mut fd: std::os::raw::c_int,\n                                       mut mode: *const std::os::raw::c_char,\n                                       mut open_mode: std::os::raw::c_int)\n -> *mut std::os::raw::c_void \n /* bzopen: 0, bzdopen:1 */\n {\n    let mut bzerr: std::os::raw::c_int = 0; /* binary mode */\n    let mut unused: [std::os::raw::c_char; 5000] = [0; 5000];\n    let mut blockSize100k: std::os::raw::c_int = 9 as std::os::raw::c_int;\n    let mut writing: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut mode2: [std::os::raw::c_char; 10] =\n        *::std::mem::transmute::<&[u8; 10],\n                                 &mut [std::os::raw::c_char; 10]>(b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");\n    let mut fp: *mut FILE = 0 as *mut FILE;\n    let mut bzfp: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    let mut verbosity: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut workFactor: std::os::raw::c_int = 30 as std::os::raw::c_int;\n    let mut smallMode: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut nUnused: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    if mode.is_null() { return 0 as *mut std::os::raw::c_void }\n    while *mode != 0 {\n        match *mode as std::os::raw::c_int {\n            114 => { writing = 0 as std::os::raw::c_int }\n            119 => { writing = 1 as std::os::raw::c_int }\n            115 => { smallMode = 1 as std::os::raw::c_int }\n            _ => {\n                if isdigit(*mode as std::os::raw::c_int) != 0 {\n                    blockSize100k = *mode as std::os::raw::c_int - 0x30 as std::os::raw::c_int\n                }\n            }\n        }\n        mode = mode.offset(1)\n    }\n    strcat(mode2.as_mut_ptr(),\n           if writing != 0 {\n               b\"w\\x00\" as *const u8 as *const std::os::raw::c_char\n           } else { b\"r\\x00\" as *const u8 as *const std::os::raw::c_char });\n    strcat(mode2.as_mut_ptr(), b\"b\\x00\" as *const u8 as *const std::os::raw::c_char);\n    if open_mode == 0 as std::os::raw::c_int {\n        if path.is_null() ||\n               strcmp(path, b\"\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                   0 as std::os::raw::c_int {\n            fp = if writing != 0 { __stdoutp } else { __stdinp }\n        } else { fp = fopen(path, mode2.as_mut_ptr()) }\n    } else { fp = fdopen(fd, mode2.as_mut_ptr()) }\n    if fp.is_null() { return 0 as *mut std::os::raw::c_void }\n    if writing != 0 {\n        /* Guard against total chaos and anarchy -- JRS */\n        if blockSize100k < 1 as std::os::raw::c_int {\n            blockSize100k = 1 as std::os::raw::c_int\n        }\n        if blockSize100k > 9 as std::os::raw::c_int {\n            blockSize100k = 9 as std::os::raw::c_int\n        }\n        bzfp =\n            BZ2_bzWriteOpen(&mut bzerr, fp, blockSize100k, verbosity,\n                            workFactor)\n    } else {\n        bzfp =\n            BZ2_bzReadOpen(&mut bzerr, fp, verbosity, smallMode,\n                           unused.as_mut_ptr() as *mut std::os::raw::c_void, nUnused)\n    }\n    if bzfp.is_null() {\n        if fp != __stdinp && fp != __stdoutp { fclose(fp); }\n        return 0 as *mut std::os::raw::c_void\n    }\n    return bzfp;\n}",
    "calls": [
      {
        "caller": "DefId(0:541 ~ c2rust_out[3c70]::bzlib::BZ2_bzopen)",
        "span": "bzlib.rs:2285:18: 2287:6 (#0)",
        "source": "unsafe {\n        bzopen_or_bzdopen(c_path.as_ptr(), -(1 as std::os::raw::c_int), c_mode.as_ptr(), 0 as std::os::raw::c_int)\n    }"
      },
      {
        "caller": "DefId(0:542 ~ c2rust_out[3c70]::bzlib::BZ2_bzdopen)",
        "span": "bzlib.rs:2300:18: 2300:88 (#0)",
        "source": "unsafe { bzopen_or_bzdopen(std::ptr::null(), fd, c_mode.as_ptr(), 1) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:456 ~ c2rust_out[3c70]::bzlib::BZ2_bzopen)",
    "span": "bzlib.rs:2281:1: 2294:2 (#0)",
    "pieces": [
      "bzlib.rs:2281:1: 2294:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn BZ2_bzopen(mut path: *const std::os::raw::c_char,\n                                    mut mode: *const std::os::raw::c_char)\n -> *mut std::os::raw::c_void {\n    return bzopen_or_bzdopen(path, -(1 as std::os::raw::c_int), mode,\n                             0 as std::os::raw::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:275 ~ c2rust_out[3c70]::bzip2::usage)",
    "span": "bzip2.rs:2545:1: 2552:2 (#0)",
    "pieces": [
      "bzip2.rs:2545:1: 2552:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn usage(mut fullProgName: *mut Char) {\n    fprintf(__stderrp,\n            b\"bzip2, a block-sorting file compressor.  Version %s.\\n\\n   usage: %s [flags and input files in any order]\\n\\n   -h --help           print this message\\n   -d --decompress     force decompression\\n   -z --compress       force compression\\n   -k --keep           keep (don\\'t delete) input files\\n   -f --force          overwrite existing output files\\n   -t --test           test compressed file integrity\\n   -c --stdout         output to standard out\\n   -q --quiet          suppress noncritical error messages\\n   -v --verbose        be verbose (a 2nd -v gives more)\\n   -L --license        display software version & license\\n   -V --version        display software version & license\\n   -s --small          use less memory (at most 2500k)\\n   -1 .. -9            set block size to 100k .. 900k\\n   --fast              alias for -1\\n   --best              alias for -9\\n\\n   If invoked as `bzip2\\', default action is to compress.\\n              as `bunzip2\\',  default action is to decompress.\\n              as `bzcat\\', default action is to decompress to stdout.\\n\\n   If no file names are given, bzip2 compresses or decompresses\\n   from standard input to standard output.  You can combine\\n   short flags, so `-v -4\\' means the same as -v4 or -4v, &c.\\n\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, BZ2_bzlibVersion(),\n            fullProgName);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:438 ~ c2rust_out[3c70]::bzlib::myfeof)",
    "span": "bzlib.rs:1649:1: 1654:2 (#0)",
    "pieces": [
      "bzlib.rs:1649:1: 1654:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn myfeof(mut f: *mut FILE) -> Bool {\n    let mut c: Int32 = fgetc(f);\n    if c == -(1 as std::os::raw::c_int) { return 1 as std::os::raw::c_int as Bool }\n    ungetc(c, f);\n    return 0 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:266 ~ c2rust_out[3c70]::bzip2::hasSuffix)",
    "span": "bzip2.rs:1894:1: 1904:2 (#0)",
    "pieces": [
      "bzip2.rs:1894:1: 1904:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn hasSuffix(mut s: *mut Char, mut suffix: *const Char)\n -> Bool {\n    let mut ns: Int32 = strlen(s) as Int32;\n    let mut nx: Int32 = strlen(suffix) as Int32;\n    if ns < nx { return 0 as std::os::raw::c_int as Bool }\n    if strcmp(s.offset(ns as isize).offset(-(nx as isize)), suffix) ==\n           0 as std::os::raw::c_int {\n        return 1 as std::os::raw::c_int as Bool\n    }\n    return 0 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:500 ~ c2rust_out[3c70]::compress::bsPutUInt32)",
    "span": "compress.rs:124:1: 136:2 (#0)",
    "pieces": [
      "compress.rs:124:1: 136:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn bsPutUInt32(mut s: *mut EState, mut u: UInt32) {\n    bsW(s, 8 as std::os::raw::c_int,\n        ((u >> 24 as std::os::raw::c_int) as std::os::raw::c_long & 0xff as std::os::raw::c_long) as\n            UInt32);\n    bsW(s, 8 as std::os::raw::c_int,\n        ((u >> 16 as std::os::raw::c_int) as std::os::raw::c_long & 0xff as std::os::raw::c_long) as\n            UInt32);\n    bsW(s, 8 as std::os::raw::c_int,\n        ((u >> 8 as std::os::raw::c_int) as std::os::raw::c_long & 0xff as std::os::raw::c_long) as\n            UInt32);\n    bsW(s, 8 as std::os::raw::c_int,\n        (u as std::os::raw::c_long & 0xff as std::os::raw::c_long) as UInt32);\n}",
    "calls": [
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1323:9: 1323:45 (#0)",
        "source": "bsPutUInt32(&mut *s, (*s).blockCRC);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1352:9: 1352:48 (#0)",
        "source": "bsPutUInt32(&mut *s, (*s).combinedCRC);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:40:1: 40:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:41:1: 41:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:39:1: 39:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:42:1: 42:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:43:1: 43:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:332 ~ c2rust_out[3c70]::bzip2recover::tooManyBlocks)",
    "span": "bzip2recover.rs:161:1: 171:2 (#0)",
    "pieces": [
      "bzip2recover.rs:161:1: 171:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn tooManyBlocks(mut max_handled_blocks: Int32) {\n    fprintf(__stderrp,\n            b\"%s: `%s\\' appears to contain more than %d blocks\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr(),\n            inFileName.as_mut_ptr(), max_handled_blocks);\n    fprintf(__stderrp,\n            b\"%s: and cannot be handled.  To fix, increase\\n\\x00\" as *const u8\n                as *const std::os::raw::c_char, progName.as_mut_ptr());\n    fprintf(__stderrp,\n            b\"%s: BZ_MAX_HANDLED_BLOCKS in bzip2recover.c, and recompile.\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());\n    exit(1 as std::os::raw::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:572 ~ c2rust_out[3c70]::huffman::BZ2_hbCreateDecodeTables)",
    "span": "huffman.rs:218:1: 284:2 (#0)",
    "pieces": [
      "huffman.rs:218:1: 284:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 67,
    "source": "pub unsafe extern \"C\" fn BZ2_hbCreateDecodeTables(mut limit: *mut Int32,\n                                                  mut base: *mut Int32,\n                                                  mut perm: *mut Int32,\n                                                  mut length: *mut UChar,\n                                                  mut minLen: Int32,\n                                                  mut maxLen: Int32,\n                                                  mut alphaSize: Int32) {\n    let mut pp: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut vec: Int32 = 0;\n    pp = 0 as std::os::raw::c_int;\n    i = minLen;\n    while i <= maxLen {\n        j = 0 as std::os::raw::c_int;\n        while j < alphaSize {\n            if *length.offset(j as isize) as std::os::raw::c_int == i {\n                *perm.offset(pp as isize) = j;\n                pp += 1\n            }\n            j += 1\n        }\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 23 as std::os::raw::c_int {\n        *base.offset(i as isize) = 0 as std::os::raw::c_int;\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < alphaSize {\n        let ref mut fresh0 =\n            *base.offset((*length.offset(i as isize) as std::os::raw::c_int +\n                              1 as std::os::raw::c_int) as isize);\n        *fresh0 += 1;\n        i += 1\n    }\n    i = 1 as std::os::raw::c_int;\n    while i < 23 as std::os::raw::c_int {\n        let ref mut fresh1 = *base.offset(i as isize);\n        *fresh1 += *base.offset((i - 1 as std::os::raw::c_int) as isize);\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 23 as std::os::raw::c_int {\n        *limit.offset(i as isize) = 0 as std::os::raw::c_int;\n        i += 1\n    }\n    vec = 0 as std::os::raw::c_int;\n    i = minLen;\n    while i <= maxLen {\n        vec +=\n            *base.offset((i + 1 as std::os::raw::c_int) as isize) -\n                *base.offset(i as isize);\n        *limit.offset(i as isize) = vec - 1 as std::os::raw::c_int;\n        vec <<= 1 as std::os::raw::c_int;\n        i += 1\n    }\n    i = minLen + 1 as std::os::raw::c_int;\n    while i <= maxLen {\n        *base.offset(i as isize) =\n            ((*limit.offset((i - 1 as std::os::raw::c_int) as isize) +\n                  1 as std::os::raw::c_int) << 1 as std::os::raw::c_int) -\n                *base.offset(i as isize);\n        i += 1\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "huffman.rs:6:1: 6:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:175 ~ c2rust_out[3c70]::bzip2::isascii)",
    "span": "bzip2.rs:359:2: 361:2 (#0)",
    "pieces": [
      "bzip2.rs:359:2: 361:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "extern \"C\" fn isascii(mut _c: std::os::raw::c_int) -> std::os::raw::c_int {\n    return (_c & !(0x7f as std::os::raw::c_int) == 0 as std::os::raw::c_int) as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
    "span": "bzip2.rs:1139:1: 1432:2 (#0)",
    "pieces": [
      "bzip2.rs:1139:1: 1140:4 (#0)",
      "bzip2.rs:1431:1: 1432:2 (#0)"
    ],
    "sub_chunks": [
      9
    ],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn testStream(mut zStream: *mut FILE) -> Bool {\n   <<chunk 9>>    /*notreached*/\n}",
    "calls": [
      {
        "caller": "DefId(0:321 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2530:5: 2530:31 (#0)",
        "source": "allOK = testStream(inStr);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:390:1: 390:36 (#0)",
        "source": "pub static mut smallMode: Bool = 0;"
      },
      {
        "span": "bzip2.rs:422:1: 422:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      },
      {
        "span": "bzip2.rs:416:1: 416:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:386:1: 386:37 (#0)",
        "source": "pub static mut verbosity: Int32 = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "bzip2.rs:1200:9: 1208:2 (#0)",
        "pieces": [
          "bzip2.rs:1200:9: 1208:2 (#0)"
        ],
        "num_lines": 11,
        "source": "if !(ferror(zStream) != 0) {\n                    ret = fclose(zStream);\n                    if !(ret == -(1 as std::os::raw::c_int)) {\n                        if verbosity >= 2 as std::os::raw::c_int {\n                            fprintf(__stderrp,\n                                    b\"\\n    \\x00\" as *const u8 as\n                                        *const std::os::raw::c_char);\n                        }\n                        return 1 as std::os::raw::c_int as Bool\n                    }\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut ret: i32"
        ],
        "live_out": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut ret: i32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "bzip2.rs:1223:25: 1255:2 (#0)",
        "pieces": [
          "bzip2.rs:1223:25: 1255:2 (#0)"
        ],
        "num_lines": 40,
        "source": "current_block = 18238374633732057650;\n                        match current_block {\n                            6101827300316655396 => {\n                                panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);\n                            }\n                            10380742613918245393 => {\n                                fprintf(__stderrp,\n                                        b\"file ends unexpectedly\\n\\x00\" as\n                                            *const u8 as *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                            2539039579982765382 => {\n                                if zStream != __stdinp { fclose(zStream); }\n                                if streamNo == 1 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"bad magic number (file not created by bzip2)\\n\\x00\"\n                                                as *const u8 as\n                                                *const std::os::raw::c_char);\n                                    return 0 as std::os::raw::c_int as Bool\n                                } else {\n                                    if noisy != 0 {\n                                        fprintf(__stderrp,\n                                                b\"trailing garbage after EOF ignored\\n\\x00\"\n                                                    as *const u8 as\n                                                    *const std::os::raw::c_char);\n                                    }\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                            }\n                            18238374633732057650 => { configError(); }\n                            13802719682174684861 => { outOfMemory(); }\n                            _ => {\n                                fprintf(__stderrp,\n                                        b\"data integrity (CRC) error in data\\n\\x00\"\n                                            as *const u8 as\n                                            *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                        }",
        "sub_chunks": [],
        "live_in": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32"
        ],
        "live_out": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32"
        ]
      },
      {
        "chunk_id": 2,
        "span": "bzip2.rs:1260:25: 1289:2 (#0)",
        "pieces": [
          "bzip2.rs:1260:25: 1289:2 (#0)"
        ],
        "num_lines": 40,
        "source": "current_block = 11224962462315262049;\n                        match current_block {\n                            6101827300316655396 => {\n                                panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);\n                            }\n                            10380742613918245393 => {\n                                fprintf(__stderrp,\n                                        b\"file ends unexpectedly\\n\\x00\" as\n                                            *const u8 as *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                            2539039579982765382 => {\n                                if zStream != __stdinp { fclose(zStream); }\n                                if streamNo == 1 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"bad magic number (file not created by bzip2)\\n\\x00\"\n                                                as *const u8 as\n                                                *const std::os::raw::c_char);\n                                    return 0 as std::os::raw::c_int as Bool\n                                } else {\n                                    if noisy != 0 {\n                                        fprintf(__stderrp,\n                                                b\"trailing garbage after EOF ignored\\n\\x00\"\n                                                    as *const u8 as\n                                                    *const std::os::raw::c_char);\n                                    }\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                            }\n                            18238374633732057650 => { configError(); }\n                            13802719682174684861 => { outOfMemory(); }\n                            _ => {\n                                fprintf(__stderrp,\n                                        b\"data integrity (CRC) error in data\\n\\x00\"\n                                            as *const u8 as\n                                            *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                        }",
        "sub_chunks": [],
        "live_in": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32"
        ],
        "live_out": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32"
        ]
      },
      {
        "chunk_id": 3,
        "span": "bzip2.rs:1293:25: 1322:2 (#0)",
        "pieces": [
          "bzip2.rs:1293:25: 1322:2 (#0)"
        ],
        "num_lines": 40,
        "source": "current_block = 13802719682174684861;\n                        match current_block {\n                            6101827300316655396 => {\n                                panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);\n                            }\n                            10380742613918245393 => {\n                                fprintf(__stderrp,\n                                        b\"file ends unexpectedly\\n\\x00\" as\n                                            *const u8 as *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                            2539039579982765382 => {\n                                if zStream != __stdinp { fclose(zStream); }\n                                if streamNo == 1 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"bad magic number (file not created by bzip2)\\n\\x00\"\n                                                as *const u8 as\n                                                *const std::os::raw::c_char);\n                                    return 0 as std::os::raw::c_int as Bool\n                                } else {\n                                    if noisy != 0 {\n                                        fprintf(__stderrp,\n                                                b\"trailing garbage after EOF ignored\\n\\x00\"\n                                                    as *const u8 as\n                                                    *const std::os::raw::c_char);\n                                    }\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                            }\n                            18238374633732057650 => { configError(); }\n                            13802719682174684861 => { outOfMemory(); }\n                            _ => {\n                                fprintf(__stderrp,\n                                        b\"data integrity (CRC) error in data\\n\\x00\"\n                                            as *const u8 as\n                                            *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                        }",
        "sub_chunks": [],
        "live_in": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32"
        ],
        "live_out": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32"
        ]
      },
      {
        "chunk_id": 4,
        "span": "bzip2.rs:1326:25: 1355:2 (#0)",
        "pieces": [
          "bzip2.rs:1326:25: 1355:2 (#0)"
        ],
        "num_lines": 40,
        "source": "current_block = 10380742613918245393;\n                        match current_block {\n                            6101827300316655396 => {\n                                panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);\n                            }\n                            10380742613918245393 => {\n                                fprintf(__stderrp,\n                                        b\"file ends unexpectedly\\n\\x00\" as\n                                            *const u8 as *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                            2539039579982765382 => {\n                                if zStream != __stdinp { fclose(zStream); }\n                                if streamNo == 1 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"bad magic number (file not created by bzip2)\\n\\x00\"\n                                                as *const u8 as\n                                                *const std::os::raw::c_char);\n                                    return 0 as std::os::raw::c_int as Bool\n                                } else {\n                                    if noisy != 0 {\n                                        fprintf(__stderrp,\n                                                b\"trailing garbage after EOF ignored\\n\\x00\"\n                                                    as *const u8 as\n                                                    *const std::os::raw::c_char);\n                                    }\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                            }\n                            18238374633732057650 => { configError(); }\n                            13802719682174684861 => { outOfMemory(); }\n                            _ => {\n                                fprintf(__stderrp,\n                                        b\"data integrity (CRC) error in data\\n\\x00\"\n                                            as *const u8 as\n                                            *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                        }",
        "sub_chunks": [],
        "live_in": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32"
        ],
        "live_out": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32"
        ]
      },
      {
        "chunk_id": 5,
        "span": "bzip2.rs:1359:25: 1388:2 (#0)",
        "pieces": [
          "bzip2.rs:1359:25: 1388:2 (#0)"
        ],
        "num_lines": 40,
        "source": "current_block = 2539039579982765382;\n                        match current_block {\n                            6101827300316655396 => {\n                                panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);\n                            }\n                            10380742613918245393 => {\n                                fprintf(__stderrp,\n                                        b\"file ends unexpectedly\\n\\x00\" as\n                                            *const u8 as *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                            2539039579982765382 => {\n                                if zStream != __stdinp { fclose(zStream); }\n                                if streamNo == 1 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"bad magic number (file not created by bzip2)\\n\\x00\"\n                                                as *const u8 as\n                                                *const std::os::raw::c_char);\n                                    return 0 as std::os::raw::c_int as Bool\n                                } else {\n                                    if noisy != 0 {\n                                        fprintf(__stderrp,\n                                                b\"trailing garbage after EOF ignored\\n\\x00\"\n                                                    as *const u8 as\n                                                    *const std::os::raw::c_char);\n                                    }\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                            }\n                            18238374633732057650 => { configError(); }\n                            13802719682174684861 => { outOfMemory(); }\n                            _ => {\n                                fprintf(__stderrp,\n                                        b\"data integrity (CRC) error in data\\n\\x00\"\n                                            as *const u8 as\n                                            *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                        }",
        "sub_chunks": [],
        "live_in": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32"
        ],
        "live_out": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32"
        ]
      },
      {
        "chunk_id": 6,
        "span": "bzip2.rs:1392:25: 1421:2 (#0)",
        "pieces": [
          "bzip2.rs:1392:25: 1421:2 (#0)"
        ],
        "num_lines": 40,
        "source": "current_block = 6101827300316655396;\n                        match current_block {\n                            6101827300316655396 => {\n                                panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);\n                            }\n                            10380742613918245393 => {\n                                fprintf(__stderrp,\n                                        b\"file ends unexpectedly\\n\\x00\" as\n                                            *const u8 as *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                            2539039579982765382 => {\n                                if zStream != __stdinp { fclose(zStream); }\n                                if streamNo == 1 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"bad magic number (file not created by bzip2)\\n\\x00\"\n                                                as *const u8 as\n                                                *const std::os::raw::c_char);\n                                    return 0 as std::os::raw::c_int as Bool\n                                } else {\n                                    if noisy != 0 {\n                                        fprintf(__stderrp,\n                                                b\"trailing garbage after EOF ignored\\n\\x00\"\n                                                    as *const u8 as\n                                                    *const std::os::raw::c_char);\n                                    }\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                            }\n                            18238374633732057650 => { configError(); }\n                            13802719682174684861 => { outOfMemory(); }\n                            _ => {\n                                fprintf(__stderrp,\n                                        b\"data integrity (CRC) error in data\\n\\x00\"\n                                            as *const u8 as\n                                            *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                        }",
        "sub_chunks": [],
        "live_in": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32"
        ],
        "live_out": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut streamNo: i32"
        ]
      },
      {
        "chunk_id": 7,
        "span": "bzip2.rs:1213:9: 1424:18 (#0)",
        "pieces": [
          "bzip2.rs:1213:9: 1223:24 (#0)",
          "bzip2.rs:1257:1: 1260:24 (#0)",
          "bzip2.rs:1291:1: 1293:24 (#0)",
          "bzip2.rs:1324:1: 1326:24 (#0)",
          "bzip2.rs:1357:1: 1359:24 (#0)",
          "bzip2.rs:1390:1: 1392:24 (#0)",
          "bzip2.rs:1423:1: 1424:18 (#0)"
        ],
        "num_lines": 28,
        "source": "BZ2_bzReadClose(&mut bzerr_dummy, bzf);\n                if verbosity == 0 as std::os::raw::c_int {\n                    fprintf(__stderrp,\n                            b\"%s: %s: \\x00\" as *const u8 as\n                                *const std::os::raw::c_char, progName,\n                            inName.as_mut_ptr());\n                }\n                match bzerr {\n                    -9 => {\n                       <<chunk 1>>                    }\n                    -6 => { }\n                    -4 => {\n                       <<chunk 2>>                    }\n                    -3 => {\n                       <<chunk 3>>                    }\n                    -7 => {\n                       <<chunk 4>>                    }\n                    -5 => {\n                       <<chunk 5>>                    }\n                    _ => {\n                       <<chunk 6>>                    }\n                }",
        "sub_chunks": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "live_in": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut streamNo: i32"
        ],
        "live_out": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut streamNo: i32",
          "mut bzerr_dummy: i32"
        ]
      },
      {
        "chunk_id": 8,
        "span": "bzip2.rs:1155:9: 1427:2 (#0)",
        "pieces": [
          "bzip2.rs:1155:9: 1200:8 (#0)",
          "bzip2.rs:1210:1: 1213:8 (#0)",
          "bzip2.rs:1425:1: 1427:2 (#0)"
        ],
        "num_lines": 60,
        "source": "'s_41:\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 15125582407903384992;\n                    break ;\n                }\n                bzf =\n                    BZ2_bzReadOpen(&mut bzerr, zStream, verbosity,\n                                   smallMode as std::os::raw::c_int,\n                                   unused.as_mut_ptr() as *mut std::os::raw::c_void,\n                                   nUnused);\n                if bzf.is_null() || bzerr != 0 as std::os::raw::c_int {\n                    current_block = 10905486111603547446;\n                    break ;\n                }\n                streamNo += 1;\n                while bzerr == 0 as std::os::raw::c_int {\n                    BZ2_bzRead(&mut bzerr, bzf,\n                               obuf.as_mut_ptr() as *mut std::os::raw::c_void,\n                               5000 as std::os::raw::c_int);\n                    if bzerr == -(5 as std::os::raw::c_int) {\n                        current_block = 10905486111603547446;\n                        break 's_41 ;\n                    }\n                }\n                if bzerr != 4 as std::os::raw::c_int {\n                    current_block = 10905486111603547446;\n                    break ;\n                }\n                BZ2_bzReadGetUnused(&mut bzerr, bzf, &mut unusedTmpV,\n                                    &mut nUnused);\n                if bzerr != 0 as std::os::raw::c_int {\n                    panic(b\"test:bzReadGetUnused\\x00\" as *const u8 as\n                              *const std::os::raw::c_char);\n                }\n                unusedTmp = unusedTmpV as *mut UChar;\n                i = 0 as std::os::raw::c_int;\n                while i < nUnused {\n                    unused[i as usize] = *unusedTmp.offset(i as isize);\n                    i += 1\n                }\n                BZ2_bzReadClose(&mut bzerr, bzf);\n                if bzerr != 0 as std::os::raw::c_int {\n                    panic(b\"test:bzReadGetUnused\\x00\" as *const u8 as\n                              *const std::os::raw::c_char);\n                }\n                if nUnused == 0 as std::os::raw::c_int &&\n                       myfeof(zStream) as std::os::raw::c_int != 0 {\n                    current_block = 15125582407903384992;\n                    break ;\n                }\n            }\n        match current_block {\n            15125582407903384992 => {\n               <<chunk 0>>            }\n            _ => {\n               <<chunk 7>>            }\n        }",
        "sub_chunks": [
          0,
          7
        ],
        "live_in": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut ret: i32",
          "mut streamNo: i32",
          "mut obuf: [u8; 5000]",
          "mut unused: [u8; 5000]",
          "mut nUnused: i32",
          "mut unusedTmpV: *mut std::ffi::c_void"
        ],
        "live_out": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut ret: i32",
          "mut streamNo: i32",
          "mut obuf: [u8; 5000]",
          "mut unused: [u8; 5000]",
          "mut nUnused: i32",
          "mut unusedTmpV: *mut std::ffi::c_void"
        ]
      },
      {
        "chunk_id": 9,
        "span": "bzip2.rs:1140:5: 1430:10 (#0)",
        "pieces": [
          "bzip2.rs:1140:5: 1155:8 (#0)",
          "bzip2.rs:1429:1: 1430:10 (#0)"
        ],
        "num_lines": 18,
        "source": "let mut current_block: u64;\n    let mut bzf: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    let mut bzerr: Int32 = 0;\n    let mut bzerr_dummy: Int32 = 0;\n    let mut ret: Int32 = 0;\n    let mut streamNo: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut obuf: [UChar; 5000] = [0; 5000];\n    let mut unused: [UChar; 5000] = [0; 5000];\n    let mut nUnused: Int32 = 0;\n    let mut unusedTmpV: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    let mut unusedTmp: *mut UChar = 0 as *mut UChar;\n    nUnused = 0 as std::os::raw::c_int;\n    streamNo = 0 as std::os::raw::c_int;\n    if !(ferror(zStream) != 0) {\n       <<chunk 8>>    }\n    ioError();",
        "sub_chunks": [
          8
        ],
        "live_in": [
          "mut zStream: *mut blocksort::__sFILE"
        ],
        "live_out": [
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut ret: i32",
          "mut streamNo: i32",
          "mut i: i32",
          "mut obuf: [u8; 5000]",
          "mut unused: [u8; 5000]",
          "mut nUnused: i32",
          "mut unusedTmpV: *mut std::ffi::c_void",
          "mut unusedTmp: *mut u8"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:244 ~ c2rust_out[3c70]::bzip2::mySignalCatcher)",
    "span": "bzip2.rs:1568:1: 1571:2 (#0)",
    "pieces": [
      "bzip2.rs:1568:1: 1571:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn mySignalCatcher(mut n: IntNative) {\n    fprintf(__stderrp,\n            b\"\\n%s: Control-C or similar caught, quitting.\\n\\x00\" as *const u8\n                as *const std::os::raw::c_char, progName);\n    cleanUpAndFail(1 as std::os::raw::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:423 ~ c2rust_out[3c70]::bzlib::isempty_RL)",
    "span": "bzlib.rs:319:1: 326:2 (#0)",
    "pieces": [
      "bzlib.rs:319:1: 326:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn isempty_RL(mut s: *mut EState) -> Bool {\n    if (*s).state_in_ch < 256 as std::os::raw::c_int as std::os::raw::c_uint &&\n           (*s).state_in_len > 0 as std::os::raw::c_int {\n        return 0 as std::os::raw::c_int as Bool\n    } else { return 1 as std::os::raw::c_int as Bool };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:552 ~ c2rust_out[3c70]::decompress::makeMaps_d)",
    "span": "decompress.rs:96:1: 106:2 (#0)",
    "pieces": [
      "decompress.rs:96:1: 106:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn makeMaps_d(mut s: *mut DState) {\n    let mut i: Int32 = 0;\n    (*s).nInUse = 0 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n    while i < 256 as std::os::raw::c_int {\n        if (*s).inUse[i as usize] != 0 {\n            (*s).seqToUnseq[(*s).nInUse as usize] = i as UChar;\n            (*s).nInUse += 1\n        }\n        i += 1\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:642 ~ c2rust_out[3c70]::decompress::BZ2_decompress)",
        "span": "decompress.rs:2578:17: 2578:36 (#0)",
        "source": "makeMaps_d(&mut s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "decompress.rs:53:1: 53:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "decompress.rs:54:1: 54:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_indexIntoF;"
      },
      {
        "span": "decompress.rs:55:1: 55:50 (#0)",
        "source": "pub use crate::huffman::BZ2_hbCreateDecodeTables;"
      },
      {
        "span": "decompress.rs:52:1: 52:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "decompress.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:434 ~ c2rust_out[3c70]::bzlib::BZ2_indexIntoF)",
    "span": "bzlib.rs:1165:1: 1178:2 (#0)",
    "pieces": [
      "bzlib.rs:1165:1: 1178:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn BZ2_indexIntoF(mut indx: Int32,\n                                        mut cftab: *mut Int32) -> Int32 {\n    let mut nb: Int32 = 0;\n    let mut na: Int32 = 0;\n    let mut mid: Int32 = 0;\n    nb = 0 as std::os::raw::c_int;\n    na = 256 as std::os::raw::c_int;\n    loop  {\n        mid = nb + na >> 1 as std::os::raw::c_int;\n        if indx >= *cftab.offset(mid as isize) { nb = mid } else { na = mid }\n        if !(na - nb != 1 as std::os::raw::c_int) { break ; }\n    }\n    return nb;\n}",
    "calls": [
      {
        "caller": "DefId(0:642 ~ c2rust_out[3c70]::decompress::BZ2_decompress)",
        "span": "decompress.rs:2343:41: 2345:85 (#0)",
        "source": "(*s).k0 =\n                                            BZ2_indexIntoF((*s).tPos as Int32,\n                                                           (*s).cftab.as_mut_ptr());"
      },
      {
        "caller": "DefId(0:642 ~ c2rust_out[3c70]::decompress::BZ2_decompress)",
        "span": "decompress.rs:2392:41: 2394:85 (#0)",
        "source": "(*s).k0 =\n                                            BZ2_indexIntoF((*s).tPos as Int32,\n                                                           (*s).cftab.as_mut_ptr());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:417 ~ c2rust_out[3c70]::bzlib::BZ2_bz__AssertH__fail)",
    "span": "bzlib.rs:257:1: 270:2 (#0)",
    "pieces": [
      "bzlib.rs:257:1: 270:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn BZ2_bz__AssertH__fail(mut errcode: std::os::raw::c_int) {\n    fprintf(__stderrp,\n            b\"\\n\\nbzip2/libbzip2: internal error number %d.\\nThis is a bug in bzip2/libbzip2, %s.\\nPlease report it to: bzip2-devel@sourceware.org.  If this happened\\nwhen you were using some program which uses libbzip2 as a\\ncomponent, you should also report this bug to the author(s)\\nof that program.  Please make an effort to report this bug;\\ntimely and accurate bug reports eventually lead to higher\\nquality software.  Thanks.\\n\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, errcode,\n            BZ2_bzlibVersion());\n    if errcode == 1007 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"\\n*** A special note about internal error number 1007 ***\\n\\nExperience suggests that a common cause of i.e. 1007\\nis unreliable memory or other hardware.  The 1007 assertion\\njust happens to cross-check the results of huge numbers of\\nmemory reads/writes, and so acts (unintendedly) as a stress\\ntest of your memory system.\\n\\nI suggest the following: try compressing the file again,\\npossibly monitoring progress in detail with the -vv flag.\\n\\n* If the error cannot be reproduced, and/or happens at different\\n  points in compression, you may have a flaky memory system.\\n  Try a memory-test program.  I have used Memtest86\\n  (www.memtest86.com).  At the time of writing it is free (GPLd).\\n  Memtest86 tests memory much more thorougly than your BIOSs\\n  power-on test, and may find failures that the BIOS doesn\\'t.\\n\\n* If the error can be repeatably reproduced, this is a bug in\\n  bzip2, and I would very much like to hear about it.  Please\\n  let me know, and, ideally, save a copy of the file causing the\\n  problem -- without which I will be unable to investigate it.\\n\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char);\n    }\n    exit(3 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:594 ~ c2rust_out[3c70]::compress::sendMTFValues)",
        "span": "compress.rs:903:9: 903:37 (#0)",
        "source": "BZ2_bz__AssertH__fail(3002);"
      },
      {
        "caller": "DefId(0:642 ~ c2rust_out[3c70]::decompress::BZ2_decompress)",
        "span": "decompress.rs:286:13: 286:41 (#0)",
        "source": "BZ2_bz__AssertH__fail(4002);"
      },
      {
        "caller": "DefId(0:26 ~ c2rust_out[3c70]::blocksort::fallbackSort)",
        "span": "blocksort.rs:520:5: 520:33 (#0)",
        "source": "BZ2_bz__AssertH__fail(1005);"
      },
      {
        "caller": "DefId(0:58 ~ c2rust_out[3c70]::blocksort::BZ2_blockSort)",
        "span": "blocksort.rs:1493:9: 1493:37 (#0)",
        "source": "BZ2_bz__AssertH__fail(1003);"
      },
      {
        "caller": "DefId(0:594 ~ c2rust_out[3c70]::compress::sendMTFValues)",
        "span": "compress.rs:909:9: 909:37 (#0)",
        "source": "BZ2_bz__AssertH__fail(3003);"
      },
      {
        "caller": "DefId(0:594 ~ c2rust_out[3c70]::compress::sendMTFValues)",
        "span": "compress.rs:333:9: 333:37 (#0)",
        "source": "BZ2_bz__AssertH__fail(3001);"
      },
      {
        "caller": "DefId(0:642 ~ c2rust_out[3c70]::decompress::BZ2_decompress)",
        "span": "decompress.rs:283:13: 283:41 (#0)",
        "source": "BZ2_bz__AssertH__fail(4001);"
      },
      {
        "caller": "DefId(0:594 ~ c2rust_out[3c70]::compress::sendMTFValues)",
        "span": "compress.rs:1268:5: 1268:33 (#0)",
        "source": "BZ2_bz__AssertH__fail(3007);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:553 ~ c2rust_out[3c70]::decompress::BZ2_decompress)",
    "span": "decompress.rs:113:1: 2808:2 (#0)",
    "pieces": [
      "decompress.rs:113:1: 114:4 (#0)",
      "decompress.rs:198:1: 198:4 (#0)",
      "decompress.rs:292:1: 292:4 (#0)",
      "decompress.rs:396:1: 396:4 (#0)",
      "decompress.rs:470:1: 470:4 (#0)",
      "decompress.rs:524:1: 524:4 (#0)",
      "decompress.rs:616:1: 616:4 (#0)",
      "decompress.rs:702:1: 702:4 (#0)",
      "decompress.rs:786:1: 786:4 (#0)",
      "decompress.rs:878:1: 878:4 (#0)",
      "decompress.rs:978:1: 978:4 (#0)",
      "decompress.rs:1054:1: 1054:4 (#0)",
      "decompress.rs:1130:1: 1130:4 (#0)",
      "decompress.rs:1206:1: 1206:4 (#0)",
      "decompress.rs:1286:1: 1286:4 (#0)",
      "decompress.rs:1366:1: 1366:4 (#0)",
      "decompress.rs:2808:1: 2808:2 (#0)"
    ],
    "sub_chunks": [
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43
    ],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn BZ2_decompress(mut s: *mut DState) -> Int32 {\n   <<chunk 28>>   <<chunk 29>>   <<chunk 30>>   <<chunk 31>>   <<chunk 32>>   <<chunk 33>>   <<chunk 34>>   <<chunk 35>>   <<chunk 36>>   <<chunk 37>>   <<chunk 38>>   <<chunk 39>>   <<chunk 40>>   <<chunk 41>>   <<chunk 42>>   <<chunk 43>>}",
    "calls": [
      {
        "caller": "DefId(0:520 ~ c2rust_out[3c70]::bzlib::BZ2_bzDecompress)",
        "span": "bzlib.rs:1605:28: 1605:56 (#0)",
        "source": "unsafe { BZ2_decompress(s) }"
      }
    ],
    "globals": [
      {
        "span": "randtable.rs:22:1: 193:62 (#0)",
        "source": "pub static mut BZ2_rNums: [Int32; 512] =\n    [619 as std::os::raw::c_int, 720 as std::os::raw::c_int, 127 as std::os::raw::c_int,\n     481 as std::os::raw::c_int, 931 as std::os::raw::c_int, 816 as std::os::raw::c_int,\n     813 as std::os::raw::c_int, 233 as std::os::raw::c_int, 566 as std::os::raw::c_int,\n     247 as std::os::raw::c_int, 985 as std::os::raw::c_int, 724 as std::os::raw::c_int,\n     205 as std::os::raw::c_int, 454 as std::os::raw::c_int, 863 as std::os::raw::c_int,\n     491 as std::os::raw::c_int, 741 as std::os::raw::c_int, 242 as std::os::raw::c_int,\n     949 as std::os::raw::c_int, 214 as std::os::raw::c_int, 733 as std::os::raw::c_int,\n     859 as std::os::raw::c_int, 335 as std::os::raw::c_int, 708 as std::os::raw::c_int,\n     621 as std::os::raw::c_int, 574 as std::os::raw::c_int, 73 as std::os::raw::c_int,\n     654 as std::os::raw::c_int, 730 as std::os::raw::c_int, 472 as std::os::raw::c_int,\n     419 as std::os::raw::c_int, 436 as std::os::raw::c_int, 278 as std::os::raw::c_int,\n     496 as std::os::raw::c_int, 867 as std::os::raw::c_int, 210 as std::os::raw::c_int,\n     399 as std::os::raw::c_int, 680 as std::os::raw::c_int, 480 as std::os::raw::c_int,\n     51 as std::os::raw::c_int, 878 as std::os::raw::c_int, 465 as std::os::raw::c_int,\n     811 as std::os::raw::c_int, 169 as std::os::raw::c_int, 869 as std::os::raw::c_int,\n     675 as std::os::raw::c_int, 611 as std::os::raw::c_int, 697 as std::os::raw::c_int,\n     867 as std::os::raw::c_int, 561 as std::os::raw::c_int, 862 as std::os::raw::c_int,\n     687 as std::os::raw::c_int, 507 as std::os::raw::c_int, 283 as std::os::raw::c_int,\n     482 as std::os::raw::c_int, 129 as std::os::raw::c_int, 807 as std::os::raw::c_int,\n     591 as std::os::raw::c_int, 733 as std::os::raw::c_int, 623 as std::os::raw::c_int,\n     150 as std::os::raw::c_int, 238 as std::os::raw::c_int, 59 as std::os::raw::c_int,\n     379 as std::os::raw::c_int, 684 as std::os::raw::c_int, 877 as std::os::raw::c_int,\n     625 as std::os::raw::c_int, 169 as std::os::raw::c_int, 643 as std::os::raw::c_int,\n     105 as std::os::raw::c_int, 170 as std::os::raw::c_int, 607 as std::os::raw::c_int,\n     520 as std::os::raw::c_int, 932 as std::os::raw::c_int, 727 as std::os::raw::c_int,\n     476 as std::os::raw::c_int, 693 as std::os::raw::c_int, 425 as std::os::raw::c_int,\n     174 as std::os::raw::c_int, 647 as std::os::raw::c_int, 73 as std::os::raw::c_int,\n     122 as std::os::raw::c_int, 335 as std::os::raw::c_int, 530 as std::os::raw::c_int,\n     442 as std::os::raw::c_int, 853 as std::os::raw::c_int, 695 as std::os::raw::c_int,\n     249 as std::os::raw::c_int, 445 as std::os::raw::c_int, 515 as std::os::raw::c_int,\n     909 as std::os::raw::c_int, 545 as std::os::raw::c_int, 703 as std::os::raw::c_int,\n     919 as std::os::raw::c_int, 874 as std::os::raw::c_int, 474 as std::os::raw::c_int,\n     882 as std::os::raw::c_int, 500 as std::os::raw::c_int, 594 as std::os::raw::c_int,\n     612 as std::os::raw::c_int, 641 as std::os::raw::c_int, 801 as std::os::raw::c_int,\n     220 as std::os::raw::c_int, 162 as std::os::raw::c_int, 819 as std::os::raw::c_int,\n     984 as std::os::raw::c_int, 589 as std::os::raw::c_int, 513 as std::os::raw::c_int,\n     495 as std::os::raw::c_int, 799 as std::os::raw::c_int, 161 as std::os::raw::c_int,\n     604 as std::os::raw::c_int, 958 as std::os::raw::c_int, 533 as std::os::raw::c_int,\n     221 as std::os::raw::c_int, 400 as std::os::raw::c_int, 386 as std::os::raw::c_int,\n     867 as std::os::raw::c_int, 600 as std::os::raw::c_int, 782 as std::os::raw::c_int,\n     382 as std::os::raw::c_int, 596 as std::os::raw::c_int, 414 as std::os::raw::c_int,\n     171 as std::os::raw::c_int, 516 as std::os::raw::c_int, 375 as std::os::raw::c_int,\n     682 as std::os::raw::c_int, 485 as std::os::raw::c_int, 911 as std::os::raw::c_int,\n     276 as std::os::raw::c_int, 98 as std::os::raw::c_int, 553 as std::os::raw::c_int,\n     163 as std::os::raw::c_int, 354 as std::os::raw::c_int, 666 as std::os::raw::c_int,\n     933 as std::os::raw::c_int, 424 as std::os::raw::c_int, 341 as std::os::raw::c_int,\n     533 as std::os::raw::c_int, 870 as std::os::raw::c_int, 227 as std::os::raw::c_int,\n     730 as std::os::raw::c_int, 475 as std::os::raw::c_int, 186 as std::os::raw::c_int,\n     263 as std::os::raw::c_int, 647 as std::os::raw::c_int, 537 as std::os::raw::c_int,\n     686 as std::os::raw::c_int, 600 as std::os::raw::c_int, 224 as std::os::raw::c_int,\n     469 as std::os::raw::c_int, 68 as std::os::raw::c_int, 770 as std::os::raw::c_int,\n     919 as std::os::raw::c_int, 190 as std::os::raw::c_int, 373 as std::os::raw::c_int,\n     294 as std::os::raw::c_int, 822 as std::os::raw::c_int, 808 as std::os::raw::c_int,\n     206 as std::os::raw::c_int, 184 as std::os::raw::c_int, 943 as std::os::raw::c_int,\n     795 as std::os::raw::c_int, 384 as std::os::raw::c_int, 383 as std::os::raw::c_int,\n     461 as std::os::raw::c_int, 404 as std::os::raw::c_int, 758 as std::os::raw::c_int,\n     839 as std::os::raw::c_int, 887 as std::os::raw::c_int, 715 as std::os::raw::c_int,\n     67 as std::os::raw::c_int, 618 as std::os::raw::c_int, 276 as std::os::raw::c_int,\n     204 as std::os::raw::c_int, 918 as std::os::raw::c_int, 873 as std::os::raw::c_int,\n     777 as std::os::raw::c_int, 604 as std::os::raw::c_int, 560 as std::os::raw::c_int,\n     951 as std::os::raw::c_int, 160 as std::os::raw::c_int, 578 as std::os::raw::c_int,\n     722 as std::os::raw::c_int, 79 as std::os::raw::c_int, 804 as std::os::raw::c_int,\n     96 as std::os::raw::c_int, 409 as std::os::raw::c_int, 713 as std::os::raw::c_int,\n     940 as std::os::raw::c_int, 652 as std::os::raw::c_int, 934 as std::os::raw::c_int,\n     970 as std::os::raw::c_int, 447 as std::os::raw::c_int, 318 as std::os::raw::c_int,\n     353 as std::os::raw::c_int, 859 as std::os::raw::c_int, 672 as std::os::raw::c_int,\n     112 as std::os::raw::c_int, 785 as std::os::raw::c_int, 645 as std::os::raw::c_int,\n     863 as std::os::raw::c_int, 803 as std::os::raw::c_int, 350 as std::os::raw::c_int,\n     139 as std::os::raw::c_int, 93 as std::os::raw::c_int, 354 as std::os::raw::c_int,\n     99 as std::os::raw::c_int, 820 as std::os::raw::c_int, 908 as std::os::raw::c_int,\n     609 as std::os::raw::c_int, 772 as std::os::raw::c_int, 154 as std::os::raw::c_int,\n     274 as std::os::raw::c_int, 580 as std::os::raw::c_int, 184 as std::os::raw::c_int,\n     79 as std::os::raw::c_int, 626 as std::os::raw::c_int, 630 as std::os::raw::c_int,\n     742 as std::os::raw::c_int, 653 as std::os::raw::c_int, 282 as std::os::raw::c_int,\n     762 as std::os::raw::c_int, 623 as std::os::raw::c_int, 680 as std::os::raw::c_int,\n     81 as std::os::raw::c_int, 927 as std::os::raw::c_int, 626 as std::os::raw::c_int,\n     789 as std::os::raw::c_int, 125 as std::os::raw::c_int, 411 as std::os::raw::c_int,\n     521 as std::os::raw::c_int, 938 as std::os::raw::c_int, 300 as std::os::raw::c_int,\n     821 as std::os::raw::c_int, 78 as std::os::raw::c_int, 343 as std::os::raw::c_int,\n     175 as std::os::raw::c_int, 128 as std::os::raw::c_int, 250 as std::os::raw::c_int,\n     170 as std::os::raw::c_int, 774 as std::os::raw::c_int, 972 as std::os::raw::c_int,\n     275 as std::os::raw::c_int, 999 as std::os::raw::c_int, 639 as std::os::raw::c_int,\n     495 as std::os::raw::c_int, 78 as std::os::raw::c_int, 352 as std::os::raw::c_int,\n     126 as std::os::raw::c_int, 857 as std::os::raw::c_int, 956 as std::os::raw::c_int,\n     358 as std::os::raw::c_int, 619 as std::os::raw::c_int, 580 as std::os::raw::c_int,\n     124 as std::os::raw::c_int, 737 as std::os::raw::c_int, 594 as std::os::raw::c_int,\n     701 as std::os::raw::c_int, 612 as std::os::raw::c_int, 669 as std::os::raw::c_int,\n     112 as std::os::raw::c_int, 134 as std::os::raw::c_int, 694 as std::os::raw::c_int,\n     363 as std::os::raw::c_int, 992 as std::os::raw::c_int, 809 as std::os::raw::c_int,\n     743 as std::os::raw::c_int, 168 as std::os::raw::c_int, 974 as std::os::raw::c_int,\n     944 as std::os::raw::c_int, 375 as std::os::raw::c_int, 748 as std::os::raw::c_int,\n     52 as std::os::raw::c_int, 600 as std::os::raw::c_int, 747 as std::os::raw::c_int,\n     642 as std::os::raw::c_int, 182 as std::os::raw::c_int, 862 as std::os::raw::c_int,\n     81 as std::os::raw::c_int, 344 as std::os::raw::c_int, 805 as std::os::raw::c_int,\n     988 as std::os::raw::c_int, 739 as std::os::raw::c_int, 511 as std::os::raw::c_int,\n     655 as std::os::raw::c_int, 814 as std::os::raw::c_int, 334 as std::os::raw::c_int,\n     249 as std::os::raw::c_int, 515 as std::os::raw::c_int, 897 as std::os::raw::c_int,\n     955 as std::os::raw::c_int, 664 as std::os::raw::c_int, 981 as std::os::raw::c_int,\n     649 as std::os::raw::c_int, 113 as std::os::raw::c_int, 974 as std::os::raw::c_int,\n     459 as std::os::raw::c_int, 893 as std::os::raw::c_int, 228 as std::os::raw::c_int,\n     433 as std::os::raw::c_int, 837 as std::os::raw::c_int, 553 as std::os::raw::c_int,\n     268 as std::os::raw::c_int, 926 as std::os::raw::c_int, 240 as std::os::raw::c_int,\n     102 as std::os::raw::c_int, 654 as std::os::raw::c_int, 459 as std::os::raw::c_int,\n     51 as std::os::raw::c_int, 686 as std::os::raw::c_int, 754 as std::os::raw::c_int,\n     806 as std::os::raw::c_int, 760 as std::os::raw::c_int, 493 as std::os::raw::c_int,\n     403 as std::os::raw::c_int, 415 as std::os::raw::c_int, 394 as std::os::raw::c_int,\n     687 as std::os::raw::c_int, 700 as std::os::raw::c_int, 946 as std::os::raw::c_int,\n     670 as std::os::raw::c_int, 656 as std::os::raw::c_int, 610 as std::os::raw::c_int,\n     738 as std::os::raw::c_int, 392 as std::os::raw::c_int, 760 as std::os::raw::c_int,\n     799 as std::os::raw::c_int, 887 as std::os::raw::c_int, 653 as std::os::raw::c_int,\n     978 as std::os::raw::c_int, 321 as std::os::raw::c_int, 576 as std::os::raw::c_int,\n     617 as std::os::raw::c_int, 626 as std::os::raw::c_int, 502 as std::os::raw::c_int,\n     894 as std::os::raw::c_int, 679 as std::os::raw::c_int, 243 as std::os::raw::c_int,\n     440 as std::os::raw::c_int, 680 as std::os::raw::c_int, 879 as std::os::raw::c_int,\n     194 as std::os::raw::c_int, 572 as std::os::raw::c_int, 640 as std::os::raw::c_int,\n     724 as std::os::raw::c_int, 926 as std::os::raw::c_int, 56 as std::os::raw::c_int,\n     204 as std::os::raw::c_int, 700 as std::os::raw::c_int, 707 as std::os::raw::c_int,\n     151 as std::os::raw::c_int, 457 as std::os::raw::c_int, 449 as std::os::raw::c_int,\n     797 as std::os::raw::c_int, 195 as std::os::raw::c_int, 791 as std::os::raw::c_int,\n     558 as std::os::raw::c_int, 945 as std::os::raw::c_int, 679 as std::os::raw::c_int,\n     297 as std::os::raw::c_int, 59 as std::os::raw::c_int, 87 as std::os::raw::c_int,\n     824 as std::os::raw::c_int, 713 as std::os::raw::c_int, 663 as std::os::raw::c_int,\n     412 as std::os::raw::c_int, 693 as std::os::raw::c_int, 342 as std::os::raw::c_int,\n     606 as std::os::raw::c_int, 134 as std::os::raw::c_int, 108 as std::os::raw::c_int,\n     571 as std::os::raw::c_int, 364 as std::os::raw::c_int, 631 as std::os::raw::c_int,\n     212 as std::os::raw::c_int, 174 as std::os::raw::c_int, 643 as std::os::raw::c_int,\n     304 as std::os::raw::c_int, 329 as std::os::raw::c_int, 343 as std::os::raw::c_int,\n     97 as std::os::raw::c_int, 430 as std::os::raw::c_int, 751 as std::os::raw::c_int,\n     497 as std::os::raw::c_int, 314 as std::os::raw::c_int, 983 as std::os::raw::c_int,\n     374 as std::os::raw::c_int, 822 as std::os::raw::c_int, 928 as std::os::raw::c_int,\n     140 as std::os::raw::c_int, 206 as std::os::raw::c_int, 73 as std::os::raw::c_int,\n     263 as std::os::raw::c_int, 980 as std::os::raw::c_int, 736 as std::os::raw::c_int,\n     876 as std::os::raw::c_int, 478 as std::os::raw::c_int, 430 as std::os::raw::c_int,\n     305 as std::os::raw::c_int, 170 as std::os::raw::c_int, 514 as std::os::raw::c_int,\n     364 as std::os::raw::c_int, 692 as std::os::raw::c_int, 829 as std::os::raw::c_int,\n     82 as std::os::raw::c_int, 855 as std::os::raw::c_int, 953 as std::os::raw::c_int,\n     676 as std::os::raw::c_int, 246 as std::os::raw::c_int, 369 as std::os::raw::c_int,\n     970 as std::os::raw::c_int, 294 as std::os::raw::c_int, 750 as std::os::raw::c_int,\n     807 as std::os::raw::c_int, 827 as std::os::raw::c_int, 150 as std::os::raw::c_int,\n     790 as std::os::raw::c_int, 288 as std::os::raw::c_int, 923 as std::os::raw::c_int,\n     804 as std::os::raw::c_int, 378 as std::os::raw::c_int, 215 as std::os::raw::c_int,\n     828 as std::os::raw::c_int, 592 as std::os::raw::c_int, 281 as std::os::raw::c_int,\n     565 as std::os::raw::c_int, 555 as std::os::raw::c_int, 710 as std::os::raw::c_int,\n     82 as std::os::raw::c_int, 896 as std::os::raw::c_int, 831 as std::os::raw::c_int,\n     547 as std::os::raw::c_int, 261 as std::os::raw::c_int, 524 as std::os::raw::c_int,\n     462 as std::os::raw::c_int, 293 as std::os::raw::c_int, 465 as std::os::raw::c_int,\n     502 as std::os::raw::c_int, 56 as std::os::raw::c_int, 661 as std::os::raw::c_int,\n     821 as std::os::raw::c_int, 976 as std::os::raw::c_int, 991 as std::os::raw::c_int,\n     658 as std::os::raw::c_int, 869 as std::os::raw::c_int, 905 as std::os::raw::c_int,\n     758 as std::os::raw::c_int, 745 as std::os::raw::c_int, 193 as std::os::raw::c_int,\n     768 as std::os::raw::c_int, 550 as std::os::raw::c_int, 608 as std::os::raw::c_int,\n     933 as std::os::raw::c_int, 378 as std::os::raw::c_int, 286 as std::os::raw::c_int,\n     215 as std::os::raw::c_int, 979 as std::os::raw::c_int, 792 as std::os::raw::c_int,\n     961 as std::os::raw::c_int, 61 as std::os::raw::c_int, 688 as std::os::raw::c_int,\n     793 as std::os::raw::c_int, 644 as std::os::raw::c_int, 986 as std::os::raw::c_int,\n     403 as std::os::raw::c_int, 106 as std::os::raw::c_int, 366 as std::os::raw::c_int,\n     905 as std::os::raw::c_int, 644 as std::os::raw::c_int, 372 as std::os::raw::c_int,\n     567 as std::os::raw::c_int, 466 as std::os::raw::c_int, 434 as std::os::raw::c_int,\n     645 as std::os::raw::c_int, 210 as std::os::raw::c_int, 389 as std::os::raw::c_int,\n     550 as std::os::raw::c_int, 919 as std::os::raw::c_int, 135 as std::os::raw::c_int,\n     780 as std::os::raw::c_int, 773 as std::os::raw::c_int, 635 as std::os::raw::c_int,\n     389 as std::os::raw::c_int, 707 as std::os::raw::c_int, 100 as std::os::raw::c_int,\n     626 as std::os::raw::c_int, 958 as std::os::raw::c_int, 165 as std::os::raw::c_int,\n     504 as std::os::raw::c_int, 920 as std::os::raw::c_int, 176 as std::os::raw::c_int,\n     193 as std::os::raw::c_int, 713 as std::os::raw::c_int, 857 as std::os::raw::c_int,\n     265 as std::os::raw::c_int, 203 as std::os::raw::c_int, 50 as std::os::raw::c_int,\n     668 as std::os::raw::c_int, 108 as std::os::raw::c_int, 645 as std::os::raw::c_int,\n     990 as std::os::raw::c_int, 626 as std::os::raw::c_int, 197 as std::os::raw::c_int,\n     510 as std::os::raw::c_int, 357 as std::os::raw::c_int, 358 as std::os::raw::c_int,\n     850 as std::os::raw::c_int, 858 as std::os::raw::c_int, 364 as std::os::raw::c_int,\n     936 as std::os::raw::c_int, 638 as std::os::raw::c_int];"
      }
    ],
    "imports": [
      {
        "span": "decompress.rs:54:1: 54:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_indexIntoF;"
      },
      {
        "span": "decompress.rs:55:1: 55:50 (#0)",
        "source": "pub use crate::huffman::BZ2_hbCreateDecodeTables;"
      },
      {
        "span": "decompress.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "decompress.rs:52:1: 52:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "decompress.rs:53:1: 53:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "decompress.rs:1469:9: 1496:2 (#0)",
        "pieces": [
          "decompress.rs:1469:9: 1496:2 (#0)"
        ],
        "num_lines": 36,
        "source": "(*s).state = 40 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= zn {\n                            let mut v_30: UInt32 = 0;\n                            v_30 =\n                                (*s).bsBuff >> (*s).bsLive - zn &\n                                    (((1 as std::os::raw::c_int) << zn) -\n                                         1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= zn;\n                            zvec = v_30 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    current_block = 9078889872071895942;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut zn: i32",
          "mut zvec: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut zn: i32",
          "mut zvec: i32",
          "s: &mut bzlib::DState",
          "strm: &mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 1,
        "span": "decompress.rs:1501:9: 1529:38 (#0)",
        "pieces": [
          "decompress.rs:1501:9: 1529:38 (#0)"
        ],
        "num_lines": 38,
        "source": "(*s).state = 39 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_29: UInt32 = 0;\n                            v_29 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            zj = v_29 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    zvec = zvec << 1 as std::os::raw::c_int | zj;\n                    current_block = 13605767259572914371;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut zvec: i32",
          "mut zj: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut zvec: i32",
          "mut zj: i32"
        ]
      },
      {
        "chunk_id": 2,
        "span": "decompress.rs:1534:9: 1561:38 (#0)",
        "pieces": [
          "decompress.rs:1534:9: 1561:38 (#0)"
        ],
        "num_lines": 36,
        "source": "(*s).state = 38 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= zn {\n                            let mut v_28: UInt32 = 0;\n                            v_28 =\n                                (*s).bsBuff >> (*s).bsLive - zn &\n                                    (((1 as std::os::raw::c_int) << zn) -\n                                         1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= zn;\n                            zvec = v_28 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    current_block = 13605767259572914371;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut zn: i32",
          "mut zvec: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut zn: i32",
          "mut zvec: i32",
          "mut s: &mut bzlib::DState",
          "strm: &mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 3,
        "span": "decompress.rs:1566:9: 1593:37 (#0)",
        "pieces": [
          "decompress.rs:1566:9: 1593:37 (#0)"
        ],
        "num_lines": 38,
        "source": "(*s).state = 37 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_27: UInt32 = 0;\n                            v_27 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            zj = v_27 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    zvec = zvec << 1 as std::os::raw::c_int | zj;\n                    current_block = 1550405138573481750;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut zvec: i32",
          "mut zj: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut zvec: i32",
          "mut zj: i32"
        ]
      },
      {
        "chunk_id": 4,
        "span": "decompress.rs:1598:9: 1625:37 (#0)",
        "pieces": [
          "decompress.rs:1598:9: 1625:37 (#0)"
        ],
        "num_lines": 36,
        "source": "(*s).state = 36 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= zn {\n                            let mut v_26: UInt32 = 0;\n                            v_26 =\n                                (*s).bsBuff >> (*s).bsLive - zn &\n                                    (((1 as std::os::raw::c_int) << zn) -\n                                         1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= zn;\n                            zvec = v_26 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    current_block = 1550405138573481750;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut zn: i32",
          "mut zvec: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut zn: i32",
          "mut zvec: i32",
          "mut s: &mut bzlib::DState",
          "strm: &mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 5,
        "span": "decompress.rs:1630:9: 1662:38 (#0)",
        "pieces": [
          "decompress.rs:1630:9: 1662:38 (#0)"
        ],
        "num_lines": 40,
        "source": "(*s).state = 35 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_25: UInt32 = 0;\n                            v_25 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            uc = v_25 as UChar;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if uc as std::os::raw::c_int == 0 as std::os::raw::c_int {\n                        curr += 1\n                    } else { curr -= 1 }\n                    current_block = 11858046780433112516;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut curr: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut curr: i32"
        ]
      },
      {
        "chunk_id": 6,
        "span": "decompress.rs:1667:9: 1699:38 (#0)",
        "pieces": [
          "decompress.rs:1667:9: 1699:38 (#0)"
        ],
        "num_lines": 41,
        "source": "(*s).state = 34 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_24: UInt32 = 0;\n                            v_24 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            uc = v_24 as UChar;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if !(uc as std::os::raw::c_int == 0 as std::os::raw::c_int) {\n                        current_block = 5008197131544113214;\n                        continue ;\n                    }\n                    current_block = 17503523010989424999;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 7,
        "span": "decompress.rs:1704:9: 1732:37 (#0)",
        "pieces": [
          "decompress.rs:1704:9: 1732:37 (#0)"
        ],
        "num_lines": 38,
        "source": "(*s).state = 33 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 5 as std::os::raw::c_int {\n                            let mut v_23: UInt32 = 0;\n                            v_23 =\n                                (*s).bsBuff >> (*s).bsLive - 5 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 5 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 5 as std::os::raw::c_int;\n                            curr = v_23 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    i = 0 as std::os::raw::c_int;\n                    current_block = 3770765986603902964;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut i: i32",
          "mut curr: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut i: i32",
          "mut curr: i32",
          "mut s: &mut bzlib::DState",
          "strm: &mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 8,
        "span": "decompress.rs:1737:9: 1773:2 (#0)",
        "pieces": [
          "decompress.rs:1737:9: 1773:2 (#0)"
        ],
        "num_lines": 46,
        "source": "(*s).state = 32 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_21: UInt32 = 0;\n                            v_21 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            uc = v_21 as UChar;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if uc as std::os::raw::c_int == 0 as std::os::raw::c_int {\n                        current_block = 5281038271658253520;\n                    } else {\n                        j += 1;\n                        if j >= nGroups {\n                            retVal = -(4 as std::os::raw::c_int);\n                            current_block = 15885526978618306830;\n                            continue ;\n                        } else { current_block = 6927328446518169316; }\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut j: i32",
          "mut nGroups: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut j: i32",
          "mut nGroups: i32",
          "mut s: &mut bzlib::DState"
        ]
      },
      {
        "chunk_id": 9,
        "span": "decompress.rs:1778:9: 1812:37 (#0)",
        "pieces": [
          "decompress.rs:1778:9: 1812:37 (#0)"
        ],
        "num_lines": 42,
        "source": "(*s).state = 31 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 15 as std::os::raw::c_int {\n                            let mut v_20: UInt32 = 0;\n                            v_20 =\n                                (*s).bsBuff >> (*s).bsLive - 15 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 15 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 15 as std::os::raw::c_int;\n                            nSelectors = v_20 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if nSelectors < 1 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                        continue ;\n                    } else { i = 0 as std::os::raw::c_int }\n                    current_block = 6591141407893725683;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut i: i32",
          "mut nSelectors: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut i: i32",
          "mut nSelectors: i32"
        ]
      },
      {
        "chunk_id": 10,
        "span": "decompress.rs:1817:9: 1848:38 (#0)",
        "pieces": [
          "decompress.rs:1817:9: 1848:38 (#0)"
        ],
        "num_lines": 44,
        "source": "(*s).state = 30 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 3 as std::os::raw::c_int {\n                            let mut v_19: UInt32 = 0;\n                            v_19 =\n                                (*s).bsBuff >> (*s).bsLive - 3 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 3 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 3 as std::os::raw::c_int;\n                            nGroups = v_19 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if !(nGroups < 2 as std::os::raw::c_int ||\n                             nGroups > 6 as std::os::raw::c_int) {\n                        current_block = 5769007513321684282;\n                        continue ;\n                    }\n                    retVal = -(4 as std::os::raw::c_int);\n                    current_block = 15885526978618306830;\n                    continue ;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut nGroups: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut nGroups: i32"
        ]
      },
      {
        "chunk_id": 11,
        "span": "decompress.rs:1853:9: 1882:2 (#0)",
        "pieces": [
          "decompress.rs:1853:9: 1882:2 (#0)"
        ],
        "num_lines": 42,
        "source": "(*s).state = 29 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_18: UInt32 = 0;\n                            v_18 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            uc = v_18 as UChar;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if uc as std::os::raw::c_int == 1 as std::os::raw::c_int {\n                        (*s).inUse[(i * 16 as std::os::raw::c_int + j) as usize] =\n                            1 as std::os::raw::c_int as Bool\n                    }\n                    j += 1;\n                    current_block = 3854024847017804838;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut i: i32",
          "mut j: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut i: i32",
          "mut j: i32"
        ]
      },
      {
        "chunk_id": 12,
        "span": "decompress.rs:1887:9: 1897:37 (#0)",
        "pieces": [
          "decompress.rs:1887:9: 1897:37 (#0)"
        ],
        "num_lines": 11,
        "source": "if i < 16 as std::os::raw::c_int {\n                        current_block = 16487873541482693172;\n                        continue ;\n                    }\n                    i = 0 as std::os::raw::c_int;\n                    while i < 256 as std::os::raw::c_int {\n                        (*s).inUse[i as usize] = 0 as std::os::raw::c_int as Bool;\n                        i += 1\n                    }\n                    i = 0 as std::os::raw::c_int;\n                    current_block = 3472349144349095221;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut i: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut i: i32"
        ]
      },
      {
        "chunk_id": 13,
        "span": "decompress.rs:1902:9: 1930:10 (#0)",
        "pieces": [
          "decompress.rs:1902:9: 1930:10 (#0)"
        ],
        "num_lines": 44,
        "source": "(*s).state = 28 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_17: UInt32 = 0;\n                            v_17 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            uc = v_17 as UChar;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if uc as std::os::raw::c_int == 1 as std::os::raw::c_int {\n                        (*s).inUse16[i as usize] = 1 as std::os::raw::c_int as Bool\n                    } else {\n                        (*s).inUse16[i as usize] = 0 as std::os::raw::c_int as Bool\n                    }\n                    i += 1;\n                    current_block = 17262312153619709241;\n                    continue ;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut i: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut i: i32",
          "mut s: &mut bzlib::DState"
        ]
      },
      {
        "chunk_id": 14,
        "span": "decompress.rs:1935:9: 1962:2 (#0)",
        "pieces": [
          "decompress.rs:1935:9: 1962:2 (#0)"
        ],
        "num_lines": 38,
        "source": "(*s).state = 41 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_31: UInt32 = 0;\n                            v_31 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            zj = v_31 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    zvec = zvec << 1 as std::os::raw::c_int | zj;\n                    current_block = 9078889872071895942;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut zvec: i32",
          "mut zj: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut zvec: i32",
          "mut zj: i32"
        ]
      },
      {
        "chunk_id": 15,
        "span": "decompress.rs:2086:5: 2160:13 (#0)",
        "pieces": [
          "decompress.rs:2086:5: 2160:13 (#0)"
        ],
        "num_lines": 142,
        "source": "let mut ii_0: Int32 = 0;\n                                let mut jj_0: Int32 = 0;\n                                let mut kk_0: Int32 = 0;\n                                let mut pp: Int32 = 0;\n                                let mut lno: Int32 = 0;\n                                let mut off: Int32 = 0;\n                                let mut nn: UInt32 = 0;\n                                nn = (nextSym - 1 as std::os::raw::c_int) as UInt32;\n                                if nn < 16 as std::os::raw::c_int as std::os::raw::c_uint {\n                                    /* avoid general-case expense */\n                                    pp =\n                                        (*s).mtfbase[0 as std::os::raw::c_int as\n                                                         usize];\n                                    uc =\n                                        (*s).mtfa[(pp as\n                                                       std::os::raw::c_uint).wrapping_add(nn)\n                                                      as usize];\n                                    while nn >\n                                              3 as std::os::raw::c_int as std::os::raw::c_uint\n                                          {\n                                        let mut z: Int32 =\n                                            (pp as\n                                                 std::os::raw::c_uint).wrapping_add(nn)\n                                                as Int32;\n                                        (*s).mtfa[z as usize] =\n                                            (*s).mtfa[(z - 1 as std::os::raw::c_int)\n                                                          as usize];\n                                        (*s).mtfa[(z - 1 as std::os::raw::c_int) as\n                                                      usize] =\n                                            (*s).mtfa[(z - 2 as std::os::raw::c_int)\n                                                          as usize];\n                                        (*s).mtfa[(z - 2 as std::os::raw::c_int) as\n                                                      usize] =\n                                            (*s).mtfa[(z - 3 as std::os::raw::c_int)\n                                                          as usize];\n                                        (*s).mtfa[(z - 3 as std::os::raw::c_int) as\n                                                      usize] =\n                                            (*s).mtfa[(z - 4 as std::os::raw::c_int)\n                                                          as usize];\n                                        nn =\n                                            (nn as\n                                                 std::os::raw::c_uint).wrapping_sub(4\n                                                                                as\n                                                                                std::os::raw::c_int\n                                                                                as\n                                                                                std::os::raw::c_uint)\n                                                as UInt32 as UInt32\n                                    }\n                                    while nn >\n                                              0 as std::os::raw::c_int as std::os::raw::c_uint\n                                          {\n                                        (*s).mtfa[(pp as\n                                                       std::os::raw::c_uint).wrapping_add(nn)\n                                                      as usize] =\n                                            (*s).mtfa[(pp as\n                                                           std::os::raw::c_uint).wrapping_add(nn).wrapping_sub(1\n                                                                                                           as\n                                                                                                           std::os::raw::c_int\n                                                                                                           as\n                                                                                                           std::os::raw::c_uint)\n                                                          as usize];\n                                        nn = nn.wrapping_sub(1)\n                                    }\n                                    (*s).mtfa[pp as usize] = uc\n                                } else {\n                                    /* general case */\n                                    lno =\n                                        nn.wrapping_div(16 as std::os::raw::c_int as\n                                                            std::os::raw::c_uint) as\n                                            Int32;\n                                    off =\n                                        nn.wrapping_rem(16 as std::os::raw::c_int as\n                                                            std::os::raw::c_uint) as\n                                            Int32;\n                                    pp = (*s).mtfbase[lno as usize] + off;\n                                    uc = (*s).mtfa[pp as usize];\n                                    while pp > (*s).mtfbase[lno as usize] {\n                                        (*s).mtfa[pp as usize] =\n                                            (*s).mtfa[(pp - 1 as std::os::raw::c_int)\n                                                          as usize];\n                                        pp -= 1\n                                    }\n                                    (*s).mtfbase[lno as usize] += 1;\n                                    while lno > 0 as std::os::raw::c_int {\n                                        (*s).mtfbase[lno as usize] -= 1;\n                                        (*s).mtfa[(*s).mtfbase[lno as usize]\n                                                      as usize] =\n                                            (*s).mtfa[((*s).mtfbase[(lno -\n                                                                         1 as\n                                                                             std::os::raw::c_int)\n                                                                        as\n                                                                        usize]\n                                                           + 16 as std::os::raw::c_int\n                                                           - 1 as std::os::raw::c_int)\n                                                          as usize];\n                                        lno -= 1\n                                    }\n                                    (*s).mtfbase[0 as std::os::raw::c_int as usize] -=\n                                        1;\n                                    (*s).mtfa[(*s).mtfbase[0 as std::os::raw::c_int as\n                                                               usize] as\n                                                  usize] = uc;\n                                    if (*s).mtfbase[0 as std::os::raw::c_int as usize]\n                                           == 0 as std::os::raw::c_int {\n                                        kk_0 =\n                                            4096 as std::os::raw::c_int -\n                                                1 as std::os::raw::c_int;\n                                        ii_0 =\n                                            256 as std::os::raw::c_int /\n                                                16 as std::os::raw::c_int -\n                                                1 as std::os::raw::c_int;\n                                        while ii_0 >= 0 as std::os::raw::c_int {\n                                            jj_0 =\n                                                16 as std::os::raw::c_int -\n                                                    1 as std::os::raw::c_int;\n                                            while jj_0 >= 0 as std::os::raw::c_int {\n                                                (*s).mtfa[kk_0 as usize] =\n                                                    (*s).mtfa[((*s).mtfbase[ii_0\n                                                                                as\n                                                                                usize]\n                                                                   + jj_0) as\n                                                                  usize];\n                                                kk_0 -= 1;\n                                                jj_0 -= 1\n                                            }\n                                            (*s).mtfbase[ii_0 as usize] =\n                                                kk_0 + 1 as std::os::raw::c_int;\n                                            ii_0 -= 1\n                                        }\n                                    }\n                                }\n                                /*-- end uc = MTF ( nextSym-1 ) --*/\n                                (*s).unzftab[(*s).seqToUnseq[uc as usize] as\n                                                 usize] += 1;\n                                if (*s).smallDecompress != 0 {\n                                    *(*s).ll16.offset(nblock as isize) =\n                                        (*s).seqToUnseq[uc as usize] as UInt16\n                                } else {\n                                    *(*s).tt.offset(nblock as isize) =\n                                        (*s).seqToUnseq[uc as usize] as UInt32\n                                }\n                                nblock += 1;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut uc: u8",
          "mut nextSym: i32",
          "mut nblock: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut uc: u8",
          "mut nextSym: i32",
          "mut nblock: i32",
          "mut ii_0: i32",
          "mut jj_0: i32",
          "mut kk_0: i32",
          "mut pp: i32",
          "mut lno: i32",
          "mut off: i32",
          "mut nn: u32",
          "s: &mut bzlib::DState"
        ]
      },
      {
        "chunk_id": 16,
        "span": "decompress.rs:2162:32: 2180:10 (#0)",
        "pieces": [
          "decompress.rs:2162:32: 2180:10 (#0)"
        ],
        "num_lines": 45,
        "source": "if groupPos == 0 as std::os::raw::c_int {\n                                    groupNo += 1;\n                                    if groupNo >= nSelectors {\n                                        retVal = -(4 as std::os::raw::c_int);\n                                        current_block = 15885526978618306830;\n                                        continue ;\n                                    } else {\n                                        groupPos = 50 as std::os::raw::c_int;\n                                        gSel =\n                                            (*s).selector[groupNo as usize] as\n                                                Int32;\n                                        gMinlen = (*s).minLens[gSel as usize];\n                                        gLimit =\n                                            &mut *(*(*s).limit.as_mut_ptr().offset(gSel\n                                                                                       as\n                                                                                       isize)).as_mut_ptr().offset(0\n                                                                                                                       as\n                                                                                                                       std::os::raw::c_int\n                                                                                                                       as\n                                                                                                                       isize)\n                                                as *mut Int32;\n                                        gPerm =\n                                            &mut *(*(*s).perm.as_mut_ptr().offset(gSel\n                                                                                      as\n                                                                                      isize)).as_mut_ptr().offset(0\n                                                                                                                      as\n                                                                                                                      std::os::raw::c_int\n                                                                                                                      as\n                                                                                                                      isize)\n                                                as *mut Int32;\n                                        gBase =\n                                            &mut *(*(*s).base.as_mut_ptr().offset(gSel\n                                                                                      as\n                                                                                      isize)).as_mut_ptr().offset(0\n                                                                                                                      as\n                                                                                                                      std::os::raw::c_int\n                                                                                                                      as\n                                                                                                                      isize)\n                                                as *mut Int32\n                                    }\n                                }\n                                groupPos -= 1;\n                                zn = gMinlen;\n                                current_block = 2629672494974161066;\n                                continue ;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut nSelectors: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut zn: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32",
          "s: &mut bzlib::DState"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut nSelectors: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut zn: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32",
          "s: &mut bzlib::DState"
        ]
      },
      {
        "chunk_id": 17,
        "span": "decompress.rs:2077:9: 2188:3 (#0)",
        "pieces": [
          "decompress.rs:2077:9: 2086:4 (#0)",
          "decompress.rs:2162:1: 2162:31 (#0)",
          "decompress.rs:2182:1: 2188:3 (#0)"
        ],
        "num_lines": 14,
        "source": "if nextSym == 0 as std::os::raw::c_int ||\n                                   nextSym == 1 as std::os::raw::c_int {\n                                es = -(1 as std::os::raw::c_int);\n                                N = 1 as std::os::raw::c_int\n                            } else if nblock >= nblockMAX {\n                                retVal = -(4 as std::os::raw::c_int);\n                                current_block = 15885526978618306830;\n                                continue ;\n                            } else {\n                                /*-- uc = MTF ( nextSym-1 ) --*/\n                               <<chunk 15>>                               <<chunk 16>>                            }\n                            current_block = 4550729491376650574;",
        "sub_chunks": [
          15,
          16
        ],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut nSelectors: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut nextSym: i32",
          "mut nblockMAX: i32",
          "mut nblock: i32",
          "mut es: i32",
          "mut N: i32",
          "mut zn: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut nSelectors: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut nextSym: i32",
          "mut nblockMAX: i32",
          "mut nblock: i32",
          "mut es: i32",
          "mut N: i32",
          "mut zn: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32"
        ]
      },
      {
        "chunk_id": 18,
        "span": "decompress.rs:2271:37: 2329:2 (#0)",
        "pieces": [
          "decompress.rs:2271:37: 2329:2 (#0)"
        ],
        "num_lines": 127,
        "source": "i = 0 as std::os::raw::c_int;\n                                    while i <= 256 as std::os::raw::c_int {\n                                        (*s).cftabCopy[i as usize] =\n                                            (*s).cftab[i as usize];\n                                        i += 1\n                                    }\n                                    /*-- compute the T vector --*/\n                                    i = 0 as std::os::raw::c_int;\n                                    while i < nblock {\n                                        uc =\n                                            *(*s).ll16.offset(i as isize) as\n                                                UChar;\n                                        *(*s).ll16.offset(i as isize) =\n                                            ((*s).cftabCopy[uc as usize] &\n                                                 0xffff as std::os::raw::c_int) as\n                                                UInt16;\n                                        if i & 0x1 as std::os::raw::c_int ==\n                                               0 as std::os::raw::c_int {\n                                            *(*s).ll4.offset((i >>\n                                                                  1 as\n                                                                      std::os::raw::c_int)\n                                                                 as isize) =\n                                                (*(*s).ll4.offset((i >>\n                                                                       1 as\n                                                                           std::os::raw::c_int)\n                                                                      as\n                                                                      isize)\n                                                     as std::os::raw::c_int &\n                                                     0xf0 as std::os::raw::c_int |\n                                                     (*s).cftabCopy[uc as\n                                                                        usize]\n                                                         >> 16 as std::os::raw::c_int)\n                                                    as UChar\n                                        } else {\n                                            *(*s).ll4.offset((i >>\n                                                                  1 as\n                                                                      std::os::raw::c_int)\n                                                                 as isize) =\n                                                (*(*s).ll4.offset((i >>\n                                                                       1 as\n                                                                           std::os::raw::c_int)\n                                                                      as\n                                                                      isize)\n                                                     as std::os::raw::c_int &\n                                                     0xf as std::os::raw::c_int |\n                                                     ((*s).cftabCopy[uc as\n                                                                         usize]\n                                                          >>\n                                                          16 as std::os::raw::c_int)\n                                                         << 4 as std::os::raw::c_int)\n                                                    as UChar\n                                        }\n                                        (*s).cftabCopy[uc as usize] += 1;\n                                        i += 1\n                                    }\n                                    /*-- Compute T^(-1) by pointer reversal on T --*/\n                                    i = (*s).origPtr;\n                                    j =\n                                        (*(*s).ll16.offset(i as isize) as\n                                             UInt32 |\n                                             (*(*s).ll4.offset((i >>\n                                                                    1 as\n                                                                        std::os::raw::c_int)\n                                                                   as isize)\n                                                  as UInt32 >>\n                                                  (i << 2 as std::os::raw::c_int &\n                                                       0x4 as std::os::raw::c_int) &\n                                                  0xf as std::os::raw::c_int as\n                                                      std::os::raw::c_uint) <<\n                                                 16 as std::os::raw::c_int) as Int32;\n                                    loop  {\n                                        let mut tmp_0: Int32 =\n                                            (*(*s).ll16.offset(j as isize) as\n                                                 UInt32 |\n                                                 (*(*s).ll4.offset((j >>\n                                                                        1 as\n                                                                            std::os::raw::c_int)\n                                                                       as\n                                                                       isize)\n                                                      as UInt32 >>\n                                                      (j << 2 as std::os::raw::c_int &\n                                                           0x4 as std::os::raw::c_int)\n                                                      &\n                                                      0xf as std::os::raw::c_int as\n                                                          std::os::raw::c_uint) <<\n                                                     16 as std::os::raw::c_int) as\n                                                Int32;\n                                        *(*s).ll16.offset(j as isize) =\n                                            (i & 0xffff as std::os::raw::c_int) as\n                                                UInt16;\n                                        if j & 0x1 as std::os::raw::c_int ==\n                                               0 as std::os::raw::c_int {\n                                            *(*s).ll4.offset((j >>\n                                                                  1 as\n                                                                      std::os::raw::c_int)\n                                                                 as isize) =\n                                                (*(*s).ll4.offset((j >>\n                                                                       1 as\n                                                                           std::os::raw::c_int)\n                                                                      as\n                                                                      isize)\n                                                     as std::os::raw::c_int &\n                                                     0xf0 as std::os::raw::c_int |\n                                                     i >> 16 as std::os::raw::c_int)\n                                                    as UChar\n                                        } else {\n                                            *(*s).ll4.offset((j >>\n                                                                  1 as\n                                                                      std::os::raw::c_int)\n                                                                 as isize) =\n                                                (*(*s).ll4.offset((j >>\n                                                                       1 as\n                                                                           std::os::raw::c_int)\n                                                                      as\n                                                                      isize)\n                                                     as std::os::raw::c_int &\n                                                     0xf as std::os::raw::c_int |\n                                                     (i >> 16 as std::os::raw::c_int)\n                                                         << 4 as std::os::raw::c_int)\n                                                    as UChar\n                                        }\n                                        i = j;\n                                        j = tmp_0;\n                                        if !(i != (*s).origPtr) { break ; }\n                                    }\n                                    (*s).tPos = (*s).origPtr as UInt32;\n                                    (*s).nblock_used = 0 as std::os::raw::c_int;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut uc: u8",
          "mut i: i32",
          "mut j: i32",
          "mut nblock: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut uc: u8",
          "mut i: i32",
          "mut j: i32",
          "mut nblock: i32"
        ]
      },
      {
        "chunk_id": 19,
        "span": "decompress.rs:2331:37: 2415:38 (#0)",
        "pieces": [
          "decompress.rs:2331:37: 2415:38 (#0)"
        ],
        "num_lines": 85,
        "source": "if (*s).blockRandomised != 0 {\n                                        (*s).rNToGo = 0 as std::os::raw::c_int;\n                                        (*s).rTPos = 0 as std::os::raw::c_int;\n                                        if (*s).tPos >=\n                                               (100000 as std::os::raw::c_int as\n                                                    UInt32).wrapping_mul((*s).blockSize100k\n                                                                             as\n                                                                             UInt32)\n                                           {\n                                            return 1 as std::os::raw::c_int as Bool as\n                                                       Int32\n                                        }\n                                        (*s).k0 =\n                                            BZ2_indexIntoF((*s).tPos as Int32,\n                                                           (*s).cftab.as_mut_ptr());\n                                        (*s).tPos =\n                                            *(*s).ll16.offset((*s).tPos as\n                                                                  isize) as\n                                                UInt32 |\n                                                (*(*s).ll4.offset(((*s).tPos\n                                                                       >>\n                                                                       1 as\n                                                                           std::os::raw::c_int)\n                                                                      as\n                                                                      isize)\n                                                     as UInt32 >>\n                                                     ((*s).tPos <<\n                                                          2 as std::os::raw::c_int &\n                                                          0x4 as std::os::raw::c_int\n                                                              as std::os::raw::c_uint)\n                                                     &\n                                                     0xf as std::os::raw::c_int as\n                                                         std::os::raw::c_uint) <<\n                                                    16 as std::os::raw::c_int;\n                                        (*s).nblock_used += 1;\n                                        if (*s).rNToGo == 0 as std::os::raw::c_int {\n                                            (*s).rNToGo =\n                                                BZ2_rNums[(*s).rTPos as\n                                                              usize];\n                                            (*s).rTPos += 1;\n                                            if (*s).rTPos ==\n                                                   512 as std::os::raw::c_int {\n                                                (*s).rTPos = 0 as std::os::raw::c_int\n                                            }\n                                        }\n                                        (*s).rNToGo -= 1;\n                                        (*s).k0 ^=\n                                            if (*s).rNToGo == 1 as std::os::raw::c_int\n                                               {\n                                                1 as std::os::raw::c_int\n                                            } else { 0 as std::os::raw::c_int }\n                                    } else {\n                                        if (*s).tPos >=\n                                               (100000 as std::os::raw::c_int as\n                                                    UInt32).wrapping_mul((*s).blockSize100k\n                                                                             as\n                                                                             UInt32)\n                                           {\n                                            return 1 as std::os::raw::c_int as Bool as\n                                                       Int32\n                                        }\n                                        (*s).k0 =\n                                            BZ2_indexIntoF((*s).tPos as Int32,\n                                                           (*s).cftab.as_mut_ptr());\n                                        (*s).tPos =\n                                            *(*s).ll16.offset((*s).tPos as\n                                                                  isize) as\n                                                UInt32 |\n                                                (*(*s).ll4.offset(((*s).tPos\n                                                                       >>\n                                                                       1 as\n                                                                           std::os::raw::c_int)\n                                                                      as\n                                                                      isize)\n                                                     as UInt32 >>\n                                                     ((*s).tPos <<\n                                                          2 as std::os::raw::c_int &\n                                                          0x4 as std::os::raw::c_int\n                                                              as std::os::raw::c_uint)\n                                                     &\n                                                     0xf as std::os::raw::c_int as\n                                                         std::os::raw::c_uint) <<\n                                                    16 as std::os::raw::c_int;\n                                        (*s).nblock_used += 1\n                                    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState"
        ]
      },
      {
        "chunk_id": 20,
        "span": "decompress.rs:2418:37: 2461:2 (#0)",
        "pieces": [
          "decompress.rs:2418:37: 2461:2 (#0)"
        ],
        "num_lines": 79,
        "source": "i = 0 as std::os::raw::c_int;\n                                    while i < nblock {\n                                        uc =\n                                            (*(*s).tt.offset(i as isize) &\n                                                 0xff as std::os::raw::c_int as\n                                                     std::os::raw::c_uint) as UChar;\n                                        let ref mut fresh0 =\n                                            *(*s).tt.offset((*s).cftab[uc as\n                                                                           usize]\n                                                                as isize);\n                                        *fresh0 |=\n                                            (i << 8 as std::os::raw::c_int) as\n                                                std::os::raw::c_uint;\n                                        (*s).cftab[uc as usize] += 1;\n                                        i += 1\n                                    }\n                                    (*s).tPos =\n                                        *(*s).tt.offset((*s).origPtr as isize)\n                                            >> 8 as std::os::raw::c_int;\n                                    (*s).nblock_used = 0 as std::os::raw::c_int;\n                                    if (*s).blockRandomised != 0 {\n                                        (*s).rNToGo = 0 as std::os::raw::c_int;\n                                        (*s).rTPos = 0 as std::os::raw::c_int;\n                                        if (*s).tPos >=\n                                               (100000 as std::os::raw::c_int as\n                                                    UInt32).wrapping_mul((*s).blockSize100k\n                                                                             as\n                                                                             UInt32)\n                                           {\n                                            return 1 as std::os::raw::c_int as Bool as\n                                                       Int32\n                                        }\n                                        (*s).tPos =\n                                            *(*s).tt.offset((*s).tPos as\n                                                                isize);\n                                        (*s).k0 =\n                                            ((*s).tPos &\n                                                 0xff as std::os::raw::c_int as\n                                                     std::os::raw::c_uint) as UChar as\n                                                Int32;\n                                        (*s).tPos >>= 8 as std::os::raw::c_int;\n                                        (*s).nblock_used += 1;\n                                        if (*s).rNToGo == 0 as std::os::raw::c_int {\n                                            (*s).rNToGo =\n                                                BZ2_rNums[(*s).rTPos as\n                                                              usize];\n                                            (*s).rTPos += 1;\n                                            if (*s).rTPos ==\n                                                   512 as std::os::raw::c_int {\n                                                (*s).rTPos = 0 as std::os::raw::c_int\n                                            }\n                                        }\n                                        (*s).rNToGo -= 1;\n                                        (*s).k0 ^=\n                                            if (*s).rNToGo == 1 as std::os::raw::c_int\n                                               {\n                                                1 as std::os::raw::c_int\n                                            } else { 0 as std::os::raw::c_int }\n                                    } else {\n                                        if (*s).tPos >=\n                                               (100000 as std::os::raw::c_int as\n                                                    UInt32).wrapping_mul((*s).blockSize100k\n                                                                             as\n                                                                             UInt32)\n                                           {\n                                            return 1 as std::os::raw::c_int as Bool as\n                                                       Int32\n                                        }\n                                        (*s).tPos =\n                                            *(*s).tt.offset((*s).tPos as\n                                                                isize);\n                                        (*s).k0 =\n                                            ((*s).tPos &\n                                                 0xff as std::os::raw::c_int as\n                                                     std::os::raw::c_uint) as UChar as\n                                                Int32;\n                                        (*s).tPos >>= 8 as std::os::raw::c_int;\n                                        (*s).nblock_used += 1\n                                    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut uc: u8",
          "mut i: i32",
          "mut nblock: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut uc: u8",
          "mut i: i32",
          "mut nblock: i32",
          "mut i: i32"
        ]
      },
      {
        "chunk_id": 21,
        "span": "decompress.rs:2209:13: 2466:43 (#0)",
        "pieces": [
          "decompress.rs:2209:13: 2271:36 (#0)",
          "decompress.rs:2331:1: 2331:36 (#0)",
          "decompress.rs:2416:1: 2418:36 (#0)",
          "decompress.rs:2463:1: 2466:43 (#0)"
        ],
        "num_lines": 71,
        "source": "i = 0 as std::os::raw::c_int;\n                                while i <= 255 as std::os::raw::c_int {\n                                    if (*s).unzftab[i as usize] <\n                                           0 as std::os::raw::c_int ||\n                                           (*s).unzftab[i as usize] > nblock {\n                                        retVal = -(4 as std::os::raw::c_int);\n                                        current_block = 15885526978618306830;\n                                        continue 'c_10532 ;\n                                    } else { i += 1 }\n                                }\n                                /* Actually generate cftab. */\n                                (*s).cftab[0 as std::os::raw::c_int as usize] =\n                                    0 as std::os::raw::c_int;\n                                i = 1 as std::os::raw::c_int;\n                                while i <= 256 as std::os::raw::c_int {\n                                    (*s).cftab[i as usize] =\n                                        (*s).unzftab[(i - 1 as std::os::raw::c_int) as\n                                                         usize];\n                                    i += 1\n                                }\n                                i = 1 as std::os::raw::c_int;\n                                while i <= 256 as std::os::raw::c_int {\n                                    (*s).cftab[i as usize] +=\n                                        (*s).cftab[(i - 1 as std::os::raw::c_int) as\n                                                       usize];\n                                    i += 1\n                                }\n                                /* Check: cftab entries in range. */\n                                i = 0 as std::os::raw::c_int;\n                                while i <= 256 as std::os::raw::c_int {\n                                    if (*s).cftab[i as usize] <\n                                           0 as std::os::raw::c_int ||\n                                           (*s).cftab[i as usize] > nblock {\n                                        /* s->cftab[i] can legitimately be == nblock */\n                                        retVal = -(4 as std::os::raw::c_int);\n                                        current_block = 15885526978618306830;\n                                        continue 'c_10532 ;\n                                    } else { i += 1 }\n                                }\n                                /* Check: cftab entries non-descending. */\n                                i = 1 as std::os::raw::c_int;\n                                while i <= 256 as std::os::raw::c_int {\n                                    if (*s).cftab[(i - 1 as std::os::raw::c_int) as\n                                                      usize] >\n                                           (*s).cftab[i as usize] {\n                                        retVal = -(4 as std::os::raw::c_int);\n                                        current_block = 15885526978618306830;\n                                        continue 'c_10532 ;\n                                    } else { i += 1 }\n                                }\n                                (*s).state_out_len = 0 as std::os::raw::c_int;\n                                (*s).state_out_ch = 0 as std::os::raw::c_int as UChar;\n                                (*s).calculatedBlockCRC =\n                                    0xffffffff as std::os::raw::c_long as UInt32;\n                                (*s).state = 2 as std::os::raw::c_int;\n                                if (*s).verbosity >= 2 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"rt+rld\\x00\" as *const u8 as\n                                                *const std::os::raw::c_char);\n                                }\n                                if (*s).smallDecompress != 0 {\n                                    /*-- Make a copy of cftab, used in generation of T --*/\n                                   <<chunk 18>>                                   <<chunk 19>>                                } else {\n                                    /*-- compute the T^(-1) vector --*/\n                                   <<chunk 20>>                                }\n                                retVal = 0 as std::os::raw::c_int;\n                                current_block = 15885526978618306830;\n                                continue ;",
        "sub_chunks": [
          18,
          19,
          20
        ],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut i: i32",
          "mut j: i32",
          "mut nblock: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut i: i32",
          "mut j: i32",
          "mut nblock: i32"
        ]
      },
      {
        "chunk_id": 22,
        "span": "decompress.rs:2073:9: 2474:3 (#0)",
        "pieces": [
          "decompress.rs:2073:9: 2077:8 (#0)",
          "decompress.rs:2190:1: 2209:12 (#0)",
          "decompress.rs:2467:1: 2474:3 (#0)"
        ],
        "num_lines": 26,
        "source": "if 1 as std::os::raw::c_int as Bool != 0 {\n                        if nextSym == EOB {\n                            current_block = 12118509005321596519;\n                        } else {\n                           <<chunk 17>>                        }\n                    } else { current_block = 12118509005321596519; }\n                    match current_block {\n                        4550729491376650574 => { }\n                        _ =>\n                        /* Now we know what nblock is, we can do a better sanity\n         check on s->origPtr.\n      */\n                        {\n                            if (*s).origPtr < 0 as std::os::raw::c_int ||\n                                   (*s).origPtr >= nblock {\n                                retVal = -(4 as std::os::raw::c_int);\n                                current_block = 15885526978618306830;\n                                continue ;\n                            } else {\n                                /*-- Set up cftab to facilitate generation of T^(-1) --*/\n      /* Check: unzftab entries in range. */\n                               <<chunk 21>>                            }\n                        }\n                    }",
        "sub_chunks": [
          17,
          21
        ],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut i: i32",
          "mut j: i32",
          "mut nSelectors: i32",
          "mut EOB: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut nextSym: i32",
          "mut nblockMAX: i32",
          "mut nblock: i32",
          "mut es: i32",
          "mut N: i32",
          "mut zn: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut i: i32",
          "mut j: i32",
          "mut nSelectors: i32",
          "mut EOB: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut nextSym: i32",
          "mut nblockMAX: i32",
          "mut nblock: i32",
          "mut es: i32",
          "mut N: i32",
          "mut zn: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32"
        ]
      },
      {
        "chunk_id": 23,
        "span": "decompress.rs:1466:5: 1970:3 (#0)",
        "pieces": [
          "decompress.rs:1466:5: 1469:8 (#0)",
          "decompress.rs:1498:1: 1501:8 (#0)",
          "decompress.rs:1531:1: 1534:8 (#0)",
          "decompress.rs:1563:1: 1566:8 (#0)",
          "decompress.rs:1595:1: 1598:8 (#0)",
          "decompress.rs:1627:1: 1630:8 (#0)",
          "decompress.rs:1664:1: 1667:8 (#0)",
          "decompress.rs:1701:1: 1704:8 (#0)",
          "decompress.rs:1734:1: 1737:8 (#0)",
          "decompress.rs:1775:1: 1778:8 (#0)",
          "decompress.rs:1814:1: 1817:8 (#0)",
          "decompress.rs:1850:1: 1853:8 (#0)",
          "decompress.rs:1884:1: 1887:8 (#0)",
          "decompress.rs:1899:1: 1902:8 (#0)",
          "decompress.rs:1932:1: 1935:8 (#0)",
          "decompress.rs:1964:1: 1970:3 (#0)"
        ],
        "num_lines": 50,
        "source": "match current_block {\n                15885526978618306830 => { (*s).save_i = i; break ; }\n                2629672494974161066 => {\n                   <<chunk 0>>                }\n                13999925517074022731 => {\n                   <<chunk 1>>                }\n                5374617794059532979 => {\n                   <<chunk 2>>                }\n                14744029255125744966 => {\n                   <<chunk 3>>                }\n                16722720626876144162 => {\n                   <<chunk 4>>                }\n                5008197131544113214 => {\n                   <<chunk 5>>                }\n                1736021991379636935 => {\n                   <<chunk 6>>                }\n                10945178116989557996 => {\n                   <<chunk 7>>                }\n                4874723077730206021 => {\n                   <<chunk 8>>                }\n                5769007513321684282 => {\n                   <<chunk 9>>                }\n                3906616468301123675 =>\n                /*--- Now the selectors ---*/\n                {\n                   <<chunk 10>>                }\n                1422779171932145779 => {\n                   <<chunk 11>>                }\n                17262312153619709241 => {\n                   <<chunk 12>>                }\n                16487873541482693172 => {\n                   <<chunk 13>>                }\n                _ => {\n                   <<chunk 14>>                }\n            }",
        "sub_chunks": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14
        ],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut i: i32",
          "mut j: i32",
          "mut nGroups: i32",
          "mut nSelectors: i32",
          "mut curr: i32",
          "mut zn: i32",
          "mut zvec: i32",
          "mut zj: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut i: i32",
          "mut j: i32",
          "mut nGroups: i32",
          "mut nSelectors: i32",
          "mut curr: i32",
          "mut zn: i32",
          "mut zvec: i32",
          "mut zj: i32"
        ]
      },
      {
        "chunk_id": 24,
        "span": "decompress.rs:1972:12: 2479:2 (#0)",
        "pieces": [
          "decompress.rs:1972:12: 2073:8 (#0)",
          "decompress.rs:2476:1: 2479:2 (#0)"
        ],
        "num_lines": 131,
        "source": "match current_block {\n                9078889872071895942 => {\n                    if zn > 20 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                        continue ;\n                    } else if zvec <= *gLimit.offset(zn as isize) {\n                        if zvec - *gBase.offset(zn as isize) <\n                               0 as std::os::raw::c_int ||\n                               zvec - *gBase.offset(zn as isize) >=\n                                   258 as std::os::raw::c_int {\n                            retVal = -(4 as std::os::raw::c_int);\n                            current_block = 15885526978618306830;\n                            continue ;\n                        } else {\n                            nextSym =\n                                *gPerm.offset((zvec -\n                                                   *gBase.offset(zn as isize))\n                                                  as isize)\n                        }\n                    } else {\n                        zn += 1;\n                        current_block = 1050378859040334210;\n                        continue ;\n                    }\n                    current_block = 15093386068129942558;\n                }\n                13605767259572914371 => {\n                    if zn > 20 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                        continue ;\n                    } else if zvec <= *gLimit.offset(zn as isize) {\n                        if zvec - *gBase.offset(zn as isize) <\n                               0 as std::os::raw::c_int ||\n                               zvec - *gBase.offset(zn as isize) >=\n                                   258 as std::os::raw::c_int {\n                            retVal = -(4 as std::os::raw::c_int);\n                            current_block = 15885526978618306830;\n                            continue ;\n                        } else {\n                            nextSym =\n                                *gPerm.offset((zvec -\n                                                   *gBase.offset(zn as isize))\n                                                  as isize);\n                            if nextSym == 0 as std::os::raw::c_int ||\n                                   nextSym == 1 as std::os::raw::c_int {\n                                current_block = 4550729491376650574;\n                            } else {\n                                es += 1;\n                                uc =\n                                    (*s).seqToUnseq[(*s).mtfa[(*s).mtfbase[0\n                                                                               as\n                                                                               std::os::raw::c_int\n                                                                               as\n                                                                               usize]\n                                                                  as usize] as\n                                                        usize];\n                                (*s).unzftab[uc as usize] += es;\n                                if (*s).smallDecompress != 0 {\n                                    while es > 0 as std::os::raw::c_int {\n                                        if nblock >= nblockMAX {\n                                            retVal = -(4 as std::os::raw::c_int);\n                                            current_block =\n                                                15885526978618306830;\n                                            continue 'c_10532 ;\n                                        } else {\n                                            *(*s).ll16.offset(nblock as isize)\n                                                = uc as UInt16;\n                                            nblock += 1;\n                                            es -= 1\n                                        }\n                                    }\n                                } else {\n                                    while es > 0 as std::os::raw::c_int {\n                                        if nblock >= nblockMAX {\n                                            retVal = -(4 as std::os::raw::c_int);\n                                            current_block =\n                                                15885526978618306830;\n                                            continue 'c_10532 ;\n                                        } else {\n                                            *(*s).tt.offset(nblock as isize) =\n                                                uc as UInt32;\n                                            nblock += 1;\n                                            es -= 1\n                                        }\n                                    }\n                                }\n                                current_block = 15093386068129942558;\n                            }\n                        }\n                    } else {\n                        zn += 1;\n                        current_block = 13999925517074022731;\n                        continue ;\n                    }\n                }\n                1550405138573481750 => {\n                    if zn > 20 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                        continue ;\n                    } else if zvec <= *gLimit.offset(zn as isize) {\n                        if zvec - *gBase.offset(zn as isize) <\n                               0 as std::os::raw::c_int ||\n                               zvec - *gBase.offset(zn as isize) >=\n                                   258 as std::os::raw::c_int {\n                            retVal = -(4 as std::os::raw::c_int);\n                            current_block = 15885526978618306830;\n                            continue ;\n                        } else {\n                            nextSym =\n                                *gPerm.offset((zvec -\n                                                   *gBase.offset(zn as isize))\n                                                  as isize)\n                        }\n                    } else {\n                        zn += 1;\n                        current_block = 14744029255125744966;\n                        continue ;\n                    }\n                    current_block = 15093386068129942558;\n                }\n                _ => { }\n            }\n            match current_block {\n                15093386068129942558 => {\n                   <<chunk 22>>                }\n                _ => { }\n            }",
        "sub_chunks": [
          22
        ],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut i: i32",
          "mut j: i32",
          "mut nSelectors: i32",
          "mut EOB: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut nextSym: i32",
          "mut nblockMAX: i32",
          "mut nblock: i32",
          "mut es: i32",
          "mut N: i32",
          "mut zn: i32",
          "mut zvec: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut i: i32",
          "mut j: i32",
          "mut nSelectors: i32",
          "mut EOB: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut nextSym: i32",
          "mut nblockMAX: i32",
          "mut nblock: i32",
          "mut es: i32",
          "mut N: i32",
          "mut zn: i32",
          "mut zvec: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32"
        ]
      },
      {
        "chunk_id": 25,
        "span": "decompress.rs:2481:12: 2523:2 (#0)",
        "pieces": [
          "decompress.rs:2481:12: 2523:2 (#0)"
        ],
        "num_lines": 72,
        "source": "match current_block {\n                4550729491376650574 =>\n                /* Check that N doesn't get too big, so that es doesn't\n                  go negative.  The maximum value that can be\n                  RUNA/RUNB encoded is equal to the block size (post\n                  the initial RLE), viz, 900k, so bounding N at 2\n                  million should guard against overflow without\n                  rejecting any legitimate inputs. */\n                {\n                    if N >=\n                           2 as std::os::raw::c_int * 1024 as std::os::raw::c_int *\n                               1024 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                        continue ;\n                    } else {\n                        if nextSym == 0 as std::os::raw::c_int {\n                            es =\n                                es + (0 as std::os::raw::c_int + 1 as std::os::raw::c_int) * N\n                        } else if nextSym == 1 as std::os::raw::c_int {\n                            es =\n                                es + (1 as std::os::raw::c_int + 1 as std::os::raw::c_int) * N\n                        }\n                        N = N * 2 as std::os::raw::c_int;\n                        if groupPos == 0 as std::os::raw::c_int {\n                            groupNo += 1;\n                            if groupNo >= nSelectors {\n                                retVal = -(4 as std::os::raw::c_int);\n                                current_block = 15885526978618306830;\n                                continue ;\n                            } else {\n                                groupPos = 50 as std::os::raw::c_int;\n                                gSel =\n                                    (*s).selector[groupNo as usize] as Int32;\n                                gMinlen = (*s).minLens[gSel as usize];\n                                gLimit =\n                                    &mut *(*(*s).limit.as_mut_ptr().offset(gSel\n                                                                               as\n                                                                               isize)).as_mut_ptr().offset(0\n                                                                                                               as\n                                                                                                               std::os::raw::c_int\n                                                                                                               as\n                                                                                                               isize)\n                                        as *mut Int32;\n                                gPerm =\n                                    &mut *(*(*s).perm.as_mut_ptr().offset(gSel\n                                                                              as\n                                                                              isize)).as_mut_ptr().offset(0\n                                                                                                              as\n                                                                                                              std::os::raw::c_int\n                                                                                                              as\n                                                                                                              isize)\n                                        as *mut Int32;\n                                gBase =\n                                    &mut *(*(*s).base.as_mut_ptr().offset(gSel\n                                                                              as\n                                                                              isize)).as_mut_ptr().offset(0\n                                                                                                              as\n                                                                                                              std::os::raw::c_int\n                                                                                                              as\n                                                                                                              isize)\n                                        as *mut Int32\n                            }\n                        }\n                        groupPos -= 1;\n                        zn = gMinlen;\n                        current_block = 5374617794059532979;\n                        continue ;\n                    }\n                }\n                _ => { }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut t: i32",
          "mut nSelectors: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut nextSym: i32",
          "mut es: i32",
          "mut N: i32",
          "mut zn: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut t: i32",
          "mut nSelectors: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut nextSym: i32",
          "mut es: i32",
          "mut N: i32",
          "mut zn: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32"
        ]
      },
      {
        "chunk_id": 26,
        "span": "decompress.rs:2525:12: 2640:2 (#0)",
        "pieces": [
          "decompress.rs:2525:12: 2640:2 (#0)"
        ],
        "num_lines": 125,
        "source": "loop  {\n                match current_block {\n                    3854024847017804838 => {\n                        if j < 16 as std::os::raw::c_int {\n                            current_block = 1422779171932145779;\n                            continue 'c_10532 ;\n                        }\n                    }\n                    6591141407893725683 => {\n                        if i < nSelectors {\n                            j = 0 as std::os::raw::c_int;\n                            current_block = 6927328446518169316;\n                            continue ;\n                        } else {\n                            if nSelectors >\n                                   2 as std::os::raw::c_int +\n                                       900000 as std::os::raw::c_int /\n                                           50 as std::os::raw::c_int {\n                                nSelectors =\n                                    2 as std::os::raw::c_int +\n                                        900000 as std::os::raw::c_int /\n                                            50 as std::os::raw::c_int\n                            }\n                            /*--- Undo the MTF values for the selectors. ---*/\n                            let mut pos: [UChar; 6] = [0; 6];\n                            let mut tmp: UChar = 0;\n                            let mut v_22: UChar = 0;\n                            v_22 = 0 as std::os::raw::c_int as UChar;\n                            while (v_22 as std::os::raw::c_int) < nGroups {\n                                pos[v_22 as usize] = v_22;\n                                v_22 = v_22.wrapping_add(1)\n                            }\n                            i = 0 as std::os::raw::c_int;\n                            while i < nSelectors {\n                                v_22 = (*s).selectorMtf[i as usize];\n                                tmp = pos[v_22 as usize];\n                                while v_22 as std::os::raw::c_int > 0 as std::os::raw::c_int {\n                                    pos[v_22 as usize] =\n                                        pos[(v_22 as std::os::raw::c_int -\n                                                 1 as std::os::raw::c_int) as usize];\n                                    v_22 = v_22.wrapping_sub(1)\n                                }\n                                pos[0 as std::os::raw::c_int as usize] = tmp;\n                                (*s).selector[i as usize] = tmp;\n                                i += 1\n                            }\n                            /*--- Now the coding tables ---*/\n                            t = 0 as std::os::raw::c_int;\n                            current_block = 16916874950763617094;\n                            break ;\n                        }\n                    }\n                    3472349144349095221 => {\n                        if i < 16 as std::os::raw::c_int {\n                            if (*s).inUse16[i as usize] != 0 {\n                                j = 0 as std::os::raw::c_int;\n                                current_block = 3854024847017804838;\n                                continue ;\n                            }\n                        } else {\n                            makeMaps_d(s);\n                            if (*s).nInUse == 0 as std::os::raw::c_int {\n                                current_block = 11906008669688594715;\n                                break ;\n                            } else {\n                                current_block = 7606051654693192361;\n                                break ;\n                            }\n                        }\n                    }\n                    17503523010989424999 => {\n                        (*s).len[t as usize][i as usize] = curr as UChar;\n                        i += 1;\n                        current_block = 3770765986603902964;\n                        continue ;\n                    }\n                    3770765986603902964 => {\n                        if i < alphaSize {\n                            current_block = 11858046780433112516;\n                            continue ;\n                        }\n                        t += 1;\n                        current_block = 16916874950763617094;\n                        break ;\n                    }\n                    5281038271658253520 => {\n                        /* Having more than BZ_MAX_SELECTORS doesn't make much sense\n            since they will never be used, but some implementations might\n            \"round up\" the number of selectors, so just ignore those. */\n                        if i <\n                               2 as std::os::raw::c_int +\n                                   900000 as std::os::raw::c_int / 50 as std::os::raw::c_int {\n                            (*s).selectorMtf[i as usize] = j as UChar\n                        }\n                        i += 1;\n                        current_block = 6591141407893725683;\n                        continue ;\n                    }\n                    6927328446518169316 => {\n                        if 1 as std::os::raw::c_int as Bool != 0 {\n                            current_block = 4874723077730206021;\n                            continue 'c_10532 ;\n                        } else {\n                            current_block = 5281038271658253520;\n                            continue ;\n                        }\n                    }\n                    _ => {\n                        if !(1 as std::os::raw::c_int as Bool != 0) {\n                            current_block = 17503523010989424999;\n                            continue ;\n                        }\n                        if !(curr < 1 as std::os::raw::c_int ||\n                                 curr > 20 as std::os::raw::c_int) {\n                            current_block = 1736021991379636935;\n                            continue 'c_10532 ;\n                        }\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                        continue 'c_10532 ;\n                    }\n                }\n                i += 1;\n                current_block = 3472349144349095221;\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut i: i32",
          "mut j: i32",
          "mut t: i32",
          "mut alphaSize: i32",
          "mut nGroups: i32",
          "mut nSelectors: i32",
          "mut curr: i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut i: i32",
          "mut j: i32",
          "mut t: i32",
          "mut alphaSize: i32",
          "mut nGroups: i32",
          "mut nSelectors: i32",
          "mut curr: i32"
        ]
      },
      {
        "chunk_id": 27,
        "span": "decompress.rs:2642:12: 2778:14 (#0)",
        "pieces": [
          "decompress.rs:2642:12: 2778:14 (#0)"
        ],
        "num_lines": 137,
        "source": "match current_block {\n                7606051654693192361 => {\n                    alphaSize = (*s).nInUse + 2 as std::os::raw::c_int;\n                    current_block = 3906616468301123675;\n                }\n                11906008669688594715 => {\n                    retVal = -(4 as std::os::raw::c_int);\n                    current_block = 15885526978618306830;\n                }\n                _ => {\n                    if t < nGroups {\n                        current_block = 10945178116989557996;\n                        continue ;\n                    }\n                    /*--- Create the Huffman decoding tables ---*/\n                    t = 0 as std::os::raw::c_int;\n                    while t < nGroups {\n                        minLen = 32 as std::os::raw::c_int;\n                        maxLen = 0 as std::os::raw::c_int;\n                        i = 0 as std::os::raw::c_int;\n                        while i < alphaSize {\n                            if (*s).len[t as usize][i as usize] as std::os::raw::c_int\n                                   > maxLen {\n                                maxLen =\n                                    (*s).len[t as usize][i as usize] as Int32\n                            }\n                            if ((*s).len[t as usize][i as usize] as\n                                    std::os::raw::c_int) < minLen {\n                                minLen =\n                                    (*s).len[t as usize][i as usize] as Int32\n                            }\n                            i += 1\n                        }\n                        BZ2_hbCreateDecodeTables(&mut *(*(*s).limit.as_mut_ptr().offset(t\n                                                                                            as\n                                                                                            isize)).as_mut_ptr().offset(0\n                                                                                                                            as\n                                                                                                                            std::os::raw::c_int\n                                                                                                                            as\n                                                                                                                            isize),\n                                                 &mut *(*(*s).base.as_mut_ptr().offset(t\n                                                                                           as\n                                                                                           isize)).as_mut_ptr().offset(0\n                                                                                                                           as\n                                                                                                                           std::os::raw::c_int\n                                                                                                                           as\n                                                                                                                           isize),\n                                                 &mut *(*(*s).perm.as_mut_ptr().offset(t\n                                                                                           as\n                                                                                           isize)).as_mut_ptr().offset(0\n                                                                                                                           as\n                                                                                                                           std::os::raw::c_int\n                                                                                                                           as\n                                                                                                                           isize),\n                                                 &mut *(*(*s).len.as_mut_ptr().offset(t\n                                                                                          as\n                                                                                          isize)).as_mut_ptr().offset(0\n                                                                                                                          as\n                                                                                                                          std::os::raw::c_int\n                                                                                                                          as\n                                                                                                                          isize),\n                                                 minLen, maxLen, alphaSize);\n                        (*s).minLens[t as usize] = minLen;\n                        t += 1\n                    }\n                    /*--- Now the MTF values ---*/\n                    EOB = (*s).nInUse + 1 as std::os::raw::c_int;\n                    nblockMAX = 100000 as std::os::raw::c_int * (*s).blockSize100k;\n                    groupNo = -(1 as std::os::raw::c_int);\n                    groupPos = 0 as std::os::raw::c_int;\n                    i = 0 as std::os::raw::c_int;\n                    while i <= 255 as std::os::raw::c_int {\n                        (*s).unzftab[i as usize] = 0 as std::os::raw::c_int;\n                        i += 1\n                    }\n                    /*-- MTF init --*/\n                    let mut ii: Int32 = 0;\n                    let mut jj: Int32 = 0;\n                    let mut kk: Int32 = 0;\n                    kk = 4096 as std::os::raw::c_int - 1 as std::os::raw::c_int;\n                    ii =\n                        256 as std::os::raw::c_int / 16 as std::os::raw::c_int -\n                            1 as std::os::raw::c_int;\n                    while ii >= 0 as std::os::raw::c_int {\n                        jj = 16 as std::os::raw::c_int - 1 as std::os::raw::c_int;\n                        while jj >= 0 as std::os::raw::c_int {\n                            (*s).mtfa[kk as usize] =\n                                (ii * 16 as std::os::raw::c_int + jj) as UChar;\n                            kk -= 1;\n                            jj -= 1\n                        }\n                        (*s).mtfbase[ii as usize] = kk + 1 as std::os::raw::c_int;\n                        ii -= 1\n                    }\n                    /*-- end MTF init --*/\n                    nblock = 0 as std::os::raw::c_int;\n                    if groupPos == 0 as std::os::raw::c_int {\n                        groupNo += 1;\n                        if groupNo >= nSelectors {\n                            retVal = -(4 as std::os::raw::c_int);\n                            current_block = 15885526978618306830;\n                            continue ;\n                        } else {\n                            groupPos = 50 as std::os::raw::c_int;\n                            gSel = (*s).selector[groupNo as usize] as Int32;\n                            gMinlen = (*s).minLens[gSel as usize];\n                            gLimit =\n                                &mut *(*(*s).limit.as_mut_ptr().offset(gSel as\n                                                                           isize)).as_mut_ptr().offset(0\n                                                                                                           as\n                                                                                                           std::os::raw::c_int\n                                                                                                           as\n                                                                                                           isize)\n                                    as *mut Int32;\n                            gPerm =\n                                &mut *(*(*s).perm.as_mut_ptr().offset(gSel as\n                                                                          isize)).as_mut_ptr().offset(0\n                                                                                                          as\n                                                                                                          std::os::raw::c_int\n                                                                                                          as\n                                                                                                          isize)\n                                    as *mut Int32;\n                            gBase =\n                                &mut *(*(*s).base.as_mut_ptr().offset(gSel as\n                                                                          isize)).as_mut_ptr().offset(0\n                                                                                                          as\n                                                                                                          std::os::raw::c_int\n                                                                                                          as\n                                                                                                          isize)\n                                    as *mut Int32\n                        }\n                    }\n                    groupPos -= 1;\n                    zn = gMinlen;\n                    current_block = 16722720626876144162;\n                }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut minLen: i32",
          "mut maxLen: i32",
          "mut i: i32",
          "mut t: i32",
          "mut alphaSize: i32",
          "mut nGroups: i32",
          "mut nSelectors: i32",
          "mut EOB: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut nblockMAX: i32",
          "mut nblock: i32",
          "mut zn: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut minLen: i32",
          "mut maxLen: i32",
          "mut i: i32",
          "mut t: i32",
          "mut alphaSize: i32",
          "mut nGroups: i32",
          "mut nSelectors: i32",
          "mut EOB: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut nblockMAX: i32",
          "mut nblock: i32",
          "mut zn: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32"
        ]
      },
      {
        "chunk_id": 28,
        "span": "decompress.rs:114:5: 197:39 (#0)",
        "pieces": [
          "decompress.rs:114:5: 197:39 (#0)"
        ],
        "num_lines": 84,
        "source": "let mut current_block: u64;\n    let mut uc: UChar = 0;\n    let mut retVal: Int32 = 0;\n    let mut minLen: Int32 = 0;\n    let mut maxLen: Int32 = 0;\n    let mut strm: *mut bz_stream = (*s).strm;\n    /* stuff that needs to be saved/restored */\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut t: Int32 = 0;\n    let mut alphaSize: Int32 = 0;\n    let mut nGroups: Int32 = 0;\n    let mut nSelectors: Int32 = 0;\n    let mut EOB: Int32 = 0;\n    let mut groupNo: Int32 = 0;\n    let mut groupPos: Int32 = 0;\n    let mut nextSym: Int32 = 0;\n    let mut nblockMAX: Int32 = 0;\n    let mut nblock: Int32 = 0;\n    let mut es: Int32 = 0;\n    let mut N: Int32 = 0;\n    let mut curr: Int32 = 0;\n    let mut zt: Int32 = 0;\n    let mut zn: Int32 = 0;\n    let mut zvec: Int32 = 0;\n    let mut zj: Int32 = 0;\n    let mut gSel: Int32 = 0;\n    let mut gMinlen: Int32 = 0;\n    let mut gLimit: *mut Int32 = 0 as *mut Int32;\n    let mut gBase: *mut Int32 = 0 as *mut Int32;\n    let mut gPerm: *mut Int32 = 0 as *mut Int32;\n    if (*s).state == 10 as std::os::raw::c_int {\n        /*initialise the save area*/\n        (*s).save_i = 0 as std::os::raw::c_int;\n        (*s).save_j = 0 as std::os::raw::c_int;\n        (*s).save_t = 0 as std::os::raw::c_int;\n        (*s).save_alphaSize = 0 as std::os::raw::c_int;\n        (*s).save_nGroups = 0 as std::os::raw::c_int;\n        (*s).save_nSelectors = 0 as std::os::raw::c_int;\n        (*s).save_EOB = 0 as std::os::raw::c_int;\n        (*s).save_groupNo = 0 as std::os::raw::c_int;\n        (*s).save_groupPos = 0 as std::os::raw::c_int;\n        (*s).save_nextSym = 0 as std::os::raw::c_int;\n        (*s).save_nblockMAX = 0 as std::os::raw::c_int;\n        (*s).save_nblock = 0 as std::os::raw::c_int;\n        (*s).save_es = 0 as std::os::raw::c_int;\n        (*s).save_N = 0 as std::os::raw::c_int;\n        (*s).save_curr = 0 as std::os::raw::c_int;\n        (*s).save_zt = 0 as std::os::raw::c_int;\n        (*s).save_zn = 0 as std::os::raw::c_int;\n        (*s).save_zvec = 0 as std::os::raw::c_int;\n        (*s).save_zj = 0 as std::os::raw::c_int;\n        (*s).save_gSel = 0 as std::os::raw::c_int;\n        (*s).save_gMinlen = 0 as std::os::raw::c_int;\n        (*s).save_gLimit = 0 as *mut Int32;\n        (*s).save_gBase = 0 as *mut Int32;\n        (*s).save_gPerm = 0 as *mut Int32\n    }\n    /*restore from the save area*/\n    i = (*s).save_i;\n    j = (*s).save_j;\n    t = (*s).save_t;\n    alphaSize = (*s).save_alphaSize;\n    nGroups = (*s).save_nGroups;\n    nSelectors = (*s).save_nSelectors;\n    EOB = (*s).save_EOB;\n    groupNo = (*s).save_groupNo;\n    groupPos = (*s).save_groupPos;\n    nextSym = (*s).save_nextSym;\n    nblockMAX = (*s).save_nblockMAX;\n    nblock = (*s).save_nblock;\n    es = (*s).save_es;\n    N = (*s).save_N;\n    curr = (*s).save_curr;\n    zt = (*s).save_zt;\n    zn = (*s).save_zn;\n    zvec = (*s).save_zvec;\n    zj = (*s).save_zj;\n    gSel = (*s).save_gSel;\n    gMinlen = (*s).save_gMinlen;\n    gLimit = (*s).save_gLimit;\n    gBase = (*s).save_gBase;\n    gPerm = (*s).save_gPerm;\n    retVal = 0 as std::os::raw::c_int;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut minLen: i32",
          "mut maxLen: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut i: i32",
          "mut j: i32",
          "mut t: i32",
          "mut alphaSize: i32",
          "mut nGroups: i32",
          "mut nSelectors: i32",
          "mut EOB: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut nextSym: i32",
          "mut nblockMAX: i32",
          "mut nblock: i32",
          "mut es: i32",
          "mut N: i32",
          "mut curr: i32",
          "mut zt: i32",
          "mut zn: i32",
          "mut zvec: i32",
          "mut zj: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32"
        ]
      },
      {
        "chunk_id": 29,
        "span": "decompress.rs:198:5: 290:2 (#0)",
        "pieces": [
          "decompress.rs:198:5: 290:2 (#0)"
        ],
        "num_lines": 100,
        "source": "match (*s).state {\n        10 => {\n            (*s).state = 10 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 5658374378798827547;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v: UInt32 = 0;\n                    v =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v as UChar;\n                    current_block = 5658374378798827547;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x42 as std::os::raw::c_int {\n                        retVal = -(5 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 12259750428863723923; }\n                }\n            }\n        }\n        11 => { current_block = 12259750428863723923; }\n        12 => { current_block = 15146946972525368609; }\n        13 => { current_block = 13504760517129887221; }\n        14 => { current_block = 7948568793456312728; }\n        15 => { current_block = 16703841960874917807; }\n        16 => { current_block = 12231332282017165356; }\n        17 => { current_block = 7286555771988341860; }\n        18 => { current_block = 6656868271313165664; }\n        19 => { current_block = 15902903523132075486; }\n        20 => { current_block = 16204949703499709801; }\n        21 => { current_block = 5505795673017046993; }\n        22 => { current_block = 14563596112884461881; }\n        23 => { current_block = 12051594319698232578; }\n        24 => { current_block = 14315698657705028467; }\n        25 => { current_block = 640681092829779800; }\n        26 => { current_block = 588075840077989673; }\n        27 => { current_block = 34749046854646975; }\n        28 => { current_block = 16487873541482693172; }\n        29 => { current_block = 1422779171932145779; }\n        30 => { current_block = 3906616468301123675; }\n        31 => { current_block = 5769007513321684282; }\n        32 => { current_block = 4874723077730206021; }\n        33 => { current_block = 10945178116989557996; }\n        34 => { current_block = 1736021991379636935; }\n        35 => { current_block = 5008197131544113214; }\n        36 => { current_block = 16722720626876144162; }\n        37 => { current_block = 14744029255125744966; }\n        38 => { current_block = 5374617794059532979; }\n        39 => { current_block = 13999925517074022731; }\n        40 => { current_block = 2629672494974161066; }\n        41 => { current_block = 1050378859040334210; }\n        42 => { current_block = 10200488719709598753; }\n        43 => { current_block = 9864403379770423142; }\n        44 => { current_block = 8489059574810375089; }\n        45 => { current_block = 12998570369541158573; }\n        46 => { current_block = 10541196509243133637; }\n        47 => { current_block = 8760950161942609538; }\n        48 => { current_block = 3131443096645543054; }\n        49 => { current_block = 1975408140333322065; }\n        50 => { current_block = 15818179691129344165; }\n        _ => {\n            if 0 as std::os::raw::c_int as Bool == 0 {\n                BZ2_bz__AssertH__fail(4001 as std::os::raw::c_int);\n            }\n            if 0 as std::os::raw::c_int as Bool == 0 {\n                BZ2_bz__AssertH__fail(4002 as std::os::raw::c_int);\n            }\n            current_block = 15885526978618306830;\n        }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 30,
        "span": "decompress.rs:292:5: 395:6 (#0)",
        "pieces": [
          "decompress.rs:292:5: 395:6 (#0)"
        ],
        "num_lines": 104,
        "source": "match current_block {\n        12259750428863723923 => {\n            (*s).state = 11 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 1658462350791934405;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_0: UInt32 = 0;\n                    v_0 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_0 as UChar;\n                    current_block = 1658462350791934405;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x5a as std::os::raw::c_int {\n                        retVal = -(5 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 15146946972525368609; }\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        15146946972525368609 => {\n            (*s).state = 12 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 16314074004867283505;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_1: UInt32 = 0;\n                    v_1 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_1 as UChar;\n                    current_block = 16314074004867283505;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x68 as std::os::raw::c_int {\n                        retVal = -(5 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 13504760517129887221; }\n                }\n            }\n        }\n        _ => { }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 31,
        "span": "decompress.rs:396:5: 468:2 (#0)",
        "pieces": [
          "decompress.rs:396:5: 468:2 (#0)"
        ],
        "num_lines": 127,
        "source": "match current_block {\n        13504760517129887221 => {\n            (*s).state = 13 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 1915186496383530739;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_2: UInt32 = 0;\n                    v_2 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    (*s).blockSize100k = v_2 as Int32;\n                    current_block = 1915186496383530739;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if (*s).blockSize100k <\n                           0x30 as std::os::raw::c_int + 1 as std::os::raw::c_int ||\n                           (*s).blockSize100k >\n                               0x30 as std::os::raw::c_int + 9 as std::os::raw::c_int {\n                        retVal = -(5 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else {\n                        (*s).blockSize100k -= 0x30 as std::os::raw::c_int;\n                        if (*s).smallDecompress != 0 {\n                            (*s).ll16 =\n                                (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                                                    (((*s).blockSize100k\n                                                                                          *\n                                                                                          100000\n                                                                                              as\n                                                                                              std::os::raw::c_int)\n                                                                                         as\n                                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UInt16>()\n                                                                                                                         as\n                                                                                                                         std::os::raw::c_ulong)\n                                                                                        as\n                                                                                        std::os::raw::c_int,\n                                                                                    1\n                                                                                        as\n                                                                                        std::os::raw::c_int)\n                                    as *mut UInt16;\n                            (*s).ll4 =\n                                (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                                                    ((1\n                                                                                          as\n                                                                                          std::os::raw::c_int\n                                                                                          +\n                                                                                          (*s).blockSize100k\n                                                                                              *\n                                                                                              100000\n                                                                                                  as\n                                                                                                  std::os::raw::c_int\n                                                                                          >>\n                                                                                          1\n                                                                                              as\n                                                                                              std::os::raw::c_int)\n                                                                                         as\n                                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UChar>()\n                                                                                                                         as\n                                                                                                                         std::os::raw::c_ulong)\n                                                                                        as\n                                                                                        std::os::raw::c_int,\n                                                                                    1\n                                                                                        as\n                                                                                        std::os::raw::c_int)\n                                    as *mut UChar;\n                            if (*s).ll16.is_null() || (*s).ll4.is_null() {\n                                retVal = -(3 as std::os::raw::c_int);\n                                current_block = 15885526978618306830;\n                            } else { current_block = 7948568793456312728; }\n                        } else {\n                            (*s).tt =\n                                (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                                                    (((*s).blockSize100k\n                                                                                          *\n                                                                                          100000\n                                                                                              as\n                                                                                              std::os::raw::c_int)\n                                                                                         as\n                                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<Int32>()\n                                                                                                                         as\n                                                                                                                         std::os::raw::c_ulong)\n                                                                                        as\n                                                                                        std::os::raw::c_int,\n                                                                                    1\n                                                                                        as\n                                                                                        std::os::raw::c_int)\n                                    as *mut UInt32;\n                            if (*s).tt.is_null() {\n                                retVal = -(3 as std::os::raw::c_int);\n                                current_block = 15885526978618306830;\n                            } else { current_block = 7948568793456312728; }\n                        }\n                    }\n                }\n            }\n        }\n        _ => { }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 32,
        "span": "decompress.rs:470:5: 523:6 (#0)",
        "pieces": [
          "decompress.rs:470:5: 523:6 (#0)"
        ],
        "num_lines": 54,
        "source": "match current_block {\n        7948568793456312728 => {\n            (*s).state = 14 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 9846950269610550213;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_3: UInt32 = 0;\n                    v_3 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_3 as UChar;\n                    current_block = 9846950269610550213;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int == 0x17 as std::os::raw::c_int {\n                        current_block = 10200488719709598753;\n                    } else if uc as std::os::raw::c_int != 0x31 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 16703841960874917807; }\n                }\n            }\n        }\n        _ => { }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 33,
        "span": "decompress.rs:524:5: 614:2 (#0)",
        "pieces": [
          "decompress.rs:524:5: 614:2 (#0)"
        ],
        "num_lines": 101,
        "source": "match current_block {\n        10200488719709598753 => {\n            (*s).state = 42 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 13262463590990658200;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_32: UInt32 = 0;\n                    v_32 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_32 as UChar;\n                    current_block = 13262463590990658200;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x72 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 9864403379770423142; }\n                }\n            }\n        }\n        16703841960874917807 => {\n            (*s).state = 15 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 3569141194949357899;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_4: UInt32 = 0;\n                    v_4 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_4 as UChar;\n                    current_block = 3569141194949357899;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x41 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 12231332282017165356; }\n                }\n            }\n        }\n        _ => { }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 34,
        "span": "decompress.rs:616:5: 700:2 (#0)",
        "pieces": [
          "decompress.rs:616:5: 700:2 (#0)"
        ],
        "num_lines": 101,
        "source": "match current_block {\n        9864403379770423142 => {\n            (*s).state = 43 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 10756506701594629759;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_33: UInt32 = 0;\n                    v_33 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_33 as UChar;\n                    current_block = 10756506701594629759;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x45 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 8489059574810375089; }\n                }\n            }\n        }\n        12231332282017165356 => {\n            (*s).state = 16 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 16517180880614114163;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_5: UInt32 = 0;\n                    v_5 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_5 as UChar;\n                    current_block = 16517180880614114163;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x59 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 7286555771988341860; }\n                }\n            }\n        }\n        _ => { }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 35,
        "span": "decompress.rs:702:5: 784:2 (#0)",
        "pieces": [
          "decompress.rs:702:5: 784:2 (#0)"
        ],
        "num_lines": 101,
        "source": "match current_block {\n        8489059574810375089 => {\n            (*s).state = 44 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 9819403752380335018;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_34: UInt32 = 0;\n                    v_34 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_34 as UChar;\n                    current_block = 9819403752380335018;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x38 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 12998570369541158573; }\n                }\n            }\n        }\n        7286555771988341860 => {\n            (*s).state = 17 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 2606663910910355487;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_6: UInt32 = 0;\n                    v_6 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_6 as UChar;\n                    current_block = 2606663910910355487;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x26 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 6656868271313165664; }\n                }\n            }\n        }\n        _ => { }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 36,
        "span": "decompress.rs:786:5: 876:2 (#0)",
        "pieces": [
          "decompress.rs:786:5: 876:2 (#0)"
        ],
        "num_lines": 101,
        "source": "match current_block {\n        12998570369541158573 => {\n            (*s).state = 45 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 9454797012561717444;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_35: UInt32 = 0;\n                    v_35 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_35 as UChar;\n                    current_block = 9454797012561717444;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x50 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 10541196509243133637; }\n                }\n            }\n        }\n        6656868271313165664 => {\n            (*s).state = 18 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 8125779086361653720;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_7: UInt32 = 0;\n                    v_7 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_7 as UChar;\n                    current_block = 8125779086361653720;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x53 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 15902903523132075486; }\n                }\n            }\n        }\n        _ => { }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 37,
        "span": "decompress.rs:878:5: 976:2 (#0)",
        "pieces": [
          "decompress.rs:878:5: 976:2 (#0)"
        ],
        "num_lines": 114,
        "source": "match current_block {\n        10541196509243133637 => {\n            (*s).state = 46 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 724777313732190959;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_36: UInt32 = 0;\n                    v_36 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_36 as UChar;\n                    current_block = 724777313732190959;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x90 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else {\n                        (*s).storedCombinedCRC = 0 as std::os::raw::c_int as UInt32;\n                        current_block = 8760950161942609538;\n                    }\n                }\n            }\n        }\n        15902903523132075486 => {\n            (*s).state = 19 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 958128786106592581;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_8: UInt32 = 0;\n                    v_8 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_8 as UChar;\n                    current_block = 958128786106592581;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x59 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else {\n                        (*s).currBlockNo += 1;\n                        if (*s).verbosity >= 2 as std::os::raw::c_int {\n                            fprintf(__stderrp,\n                                    b\"\\n    [%d: huff+mtf \\x00\" as *const u8\n                                        as *const std::os::raw::c_char,\n                                    (*s).currBlockNo);\n                        }\n                        (*s).storedBlockCRC = 0 as std::os::raw::c_int as UInt32;\n                        current_block = 16204949703499709801;\n                    }\n                }\n            }\n        }\n        _ => { }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 38,
        "span": "decompress.rs:978:5: 1052:2 (#0)",
        "pieces": [
          "decompress.rs:978:5: 1052:2 (#0)"
        ],
        "num_lines": 101,
        "source": "match current_block {\n        8760950161942609538 => {\n            (*s).state = 47 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 14486187473704332379;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_37: UInt32 = 0;\n                    v_37 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_37 as UChar;\n                    current_block = 14486187473704332379;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedCombinedCRC =\n                        (*s).storedCombinedCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 3131443096645543054;\n                }\n            }\n        }\n        16204949703499709801 => {\n            (*s).state = 20 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 3790734079518302164;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_9: UInt32 = 0;\n                    v_9 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_9 as UChar;\n                    current_block = 3790734079518302164;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedBlockCRC =\n                        (*s).storedBlockCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 5505795673017046993;\n                }\n            }\n        }\n        _ => { }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 39,
        "span": "decompress.rs:1054:5: 1128:2 (#0)",
        "pieces": [
          "decompress.rs:1054:5: 1128:2 (#0)"
        ],
        "num_lines": 101,
        "source": "match current_block {\n        3131443096645543054 => {\n            (*s).state = 48 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 3659807904093622879;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_38: UInt32 = 0;\n                    v_38 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_38 as UChar;\n                    current_block = 3659807904093622879;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedCombinedCRC =\n                        (*s).storedCombinedCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 1975408140333322065;\n                }\n            }\n        }\n        5505795673017046993 => {\n            (*s).state = 21 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 16711521214030637000;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_10: UInt32 = 0;\n                    v_10 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_10 as UChar;\n                    current_block = 16711521214030637000;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedBlockCRC =\n                        (*s).storedBlockCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 14563596112884461881;\n                }\n            }\n        }\n        _ => { }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 40,
        "span": "decompress.rs:1130:5: 1204:2 (#0)",
        "pieces": [
          "decompress.rs:1130:5: 1204:2 (#0)"
        ],
        "num_lines": 101,
        "source": "match current_block {\n        1975408140333322065 => {\n            (*s).state = 49 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 2394045633138979148;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_39: UInt32 = 0;\n                    v_39 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_39 as UChar;\n                    current_block = 2394045633138979148;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedCombinedCRC =\n                        (*s).storedCombinedCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 15818179691129344165;\n                }\n            }\n        }\n        14563596112884461881 => {\n            (*s).state = 22 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 17870985093275900527;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_11: UInt32 = 0;\n                    v_11 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_11 as UChar;\n                    current_block = 17870985093275900527;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedBlockCRC =\n                        (*s).storedBlockCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 12051594319698232578;\n                }\n            }\n        }\n        _ => { }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 41,
        "span": "decompress.rs:1206:5: 1284:2 (#0)",
        "pieces": [
          "decompress.rs:1206:5: 1284:2 (#0)"
        ],
        "num_lines": 103,
        "source": "match current_block {\n        12051594319698232578 => {\n            (*s).state = 23 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 13734492969709581318;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_12: UInt32 = 0;\n                    v_12 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_12 as UChar;\n                    current_block = 13734492969709581318;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedBlockCRC =\n                        (*s).storedBlockCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 14315698657705028467;\n                }\n            }\n        }\n        15818179691129344165 => {\n            (*s).state = 50 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 1904329045571868869;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_40: UInt32 = 0;\n                    v_40 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_40 as UChar;\n                    current_block = 1904329045571868869;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedCombinedCRC =\n                        (*s).storedCombinedCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    (*s).state = 1 as std::os::raw::c_int;\n                    retVal = 4 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                }\n            }\n        }\n        _ => { }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 42,
        "span": "decompress.rs:1286:5: 1364:2 (#0)",
        "pieces": [
          "decompress.rs:1286:5: 1364:2 (#0)"
        ],
        "num_lines": 101,
        "source": "match current_block {\n        14315698657705028467 => {\n            (*s).state = 24 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 15030729790988239748;\n                    break ;\n                }\n                if (*s).bsLive >= 1 as std::os::raw::c_int {\n                    let mut v_13: UInt32 = 0;\n                    v_13 =\n                        (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 1 as std::os::raw::c_int;\n                    (*s).blockRandomised = v_13 as Bool;\n                    current_block = 15030729790988239748;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).origPtr = 0 as std::os::raw::c_int;\n                    current_block = 640681092829779800;\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        640681092829779800 => {\n            (*s).state = 25 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 8260322496947496197;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_14: UInt32 = 0;\n                    v_14 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_14 as UChar;\n                    current_block = 8260322496947496197;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).origPtr =\n                        (*s).origPtr << 8 as std::os::raw::c_int | uc as Int32;\n                    current_block = 588075840077989673;\n                }\n            }\n        }\n        _ => { }\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut strm: *mut blocksort::bz_stream"
        ]
      },
      {
        "chunk_id": 43,
        "span": "decompress.rs:1366:5: 2806:7 (#0)",
        "pieces": [
          "decompress.rs:1366:5: 1466:4 (#0)",
          "decompress.rs:1972:1: 1972:11 (#0)",
          "decompress.rs:2481:1: 2481:11 (#0)",
          "decompress.rs:2525:1: 2525:11 (#0)",
          "decompress.rs:2642:1: 2642:11 (#0)",
          "decompress.rs:2779:1: 2806:7 (#0)"
        ],
        "num_lines": 147,
        "source": "match current_block {\n        588075840077989673 => {\n            (*s).state = 26 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 5561851013817067674;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_15: UInt32 = 0;\n                    v_15 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_15 as UChar;\n                    current_block = 5561851013817067674;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).origPtr =\n                        (*s).origPtr << 8 as std::os::raw::c_int | uc as Int32;\n                    current_block = 34749046854646975;\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        34749046854646975 => {\n            (*s).state = 27 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 10471999855724930313;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_16: UInt32 = 0;\n                    v_16 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_16 as UChar;\n                    current_block = 10471999855724930313;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).origPtr =\n                        (*s).origPtr << 8 as std::os::raw::c_int | uc as Int32;\n                    if (*s).origPtr < 0 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else if (*s).origPtr >\n                                  10 as std::os::raw::c_int +\n                                      100000 as std::os::raw::c_int *\n                                          (*s).blockSize100k {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else {\n                        /*--- Receive the mapping table ---*/\n                        i = 0 as std::os::raw::c_int;\n                        current_block = 17262312153619709241;\n                    }\n                }\n            }\n        }\n        _ => { }\n    }\n    'c_10532:\n        loop  {\n           <<chunk 23>>           <<chunk 24>>           <<chunk 25>>           <<chunk 26>>           <<chunk 27>>        }\n    (*s).save_j = j;\n    (*s).save_t = t;\n    (*s).save_alphaSize = alphaSize;\n    (*s).save_nGroups = nGroups;\n    (*s).save_nSelectors = nSelectors;\n    (*s).save_EOB = EOB;\n    (*s).save_groupNo = groupNo;\n    (*s).save_groupPos = groupPos;\n    (*s).save_nextSym = nextSym;\n    (*s).save_nblockMAX = nblockMAX;\n    (*s).save_nblock = nblock;\n    (*s).save_es = es;\n    (*s).save_N = N;\n    (*s).save_curr = curr;\n    (*s).save_zt = zt;\n    (*s).save_zn = zn;\n    (*s).save_zvec = zvec;\n    (*s).save_zj = zj;\n    (*s).save_gSel = gSel;\n    (*s).save_gMinlen = gMinlen;\n    (*s).save_gLimit = gLimit;\n    (*s).save_gBase = gBase;\n    (*s).save_gPerm = gPerm;\n    return retVal;",
        "sub_chunks": [
          23,
          24,
          25,
          26,
          27
        ],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut minLen: i32",
          "mut maxLen: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut i: i32",
          "mut j: i32",
          "mut t: i32",
          "mut alphaSize: i32",
          "mut nGroups: i32",
          "mut nSelectors: i32",
          "mut EOB: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut nextSym: i32",
          "mut nblockMAX: i32",
          "mut nblock: i32",
          "mut es: i32",
          "mut N: i32",
          "mut curr: i32",
          "mut zt: i32",
          "mut zn: i32",
          "mut zvec: i32",
          "mut zj: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut uc: u8",
          "mut retVal: i32",
          "mut minLen: i32",
          "mut maxLen: i32",
          "mut strm: *mut blocksort::bz_stream",
          "mut i: i32",
          "mut j: i32",
          "mut t: i32",
          "mut alphaSize: i32",
          "mut nGroups: i32",
          "mut nSelectors: i32",
          "mut EOB: i32",
          "mut groupNo: i32",
          "mut groupPos: i32",
          "mut nextSym: i32",
          "mut nblockMAX: i32",
          "mut nblock: i32",
          "mut es: i32",
          "mut N: i32",
          "mut curr: i32",
          "mut zt: i32",
          "mut zn: i32",
          "mut zvec: i32",
          "mut zj: i32",
          "mut gSel: i32",
          "mut gMinlen: i32",
          "mut gLimit: *mut i32",
          "mut gBase: *mut i32",
          "mut gPerm: *mut i32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:330 ~ c2rust_out[3c70]::bzip2recover::writeError)",
    "span": "bzip2recover.rs:139:1: 150:2 (#0)",
    "pieces": [
      "bzip2recover.rs:139:1: 150:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn writeError() {\n    fprintf(__stderrp,\n            b\"%s: I/O error reading `%s\\', possible reason follows.\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr(),\n            inFileName.as_mut_ptr());\n    perror(progName.as_mut_ptr());\n    fprintf(__stderrp,\n            b\"%s: warning: output file(s) may be incomplete.\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());\n    exit(1 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:399 ~ c2rust_out[3c70]::bzip2recover::bsClose)",
        "span": "bzip2recover.rs:247:13: 247:26 (#0)",
        "source": "writeError();"
      },
      {
        "caller": "DefId(0:399 ~ c2rust_out[3c70]::bzip2recover::bsClose)",
        "span": "bzip2recover.rs:242:52: 242:65 (#0)",
        "source": "writeError();"
      },
      {
        "caller": "DefId(0:397 ~ c2rust_out[3c70]::bzip2recover::bsPutBit)",
        "span": "bzip2recover.rs:201:52: 201:65 (#0)",
        "source": "writeError();"
      },
      {
        "caller": "DefId(0:399 ~ c2rust_out[3c70]::bzip2recover::bsClose)",
        "span": "bzip2recover.rs:239:52: 239:65 (#0)",
        "source": "writeError();"
      }
    ],
    "globals": [
      {
        "span": "bzip2recover.rs:112:1: 112:53 (#0)",
        "source": "pub static mut inFileName: [Char; 2000] = [0; 2000];"
      },
      {
        "span": "bzip2recover.rs:115:1: 115:51 (#0)",
        "source": "pub static mut progName: [Char; 2000] = [0; 2000];"
      }
    ],
    "imports": [
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:440 ~ c2rust_out[3c70]::bzlib::BZ2_bzWrite)",
    "span": "bzlib.rs:1714:1: 1776:2 (#0)",
    "pieces": [
      "bzlib.rs:1714:1: 1776:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 63,
    "source": "pub unsafe extern \"C\" fn BZ2_bzWrite(mut bzerror: *mut std::os::raw::c_int,\n                                     mut b: *mut std::os::raw::c_void,\n                                     mut buf: *mut std::os::raw::c_void,\n                                     mut len: std::os::raw::c_int) {\n    let mut n: Int32 = 0;\n    let mut n2: Int32 = 0;\n    let mut ret: Int32 = 0;\n    let mut bzf: *mut bzFile = b as *mut bzFile;\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    if bzf.is_null() || buf.is_null() || len < 0 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = -(2 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(2 as std::os::raw::c_int) }\n        return\n    }\n    if (*bzf).writing == 0 {\n        if !bzerror.is_null() { *bzerror = -(1 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(1 as std::os::raw::c_int) }\n        return\n    }\n    if ferror((*bzf).handle) != 0 {\n        if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n        return\n    }\n    if len == 0 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n        if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n        return\n    }\n    (*bzf).strm.avail_in = len as std::os::raw::c_uint;\n    (*bzf).strm.next_in = buf as *mut std::os::raw::c_char;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        (*bzf).strm.avail_out = 5000 as std::os::raw::c_int as std::os::raw::c_uint;\n        (*bzf).strm.next_out = (*bzf).buf.as_mut_ptr();\n        ret = BZ2_bzCompress(&mut (*bzf).strm, 0 as std::os::raw::c_int);\n        if ret != 1 as std::os::raw::c_int {\n            if !bzerror.is_null() { *bzerror = ret }\n            if !bzf.is_null() { (*bzf).lastErr = ret }\n            return\n        }\n        if (*bzf).strm.avail_out < 5000 as std::os::raw::c_int as std::os::raw::c_uint {\n            n =\n                (5000 as std::os::raw::c_int as\n                     std::os::raw::c_uint).wrapping_sub((*bzf).strm.avail_out) as\n                    Int32;\n            n2 =\n                fwrite((*bzf).buf.as_mut_ptr() as *mut std::os::raw::c_void,\n                       ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong,\n                       n as std::os::raw::c_ulong, (*bzf).handle) as Int32;\n            if n != n2 || ferror((*bzf).handle) != 0 {\n                if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n                if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n                return\n            }\n        }\n        if (*bzf).strm.avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n            if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n            return\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:544 ~ c2rust_out[3c70]::bzlib::BZ2_bzwrite)",
        "span": "bzlib.rs:2334:9: 2334:113 (#0)",
        "source": "BZ2_bzWrite(&mut bzerr, b, buf.as_ptr() as *mut std::os::raw::c_void, buf.len() as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:557:25: 559:44 (#0)",
        "source": "BZ2_bzWrite(&mut bzerr, bzf,\n                                    ibuf.as_mut_ptr() as *mut std::os::raw::c_void,\n                                    nIbuf);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:459 ~ c2rust_out[3c70]::bzlib::BZ2_bzwrite)",
    "span": "bzlib.rs:2331:1: 2341:2 (#0)",
    "pieces": [
      "bzlib.rs:2331:1: 2341:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn BZ2_bzwrite(mut b: *mut std::os::raw::c_void,\n                                     mut buf: *mut std::os::raw::c_void,\n                                     mut len: std::os::raw::c_int) -> std::os::raw::c_int {\n    let mut bzerr: std::os::raw::c_int = 0;\n    BZ2_bzWrite(&mut bzerr, b, buf, len);\n    if bzerr == 0 as std::os::raw::c_int {\n        return len\n    } else { return -(1 as std::os::raw::c_int) };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:498 ~ c2rust_out[3c70]::compress::bsFinishWrite)",
    "span": "compress.rs:99:1: 107:2 (#0)",
    "pieces": [
      "compress.rs:99:1: 107:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn bsFinishWrite(mut s: *mut EState) {\n    while (*s).bsLive > 0 as std::os::raw::c_int {\n        *(*s).zbits.offset((*s).numZ as isize) =\n            ((*s).bsBuff >> 24 as std::os::raw::c_int) as UChar;\n        (*s).numZ += 1;\n        (*s).bsBuff <<= 8 as std::os::raw::c_int;\n        (*s).bsLive -= 8 as std::os::raw::c_int\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1358:9: 1358:32 (#0)",
        "source": "bsFinishWrite(&mut *s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:41:1: 41:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:43:1: 43:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:42:1: 42:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:40:1: 40:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "compress.rs:39:1: 39:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:252 ~ c2rust_out[3c70]::bzip2::notAStandardFile)",
    "span": "bzip2.rs:1706:1: 1734:2 (#0)",
    "pieces": [
      "bzip2.rs:1706:1: 1734:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 29,
    "source": "unsafe extern \"C\" fn notAStandardFile(mut name: *mut Char) -> Bool {\n    let mut i: IntNative = 0;\n    let mut statBuf: stat =\n        stat{st_dev: 0,\n             st_mode: 0,\n             st_nlink: 0,\n             st_ino: 0,\n             st_uid: 0,\n             st_gid: 0,\n             st_rdev: 0,\n             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_size: 0,\n             st_blocks: 0,\n             st_blksize: 0,\n             st_flags: 0,\n             st_gen: 0,\n             st_lspare: 0,\n             st_qspare: [0; 2],};\n    i = lstat(name, &mut statBuf);\n    if i != 0 as std::os::raw::c_int { return 1 as std::os::raw::c_int as Bool }\n    if statBuf.st_mode as std::os::raw::c_int & 0o170000 as std::os::raw::c_int ==\n           0o100000 as std::os::raw::c_int {\n        return 0 as std::os::raw::c_int as Bool\n    }\n    return 1 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:502 ~ c2rust_out[3c70]::compress::makeMaps_e)",
    "span": "compress.rs:149:1: 158:2 (#0)",
    "pieces": [
      "compress.rs:149:1: 158:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn makeMaps_e(mut s: *mut EState) {\n    let mut i: Int32 = 0;\n    (*s).nInUse = 0 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n    while i < 256 as std::os::raw::c_int {\n        if (*s).inUse[i as usize] != 0 {\n            (*s).unseqToSeq[i as usize] = (*s).nInUse as UChar;\n            (*s).nInUse += 1\n        }\n        i += 1\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:591 ~ c2rust_out[3c70]::compress::generateMTFValues)",
        "span": "compress.rs:193:5: 193:19 (#0)",
        "source": "makeMaps_e(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "compress.rs:40:1: 40:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:41:1: 41:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:42:1: 42:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:43:1: 43:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:39:1: 39:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:503 ~ c2rust_out[3c70]::compress::generateMTFValues)",
    "span": "compress.rs:161:1: 284:2 (#0)",
    "pieces": [
      "compress.rs:161:1: 284:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 124,
    "source": "unsafe extern \"C\" fn generateMTFValues(mut s: *mut EState) {\n    let mut yy: [UChar; 256] = [0; 256];\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut zPend: Int32 = 0;\n    let mut wr: Int32 = 0;\n    let mut EOB: Int32 = 0;\n    /* \n      After sorting (eg, here),\n         s->arr1 [ 0 .. s->nblock-1 ] holds sorted order,\n         and\n         ((UChar*)s->arr2) [ 0 .. s->nblock-1 ] \n         holds the original block data.\n\n      The first thing to do is generate the MTF values,\n      and put them in\n         ((UInt16*)s->arr1) [ 0 .. s->nblock-1 ].\n      Because there are strictly fewer or equal MTF values\n      than block values, ptr values in this area are overwritten\n      with MTF values only when they are no longer needed.\n\n      The final compressed bitstream is generated into the\n      area starting at\n         (UChar*) (&((UChar*)s->arr2)[s->nblock])\n\n      These storage aliases are set up in bzCompressInit(),\n      except for the last one, which is arranged in \n      compressBlock().\n   */\n    let mut ptr: *mut UInt32 = (*s).ptr;\n    let mut block: *mut UChar = (*s).block;\n    let mut mtfv: *mut UInt16 = (*s).mtfv;\n    makeMaps_e(s);\n    EOB = (*s).nInUse + 1 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n    while i <= EOB { (*s).mtfFreq[i as usize] = 0 as std::os::raw::c_int; i += 1 }\n    wr = 0 as std::os::raw::c_int;\n    zPend = 0 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n    while i < (*s).nInUse { yy[i as usize] = i as UChar; i += 1 }\n    i = 0 as std::os::raw::c_int;\n    while i < (*s).nblock {\n        let mut ll_i: UChar = 0;\n        j =\n            (*ptr.offset(i as\n                             isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                      std::os::raw::c_uint) as Int32;\n        if j < 0 as std::os::raw::c_int { j += (*s).nblock }\n        ll_i = (*s).unseqToSeq[*block.offset(j as isize) as usize];\n        if yy[0 as std::os::raw::c_int as usize] as std::os::raw::c_int == ll_i as std::os::raw::c_int\n           {\n            zPend += 1\n        } else {\n            if zPend > 0 as std::os::raw::c_int {\n                zPend -= 1;\n                while 1 as std::os::raw::c_int as Bool != 0 {\n                    if zPend & 1 as std::os::raw::c_int != 0 {\n                        *mtfv.offset(wr as isize) =\n                            1 as std::os::raw::c_int as UInt16;\n                        wr += 1;\n                        (*s).mtfFreq[1 as std::os::raw::c_int as usize] += 1\n                    } else {\n                        *mtfv.offset(wr as isize) =\n                            0 as std::os::raw::c_int as UInt16;\n                        wr += 1;\n                        (*s).mtfFreq[0 as std::os::raw::c_int as usize] += 1\n                    }\n                    if zPend < 2 as std::os::raw::c_int { break ; }\n                    zPend = (zPend - 2 as std::os::raw::c_int) / 2 as std::os::raw::c_int\n                }\n                zPend = 0 as std::os::raw::c_int\n            }\n            let mut rtmp: UChar = 0;\n            let mut ryy_j: *mut UChar = 0 as *mut UChar;\n            let mut rll_i: UChar = 0;\n            rtmp = yy[1 as std::os::raw::c_int as usize];\n            yy[1 as std::os::raw::c_int as usize] = yy[0 as std::os::raw::c_int as usize];\n            ryy_j =\n                &mut *yy.as_mut_ptr().offset(1 as std::os::raw::c_int as isize) as\n                    *mut UChar;\n            rll_i = ll_i;\n            while rll_i as std::os::raw::c_int != rtmp as std::os::raw::c_int {\n                let mut rtmp2: UChar = 0;\n                ryy_j = ryy_j.offset(1);\n                rtmp2 = rtmp;\n                rtmp = *ryy_j;\n                *ryy_j = rtmp2\n            }\n            yy[0 as std::os::raw::c_int as usize] = rtmp;\n            j =\n                ryy_j.offset_from(&mut *yy.as_mut_ptr().offset(0 as\n                                                                            std::os::raw::c_int\n                                                                            as\n                                                                            isize)\n                                               as *mut UChar) as std::os::raw::c_long\n                    as Int32;\n            *mtfv.offset(wr as isize) = (j + 1 as std::os::raw::c_int) as UInt16;\n            wr += 1;\n            (*s).mtfFreq[(j + 1 as std::os::raw::c_int) as usize] += 1\n        }\n        i += 1\n    }\n    if zPend > 0 as std::os::raw::c_int {\n        zPend -= 1;\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            if zPend & 1 as std::os::raw::c_int != 0 {\n                *mtfv.offset(wr as isize) = 1 as std::os::raw::c_int as UInt16;\n                wr += 1;\n                (*s).mtfFreq[1 as std::os::raw::c_int as usize] += 1\n            } else {\n                *mtfv.offset(wr as isize) = 0 as std::os::raw::c_int as UInt16;\n                wr += 1;\n                (*s).mtfFreq[0 as std::os::raw::c_int as usize] += 1\n            }\n            if zPend < 2 as std::os::raw::c_int { break ; }\n            zPend = (zPend - 2 as std::os::raw::c_int) / 2 as std::os::raw::c_int\n        }\n        zPend = 0 as std::os::raw::c_int\n    }\n    *mtfv.offset(wr as isize) = EOB as UInt16;\n    wr += 1;\n    (*s).mtfFreq[EOB as usize] += 1;\n    (*s).nMTF = wr;\n}",
    "calls": [
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1335:9: 1335:30 (#0)",
        "source": "generateMTFValues(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:42:1: 42:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:41:1: 41:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "compress.rs:39:1: 39:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:40:1: 40:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:43:1: 43:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:418 ~ c2rust_out[3c70]::bzlib::bz_config_ok)",
    "span": "bzlib.rs:273:2: 284:2 (#0)",
    "pieces": [
      "bzlib.rs:273:2: 284:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "extern \"C\" fn bz_config_ok() -> std::os::raw::c_int {\n    if ::std::mem::size_of::<std::os::raw::c_int>() as std::os::raw::c_ulong !=\n           4 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int\n    }\n    if ::std::mem::size_of::<std::os::raw::c_short>() as std::os::raw::c_ulong !=\n           2 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int\n    }\n    if ::std::mem::size_of::<std::os::raw::c_char>() as std::os::raw::c_ulong !=\n           1 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int\n    }\n    return 1 as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:497 ~ c2rust_out[3c70]::compress::BZ2_bsInitWrite)",
    "span": "compress.rs:93:1: 96:2 (#0)",
    "pieces": [
      "compress.rs:93:1: 96:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn BZ2_bsInitWrite(mut s: *mut EState) {\n    (*s).bsLive = 0 as std::os::raw::c_int;\n    (*s).bsBuff = 0 as std::os::raw::c_int as UInt32;\n}",
    "calls": [
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1299:9: 1299:34 (#0)",
        "source": "BZ2_bsInitWrite(&mut *s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:39:1: 39:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "compress.rs:41:1: 41:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:42:1: 42:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:43:1: 43:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:40:1: 40:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:215 ~ c2rust_out[3c70]::bzip2::myfeof)",
    "span": "bzip2.rs:507:1: 512:2 (#0)",
    "pieces": [
      "bzip2.rs:507:1: 512:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn myfeof(mut f: *mut FILE) -> Bool {\n    let mut c: Int32 = fgetc(f);\n    if c == -(1 as std::os::raw::c_int) { return 1 as std::os::raw::c_int as Bool }\n    ungetc(c, f);\n    return 0 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:415 ~ c2rust_out[3c70]::bzlib::__isctype)",
    "span": "bzlib.rs:207:1: 217:2 (#0)",
    "pieces": [
      "bzlib.rs:207:1: 217:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "unsafe extern \"C\" fn __isctype(mut _c: __darwin_ct_rune_t,\n                               mut _f: std::os::raw::c_ulong) -> __darwin_ct_rune_t {\n    return if _c < 0 as std::os::raw::c_int ||\n                  _c >= (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int {\n               0 as std::os::raw::c_int\n           } else {\n               (_DefaultRuneLocale.__runetype[_c as usize] as std::os::raw::c_ulong &\n                    _f != 0) as std::os::raw::c_int\n           };\n}",
    "calls": [
      {
        "caller": "DefId(0:500 ~ c2rust_out[3c70]::bzlib::isdigit)",
        "span": "bzlib.rs:222:31: 224:2 (#0)",
        "source": "{\n    __isctype(c, 0x400)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:416 ~ c2rust_out[3c70]::bzlib::isdigit)",
    "span": "bzlib.rs:222:1: 224:2 (#0)",
    "pieces": [
      "bzlib.rs:222:1: 224:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn isdigit(mut _c: std::os::raw::c_int) -> std::os::raw::c_int {\n    return __isctype(_c, 0x400 as std::os::raw::c_long as std::os::raw::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:506 ~ c2rust_out[3c70]::compress::sendMTFValues)",
    "span": "compress.rs:285:1: 1274:2 (#0)",
    "pieces": [
      "compress.rs:285:1: 286:4 (#0)",
      "compress.rs:935:1: 935:4 (#0)",
      "compress.rs:1274:1: 1274:2 (#0)"
    ],
    "sub_chunks": [
      18,
      19
    ],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn sendMTFValues(mut s: *mut EState) {\n   <<chunk 18>>   <<chunk 19>>}",
    "calls": [
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1336:9: 1336:26 (#0)",
        "source": "sendMTFValues(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:41:1: 41:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:39:1: 39:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:43:1: 43:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "compress.rs:42:1: 42:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:40:1: 40:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "compress.rs:452:17: 599:78 (#0)",
        "pieces": [
          "compress.rs:452:17: 599:78 (#0)"
        ],
        "num_lines": 148,
        "source": "let mut cost01: UInt32 = 0;\n                let mut cost23: UInt32 = 0;\n                let mut cost45: UInt32 = 0;\n                let mut icv: UInt16 = 0;\n                cost45 = 0 as std::os::raw::c_int as UInt32;\n                cost23 = cost45;\n                cost01 = cost23;\n                icv = *mtfv.offset((gs + 0 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 1 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 2 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 3 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 4 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 5 as std::os::raw::c_int) as isize);",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]"
        ]
      },
      {
        "chunk_id": 1,
        "span": "compress.rs:600:17: 611:2 (#0)",
        "pieces": [
          "compress.rs:600:17: 611:2 (#0)"
        ],
        "num_lines": 149,
        "source": "cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 6 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 7 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 8 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 9 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 10 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut i: i32",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut i: i32",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "mtfv_length: usize",
          "mtfv_slice: &[u16]",
          "mut icv_index: i32"
        ]
      },
      {
        "chunk_id": 2,
        "span": "compress.rs:613:17: 634:57 (#0)",
        "pieces": [
          "compress.rs:613:17: 634:57 (#0)"
        ],
        "num_lines": 149,
        "source": "cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 11 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 12 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 13 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 14 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 15 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]",
          "s: &blocksort::EState",
          "mut cost45: u32"
        ]
      },
      {
        "chunk_id": 3,
        "span": "compress.rs:636:17: 665:51 (#0)",
        "pieces": [
          "compress.rs:636:17: 665:51 (#0)"
        ],
        "num_lines": 150,
        "source": "cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 16 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 17 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 18 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 19 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 20 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 21 as std::os::raw::c_int) as isize);",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]",
          "s: &blocksort::EState",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]"
        ]
      },
      {
        "chunk_id": 4,
        "span": "compress.rs:667:17: 695:57 (#0)",
        "pieces": [
          "compress.rs:667:17: 695:57 (#0)"
        ],
        "num_lines": 149,
        "source": "cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 22 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 23 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 24 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 25 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 26 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "mut icv_index: i32",
          "len_pack: &[[u32; 4]; 258]",
          "s: &blocksort::EState",
          "mut cost45: u32",
          "mut icv: u16"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "mut icv_index: i32",
          "len_pack: &[[u32; 4]; 258]",
          "s: &blocksort::EState",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "mut icv_index: [closure@compress.rs:668:21: 668:33]",
          "len_pack: &[[u32; 4]; 258]"
        ]
      },
      {
        "chunk_id": 5,
        "span": "compress.rs:697:17: 706:2 (#0)",
        "pieces": [
          "compress.rs:697:17: 706:2 (#0)"
        ],
        "num_lines": 149,
        "source": "cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 27 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 28 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 29 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 30 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 31 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "mut icv_index: i32",
          "len_pack: &[[u32; 4]; 258]",
          "s: &blocksort::EState",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "mut icv_index: [closure@compress.rs:668:21: 668:33]"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "mut icv_index: i32",
          "len_pack: &[[u32; 4]; 258]",
          "s: &blocksort::EState",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "mut icv_index: [closure@compress.rs:668:21: 668:33]",
          "len_pack: &[[u32; 4]; 258]"
        ]
      },
      {
        "chunk_id": 6,
        "span": "compress.rs:708:17: 734:59 (#0)",
        "pieces": [
          "compress.rs:708:17: 734:59 (#0)"
        ],
        "num_lines": 150,
        "source": "cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 32 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 33 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 34 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 35 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 36 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 37 as std::os::raw::c_int) as isize);",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]",
          "s: &blocksort::EState",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]",
          "mut cost45: u32"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]",
          "s: &blocksort::EState",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]",
          "mut cost45: u32",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16"
        ]
      },
      {
        "chunk_id": 7,
        "span": "compress.rs:736:17: 761:59 (#0)",
        "pieces": [
          "compress.rs:736:17: 761:59 (#0)"
        ],
        "num_lines": 149,
        "source": "cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 38 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 39 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 40 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 41 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 42 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]",
          "s: &blocksort::EState",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]",
          "mut cost45: u32",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]",
          "s: &blocksort::EState",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]",
          "mut cost45: u32",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut cost23: u32"
        ]
      },
      {
        "chunk_id": 8,
        "span": "compress.rs:763:17: 793:59 (#0)",
        "pieces": [
          "compress.rs:763:17: 793:59 (#0)"
        ],
        "num_lines": 149,
        "source": "cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 43 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 44 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 45 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 46 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 47 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "mut icv_index: i32",
          "len_pack: &[[u32; 4]; 258]",
          "s: &blocksort::EState",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "mut icv_index: [closure@compress.rs:668:21: 668:33]",
          "len_pack: &[[u32; 4]; 258]",
          "mut cost45: u32",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "mut icv_index: i32",
          "len_pack: &[[u32; 4]; 258]",
          "s: &blocksort::EState",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "mut icv_index: [closure@compress.rs:668:21: 668:33]",
          "len_pack: &[[u32; 4]; 258]",
          "mut cost45: u32",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut cost23: u32",
          "mut cost45: u32",
          "icv_index: usize",
          "mut icv: u16",
          "icv_index: usize",
          "icv_index: usize",
          "icv_index: usize",
          "icv_index: usize",
          "mut cost45: u32"
        ]
      },
      {
        "chunk_id": 9,
        "span": "compress.rs:795:17: 810:33 (#0)",
        "pieces": [
          "compress.rs:795:17: 810:33 (#0)"
        ],
        "num_lines": 80,
        "source": "cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 48 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 49 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost[0 as std::os::raw::c_int as usize] =\n                    (cost01 & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as\n                        UInt16;\n                cost[1 as std::os::raw::c_int as usize] =\n                    (cost01 >> 16 as std::os::raw::c_int) as UInt16;\n                cost[2 as std::os::raw::c_int as usize] =\n                    (cost23 & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as\n                        UInt16;\n                cost[3 as std::os::raw::c_int as usize] =\n                    (cost23 >> 16 as std::os::raw::c_int) as UInt16;\n                cost[4 as std::os::raw::c_int as usize] =\n                    (cost45 & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as\n                        UInt16;\n                cost[5 as std::os::raw::c_int as usize] =\n                    (cost45 >> 16 as std::os::raw::c_int) as UInt16",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut cost: [u16; 6]",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mut cost01: u32",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]",
          "s: &blocksort::EState",
          "mut cost45: u32",
          "mut icv: u16",
          "len_pack: &[[u32; 4]; 258]",
          "len_pack: &[[u32; 4]; 258]",
          "mut cost45: u32",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut icv: u16",
          "mut cost23: u32",
          "mut cost45: u32",
          "mut icv: u16"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut cost: [u16; 6]",
          "mut mtfv: *mut u16",
          "mut gs: i32"
        ]
      },
      {
        "chunk_id": 10,
        "span": "compress.rs:814:17: 821:2 (#0)",
        "pieces": [
          "compress.rs:814:17: 821:2 (#0)"
        ],
        "num_lines": 13,
        "source": "i = gs;\n                while i <= ge {\n                    let mut icv_0: UInt16 = *mtfv.offset(i as isize);\n                    t = 0 as std::os::raw::c_int;\n                    while t < nGroups {\n                        cost[t as usize] =\n                            (cost[t as usize] as std::os::raw::c_int +\n                                 (*s).len[t as usize][icv_0 as usize] as\n                                     std::os::raw::c_int) as UInt16;\n                        t += 1\n                    }\n                    i += 1\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut t: i32",
          "mut i: i32",
          "mut gs: i32",
          "mut ge: i32",
          "mut nGroups: i32",
          "mut cost: [u16; 6]",
          "mut mtfv: *mut u16",
          "mut t: i32",
          "mut t: i32",
          "mut gs: i32"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut t: i32",
          "mut i: i32",
          "mut gs: i32",
          "mut ge: i32",
          "mut nGroups: i32",
          "mut cost: [u16; 6]",
          "mut mtfv: *mut u16",
          "mut t: i32",
          "mut t: i32",
          "mut gs: i32",
          "mut i: i32"
        ]
      },
      {
        "chunk_id": 11,
        "span": "compress.rs:848:17: 853:2 (#0)",
        "pieces": [
          "compress.rs:848:17: 853:2 (#0)"
        ],
        "num_lines": 150,
        "source": "(*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 0 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 1 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 2 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 3 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 4 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 5 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 6 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 7 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 8 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 9 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 10 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 11 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 12 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 13 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 14 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 15 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 16 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 17 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 18 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 19 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 20 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 21 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 22 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 23 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 24 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 25 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 26 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 27 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 28 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 29 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 30 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 31 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 32 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 33 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 34 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 35 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 36 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 37 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 38 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 39 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 40 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 41 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 42 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 43 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 44 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 45 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 46 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 47 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 48 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 49 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut i: i32",
          "mut gs: i32",
          "mut bt: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut i: i32",
          "mut gs: i32",
          "mut bt: i32",
          "mut mtfv: *mut u16",
          "mut gs: i32",
          "mtfv_slice: &[u16]",
          "i: i32",
          "index: i32",
          "value: u16"
        ]
      },
      {
        "chunk_id": 12,
        "span": "compress.rs:437:5: 864:47 (#0)",
        "pieces": [
          "compress.rs:437:5: 452:16 (#0)",
          "compress.rs:600:1: 600:16 (#0)",
          "compress.rs:613:1: 613:16 (#0)",
          "compress.rs:636:1: 636:16 (#0)",
          "compress.rs:667:1: 667:16 (#0)",
          "compress.rs:697:1: 697:16 (#0)",
          "compress.rs:708:1: 708:16 (#0)",
          "compress.rs:736:1: 736:16 (#0)",
          "compress.rs:763:1: 763:16 (#0)",
          "compress.rs:795:1: 795:16 (#0)",
          "compress.rs:812:1: 814:16 (#0)",
          "compress.rs:823:1: 848:16 (#0)",
          "compress.rs:855:1: 864:47 (#0)"
        ],
        "num_lines": 64,
        "source": "if gs >= (*s).nMTF { break ; }\n            ge = gs + 50 as std::os::raw::c_int - 1 as std::os::raw::c_int;\n            if ge >= (*s).nMTF { ge = (*s).nMTF - 1 as std::os::raw::c_int }\n            /*-- \n            Calculate the cost of this group as coded\n            by each of the coding tables.\n         --*/\n            t = 0 as std::os::raw::c_int;\n            while t < nGroups {\n                cost[t as usize] = 0 as std::os::raw::c_int as UInt16;\n                t += 1\n            }\n            if nGroups == 6 as std::os::raw::c_int &&\n                   50 as std::os::raw::c_int == ge - gs + 1 as std::os::raw::c_int {\n                /*--- fast track the common case ---*/\n               <<chunk 0>>               <<chunk 1>>               <<chunk 2>>               <<chunk 3>>               <<chunk 4>>               <<chunk 5>>               <<chunk 6>>               <<chunk 7>>               <<chunk 8>>               <<chunk 9>>            } else {\n                /*--- slow version which correctly handles all situations ---*/\n               <<chunk 10>>            }\n            /*-- \n            Find the coding table which is best for this group,\n            and record its identity in the selector table.\n         --*/\n            bc = 999999999 as std::os::raw::c_int;\n            bt = -(1 as std::os::raw::c_int);\n            t = 0 as std::os::raw::c_int;\n            while t < nGroups {\n                if (cost[t as usize] as std::os::raw::c_int) < bc {\n                    bc = cost[t as usize] as Int32;\n                    bt = t\n                }\n                t += 1\n            }\n            totc += bc;\n            fave[bt as usize] += 1;\n            (*s).selector[nSelectors as usize] = bt as UChar;\n            nSelectors += 1;\n            /*-- \n            Increment the symbol frequencies for the selected table.\n          --*/\n            if nGroups == 6 as std::os::raw::c_int &&\n                   50 as std::os::raw::c_int == ge - gs + 1 as std::os::raw::c_int {\n                /*--- fast track the common case ---*/\n               <<chunk 11>>            } else {\n                /*--- slow version which correctly handles all situations ---*/\n                i = gs;\n                while i <= ge {\n                    (*s).rfreq[bt as usize][*mtfv.offset(i as isize) as usize]\n                        += 1;\n                    i += 1\n                }\n            }\n            gs = ge + 1 as std::os::raw::c_int",
        "sub_chunks": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut t: i32",
          "mut i: i32",
          "mut gs: i32",
          "mut ge: i32",
          "mut totc: i32",
          "mut bt: i32",
          "mut bc: i32",
          "mut nSelectors: i32",
          "mut nGroups: i32",
          "mut cost: [u16; 6]",
          "mut fave: [i32; 6]",
          "mut mtfv: *mut u16",
          "mut t: i32",
          "mut t: i32",
          "mut nSelectors: i32",
          "mut totc: i32",
          "mut gs: i32"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut t: i32",
          "mut i: i32",
          "mut gs: i32",
          "mut ge: i32",
          "mut totc: i32",
          "mut bt: i32",
          "mut bc: i32",
          "mut nSelectors: i32",
          "mut nGroups: i32",
          "mut cost: [u16; 6]",
          "mut fave: [i32; 6]",
          "mut mtfv: *mut u16",
          "mut t: i32",
          "mut t: i32",
          "mut nSelectors: i32",
          "mut totc: i32",
          "mut gs: i32"
        ]
      },
      {
        "chunk_id": 13,
        "span": "compress.rs:393:9: 899:11 (#0)",
        "pieces": [
          "compress.rs:393:9: 437:4 (#0)",
          "compress.rs:865:1: 899:11 (#0)"
        ],
        "num_lines": 80,
        "source": "t = 0 as std::os::raw::c_int;\n        while t < nGroups { fave[t as usize] = 0 as std::os::raw::c_int; t += 1 }\n        t = 0 as std::os::raw::c_int;\n        while t < nGroups {\n            v = 0 as std::os::raw::c_int;\n            while v < alphaSize {\n                (*s).rfreq[t as usize][v as usize] = 0 as std::os::raw::c_int;\n                v += 1\n            }\n            t += 1\n        }\n        /*---\n        Set up an auxiliary length table which is used to fast-track\n\tthe common case (nGroups == 6). \n      ---*/\n        if nGroups == 6 as std::os::raw::c_int {\n            v = 0 as std::os::raw::c_int;\n            while v < alphaSize {\n                (*s).len_pack[v as usize][0 as std::os::raw::c_int as usize] =\n                    (((*s).len[1 as std::os::raw::c_int as usize][v as usize] as\n                          std::os::raw::c_int) << 16 as std::os::raw::c_int |\n                         (*s).len[0 as std::os::raw::c_int as usize][v as usize] as\n                             std::os::raw::c_int) as UInt32;\n                (*s).len_pack[v as usize][1 as std::os::raw::c_int as usize] =\n                    (((*s).len[3 as std::os::raw::c_int as usize][v as usize] as\n                          std::os::raw::c_int) << 16 as std::os::raw::c_int |\n                         (*s).len[2 as std::os::raw::c_int as usize][v as usize] as\n                             std::os::raw::c_int) as UInt32;\n                (*s).len_pack[v as usize][2 as std::os::raw::c_int as usize] =\n                    (((*s).len[5 as std::os::raw::c_int as usize][v as usize] as\n                          std::os::raw::c_int) << 16 as std::os::raw::c_int |\n                         (*s).len[4 as std::os::raw::c_int as usize][v as usize] as\n                             std::os::raw::c_int) as UInt32;\n                v += 1\n            }\n        }\n        nSelectors = 0 as std::os::raw::c_int;\n        totc = 0 as std::os::raw::c_int;\n        gs = 0 as std::os::raw::c_int;\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /*--- Set group start & end marks. --*/\n           <<chunk 12>>        }\n        if (*s).verbosity >= 3 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"      pass %d: size is %d, grp uses are \\x00\" as\n                        *const u8 as *const std::os::raw::c_char,\n                    iter + 1 as std::os::raw::c_int, totc / 8 as std::os::raw::c_int);\n            t = 0 as std::os::raw::c_int;\n            while t < nGroups {\n                fprintf(__stderrp,\n                        b\"%d \\x00\" as *const u8 as *const std::os::raw::c_char,\n                        fave[t as usize]);\n                t += 1\n            }\n            fprintf(__stderrp, b\"\\n\\x00\" as *const u8 as *const std::os::raw::c_char);\n        }\n        /*--\n        Recompute the tables based on the accumulated frequencies.\n      --*/\n      /* maxLen was changed from 20 to 17 in bzip2-1.0.3.  See \n         comment in huffman.c for details. */\n        t = 0 as std::os::raw::c_int;\n        while t < nGroups {\n            BZ2_hbMakeCodeLengths(&mut *(*(*s).len.as_mut_ptr().offset(t as\n                                                                           isize)).as_mut_ptr().offset(0\n                                                                                                           as\n                                                                                                           std::os::raw::c_int\n                                                                                                           as\n                                                                                                           isize),\n                                  &mut *(*(*s).rfreq.as_mut_ptr().offset(t as\n                                                                             isize)).as_mut_ptr().offset(0\n                                                                                                             as\n                                                                                                             std::os::raw::c_int\n                                                                                                             as\n                                                                                                             isize),\n                                  alphaSize, 17 as std::os::raw::c_int);\n            t += 1\n        }\n        iter += 1",
        "sub_chunks": [
          12
        ],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut v: i32",
          "mut t: i32",
          "mut i: i32",
          "mut gs: i32",
          "mut ge: i32",
          "mut totc: i32",
          "mut bt: i32",
          "mut bc: i32",
          "mut iter: i32",
          "mut nSelectors: i32",
          "mut alphaSize: i32",
          "mut maxLen: i32",
          "mut nGroups: i32",
          "mut cost: [u16; 6]",
          "mut fave: [i32; 6]",
          "mut mtfv: *mut u16"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut v: i32",
          "mut t: i32",
          "mut i: i32",
          "mut gs: i32",
          "mut ge: i32",
          "mut totc: i32",
          "mut bt: i32",
          "mut bc: i32",
          "mut iter: i32",
          "mut nSelectors: i32",
          "mut alphaSize: i32",
          "mut maxLen: i32",
          "mut nGroups: i32",
          "mut cost: [u16; 6]",
          "mut fave: [i32; 6]",
          "mut mtfv: *mut u16"
        ]
      },
      {
        "chunk_id": 14,
        "span": "compress.rs:1066:5: 1215:78 (#0)",
        "pieces": [
          "compress.rs:1066:5: 1215:78 (#0)"
        ],
        "num_lines": 150,
        "source": "let mut mtfv_i: UInt16 = 0;\n            let mut s_len_sel_selCtr: *mut UChar =\n                &mut *(*(*s).len.as_mut_ptr().offset(*(*s).selector.as_mut_ptr().offset(selCtr\n                                                                                            as\n                                                                                            isize)\n                                                         as\n                                                         isize)).as_mut_ptr().offset(0\n                                                                                         as\n                                                                                         std::os::raw::c_int\n                                                                                         as\n                                                                                         isize)\n                    as *mut UChar;\n            let mut s_code_sel_selCtr: *mut Int32 =\n                &mut *(*(*s).code.as_mut_ptr().offset(*(*s).selector.as_mut_ptr().offset(selCtr\n                                                                                             as\n                                                                                             isize)\n                                                          as\n                                                          isize)).as_mut_ptr().offset(0\n                                                                                          as\n                                                                                          std::os::raw::c_int\n                                                                                          as\n                                                                                          isize)\n                    as *mut Int32;\n            mtfv_i = *mtfv.offset((gs + 0 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 1 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 2 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 3 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 4 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 5 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 6 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 7 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 8 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 9 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 10 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 11 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 12 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 13 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 14 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 15 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 16 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 17 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 18 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 19 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 20 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 21 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 22 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 23 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 24 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 25 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 26 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 27 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 28 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 29 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 30 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 31 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 32 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 33 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 34 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 35 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 36 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 37 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 38 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 39 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 40 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 41 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 42 as std::os::raw::c_int) as isize);",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut selCtr: i32",
          "mut mtfv: *mut u16"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut selCtr: i32",
          "mut mtfv: *mut u16",
          "mut mtfv_i: u16",
          "mut s_len_sel_selCtr: *mut u8",
          "mut s_code_sel_selCtr: *mut i32"
        ]
      },
      {
        "chunk_id": 15,
        "span": "compress.rs:1216:12: 1242:2 (#0)",
        "pieces": [
          "compress.rs:1216:12: 1242:2 (#0)"
        ],
        "num_lines": 23,
        "source": "bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 43 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 44 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 45 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 46 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 47 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 48 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 49 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16",
          "mut mtfv_i: u16",
          "mut s_len_sel_selCtr: *mut u8",
          "mut s_code_sel_selCtr: *mut i32"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut gs: i32",
          "mut mtfv: *mut u16"
        ]
      },
      {
        "chunk_id": 16,
        "span": "compress.rs:1247:5: 1258:2 (#0)",
        "pieces": [
          "compress.rs:1247:5: 1258:2 (#0)"
        ],
        "num_lines": 11,
        "source": "i = gs;\n            while i <= ge {\n                bsW(s,\n                    (*s).len[(*s).selector[selCtr as usize] as\n                                 usize][*mtfv.offset(i as isize) as usize] as\n                        Int32,\n                    (*s).code[(*s).selector[selCtr as usize] as\n                                  usize][*mtfv.offset(i as isize) as usize] as\n                        UInt32);\n                i += 1\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut i: i32",
          "mut gs: i32",
          "mut ge: i32",
          "mut selCtr: i32",
          "mut mtfv: *mut u16"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut i: i32",
          "mut gs: i32",
          "mut ge: i32",
          "mut selCtr: i32",
          "mut mtfv: *mut u16",
          "mut i: i32"
        ]
      },
      {
        "chunk_id": 17,
        "span": "compress.rs:1058:5: 1263:13 (#0)",
        "pieces": [
          "compress.rs:1058:5: 1066:4 (#0)",
          "compress.rs:1216:1: 1216:11 (#0)",
          "compress.rs:1244:1: 1247:4 (#0)",
          "compress.rs:1260:1: 1263:13 (#0)"
        ],
        "num_lines": 17,
        "source": "if gs >= (*s).nMTF { break ; }\n        ge = gs + 50 as std::os::raw::c_int - 1 as std::os::raw::c_int;\n        if ge >= (*s).nMTF { ge = (*s).nMTF - 1 as std::os::raw::c_int }\n        if !(((*s).selector[selCtr as usize] as std::os::raw::c_int) < nGroups) {\n            BZ2_bz__AssertH__fail(3006 as std::os::raw::c_int);\n        }\n        if nGroups == 6 as std::os::raw::c_int &&\n               50 as std::os::raw::c_int == ge - gs + 1 as std::os::raw::c_int {\n            /*--- fast track the common case ---*/\n           <<chunk 14>>           <<chunk 15>>        } else {\n            /*--- slow version which correctly handles all situations ---*/\n           <<chunk 16>>        }\n        gs = ge + 1 as std::os::raw::c_int;\n        selCtr += 1",
        "sub_chunks": [
          14,
          15,
          16
        ],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut i: i32",
          "mut gs: i32",
          "mut ge: i32",
          "mut selCtr: i32",
          "mut nGroups: i32",
          "mut mtfv: *mut u16"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut i: i32",
          "mut gs: i32",
          "mut ge: i32",
          "mut selCtr: i32",
          "mut nGroups: i32",
          "mut mtfv: *mut u16"
        ]
      },
      {
        "chunk_id": 18,
        "span": "compress.rs:286:5: 934:34 (#0)",
        "pieces": [
          "compress.rs:286:5: 393:8 (#0)",
          "compress.rs:901:1: 934:34 (#0)"
        ],
        "num_lines": 142,
        "source": "let mut v: Int32 = 0;\n    let mut t: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut gs: Int32 = 0;\n    let mut ge: Int32 = 0;\n    let mut totc: Int32 = 0;\n    let mut bt: Int32 = 0;\n    let mut bc: Int32 = 0;\n    let mut iter: Int32 = 0;\n    let mut nSelectors: Int32 = 0;\n    let mut alphaSize: Int32 = 0;\n    let mut minLen: Int32 = 0;\n    let mut maxLen: Int32 = 0;\n    let mut selCtr: Int32 = 0;\n    let mut nGroups: Int32 = 0;\n    let mut nBytes: Int32 = 0;\n    /*--\n   UChar  len [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];\n   is a global since the decoder also needs it.\n\n   Int32  code[BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];\n   Int32  rfreq[BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];\n   are also globals only used in this proc.\n   Made global to keep stack frame size small.\n   --*/\n    let mut cost: [UInt16; 6] = [0; 6];\n    let mut fave: [Int32; 6] = [0; 6];\n    let mut mtfv: *mut UInt16 = (*s).mtfv;\n    if (*s).verbosity >= 3 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"      %d in block, %d after MTF & 1-2 coding, %d+2 syms in use\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char, (*s).nblock,\n                (*s).nMTF, (*s).nInUse);\n    }\n    alphaSize = (*s).nInUse + 2 as std::os::raw::c_int;\n    t = 0 as std::os::raw::c_int;\n    while t < 6 as std::os::raw::c_int {\n        v = 0 as std::os::raw::c_int;\n        while v < alphaSize {\n            (*s).len[t as usize][v as usize] = 15 as std::os::raw::c_int as UChar;\n            v += 1\n        }\n        t += 1\n    }\n    /*--- Decide how many coding tables to use ---*/\n    if !((*s).nMTF > 0 as std::os::raw::c_int) {\n        BZ2_bz__AssertH__fail(3001 as std::os::raw::c_int);\n    }\n    if (*s).nMTF < 200 as std::os::raw::c_int {\n        nGroups = 2 as std::os::raw::c_int\n    } else if (*s).nMTF < 600 as std::os::raw::c_int {\n        nGroups = 3 as std::os::raw::c_int\n    } else if (*s).nMTF < 1200 as std::os::raw::c_int {\n        nGroups = 4 as std::os::raw::c_int\n    } else if (*s).nMTF < 2400 as std::os::raw::c_int {\n        nGroups = 5 as std::os::raw::c_int\n    } else { nGroups = 6 as std::os::raw::c_int }\n    /*--- Generate an initial set of coding tables ---*/\n    let mut nPart: Int32 = 0;\n    let mut remF: Int32 = 0;\n    let mut tFreq: Int32 = 0;\n    let mut aFreq: Int32 = 0;\n    nPart = nGroups;\n    remF = (*s).nMTF;\n    gs = 0 as std::os::raw::c_int;\n    while nPart > 0 as std::os::raw::c_int {\n        tFreq = remF / nPart;\n        ge = gs - 1 as std::os::raw::c_int;\n        aFreq = 0 as std::os::raw::c_int;\n        while aFreq < tFreq && ge < alphaSize - 1 as std::os::raw::c_int {\n            ge += 1;\n            aFreq += (*s).mtfFreq[ge as usize]\n        }\n        if ge > gs && nPart != nGroups && nPart != 1 as std::os::raw::c_int &&\n               (nGroups - nPart) % 2 as std::os::raw::c_int == 1 as std::os::raw::c_int {\n            aFreq -= (*s).mtfFreq[ge as usize];\n            ge -= 1\n        }\n        if (*s).verbosity >= 3 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"      initial group %d, [%d .. %d], has %d syms (%4.1f%%)\\n\\x00\"\n                        as *const u8 as *const std::os::raw::c_char, nPart, gs, ge,\n                    aFreq,\n                    100.0f64 * aFreq as std::os::raw::c_float as std::os::raw::c_double /\n                        (*s).nMTF as std::os::raw::c_float as std::os::raw::c_double);\n        }\n        v = 0 as std::os::raw::c_int;\n        while v < alphaSize {\n            if v >= gs && v <= ge {\n                (*s).len[(nPart - 1 as std::os::raw::c_int) as usize][v as usize] =\n                    0 as std::os::raw::c_int as UChar\n            } else {\n                (*s).len[(nPart - 1 as std::os::raw::c_int) as usize][v as usize] =\n                    15 as std::os::raw::c_int as UChar\n            }\n            v += 1\n        }\n        nPart -= 1;\n        gs = ge + 1 as std::os::raw::c_int;\n        remF -= aFreq\n    }\n    /*--- \n      Iterate up to BZ_N_ITERS times to improve the tables.\n   ---*/\n    iter = 0 as std::os::raw::c_int;\n    while iter < 4 as std::os::raw::c_int {\n       <<chunk 13>>    }\n    if !(nGroups < 8 as std::os::raw::c_int) {\n        BZ2_bz__AssertH__fail(3002 as std::os::raw::c_int);\n    }\n    if !(nSelectors < 32768 as std::os::raw::c_int &&\n             nSelectors <=\n                 2 as std::os::raw::c_int + 900000 as std::os::raw::c_int / 50 as std::os::raw::c_int)\n       {\n        BZ2_bz__AssertH__fail(3003 as std::os::raw::c_int);\n    }\n    /*--- Compute MTF values for the selectors. ---*/\n    let mut pos: [UChar; 6] = [0; 6];\n    let mut ll_i: UChar = 0;\n    let mut tmp2: UChar = 0;\n    let mut tmp: UChar = 0;\n    i = 0 as std::os::raw::c_int;\n    while i < nGroups { pos[i as usize] = i as UChar; i += 1 }\n    i = 0 as std::os::raw::c_int;\n    while i < nSelectors {\n        ll_i = (*s).selector[i as usize];\n        j = 0 as std::os::raw::c_int;\n        tmp = pos[j as usize];\n        while ll_i as std::os::raw::c_int != tmp as std::os::raw::c_int {\n            j += 1;\n            tmp2 = tmp;\n            tmp = pos[j as usize];\n            pos[j as usize] = tmp2\n        }\n        pos[0 as std::os::raw::c_int as usize] = tmp;\n        (*s).selectorMtf[i as usize] = j as UChar;\n        i += 1\n    }\n    /*--- Assign actual codes for the tables. --*/\n    t = 0 as std::os::raw::c_int;",
        "sub_chunks": [
          13
        ],
        "live_in": [
          "mut s: *mut blocksort::EState"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut v: i32",
          "mut t: i32",
          "mut i: i32",
          "mut j: i32",
          "mut gs: i32",
          "mut ge: i32",
          "mut totc: i32",
          "mut bt: i32",
          "mut bc: i32",
          "mut iter: i32",
          "mut nSelectors: i32",
          "mut alphaSize: i32",
          "mut minLen: i32",
          "mut maxLen: i32",
          "mut selCtr: i32",
          "mut nGroups: i32",
          "mut nBytes: i32",
          "mut cost: [u16; 6]",
          "mut fave: [i32; 6]",
          "mut mtfv: *mut u16",
          "mut nPart: i32",
          "mut remF: i32",
          "mut tFreq: i32",
          "mut aFreq: i32",
          "mut pos: [u8; 6]",
          "mut ll_i: u8",
          "mut tmp2: u8",
          "mut tmp: u8"
        ]
      },
      {
        "chunk_id": 19,
        "span": "compress.rs:935:5: 1272:2 (#0)",
        "pieces": [
          "compress.rs:935:5: 1058:4 (#0)",
          "compress.rs:1265:1: 1272:2 (#0)"
        ],
        "num_lines": 137,
        "source": "while t < nGroups {\n        minLen = 32 as std::os::raw::c_int;\n        maxLen = 0 as std::os::raw::c_int;\n        i = 0 as std::os::raw::c_int;\n        while i < alphaSize {\n            if (*s).len[t as usize][i as usize] as std::os::raw::c_int > maxLen {\n                maxLen = (*s).len[t as usize][i as usize] as Int32\n            }\n            if ((*s).len[t as usize][i as usize] as std::os::raw::c_int) < minLen {\n                minLen = (*s).len[t as usize][i as usize] as Int32\n            }\n            i += 1\n        }\n        if maxLen > 17 as std::os::raw::c_int {\n            BZ2_bz__AssertH__fail(3004 as std::os::raw::c_int);\n        }\n        if minLen < 1 as std::os::raw::c_int {\n            BZ2_bz__AssertH__fail(3005 as std::os::raw::c_int);\n        }\n        BZ2_hbAssignCodes(&mut *(*(*s).code.as_mut_ptr().offset(t as\n                                                                    isize)).as_mut_ptr().offset(0\n                                                                                                    as\n                                                                                                    std::os::raw::c_int\n                                                                                                    as\n                                                                                                    isize),\n                          &mut *(*(*s).len.as_mut_ptr().offset(t as\n                                                                   isize)).as_mut_ptr().offset(0\n                                                                                                   as\n                                                                                                   std::os::raw::c_int\n                                                                                                   as\n                                                                                                   isize),\n                          minLen, maxLen, alphaSize);\n        t += 1\n    }\n    /*--- Transmit the mapping table. ---*/\n    let mut inUse16: [Bool; 16] = [0; 16];\n    i = 0 as std::os::raw::c_int;\n    while i < 16 as std::os::raw::c_int {\n        inUse16[i as usize] = 0 as std::os::raw::c_int as Bool;\n        j = 0 as std::os::raw::c_int;\n        while j < 16 as std::os::raw::c_int {\n            if (*s).inUse[(i * 16 as std::os::raw::c_int + j) as usize] != 0 {\n                inUse16[i as usize] = 1 as std::os::raw::c_int as Bool\n            }\n            j += 1\n        }\n        i += 1\n    }\n    nBytes = (*s).numZ;\n    i = 0 as std::os::raw::c_int;\n    while i < 16 as std::os::raw::c_int {\n        if inUse16[i as usize] != 0 {\n            bsW(s, 1 as std::os::raw::c_int, 1 as std::os::raw::c_int as UInt32);\n        } else { bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32); }\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 16 as std::os::raw::c_int {\n        if inUse16[i as usize] != 0 {\n            j = 0 as std::os::raw::c_int;\n            while j < 16 as std::os::raw::c_int {\n                if (*s).inUse[(i * 16 as std::os::raw::c_int + j) as usize] != 0 {\n                    bsW(s, 1 as std::os::raw::c_int, 1 as std::os::raw::c_int as UInt32);\n                } else {\n                    bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);\n                }\n                j += 1\n            }\n        }\n        i += 1\n    }\n    if (*s).verbosity >= 3 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"      bytes: mapping %d, \\x00\" as *const u8 as\n                    *const std::os::raw::c_char, (*s).numZ - nBytes);\n    }\n    /*--- Now the selectors. ---*/\n    nBytes = (*s).numZ;\n    bsW(s, 3 as std::os::raw::c_int, nGroups as UInt32);\n    bsW(s, 15 as std::os::raw::c_int, nSelectors as UInt32);\n    i = 0 as std::os::raw::c_int;\n    while i < nSelectors {\n        j = 0 as std::os::raw::c_int;\n        while j < (*s).selectorMtf[i as usize] as std::os::raw::c_int {\n            bsW(s, 1 as std::os::raw::c_int, 1 as std::os::raw::c_int as UInt32);\n            j += 1\n        }\n        bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);\n        i += 1\n    }\n    if (*s).verbosity >= 3 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"selectors %d, \\x00\" as *const u8 as *const std::os::raw::c_char,\n                (*s).numZ - nBytes);\n    }\n    /*--- Now the coding tables. ---*/\n    nBytes = (*s).numZ;\n    t = 0 as std::os::raw::c_int;\n    while t < nGroups {\n        let mut curr: Int32 =\n            (*s).len[t as usize][0 as std::os::raw::c_int as usize] as Int32;\n        bsW(s, 5 as std::os::raw::c_int, curr as UInt32);\n        i = 0 as std::os::raw::c_int;\n        while i < alphaSize {\n            while curr < (*s).len[t as usize][i as usize] as std::os::raw::c_int {\n                bsW(s, 2 as std::os::raw::c_int, 2 as std::os::raw::c_int as UInt32);\n                curr += 1\n                /* 10 */\n            }\n            while curr > (*s).len[t as usize][i as usize] as std::os::raw::c_int {\n                bsW(s, 2 as std::os::raw::c_int, 3 as std::os::raw::c_int as UInt32);\n                curr -= 1\n                /* 11 */\n            }\n            bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);\n            i += 1\n        }\n        t += 1\n    }\n    if (*s).verbosity >= 3 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"code lengths %d, \\x00\" as *const u8 as *const std::os::raw::c_char,\n                (*s).numZ - nBytes);\n    }\n    /*--- And finally, the block data proper ---*/\n    nBytes = (*s).numZ;\n    selCtr = 0 as std::os::raw::c_int;\n    gs = 0 as std::os::raw::c_int;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n       <<chunk 17>>    }\n    if !(selCtr == nSelectors) { BZ2_bz__AssertH__fail(3007 as std::os::raw::c_int); }\n    if (*s).verbosity >= 3 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"codes %d\\n\\x00\" as *const u8 as *const std::os::raw::c_char,\n                (*s).numZ - nBytes);\n    };",
        "sub_chunks": [
          17
        ],
        "live_in": [
          "mut s: *mut blocksort::EState",
          "mut t: i32",
          "mut i: i32",
          "mut j: i32",
          "mut gs: i32",
          "mut ge: i32",
          "mut nSelectors: i32",
          "mut alphaSize: i32",
          "mut minLen: i32",
          "mut maxLen: i32",
          "mut selCtr: i32",
          "mut nGroups: i32",
          "mut nBytes: i32",
          "mut mtfv: *mut u16"
        ],
        "live_out": [
          "mut s: *mut blocksort::EState",
          "mut t: i32",
          "mut i: i32",
          "mut j: i32",
          "mut gs: i32",
          "mut ge: i32",
          "mut nSelectors: i32",
          "mut alphaSize: i32",
          "mut minLen: i32",
          "mut maxLen: i32",
          "mut selCtr: i32",
          "mut nGroups: i32",
          "mut nBytes: i32",
          "mut mtfv: *mut u16",
          "mut inUse16: [bool; 16]"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:338 ~ c2rust_out[3c70]::bzip2recover::bsPutUChar)",
    "span": "bzip2recover.rs:253:1: 262:2 (#0)",
    "pieces": [
      "bzip2recover.rs:253:1: 262:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "unsafe extern \"C\" fn bsPutUChar(mut bs: *mut BitStream, mut c: UChar) {\n    let mut i: Int32 = 0;\n    i = 7 as std::os::raw::c_int;\n    while i >= 0 as std::os::raw::c_int {\n        bsPutBit(bs,\n                 (c as UInt32 >> i & 0x1 as std::os::raw::c_int as std::os::raw::c_uint) as\n                     Int32);\n        i -= 1\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
    "span": "bzip2.rs:2421:1: 2535:2 (#0)",
    "pieces": [
      "bzip2.rs:2421:1: 2535:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 116,
    "source": "unsafe extern \"C\" fn testf(mut name: *mut Char) {\n    let mut inStr: *mut FILE = 0 as *mut FILE;\n    let mut allOK: Bool = 0;\n    let mut statBuf: stat =\n        stat{st_dev: 0,\n             st_mode: 0,\n             st_nlink: 0,\n             st_ino: 0,\n             st_uid: 0,\n             st_gid: 0,\n             st_rdev: 0,\n             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_size: 0,\n             st_blocks: 0,\n             st_blksize: 0,\n             st_flags: 0,\n             st_gen: 0,\n             st_lspare: 0,\n             st_qspare: [0; 2],};\n    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n    if name.is_null() && srcMode != 1 as std::os::raw::c_int {\n        panic(b\"testf: bad modes\\n\\x00\" as *const u8 as *const std::os::raw::c_char);\n    }\n    copyFileName(outName.as_mut_ptr(),\n                 b\"(none)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                     *mut Char);\n    match srcMode {\n        1 => {\n            copyFileName(inName.as_mut_ptr(),\n                         b\"(stdin)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                             *mut Char);\n        }\n        3 => { copyFileName(inName.as_mut_ptr(), name); }\n        2 => { copyFileName(inName.as_mut_ptr(), name); }\n        _ => { }\n    }\n    if srcMode != 1 as std::os::raw::c_int &&\n           containsDubiousChars(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if noisy != 0 {\n            fprintf(__stderrp,\n                    b\"%s: There are no files matching `%s\\'.\\n\\x00\" as\n                        *const u8 as *const std::os::raw::c_char, progName,\n                    inName.as_mut_ptr());\n        }\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode != 1 as std::os::raw::c_int && fileExists(inName.as_mut_ptr()) == 0 {\n        fprintf(__stderrp,\n                b\"%s: Can\\'t open input %s: %s.\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, progName, inName.as_mut_ptr(),\n                strerror(*__error()));\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode != 1 as std::os::raw::c_int {\n        stat(inName.as_mut_ptr(), &mut statBuf);\n        if statBuf.st_mode as std::os::raw::c_int & 0o170000 as std::os::raw::c_int ==\n               0o40000 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"%s: Input file %s is a directory.\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, progName, inName.as_mut_ptr());\n            setExit(1 as std::os::raw::c_int);\n            return\n        }\n    }\n    match srcMode {\n        1 => {\n            if isatty(fileno(__stdinp)) != 0 {\n                fprintf(__stderrp,\n                        b\"%s: I won\\'t read compressed data from a terminal.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char, progName);\n                fprintf(__stderrp,\n                        b\"%s: For help, type: `%s --help\\'.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        progName);\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n            inStr = __stdinp\n        }\n        2 | 3 => {\n            inStr =\n                fopen(inName.as_mut_ptr(),\n                      b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n            if inStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t open input file %s:%s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        inName.as_mut_ptr(), strerror(*__error()));\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        _ => {\n            panic(b\"testf: bad srcMode\\x00\" as *const u8 as\n                      *const std::os::raw::c_char);\n        }\n    }\n    if verbosity >= 1 as std::os::raw::c_int {\n        fprintf(__stderrp, b\"  %s: \\x00\" as *const u8 as *const std::os::raw::c_char,\n                inName.as_mut_ptr());\n        pad(inName.as_mut_ptr());\n        fflush(__stderrp);\n    }\n    /*--- Now the input handle is sane.  Do the Biz. ---*/\n    outputHandleJustInCase = 0 as *mut FILE;\n    allOK = testStream(inStr);\n    if allOK as std::os::raw::c_int != 0 && verbosity >= 1 as std::os::raw::c_int {\n        fprintf(__stderrp, b\"ok\\n\\x00\" as *const u8 as *const std::os::raw::c_char);\n    }\n    if allOK == 0 { testFailsExist = 1 as std::os::raw::c_int as Bool };\n}",
    "calls": [
      {
        "caller": "DefId(0:330 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2949:9: 2949:37 (#0)",
        "source": "testf(std::ptr::null_mut());"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:392:1: 392:50 (#0)",
        "source": "pub static mut deleteOutputOnInterrupt: Bool = 0;"
      },
      {
        "span": "bzip2.rs:422:1: 422:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      },
      {
        "span": "bzip2.rs:418:1: 418:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:414:1: 414:43 (#0)",
        "source": "pub static mut longestFileName: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:412:1: 412:35 (#0)",
        "source": "pub static mut srcMode: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:426:1: 427:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      },
      {
        "span": "bzip2.rs:416:1: 416:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:396:1: 396:41 (#0)",
        "source": "pub static mut testFailsExist: Bool = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:211 ~ c2rust_out[3c70]::bzip2::uInt64_qrm10)",
    "span": "bzip2.rs:463:1: 475:2 (#0)",
    "pieces": [
      "bzip2.rs:463:1: 475:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn uInt64_qrm10(mut n: *mut UInt64) -> Int32 {\n    let mut rem: UInt32 = 0;\n    let mut tmp: UInt32 = 0;\n    let mut i: Int32 = 0;\n    rem = 0 as std::os::raw::c_int as UInt32;\n    i = 7 as std::os::raw::c_int;\n    while i >= 0 as std::os::raw::c_int {\n        tmp =\n            rem.wrapping_mul(256 as std::os::raw::c_int as\n                                 std::os::raw::c_uint).wrapping_add((*n).b[i as usize]\n                                                                as\n                                                                std::os::raw::c_uint);\n        (*n).b[i as usize] =\n            tmp.wrapping_div(10 as std::os::raw::c_int as std::os::raw::c_uint) as UChar;\n        rem = tmp.wrapping_rem(10 as std::os::raw::c_int as std::os::raw::c_uint);\n        i -= 1\n    }\n    return rem as Int32;\n}",
    "calls": [
      {
        "caller": "DefId(0:260 ~ c2rust_out[3c70]::bzip2::uInt64_toAscii)",
        "span": "bzip2.rs:488:9: 488:39 (#0)",
        "source": "q = uInt64_qrm10(&mut n_copy);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:212 ~ c2rust_out[3c70]::bzip2::uInt64_toAscii)",
    "span": "bzip2.rs:480:1: 501:2 (#0)",
    "pieces": [
      "bzip2.rs:480:1: 501:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn uInt64_toAscii(mut outbuf: *mut std::os::raw::c_char,\n                                    mut n: *mut UInt64) {\n    let mut i: Int32 = 0;\n    let mut q: Int32 = 0;\n    let mut buf: [UChar; 32] = [0; 32];\n    let mut nBuf: Int32 = 0 as std::os::raw::c_int;\n    let mut n_copy: UInt64 = *n;\n    loop  {\n        q = uInt64_qrm10(&mut n_copy);\n        buf[nBuf as usize] = (q + '0' as i32) as UChar;\n        nBuf += 1;\n        if !(uInt64_isZero(&mut n_copy) == 0) { break ; }\n    }\n    *outbuf.offset(nBuf as isize) = 0 as std::os::raw::c_int as std::os::raw::c_char;\n    i = 0 as std::os::raw::c_int;\n    while i < nBuf {\n        *outbuf.offset(i as isize) =\n            buf[(nBuf - i - 1 as std::os::raw::c_int) as usize] as std::os::raw::c_char;\n        i += 1\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:628:41: 628:88 (#0)",
        "source": "uInt64_toAscii(&mut buf_nout, &mut nbytes_out);"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:627:41: 627:86 (#0)",
        "source": "uInt64_toAscii(&mut buf_nin, &mut nbytes_in);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:209 ~ c2rust_out[3c70]::bzip2::uInt64_to_double)",
    "span": "bzip2.rs:441:1: 451:2 (#0)",
    "pieces": [
      "bzip2.rs:441:1: 451:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn uInt64_to_double(mut n: *mut UInt64) -> std::os::raw::c_double {\n    let mut i: Int32 = 0;\n    let mut base: std::os::raw::c_double = 1.0f64;\n    let mut sum: std::os::raw::c_double = 0.0f64;\n    i = 0 as std::os::raw::c_int;\n    while i < 8 as std::os::raw::c_int {\n        sum += base * (*n).b[i as usize] as std::os::raw::c_double;\n        base *= 256.0f64;\n        i += 1\n    }\n    return sum;\n}",
    "calls": [
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:626:41: 626:90 (#0)",
        "source": "nbytes_out_d = uInt64_to_double(&mut nbytes_out);"
      },
      {
        "caller": "DefId(0:264 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:625:41: 625:88 (#0)",
        "source": "nbytes_in_d = uInt64_to_double(&mut nbytes_in);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
    "span": "bzip2.rs:514:1: 705:2 (#0)",
    "pieces": [
      "bzip2.rs:514:1: 516:4 (#0)",
      "bzip2.rs:704:1: 705:2 (#0)"
    ],
    "sub_chunks": [
      3
    ],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn compressStream(mut stream: *mut FILE,\n                                    mut zStream: *mut FILE) {\n   <<chunk 3>>    /*notreached*/\n}",
    "calls": [
      {
        "caller": "DefId(0:317 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2135:5: 2135:35 (#0)",
        "source": "compressStream(inStr, outStr);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:429:1: 429:38 (#0)",
        "source": "pub static mut workFactor: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:426:1: 427:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      },
      {
        "span": "bzip2.rs:386:1: 386:37 (#0)",
        "source": "pub static mut verbosity: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:406:1: 406:41 (#0)",
        "source": "pub static mut blockSize100k: Int32 = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "bzip2.rs:534:5: 565:18 (#0)",
        "pieces": [
          "bzip2.rs:534:5: 565:18 (#0)"
        ],
        "num_lines": 32,
        "source": "if verbosity >= 2 as std::os::raw::c_int {\n                    fprintf(__stderrp,\n                            b\"\\n\\x00\" as *const u8 as *const std::os::raw::c_char);\n                }\n                loop  {\n                    if !(1 as std::os::raw::c_int as Bool != 0) {\n                        current_block = 13242334135786603907;\n                        break ;\n                    }\n                    if myfeof(stream) != 0 {\n                        current_block = 13242334135786603907;\n                        break ;\n                    }\n                    nIbuf =\n                        fread(ibuf.as_mut_ptr() as *mut std::os::raw::c_void,\n                              ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong,\n                              5000 as std::os::raw::c_int as std::os::raw::c_ulong, stream) as\n                            Int32;\n                    if ferror(stream) != 0 {\n                        current_block = 18225113528933273530;\n                        break ;\n                    }\n                    if nIbuf > 0 as std::os::raw::c_int {\n                        BZ2_bzWrite(&mut bzerr, bzf,\n                                    ibuf.as_mut_ptr() as *mut std::os::raw::c_void,\n                                    nIbuf);\n                    }\n                    if bzerr != 0 as std::os::raw::c_int {\n                        current_block = 660242869387099075;\n                        break ;\n                    }\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut ibuf: [u8; 5000]",
          "mut nIbuf: i32",
          "mut bzerr: i32",
          "mut bzerr: i32",
          "bzf: *mut std::ffi::c_void"
        ],
        "live_out": [
          "mut stream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut ibuf: [u8; 5000]",
          "mut nIbuf: i32",
          "mut bzerr: i32",
          "mut bzerr: i32",
          "bzf: *mut std::ffi::c_void"
        ]
      },
      {
        "chunk_id": 1,
        "span": "bzip2.rs:567:5: 645:2 (#0)",
        "pieces": [
          "bzip2.rs:567:5: 645:2 (#0)"
        ],
        "num_lines": 136,
        "source": "match current_block {\n                    18225113528933273530 => { }\n                    660242869387099075 => { }\n                    _ => {\n                        BZ2_bzWriteClose64(&mut bzerr, bzf, 0 as std::os::raw::c_int,\n                                           &mut nbytes_in_lo32,\n                                           &mut nbytes_in_hi32,\n                                           &mut nbytes_out_lo32,\n                                           &mut nbytes_out_hi32);\n                        if bzerr != 0 as std::os::raw::c_int {\n                            current_block = 660242869387099075;\n                        } else if ferror(zStream) != 0 {\n                            current_block = 18225113528933273530;\n                        } else {\n                            ret = fflush(zStream);\n                            if ret == -(1 as std::os::raw::c_int) {\n                                current_block = 18225113528933273530;\n                            } else {\n                                if zStream != __stdoutp {\n                                    let mut fd: Int32 = fileno(zStream);\n                                    if fd < 0 as std::os::raw::c_int {\n                                        current_block = 18225113528933273530;\n                                    } else {\n                                        applySavedFileAttrToOutputFile(fd);\n                                        ret = fclose(zStream);\n                                        outputHandleJustInCase =\n                                            0 as *mut FILE;\n                                        if ret == -(1 as std::os::raw::c_int) {\n                                            current_block =\n                                                18225113528933273530;\n                                        } else {\n                                            current_block =\n                                                17281240262373992796;\n                                        }\n                                    }\n                                } else {\n                                    current_block = 17281240262373992796;\n                                }\n                                match current_block {\n                                    18225113528933273530 => { }\n                                    _ => {\n                                        outputHandleJustInCase =\n                                            0 as *mut FILE;\n                                        if ferror(stream) != 0 {\n                                            current_block =\n                                                18225113528933273530;\n                                        } else {\n                                            ret = fclose(stream);\n                                            if ret == -(1 as std::os::raw::c_int) {\n                                                current_block =\n                                                    18225113528933273530;\n                                            } else {\n                                                if verbosity >=\n                                                       1 as std::os::raw::c_int {\n                                                    if nbytes_in_lo32 ==\n                                                           0 as std::os::raw::c_int as\n                                                               std::os::raw::c_uint &&\n                                                           nbytes_in_hi32 ==\n                                                               0 as\n                                                                   std::os::raw::c_int\n                                                                   as\n                                                                   std::os::raw::c_uint\n                                                       {\n                                                        fprintf(__stderrp,\n                                                                b\" no data compressed.\\n\\x00\"\n                                                                    as\n                                                                    *const u8\n                                                                    as\n                                                                    *const std::os::raw::c_char);\n                                                    } else {\n                                                        let mut buf_nin:\n                                                                [Char; 32] =\n                                                            [0; 32];\n                                                        let mut buf_nout:\n                                                                [Char; 32] =\n                                                            [0; 32];\n                                                        let mut nbytes_in:\n                                                                UInt64 =\n                                                            UInt64{b:\n                                                                       [0;\n                                                                           8],};\n                                                        let mut nbytes_out:\n                                                                UInt64 =\n                                                            UInt64{b:\n                                                                       [0;\n                                                                           8],};\n                                                        let mut nbytes_in_d:\n                                                                std::os::raw::c_double =\n                                                            0.;\n                                                        let mut nbytes_out_d:\n                                                                std::os::raw::c_double =\n                                                            0.;\n                                                        uInt64_from_UInt32s(&mut nbytes_in,\n                                                                            nbytes_in_lo32,\n                                                                            nbytes_in_hi32);\n                                                        uInt64_from_UInt32s(&mut nbytes_out,\n                                                                            nbytes_out_lo32,\n                                                                            nbytes_out_hi32);\n                                                        nbytes_in_d =\n                                                            uInt64_to_double(&mut nbytes_in);\n                                                        nbytes_out_d =\n                                                            uInt64_to_double(&mut nbytes_out);\n                                                        uInt64_toAscii(buf_nin.as_mut_ptr(),\n                                                                       &mut nbytes_in);\n                                                        uInt64_toAscii(buf_nout.as_mut_ptr(),\n                                                                       &mut nbytes_out);\n                                                        fprintf(__stderrp,\n                                                                b\"%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %s in, %s out.\\n\\x00\"\n                                                                    as\n                                                                    *const u8\n                                                                    as\n                                                                    *const std::os::raw::c_char,\n                                                                nbytes_in_d /\n                                                                    nbytes_out_d,\n                                                                8.0f64 *\n                                                                    nbytes_out_d\n                                                                    /\n                                                                    nbytes_in_d,\n                                                                100.0f64 *\n                                                                    (1.0f64 -\n                                                                         nbytes_out_d\n                                                                             /\n                                                                             nbytes_in_d),\n                                                                buf_nin.as_mut_ptr(),\n                                                                buf_nout.as_mut_ptr());\n                                                    }\n                                                }\n                                                return\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut stream: *mut blocksort::__sFILE",
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut nbytes_in_lo32: u32",
          "mut nbytes_in_hi32: u32",
          "mut nbytes_out_lo32: u32",
          "mut nbytes_out_hi32: u32",
          "mut bzerr: i32",
          "mut ret: i32",
          "mut bzerr: i32",
          "bzf: *mut std::ffi::c_void"
        ],
        "live_out": [
          "mut stream: *mut blocksort::__sFILE",
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut nbytes_in_lo32: u32",
          "mut nbytes_in_hi32: u32",
          "mut nbytes_out_lo32: u32",
          "mut nbytes_out_hi32: u32",
          "mut bzerr: i32",
          "mut ret: i32",
          "mut bzerr: i32",
          "bzf: *mut std::ffi::c_void"
        ]
      },
      {
        "chunk_id": 2,
        "span": "bzip2.rs:529:13: 699:2 (#0)",
        "pieces": [
          "bzip2.rs:529:13: 534:4 (#0)",
          "bzip2.rs:566:1: 567:4 (#0)",
          "bzip2.rs:647:1: 699:2 (#0)"
        ],
        "num_lines": 58,
        "source": "bzf =\n                BZ2_bzWriteOpen(&mut bzerr, zStream, blockSize100k, verbosity,\n                                workFactor);\n            if bzerr != 0 as std::os::raw::c_int {\n                current_block = 660242869387099075;\n            } else {\n               <<chunk 0>>               <<chunk 1>>            }\n            match current_block {\n                18225113528933273530 => { }\n                _ => {\n                    BZ2_bzWriteClose64(&mut bzerr_dummy, bzf,\n                                       1 as std::os::raw::c_int, &mut nbytes_in_lo32,\n                                       &mut nbytes_in_hi32,\n                                       &mut nbytes_out_lo32,\n                                       &mut nbytes_out_hi32);\n                    match bzerr {\n                        -9 => {\n                            current_block = 5122324059762049690;\n                            match current_block {\n                                4323399205346619401 => {\n                                    panic(b\"compress:unexpected error\\x00\" as\n                                              *const u8 as\n                                              *const std::os::raw::c_char);\n                                }\n                                2380987886157893679 => { outOfMemory(); }\n                                _ => { configError(); }\n                            }\n                        }\n                        -3 => {\n                            current_block = 2380987886157893679;\n                            match current_block {\n                                4323399205346619401 => {\n                                    panic(b\"compress:unexpected error\\x00\" as\n                                              *const u8 as\n                                              *const std::os::raw::c_char);\n                                }\n                                2380987886157893679 => { outOfMemory(); }\n                                _ => { configError(); }\n                            }\n                        }\n                        -6 => { }\n                        _ => {\n                            current_block = 4323399205346619401;\n                            match current_block {\n                                4323399205346619401 => {\n                                    panic(b\"compress:unexpected error\\x00\" as\n                                              *const u8 as\n                                              *const std::os::raw::c_char);\n                                }\n                                2380987886157893679 => { outOfMemory(); }\n                                _ => { configError(); }\n                            }\n                        }\n                    }\n                }\n            }",
        "sub_chunks": [
          0,
          1
        ],
        "live_in": [
          "mut stream: *mut blocksort::__sFILE",
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut ibuf: [u8; 5000]",
          "mut nIbuf: i32",
          "mut nbytes_in_lo32: u32",
          "mut nbytes_in_hi32: u32",
          "mut nbytes_out_lo32: u32",
          "mut nbytes_out_hi32: u32",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut ret: i32"
        ],
        "live_out": [
          "mut stream: *mut blocksort::__sFILE",
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut ibuf: [u8; 5000]",
          "mut nIbuf: i32",
          "mut nbytes_in_lo32: u32",
          "mut nbytes_in_hi32: u32",
          "mut nbytes_out_lo32: u32",
          "mut nbytes_out_hi32: u32",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut ret: i32",
          "mut bzerr: i32",
          "bzf: *mut std::ffi::c_void"
        ]
      },
      {
        "chunk_id": 3,
        "span": "bzip2.rs:516:5: 703:10 (#0)",
        "pieces": [
          "bzip2.rs:516:5: 529:12 (#0)",
          "bzip2.rs:701:1: 703:10 (#0)"
        ],
        "num_lines": 17,
        "source": "let mut current_block: u64;\n    let mut bzf: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    let mut ibuf: [UChar; 5000] = [0; 5000];\n    let mut nIbuf: Int32 = 0;\n    let mut nbytes_in_lo32: UInt32 = 0;\n    let mut nbytes_in_hi32: UInt32 = 0;\n    let mut nbytes_out_lo32: UInt32 = 0;\n    let mut nbytes_out_hi32: UInt32 = 0;\n    let mut bzerr: Int32 = 0;\n    let mut bzerr_dummy: Int32 = 0;\n    let mut ret: Int32 = 0;\n    if !(ferror(stream) != 0) {\n        if !(ferror(zStream) != 0) {\n           <<chunk 2>>        }\n    }\n    ioError();",
        "sub_chunks": [
          2
        ],
        "live_in": [
          "mut stream: *mut blocksort::__sFILE",
          "mut zStream: *mut blocksort::__sFILE"
        ],
        "live_out": [
          "mut stream: *mut blocksort::__sFILE",
          "mut zStream: *mut blocksort::__sFILE",
          "mut current_block: u64",
          "mut bzf: *mut std::ffi::c_void",
          "mut ibuf: [u8; 5000]",
          "mut nIbuf: i32",
          "mut nbytes_in_lo32: u32",
          "mut nbytes_in_hi32: u32",
          "mut nbytes_out_lo32: u32",
          "mut nbytes_out_hi32: u32",
          "mut bzerr: i32",
          "mut bzerr_dummy: i32",
          "mut ret: i32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
    "span": "bzip2.rs:1915:1: 2151:2 (#0)",
    "pieces": [
      "bzip2.rs:1915:1: 1917:7 (#0)",
      "bzip2.rs:2052:1: 2053:7 (#0)",
      "bzip2.rs:2149:1: 2151:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn compress(mut name: *mut Char) {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:330 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2911:9: 2911:40 (#0)",
        "source": "compress(std::ptr::null_mut());"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:418:1: 418:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:392:1: 392:50 (#0)",
        "source": "pub static mut deleteOutputOnInterrupt: Bool = 0;"
      },
      {
        "span": "bzip2.rs:412:1: 412:35 (#0)",
        "source": "pub static mut srcMode: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:416:1: 416:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:414:1: 414:43 (#0)",
        "source": "pub static mut longestFileName: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:422:1: 422:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      },
      {
        "span": "bzip2.rs:426:1: 427:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "bzip2.rs:1917:8: 2051:6 (#0)",
        "pieces": [
          "bzip2.rs:1917:8: 2051:6 (#0)"
        ],
        "num_lines": 136,
        "source": "let mut inStr: *mut FILE = 0 as *mut FILE;\n    let mut outStr: *mut FILE = 0 as *mut FILE;\n    let mut n: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut statBuf: stat =\n        stat{st_dev: 0,\n             st_mode: 0,\n             st_nlink: 0,\n             st_ino: 0,\n             st_uid: 0,\n             st_gid: 0,\n             st_rdev: 0,\n             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_size: 0,\n             st_blocks: 0,\n             st_blksize: 0,\n             st_flags: 0,\n             st_gen: 0,\n             st_lspare: 0,\n             st_qspare: [0; 2],};\n    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n    if name.is_null() && srcMode != 1 as std::os::raw::c_int {\n        panic(b\"compress: bad modes\\n\\x00\" as *const u8 as\n                  *const std::os::raw::c_char);\n    }\n    match srcMode {\n        1 => {\n            copyFileName(inName.as_mut_ptr(),\n                         b\"(stdin)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                             *mut Char);\n            copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);\n        }\n        3 => {\n            copyFileName(inName.as_mut_ptr(), name);\n            copyFileName(outName.as_mut_ptr(), name);\n            strcat(outName.as_mut_ptr(),\n                   b\".bz2\\x00\" as *const u8 as *const std::os::raw::c_char);\n        }\n        2 => {\n            copyFileName(inName.as_mut_ptr(), name);\n            copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);\n        }\n        _ => { }\n    }\n    if srcMode != 1 as std::os::raw::c_int &&\n           containsDubiousChars(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if noisy != 0 {\n            fprintf(__stderrp,\n                    b\"%s: There are no files matching `%s\\'.\\n\\x00\" as\n                        *const u8 as *const std::os::raw::c_char, progName,\n                    inName.as_mut_ptr());\n        }\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode != 1 as std::os::raw::c_int && fileExists(inName.as_mut_ptr()) == 0 {\n        fprintf(__stderrp,\n                b\"%s: Can\\'t open input file %s: %s.\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, progName, inName.as_mut_ptr(),\n                strerror(*__error()));\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 4 as std::os::raw::c_int {\n        if hasSuffix(inName.as_mut_ptr(), zSuffix[i as usize]) != 0 {\n            if noisy != 0 {\n                fprintf(__stderrp,\n                        b\"%s: Input file %s already has %s suffix.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        inName.as_mut_ptr(), zSuffix[i as usize]);\n            }\n            setExit(1 as std::os::raw::c_int);\n            return\n        }\n        i += 1\n    }\n    if srcMode == 3 as std::os::raw::c_int || srcMode == 2 as std::os::raw::c_int {\n        stat(inName.as_mut_ptr(), &mut statBuf);\n        if statBuf.st_mode as std::os::raw::c_int & 0o170000 as std::os::raw::c_int ==\n               0o40000 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"%s: Input file %s is a directory.\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, progName, inName.as_mut_ptr());\n            setExit(1 as std::os::raw::c_int);\n            return\n        }\n    }\n    if srcMode == 3 as std::os::raw::c_int && forceOverwrite == 0 &&\n           notAStandardFile(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if noisy != 0 {\n            fprintf(__stderrp,\n                    b\"%s: Input file %s is not a normal file.\\n\\x00\" as\n                        *const u8 as *const std::os::raw::c_char, progName,\n                    inName.as_mut_ptr());\n        }\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode == 3 as std::os::raw::c_int &&\n           fileExists(outName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if forceOverwrite != 0 {\n            remove(outName.as_mut_ptr());\n        } else {\n            fprintf(__stderrp,\n                    b\"%s: Output file %s already exists.\\n\\x00\" as *const u8\n                        as *const std::os::raw::c_char, progName,\n                    outName.as_mut_ptr());\n            setExit(1 as std::os::raw::c_int);\n            return\n        }\n    }\n    if srcMode == 3 as std::os::raw::c_int && forceOverwrite == 0 &&\n           { n = countHardLinks(inName.as_mut_ptr()); (n) > 0 as std::os::raw::c_int }\n       {\n        fprintf(__stderrp,\n                b\"%s: Input file %s has %d other link%s.\\n\\x00\" as *const u8\n                    as *const std::os::raw::c_char, progName, inName.as_mut_ptr(), n,\n                if n > 1 as std::os::raw::c_int {\n                    b\"s\\x00\" as *const u8 as *const std::os::raw::c_char\n                } else { b\"\\x00\" as *const u8 as *const std::os::raw::c_char });\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode == 3 as std::os::raw::c_int {\n        /* Save the file's meta-info before we open it.  Doing it later\n         means we mess up the access times. */\n        saveInputFileMetaInfo(inName.as_mut_ptr());\n    }",
        "sub_chunks": [],
        "live_in": [
          "name: *mut i8"
        ],
        "live_out": [
          "name: *mut i8",
          "mut inStr: *mut blocksort::__sFILE",
          "mut outStr: *mut blocksort::__sFILE",
          "mut n: i32",
          "mut i: i32",
          "mut statBuf: bzip2::stat"
        ]
      },
      {
        "chunk_id": 1,
        "span": "bzip2.rs:2053:8: 2148:64 (#0)",
        "pieces": [
          "bzip2.rs:2053:8: 2148:64 (#0)"
        ],
        "num_lines": 95,
        "source": "match srcMode {\n        1 => {\n            inStr = __stdinp;\n            outStr = __stdoutp;\n            if isatty(fileno(__stdoutp)) != 0 {\n                fprintf(__stderrp,\n                        b\"%s: I won\\'t write compressed data to a terminal.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char, progName);\n                fprintf(__stderrp,\n                        b\"%s: For help, type: `%s --help\\'.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        progName);\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        2 => {\n            inStr =\n                fopen(inName.as_mut_ptr(),\n                      b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n            outStr = __stdoutp;\n            if isatty(fileno(__stdoutp)) != 0 {\n                fprintf(__stderrp,\n                        b\"%s: I won\\'t write compressed data to a terminal.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char, progName);\n                fprintf(__stderrp,\n                        b\"%s: For help, type: `%s --help\\'.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        progName);\n                if !inStr.is_null() { fclose(inStr); }\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n            if inStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t open input file %s: %s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        inName.as_mut_ptr(), strerror(*__error()));\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        3 => {\n            inStr =\n                fopen(inName.as_mut_ptr(),\n                      b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n            outStr =\n                fopen_output_safely(outName.as_mut_ptr(),\n                                    b\"wb\\x00\" as *const u8 as\n                                        *const std::os::raw::c_char);\n            if outStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t create output file %s: %s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        outName.as_mut_ptr(), strerror(*__error()));\n                if !inStr.is_null() { fclose(inStr); }\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n            if inStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t open input file %s: %s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        inName.as_mut_ptr(), strerror(*__error()));\n                if !outStr.is_null() { fclose(outStr); }\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        _ => {\n            panic(b\"compress: bad srcMode\\x00\" as *const u8 as\n                      *const std::os::raw::c_char);\n        }\n    }\n    if verbosity >= 1 as std::os::raw::c_int {\n        fprintf(__stderrp, b\"  %s: \\x00\" as *const u8 as *const std::os::raw::c_char,\n                inName.as_mut_ptr());\n        pad(inName.as_mut_ptr());\n        fflush(__stderrp);\n    }\n    /*--- Now the input and output handles are sane.  Do the Biz. ---*/\n    outputHandleJustInCase = outStr;\n    deleteOutputOnInterrupt = 1 as std::os::raw::c_int as Bool;\n    compressStream(inStr, outStr);\n    outputHandleJustInCase = 0 as *mut FILE;\n    /*--- If there was an I/O error, we won't get here. ---*/\n    if srcMode == 3 as std::os::raw::c_int {\n        applySavedTimeInfoToOutputFile(outName.as_mut_ptr());\n        deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n        if keepInputFiles == 0 {\n            let mut retVal: IntNative = remove(inName.as_mut_ptr());\n            if retVal != 0 as std::os::raw::c_int { ioError(); }\n        }\n    }\n    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;",
        "sub_chunks": [],
        "live_in": [
          "mut inStr: *mut blocksort::__sFILE",
          "mut outStr: *mut blocksort::__sFILE",
          "mut n: i32"
        ],
        "live_out": [
          "mut inStr: *mut blocksort::__sFILE",
          "mut outStr: *mut blocksort::__sFILE",
          "mut n: i32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:281 ~ c2rust_out[3c70]::bzip2::main_0)",
    "span": "bzip2.rs:2618:1: 2984:2 (#0)",
    "pieces": [
      "bzip2.rs:2618:1: 2619:4 (#0)",
      "bzip2.rs:2750:1: 2750:4 (#0)",
      "bzip2.rs:2898:1: 2898:4 (#0)",
      "bzip2.rs:2984:1: 2984:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1,
      2
    ],
    "num_lines": 5,
    "source": "unsafe fn main_0(mut argc: IntNative, mut argv: *mut *mut Char) -> IntNative {\n   <<chunk 0>>   <<chunk 1>>   <<chunk 2>>}",
    "calls": [
      {
        "caller": "DefId(0:331 ~ c2rust_out[3c70]::bzip2::main)",
        "span": "bzip2.rs:2995:18: 2997:6 (#0)",
        "source": "unsafe {\n        main_0(arg_count - 1, c_args.as_ptr() as *mut *mut Char)\n    }"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:412:1: 412:35 (#0)",
        "source": "pub static mut srcMode: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:386:1: 386:37 (#0)",
        "source": "pub static mut verbosity: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:406:1: 406:41 (#0)",
        "source": "pub static mut blockSize100k: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:388:1: 388:41 (#0)",
        "source": "pub static mut keepInputFiles: Bool = 0;"
      },
      {
        "span": "bzip2.rs:426:1: 427:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      },
      {
        "span": "bzip2.rs:416:1: 416:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:429:1: 429:38 (#0)",
        "source": "pub static mut workFactor: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:402:1: 402:40 (#0)",
        "source": "pub static mut numFileNames: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:418:1: 418:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:424:1: 424:57 (#0)",
        "source": "pub static mut progNameReally: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:422:1: 422:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      },
      {
        "span": "bzip2.rs:410:1: 410:34 (#0)",
        "source": "pub static mut opMode: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:400:1: 400:32 (#0)",
        "source": "pub static mut noisy: Bool = 0;"
      },
      {
        "span": "bzip2.rs:414:1: 414:43 (#0)",
        "source": "pub static mut longestFileName: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:390:1: 390:36 (#0)",
        "source": "pub static mut smallMode: Bool = 0;"
      },
      {
        "span": "bzip2.rs:398:1: 398:40 (#0)",
        "source": "pub static mut unzFailsExist: Bool = 0;"
      },
      {
        "span": "bzip2.rs:396:1: 396:41 (#0)",
        "source": "pub static mut testFailsExist: Bool = 0;"
      },
      {
        "span": "bzip2.rs:404:1: 404:45 (#0)",
        "source": "pub static mut numFilesProcessed: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:408:1: 408:37 (#0)",
        "source": "pub static mut exitValue: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:394:1: 394:41 (#0)",
        "source": "pub static mut forceOverwrite: Bool = 0;"
      },
      {
        "span": "bzip2.rs:392:1: 392:50 (#0)",
        "source": "pub static mut deleteOutputOnInterrupt: Bool = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "bzip2.rs:2619:5: 2749:18 (#0)",
        "pieces": [
          "bzip2.rs:2619:5: 2749:18 (#0)"
        ],
        "num_lines": 133,
        "source": "let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut tmp: *mut Char = 0 as *mut Char;\n    let mut argList: *mut Cell = 0 as *mut Cell;\n    let mut aa: *mut Cell = 0 as *mut Cell;\n    let mut decode: Bool = 0;\n    /*-- Be really really really paranoid :-) --*/\n    if ::std::mem::size_of::<Int32>() as std::os::raw::c_ulong !=\n           4 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           ::std::mem::size_of::<UInt32>() as std::os::raw::c_ulong !=\n               4 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           ::std::mem::size_of::<Int16>() as std::os::raw::c_ulong !=\n               2 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           ::std::mem::size_of::<UInt16>() as std::os::raw::c_ulong !=\n               2 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           ::std::mem::size_of::<Char>() as std::os::raw::c_ulong !=\n               1 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong !=\n               1 as std::os::raw::c_int as std::os::raw::c_ulong {\n        configError();\n    }\n    /*-- Initialise --*/\n    outputHandleJustInCase =\n        0 as *mut FILE; /* avoid bogus warning from egcs-1.1.X */\n    smallMode = 0 as std::os::raw::c_int as Bool;\n    keepInputFiles = 0 as std::os::raw::c_int as Bool;\n    forceOverwrite = 0 as std::os::raw::c_int as Bool;\n    noisy = 1 as std::os::raw::c_int as Bool;\n    verbosity = 0 as std::os::raw::c_int;\n    blockSize100k = 9 as std::os::raw::c_int;\n    testFailsExist = 0 as std::os::raw::c_int as Bool;\n    unzFailsExist = 0 as std::os::raw::c_int as Bool;\n    numFileNames = 0 as std::os::raw::c_int;\n    numFilesProcessed = 0 as std::os::raw::c_int;\n    workFactor = 30 as std::os::raw::c_int;\n    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n    exitValue = 0 as std::os::raw::c_int;\n    j = 0 as std::os::raw::c_int;\n    i = j;\n    /*-- Set up signal handlers for mem access errors --*/\n    signal(11 as std::os::raw::c_int,\n           Some(mySIGSEGVorSIGBUScatcher as\n                    unsafe extern \"C\" fn(_: IntNative) -> ()));\n    signal(10 as std::os::raw::c_int,\n           Some(mySIGSEGVorSIGBUScatcher as\n                    unsafe extern \"C\" fn(_: IntNative) -> ()));\n    copyFileName(inName.as_mut_ptr(),\n                 b\"(none)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                     *mut Char);\n    copyFileName(outName.as_mut_ptr(),\n                 b\"(none)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                     *mut Char);\n    copyFileName(progNameReally.as_mut_ptr(),\n                 *argv.offset(0 as std::os::raw::c_int as isize));\n    progName =\n        &mut *progNameReally.as_mut_ptr().offset(0 as std::os::raw::c_int as isize) as\n            *mut Char;\n    tmp =\n        &mut *progNameReally.as_mut_ptr().offset(0 as std::os::raw::c_int as isize) as\n            *mut Char;\n    while *tmp as std::os::raw::c_int != '\\u{0}' as i32 {\n        if *tmp as std::os::raw::c_int == '/' as i32 {\n            progName = tmp.offset(1 as std::os::raw::c_int as isize)\n        }\n        tmp = tmp.offset(1)\n    }\n    /*-- Copy flags from env var BZIP2, and \n        expand filename wildcards in arg list.\n   --*/\n    argList = 0 as *mut Cell;\n    addFlagsFromEnvVar(&mut argList,\n                       b\"BZIP2\\x00\" as *const u8 as *const std::os::raw::c_char as\n                           *mut Char);\n    addFlagsFromEnvVar(&mut argList,\n                       b\"BZIP\\x00\" as *const u8 as *const std::os::raw::c_char as\n                           *mut Char);\n    i = 1 as std::os::raw::c_int;\n    while i <= argc - 1 as std::os::raw::c_int {\n        argList = snocString(argList, *argv.offset(i as isize));\n        i += 1\n    }\n    /*-- Find the length of the longest filename --*/\n    longestFileName = 7 as std::os::raw::c_int;\n    numFileNames = 0 as std::os::raw::c_int;\n    decode = 1 as std::os::raw::c_int as Bool;\n    aa = argList;\n    while !aa.is_null() {\n        if strcmp((*aa).name, b\"--\\x00\" as *const u8 as *const std::os::raw::c_char)\n               == 0 as std::os::raw::c_int {\n            decode = 0 as std::os::raw::c_int as Bool\n        } else if !(*(*aa).name.offset(0 as std::os::raw::c_int as isize) as\n                        std::os::raw::c_int == '-' as i32 &&\n                        decode as std::os::raw::c_int != 0) {\n            numFileNames += 1;\n            if longestFileName < strlen((*aa).name) as Int32 {\n                longestFileName = strlen((*aa).name) as Int32\n            }\n        }\n        aa = (*aa).link\n    }\n    /*-- Determine source modes; flag handling may change this too. --*/\n    if numFileNames == 0 as std::os::raw::c_int {\n        srcMode = 1 as std::os::raw::c_int\n    } else { srcMode = 3 as std::os::raw::c_int }\n    /*-- Determine what to do (compress/uncompress/test/cat). --*/\n   /*-- Note that subsequent flag handling may change this. --*/\n    opMode = 1 as std::os::raw::c_int;\n    if !strstr(progName,\n               b\"unzip\\x00\" as *const u8 as *const std::os::raw::c_char).is_null() ||\n           !strstr(progName,\n                   b\"UNZIP\\x00\" as *const u8 as *const std::os::raw::c_char).is_null()\n       {\n        opMode = 2 as std::os::raw::c_int\n    }\n    if !strstr(progName,\n               b\"z2cat\\x00\" as *const u8 as *const std::os::raw::c_char).is_null() ||\n           !strstr(progName,\n                   b\"Z2CAT\\x00\" as *const u8 as *const std::os::raw::c_char).is_null()\n           ||\n           !strstr(progName,\n                   b\"zcat\\x00\" as *const u8 as *const std::os::raw::c_char).is_null()\n           ||\n           !strstr(progName,\n                   b\"ZCAT\\x00\" as *const u8 as *const std::os::raw::c_char).is_null()\n       {\n        opMode = 2 as std::os::raw::c_int;\n        srcMode =\n            if numFileNames == 0 as std::os::raw::c_int {\n                1 as std::os::raw::c_int\n            } else { 2 as std::os::raw::c_int }\n    }\n    /*-- Look at the flags. --*/\n    aa = argList;",
        "sub_chunks": [],
        "live_in": [
          "mut argc: i32",
          "mut argv: *mut *mut i8"
        ],
        "live_out": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut i: i32",
          "mut j: i32",
          "mut tmp: *mut i8",
          "mut argList: *mut bzip2::zzzz",
          "mut aa: *mut bzip2::zzzz",
          "mut decode: u8",
          "var_name2: &str",
          "var_name1: &str"
        ]
      },
      {
        "chunk_id": 1,
        "span": "bzip2.rs:2750:5: 2897:6 (#0)",
        "pieces": [
          "bzip2.rs:2750:5: 2897:6 (#0)"
        ],
        "num_lines": 148,
        "source": "while !aa.is_null() {\n        if strcmp((*aa).name, b\"--\\x00\" as *const u8 as *const std::os::raw::c_char)\n               == 0 as std::os::raw::c_int {\n            break ;\n        }\n        if *(*aa).name.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               '-' as i32 &&\n               *(*aa).name.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int !=\n                   '-' as i32 {\n            j = 1 as std::os::raw::c_int;\n            while *(*aa).name.offset(j as isize) as std::os::raw::c_int !=\n                      '\\u{0}' as i32 {\n                match *(*aa).name.offset(j as isize) as std::os::raw::c_int {\n                    99 => { srcMode = 2 as std::os::raw::c_int }\n                    100 => { opMode = 2 as std::os::raw::c_int }\n                    122 => { opMode = 1 as std::os::raw::c_int }\n                    102 => { forceOverwrite = 1 as std::os::raw::c_int as Bool }\n                    116 => { opMode = 3 as std::os::raw::c_int }\n                    107 => { keepInputFiles = 1 as std::os::raw::c_int as Bool }\n                    115 => { smallMode = 1 as std::os::raw::c_int as Bool }\n                    113 => { noisy = 0 as std::os::raw::c_int as Bool }\n                    49 => { blockSize100k = 1 as std::os::raw::c_int }\n                    50 => { blockSize100k = 2 as std::os::raw::c_int }\n                    51 => { blockSize100k = 3 as std::os::raw::c_int }\n                    52 => { blockSize100k = 4 as std::os::raw::c_int }\n                    53 => { blockSize100k = 5 as std::os::raw::c_int }\n                    54 => { blockSize100k = 6 as std::os::raw::c_int }\n                    55 => { blockSize100k = 7 as std::os::raw::c_int }\n                    56 => { blockSize100k = 8 as std::os::raw::c_int }\n                    57 => { blockSize100k = 9 as std::os::raw::c_int }\n                    86 | 76 => { license(); }\n                    118 => { verbosity += 1 }\n                    104 => { usage(progName); exit(0 as std::os::raw::c_int); }\n                    _ => {\n                        fprintf(__stderrp,\n                                b\"%s: Bad flag `%s\\'\\n\\x00\" as *const u8 as\n                                    *const std::os::raw::c_char, progName,\n                                (*aa).name);\n                        usage(progName);\n                        exit(1 as std::os::raw::c_int);\n                    }\n                }\n                j += 1\n            }\n        }\n        aa = (*aa).link\n    }\n    /*-- And again ... --*/\n    aa = argList;\n    while !aa.is_null() {\n        if strcmp((*aa).name, b\"--\\x00\" as *const u8 as *const std::os::raw::c_char)\n               == 0 as std::os::raw::c_int {\n            break ;\n        }\n        if strcmp((*aa).name,\n                  b\"--stdout\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n               0 as std::os::raw::c_int {\n            srcMode = 2 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--decompress\\x00\" as *const u8 as\n                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {\n            opMode = 2 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--compress\\x00\" as *const u8 as\n                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {\n            opMode = 1 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--force\\x00\" as *const u8 as *const std::os::raw::c_char)\n                      == 0 as std::os::raw::c_int {\n            forceOverwrite = 1 as std::os::raw::c_int as Bool\n        } else if strcmp((*aa).name,\n                         b\"--test\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                      0 as std::os::raw::c_int {\n            opMode = 3 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--keep\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                      0 as std::os::raw::c_int {\n            keepInputFiles = 1 as std::os::raw::c_int as Bool\n        } else if strcmp((*aa).name,\n                         b\"--small\\x00\" as *const u8 as *const std::os::raw::c_char)\n                      == 0 as std::os::raw::c_int {\n            smallMode = 1 as std::os::raw::c_int as Bool\n        } else if strcmp((*aa).name,\n                         b\"--quiet\\x00\" as *const u8 as *const std::os::raw::c_char)\n                      == 0 as std::os::raw::c_int {\n            noisy = 0 as std::os::raw::c_int as Bool\n        } else if strcmp((*aa).name,\n                         b\"--version\\x00\" as *const u8 as *const std::os::raw::c_char)\n                      == 0 as std::os::raw::c_int {\n            license();\n        } else if strcmp((*aa).name,\n                         b\"--license\\x00\" as *const u8 as *const std::os::raw::c_char)\n                      == 0 as std::os::raw::c_int {\n            license();\n        } else if strcmp((*aa).name,\n                         b\"--exponential\\x00\" as *const u8 as\n                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {\n            workFactor = 1 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--repetitive-best\\x00\" as *const u8 as\n                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {\n            redundant((*aa).name);\n        } else if strcmp((*aa).name,\n                         b\"--repetitive-fast\\x00\" as *const u8 as\n                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {\n            redundant((*aa).name);\n        } else if strcmp((*aa).name,\n                         b\"--fast\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                      0 as std::os::raw::c_int {\n            blockSize100k = 1 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--best\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                      0 as std::os::raw::c_int {\n            blockSize100k = 9 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--verbose\\x00\" as *const u8 as *const std::os::raw::c_char)\n                      == 0 as std::os::raw::c_int {\n            verbosity += 1\n        } else if strcmp((*aa).name,\n                         b\"--help\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                      0 as std::os::raw::c_int {\n            usage(progName);\n            exit(0 as std::os::raw::c_int);\n        } else {\n            if strncmp((*aa).name,\n                       b\"--\\x00\" as *const u8 as *const std::os::raw::c_char,\n                       2 as std::os::raw::c_int as std::os::raw::c_ulong) == 0 as std::os::raw::c_int\n               {\n                fprintf(__stderrp,\n                        b\"%s: Bad flag `%s\\'\\n\\x00\" as *const u8 as\n                            *const std::os::raw::c_char, progName, (*aa).name);\n                usage(progName);\n                exit(1 as std::os::raw::c_int);\n            }\n        }\n        aa = (*aa).link\n    }\n    if verbosity > 4 as std::os::raw::c_int { verbosity = 4 as std::os::raw::c_int }\n    if opMode == 1 as std::os::raw::c_int && smallMode as std::os::raw::c_int != 0 &&\n           blockSize100k > 2 as std::os::raw::c_int {\n        blockSize100k = 2 as std::os::raw::c_int\n    }\n    if opMode == 3 as std::os::raw::c_int && srcMode == 2 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"%s: -c and -t cannot be used together.\\n\\x00\" as *const u8\n                    as *const std::os::raw::c_char, progName);\n        exit(1 as std::os::raw::c_int);\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut j: i32",
          "mut argList: *mut bzip2::zzzz",
          "mut aa: *mut bzip2::zzzz"
        ],
        "live_out": [
          "mut j: i32",
          "mut argList: *mut bzip2::zzzz",
          "mut aa: *mut bzip2::zzzz"
        ]
      },
      {
        "chunk_id": 2,
        "span": "bzip2.rs:2898:5: 2982:10 (#0)",
        "pieces": [
          "bzip2.rs:2898:5: 2982:10 (#0)"
        ],
        "num_lines": 99,
        "source": "if srcMode == 2 as std::os::raw::c_int && numFileNames == 0 as std::os::raw::c_int {\n        srcMode = 1 as std::os::raw::c_int\n    }\n    if opMode != 1 as std::os::raw::c_int { blockSize100k = 0 as std::os::raw::c_int }\n    if srcMode == 3 as std::os::raw::c_int {\n        signal(2 as std::os::raw::c_int,\n               Some(mySignalCatcher as\n                        unsafe extern \"C\" fn(_: IntNative) -> ()));\n        signal(15 as std::os::raw::c_int,\n               Some(mySignalCatcher as\n                        unsafe extern \"C\" fn(_: IntNative) -> ()));\n        signal(1 as std::os::raw::c_int,\n               Some(mySignalCatcher as\n                        unsafe extern \"C\" fn(_: IntNative) -> ()));\n    }\n    if opMode == 1 as std::os::raw::c_int {\n        if srcMode == 1 as std::os::raw::c_int {\n            compress(0 as *mut Char);\n        } else {\n            decode = 1 as std::os::raw::c_int as Bool;\n            aa = argList;\n            while !aa.is_null() {\n                if strcmp((*aa).name,\n                          b\"--\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                       0 as std::os::raw::c_int {\n                    decode = 0 as std::os::raw::c_int as Bool\n                } else if !(*(*aa).name.offset(0 as std::os::raw::c_int as isize) as\n                                std::os::raw::c_int == '-' as i32 &&\n                                decode as std::os::raw::c_int != 0) {\n                    numFilesProcessed += 1;\n                    compress((*aa).name);\n                }\n                aa = (*aa).link\n            }\n        }\n    } else if opMode == 2 as std::os::raw::c_int {\n        unzFailsExist = 0 as std::os::raw::c_int as Bool;\n        if srcMode == 1 as std::os::raw::c_int {\n            uncompress(0 as *mut Char);\n        } else {\n            decode = 1 as std::os::raw::c_int as Bool;\n            aa = argList;\n            while !aa.is_null() {\n                if strcmp((*aa).name,\n                          b\"--\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                       0 as std::os::raw::c_int {\n                    decode = 0 as std::os::raw::c_int as Bool\n                } else if !(*(*aa).name.offset(0 as std::os::raw::c_int as isize) as\n                                std::os::raw::c_int == '-' as i32 &&\n                                decode as std::os::raw::c_int != 0) {\n                    numFilesProcessed += 1;\n                    uncompress((*aa).name);\n                }\n                aa = (*aa).link\n            }\n        }\n        if unzFailsExist != 0 { setExit(2 as std::os::raw::c_int); exit(exitValue); }\n    } else {\n        testFailsExist = 0 as std::os::raw::c_int as Bool;\n        if srcMode == 1 as std::os::raw::c_int {\n            testf(0 as *mut Char);\n        } else {\n            decode = 1 as std::os::raw::c_int as Bool;\n            aa = argList;\n            while !aa.is_null() {\n                if strcmp((*aa).name,\n                          b\"--\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                       0 as std::os::raw::c_int {\n                    decode = 0 as std::os::raw::c_int as Bool\n                } else if !(*(*aa).name.offset(0 as std::os::raw::c_int as isize) as\n                                std::os::raw::c_int == '-' as i32 &&\n                                decode as std::os::raw::c_int != 0) {\n                    numFilesProcessed += 1;\n                    testf((*aa).name);\n                }\n                aa = (*aa).link\n            }\n        }\n        if testFailsExist != 0 {\n            if noisy != 0 {\n                fprintf(__stderrp,\n                        b\"\\nYou can use the `bzip2recover\\' program to attempt to recover\\ndata from undamaged sections of corrupted files.\\n\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char);\n            }\n            setExit(2 as std::os::raw::c_int);\n            exit(exitValue);\n        }\n    }\n    /* Free the argument list memory to mollify leak detectors \n      (eg) Purify, Checker.  Serves no other useful purpose.\n   */\n    aa = argList;\n    while !aa.is_null() {\n        let mut aa2: *mut Cell = (*aa).link;\n        if !(*aa).name.is_null() { free((*aa).name as *mut std::os::raw::c_void); }\n        free(aa as *mut std::os::raw::c_void);\n        aa = aa2\n    }\n    return exitValue;",
        "sub_chunks": [],
        "live_in": [
          "mut argList: *mut bzip2::zzzz",
          "mut aa: *mut bzip2::zzzz",
          "mut decode: u8"
        ],
        "live_out": []
      }
    ]
  },
  {
    "func_defid": "DefId(0:329 ~ c2rust_out[3c70]::bzip2recover::readError)",
    "span": "bzip2recover.rs:125:1: 136:2 (#0)",
    "pieces": [
      "bzip2recover.rs:125:1: 136:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn readError() {\n    fprintf(__stderrp,\n            b\"%s: I/O error reading `%s\\', possible reason follows.\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr(),\n            inFileName.as_mut_ptr());\n    perror(progName.as_mut_ptr());\n    fprintf(__stderrp,\n            b\"%s: warning: output file(s) may be incomplete.\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());\n    exit(1 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:399 ~ c2rust_out[3c70]::bzip2recover::bsClose)",
        "span": "bzip2recover.rs:248:18: 248:30 (#0)",
        "source": "readError();"
      },
      {
        "caller": "DefId(0:398 ~ c2rust_out[3c70]::bzip2recover::bsGetBit)",
        "span": "bzip2recover.rs:222:57: 222:69 (#0)",
        "source": "readError();"
      }
    ],
    "globals": [
      {
        "span": "bzip2recover.rs:112:1: 112:53 (#0)",
        "source": "pub static mut inFileName: [Char; 2000] = [0; 2000];"
      },
      {
        "span": "bzip2recover.rs:115:1: 115:51 (#0)",
        "source": "pub static mut progName: [Char; 2000] = [0; 2000];"
      }
    ],
    "imports": [
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:337 ~ c2rust_out[3c70]::bzip2recover::bsClose)",
    "span": "bzip2recover.rs:231:1: 251:2 (#0)",
    "pieces": [
      "bzip2recover.rs:231:1: 251:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn bsClose(mut bs: *mut BitStream) {\n    let mut retVal: Int32 = 0;\n    if (*bs).mode as std::os::raw::c_int == 'w' as i32 {\n        while (*bs).buffLive < 8 as std::os::raw::c_int {\n            (*bs).buffLive += 1;\n            (*bs).buffer <<= 1 as std::os::raw::c_int\n        }\n        retVal = putc((*bs).buffer as UChar as std::os::raw::c_int, (*bs).handle);\n        if retVal == -(1 as std::os::raw::c_int) { writeError(); }\n        bytesOut = bytesOut.wrapping_add(1);\n        retVal = fflush((*bs).handle);\n        if retVal == -(1 as std::os::raw::c_int) { writeError(); }\n    }\n    retVal = fclose((*bs).handle);\n    if retVal == -(1 as std::os::raw::c_int) {\n        if (*bs).mode as std::os::raw::c_int == 'w' as i32 {\n            writeError();\n        } else { readError(); }\n    }\n    free(bs as *mut std::os::raw::c_void);\n}",
    "calls": [
      {
        "caller": "DefId(0:415 ~ c2rust_out[3c70]::bzip2recover::main_0)",
        "span": "bzip2recover.rs:434:5: 434:19 (#0)",
        "source": "bsClose(bsIn);"
      }
    ],
    "globals": [
      {
        "span": "bzip2recover.rs:117:1: 117:80 (#0)",
        "source": "pub static mut bytesOut: MaybeUInt64 = 0 as std::os::raw::c_int as MaybeUInt64;"
      }
    ],
    "imports": [
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:331 ~ c2rust_out[3c70]::bzip2recover::mallocFail)",
    "span": "bzip2recover.rs:153:1: 158:2 (#0)",
    "pieces": [
      "bzip2recover.rs:153:1: 158:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn mallocFail(mut n: Int32) {\n    fprintf(__stderrp,\n            b\"%s: malloc failed on request for %d bytes.\\n\\x00\" as *const u8\n                as *const std::os::raw::c_char, progName.as_mut_ptr(), n);\n    fprintf(__stderrp,\n            b\"%s: warning: output file(s) may be incomplete.\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());\n    exit(1 as std::os::raw::c_int);\n}",
    "calls": [],
    "globals": [
      {
        "span": "bzip2recover.rs:115:1: 115:51 (#0)",
        "source": "pub static mut progName: [Char; 2000] = [0; 2000];"
      }
    ],
    "imports": [
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:334 ~ c2rust_out[3c70]::bzip2recover::bsOpenWriteStream)",
    "span": "bzip2recover.rs:185:1: 194:2 (#0)",
    "pieces": [
      "bzip2recover.rs:185:1: 194:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn bsOpenWriteStream(mut stream: *mut FILE)\n -> *mut BitStream {\n    let mut bs: *mut BitStream =\n        malloc(::std::mem::size_of::<BitStream>() as std::os::raw::c_ulong) as\n            *mut BitStream;\n    if bs.is_null() {\n        mallocFail(::std::mem::size_of::<BitStream>() as std::os::raw::c_ulong as\n                       Int32);\n    }\n    (*bs).handle = stream;\n    (*bs).buffer = 0 as std::os::raw::c_int;\n    (*bs).buffLive = 0 as std::os::raw::c_int;\n    (*bs).mode = 'w' as i32 as Char;\n    return bs;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:21 ~ c2rust_out[3c70]::blocksort::fallbackQSort3)",
    "span": "blocksort.rs:192:1: 341:2 (#0)",
    "pieces": [
      "blocksort.rs:192:1: 341:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 150,
    "source": "unsafe extern \"C\" fn fallbackQSort3(mut fmap: *mut UInt32,\n                                    mut eclass: *mut UInt32, mut loSt: Int32,\n                                    mut hiSt: Int32) {\n    let mut unLo: Int32 = 0;\n    let mut unHi: Int32 = 0;\n    let mut ltLo: Int32 = 0;\n    let mut gtHi: Int32 = 0;\n    let mut n: Int32 = 0;\n    let mut m: Int32 = 0;\n    let mut sp: Int32 = 0;\n    let mut lo: Int32 = 0;\n    let mut hi: Int32 = 0;\n    let mut med: UInt32 = 0;\n    let mut r: UInt32 = 0;\n    let mut r3: UInt32 = 0;\n    let mut stackLo: [Int32; 100] = [0; 100];\n    let mut stackHi: [Int32; 100] = [0; 100];\n    r = 0 as std::os::raw::c_int as UInt32;\n    sp = 0 as std::os::raw::c_int;\n    stackLo[sp as usize] = loSt;\n    stackHi[sp as usize] = hiSt;\n    sp += 1;\n    while sp > 0 as std::os::raw::c_int {\n        if !(sp < 100 as std::os::raw::c_int - 1 as std::os::raw::c_int) {\n            BZ2_bz__AssertH__fail(1004 as std::os::raw::c_int);\n        }\n        sp -= 1;\n        lo = stackLo[sp as usize];\n        hi = stackHi[sp as usize];\n        if hi - lo < 10 as std::os::raw::c_int {\n            fallbackSimpleSort(fmap, eclass, lo, hi);\n        } else {\n            /* Random partitioning.  Median of 3 sometimes fails to\n         avoid bad cases.  Median of 9 seems to help but \n         looks rather expensive.  This too seems to work but\n         is cheaper.  Guidance for the magic constants \n         7621 and 32768 is taken from Sedgewick's algorithms\n         book, chapter 35.\n      */\n            r =\n                r.wrapping_mul(7621 as std::os::raw::c_int as\n                                   std::os::raw::c_uint).wrapping_add(1 as std::os::raw::c_int\n                                                                  as\n                                                                  std::os::raw::c_uint).wrapping_rem(32768\n                                                                                                 as\n                                                                                                 std::os::raw::c_int\n                                                                                                 as\n                                                                                                 std::os::raw::c_uint);\n            r3 = r.wrapping_rem(3 as std::os::raw::c_int as std::os::raw::c_uint);\n            if r3 == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n                med = *eclass.offset(*fmap.offset(lo as isize) as isize)\n            } else if r3 == 1 as std::os::raw::c_int as std::os::raw::c_uint {\n                med =\n                    *eclass.offset(*fmap.offset((lo + hi >> 1 as std::os::raw::c_int)\n                                                    as isize) as isize)\n            } else {\n                med = *eclass.offset(*fmap.offset(hi as isize) as isize)\n            }\n            ltLo = lo;\n            unLo = ltLo;\n            gtHi = hi;\n            unHi = gtHi;\n            loop  {\n                while !(unLo > unHi) {\n                    n =\n                        *eclass.offset(*fmap.offset(unLo as isize) as isize)\n                            as Int32 - med as Int32;\n                    if n == 0 as std::os::raw::c_int {\n                        let mut zztmp: Int32 =\n                            *fmap.offset(unLo as isize) as Int32;\n                        *fmap.offset(unLo as isize) =\n                            *fmap.offset(ltLo as isize);\n                        *fmap.offset(ltLo as isize) = zztmp as UInt32;\n                        ltLo += 1;\n                        unLo += 1\n                    } else { if n > 0 as std::os::raw::c_int { break ; } unLo += 1 }\n                }\n                while !(unLo > unHi) {\n                    n =\n                        *eclass.offset(*fmap.offset(unHi as isize) as isize)\n                            as Int32 - med as Int32;\n                    if n == 0 as std::os::raw::c_int {\n                        let mut zztmp_0: Int32 =\n                            *fmap.offset(unHi as isize) as Int32;\n                        *fmap.offset(unHi as isize) =\n                            *fmap.offset(gtHi as isize);\n                        *fmap.offset(gtHi as isize) = zztmp_0 as UInt32;\n                        gtHi -= 1;\n                        unHi -= 1\n                    } else { if n < 0 as std::os::raw::c_int { break ; } unHi -= 1 }\n                }\n                if unLo > unHi { break ; }\n                let mut zztmp_1: Int32 = *fmap.offset(unLo as isize) as Int32;\n                *fmap.offset(unLo as isize) = *fmap.offset(unHi as isize);\n                *fmap.offset(unHi as isize) = zztmp_1 as UInt32;\n                unLo += 1;\n                unHi -= 1\n            }\n            if gtHi < ltLo { continue ; }\n            n =\n                if ltLo - lo < unLo - ltLo {\n                    (ltLo) - lo\n                } else { (unLo) - ltLo };\n            let mut yyp1: Int32 = lo;\n            let mut yyp2: Int32 = unLo - n;\n            let mut yyn: Int32 = n;\n            while yyn > 0 as std::os::raw::c_int {\n                let mut zztmp_2: Int32 = *fmap.offset(yyp1 as isize) as Int32;\n                *fmap.offset(yyp1 as isize) = *fmap.offset(yyp2 as isize);\n                *fmap.offset(yyp2 as isize) = zztmp_2 as UInt32;\n                yyp1 += 1;\n                yyp2 += 1;\n                yyn -= 1\n            }\n            m =\n                if hi - gtHi < gtHi - unHi {\n                    (hi) - gtHi\n                } else { (gtHi) - unHi };\n            let mut yyp1_0: Int32 = unLo;\n            let mut yyp2_0: Int32 = hi - m + 1 as std::os::raw::c_int;\n            let mut yyn_0: Int32 = m;\n            while yyn_0 > 0 as std::os::raw::c_int {\n                let mut zztmp_3: Int32 =\n                    *fmap.offset(yyp1_0 as isize) as Int32;\n                *fmap.offset(yyp1_0 as isize) = *fmap.offset(yyp2_0 as isize);\n                *fmap.offset(yyp2_0 as isize) = zztmp_3 as UInt32;\n                yyp1_0 += 1;\n                yyp2_0 += 1;\n                yyn_0 -= 1\n            }\n            n = lo + unLo - ltLo - 1 as std::os::raw::c_int;\n            m = hi - (gtHi - unHi) + 1 as std::os::raw::c_int;\n            if n - lo > hi - m {\n                stackLo[sp as usize] = lo;\n                stackHi[sp as usize] = n;\n                sp += 1;\n                stackLo[sp as usize] = m;\n                stackHi[sp as usize] = hi;\n                sp += 1\n            } else {\n                stackLo[sp as usize] = m;\n                stackHi[sp as usize] = hi;\n                sp += 1;\n                stackLo[sp as usize] = lo;\n                stackHi[sp as usize] = n;\n                sp += 1\n            }\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:26 ~ c2rust_out[3c70]::blocksort::fallbackSort)",
        "span": "blocksort.rs:483:13: 483:48 (#0)",
        "source": "fallbackQSort3(fmap, eclass, l, r);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:21:1: 21:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:436 ~ c2rust_out[3c70]::bzlib::BZ2_bzDecompress)",
    "span": "bzlib.rs:1564:1: 1621:2 (#0)",
    "pieces": [
      "bzlib.rs:1564:1: 1621:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 60,
    "source": "pub unsafe extern \"C\" fn BZ2_bzDecompress(mut strm: *mut bz_stream)\n -> std::os::raw::c_int {\n    let mut corrupt: Bool = 0;\n    let mut s: *mut DState = 0 as *mut DState;\n    if strm.is_null() { return -(2 as std::os::raw::c_int) }\n    s = (*strm).state as *mut DState;\n    if s.is_null() { return -(2 as std::os::raw::c_int) }\n    if (*s).strm != strm { return -(2 as std::os::raw::c_int) }\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        if (*s).state == 1 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }\n        if (*s).state == 2 as std::os::raw::c_int {\n            if (*s).smallDecompress != 0 {\n                corrupt = unRLE_obuf_to_output_SMALL(s)\n            } else { corrupt = unRLE_obuf_to_output_FAST(s) }\n            if corrupt != 0 { return -(4 as std::os::raw::c_int) }\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int &&\n                   (*s).state_out_len == 0 as std::os::raw::c_int {\n                (*s).calculatedBlockCRC = !(*s).calculatedBlockCRC;\n                if (*s).verbosity >= 3 as std::os::raw::c_int {\n                    fprintf(__stderrp,\n                            b\" {0x%08x, 0x%08x}\\x00\" as *const u8 as\n                                *const std::os::raw::c_char, (*s).storedBlockCRC,\n                            (*s).calculatedBlockCRC);\n                }\n                if (*s).verbosity >= 2 as std::os::raw::c_int {\n                    fprintf(__stderrp,\n                            b\"]\\x00\" as *const u8 as *const std::os::raw::c_char);\n                }\n                if (*s).calculatedBlockCRC != (*s).storedBlockCRC {\n                    return -(4 as std::os::raw::c_int)\n                }\n                (*s).calculatedCombinedCRC =\n                    (*s).calculatedCombinedCRC << 1 as std::os::raw::c_int |\n                        (*s).calculatedCombinedCRC >> 31 as std::os::raw::c_int;\n                (*s).calculatedCombinedCRC ^= (*s).calculatedBlockCRC;\n                (*s).state = 14 as std::os::raw::c_int\n            } else { return 0 as std::os::raw::c_int }\n        }\n        if (*s).state >= 10 as std::os::raw::c_int {\n            let mut r: Int32 = BZ2_decompress(s);\n            if r == 4 as std::os::raw::c_int {\n                if (*s).verbosity >= 3 as std::os::raw::c_int {\n                    fprintf(__stderrp,\n                            b\"\\n    combined CRCs: stored = 0x%08x, computed = 0x%08x\\x00\"\n                                as *const u8 as *const std::os::raw::c_char,\n                            (*s).storedCombinedCRC,\n                            (*s).calculatedCombinedCRC);\n                }\n                if (*s).calculatedCombinedCRC != (*s).storedCombinedCRC {\n                    return -(4 as std::os::raw::c_int)\n                }\n                return r\n            }\n            if (*s).state != 2 as std::os::raw::c_int { return r }\n        }\n    }\n    if 0 as std::os::raw::c_int == 0 { BZ2_bz__AssertH__fail(6001 as std::os::raw::c_int); }\n    return 0 as std::os::raw::c_int;\n    /*NOTREACHED*/\n}",
    "calls": [
      {
        "caller": "DefId(0:533 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
        "span": "bzlib.rs:2165:5: 2165:43 (#0)",
        "source": "let ret = BZ2_bzDecompress(&mut strm);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:333 ~ c2rust_out[3c70]::bzip2recover::bsOpenReadStream)",
    "span": "bzip2recover.rs:174:1: 182:2 (#0)",
    "pieces": [
      "bzip2recover.rs:174:1: 182:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn bsOpenReadStream(mut stream: *mut FILE)\n -> *mut BitStream {\n    let mut bs: *mut BitStream =\n        malloc(::std::mem::size_of::<BitStream>() as std::os::raw::c_ulong) as\n            *mut BitStream;\n    if bs.is_null() {\n        mallocFail(::std::mem::size_of::<BitStream>() as std::os::raw::c_ulong as\n                       Int32);\n    }\n    (*bs).handle = stream;\n    (*bs).buffer = 0 as std::os::raw::c_int;\n    (*bs).buffLive = 0 as std::os::raw::c_int;\n    (*bs).mode = 'r' as i32 as Char;\n    return bs;\n}",
    "calls": [
      {
        "caller": "DefId(0:415 ~ c2rust_out[3c70]::bzip2recover::main_0)",
        "span": "bzip2recover.rs:363:5: 363:41 (#0)",
        "source": "let bsIn = bsOpenReadStream(inFile);"
      },
      {
        "caller": "DefId(0:415 ~ c2rust_out[3c70]::bzip2recover::main_0)",
        "span": "bzip2recover.rs:455:5: 455:41 (#0)",
        "source": "let bsIn = bsOpenReadStream(inFile);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:353 ~ c2rust_out[3c70]::bzip2recover::main_0)",
    "span": "bzip2recover.rs:291:1: 563:2 (#0)",
    "pieces": [
      "bzip2recover.rs:291:1: 292:4 (#0)",
      "bzip2recover.rs:442:1: 442:4 (#0)",
      "bzip2recover.rs:563:1: 563:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 4,
    "source": "unsafe fn main_0(mut argc: Int32, mut argv: *mut *mut Char) -> Int32 {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:416 ~ c2rust_out[3c70]::bzip2recover::main)",
        "span": "bzip2recover.rs:572:21: 574:6 (#0)",
        "source": "unsafe {\n        main_0(arg_count as Int32, c_args.as_ptr() as *mut *mut Char)\n    }"
      }
    ],
    "globals": [
      {
        "span": "bzip2recover.rs:284:1: 284:58 (#0)",
        "source": "pub static mut bStart: [MaybeUInt64; 50000] = [0; 50000];"
      },
      {
        "span": "bzip2recover.rs:114:1: 114:54 (#0)",
        "source": "pub static mut outFileName: [Char; 2000] = [0; 2000];"
      },
      {
        "span": "bzip2recover.rs:115:1: 115:51 (#0)",
        "source": "pub static mut progName: [Char; 2000] = [0; 2000];"
      },
      {
        "span": "bzip2recover.rs:112:1: 112:53 (#0)",
        "source": "pub static mut inFileName: [Char; 2000] = [0; 2000];"
      }
    ],
    "imports": [
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "bzip2recover.rs:292:5: 441:6 (#0)",
        "pieces": [
          "bzip2recover.rs:292:5: 441:6 (#0)"
        ],
        "num_lines": 150,
        "source": "let mut inFile: *mut FILE = 0 as *mut FILE;\n    let mut outFile: *mut FILE = 0 as *mut FILE;\n    let mut bsIn: *mut BitStream = 0 as *mut BitStream;\n    let mut bsWr: *mut BitStream = 0 as *mut BitStream;\n    let mut b: Int32 = 0;\n    let mut wrBlock: Int32 = 0;\n    let mut currBlock: Int32 = 0;\n    let mut rbCtr: Int32 = 0;\n    let mut bitsRead: MaybeUInt64 = 0;\n    let mut buffHi: UInt32 = 0;\n    let mut buffLo: UInt32 = 0;\n    let mut blockCRC: UInt32 = 0;\n    let mut p: *mut Char = 0 as *mut Char;\n    strncpy(progName.as_mut_ptr(), *argv.offset(0 as std::os::raw::c_int as isize),\n            (2000 as std::os::raw::c_int - 1 as std::os::raw::c_int) as std::os::raw::c_ulong);\n    progName[(2000 as std::os::raw::c_int - 1 as std::os::raw::c_int) as usize] =\n        '\\u{0}' as i32 as Char;\n    outFileName[0 as std::os::raw::c_int as usize] = 0 as std::os::raw::c_int as Char;\n    inFileName[0 as std::os::raw::c_int as usize] =\n        outFileName[0 as std::os::raw::c_int as usize];\n    fprintf(__stderrp,\n            b\"bzip2recover 1.0.8: extracts blocks from damaged .bz2 files.\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char);\n    if argc != 2 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"%s: usage is `%s damaged_file_name\\'.\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, progName.as_mut_ptr(),\n                progName.as_mut_ptr());\n        match ::std::mem::size_of::<MaybeUInt64>() as std::os::raw::c_ulong {\n            8 => {\n                fprintf(__stderrp,\n                        b\"\\trestrictions on size of recovered file: None\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char);\n            }\n            4 => {\n                fprintf(__stderrp,\n                        b\"\\trestrictions on size of recovered file: 512 MB\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char);\n                fprintf(__stderrp,\n                        b\"\\tto circumvent, recompile with MaybeUInt64 as an\\n\\tunsigned 64-bit int.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char);\n            }\n            _ => {\n                fprintf(__stderrp,\n                        b\"\\tsizeof(MaybeUInt64) is not 4 or 8 -- configuration error.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char);\n            }\n        }\n        exit(1 as std::os::raw::c_int);\n    }\n    if strlen(*argv.offset(1 as std::os::raw::c_int as isize)) >=\n           (2000 as std::os::raw::c_int - 20 as std::os::raw::c_int) as std::os::raw::c_ulong {\n        fprintf(__stderrp,\n                b\"%s: supplied filename is suspiciously (>= %d chars) long.  Bye!\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char,\n                progName.as_mut_ptr(),\n                strlen(*argv.offset(1 as std::os::raw::c_int as isize)) as\n                    std::os::raw::c_int);\n        exit(1 as std::os::raw::c_int);\n    }\n    strcpy(inFileName.as_mut_ptr(), *argv.offset(1 as std::os::raw::c_int as isize));\n    inFile =\n        fopen(inFileName.as_mut_ptr(),\n              b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n    if inFile.is_null() {\n        fprintf(__stderrp,\n                b\"%s: can\\'t read `%s\\'\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, progName.as_mut_ptr(),\n                inFileName.as_mut_ptr());\n        exit(1 as std::os::raw::c_int);\n    }\n    bsIn = bsOpenReadStream(inFile);\n    fprintf(__stderrp,\n            b\"%s: searching for block boundaries ...\\n\\x00\" as *const u8 as\n                *const std::os::raw::c_char, progName.as_mut_ptr());\n    bitsRead = 0 as std::os::raw::c_int as MaybeUInt64;\n    buffLo = 0 as std::os::raw::c_int as UInt32;\n    buffHi = buffLo;\n    currBlock = 0 as std::os::raw::c_int;\n    bStart[currBlock as usize] = 0 as std::os::raw::c_int as MaybeUInt64;\n    rbCtr = 0 as std::os::raw::c_int;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        b = bsGetBit(bsIn);\n        bitsRead = bitsRead.wrapping_add(1);\n        if b == 2 as std::os::raw::c_int {\n            if bitsRead >= bStart[currBlock as usize] &&\n                   bitsRead.wrapping_sub(bStart[currBlock as usize]) >=\n                       40 as std::os::raw::c_int as std::os::raw::c_ulonglong {\n                bEnd[currBlock as usize] =\n                    bitsRead.wrapping_sub(1 as std::os::raw::c_int as\n                                              std::os::raw::c_ulonglong);\n                if currBlock > 0 as std::os::raw::c_int {\n                    fprintf(__stderrp,\n                            b\"   block %d runs from %Lu to %Lu (incomplete)\\n\\x00\"\n                                as *const u8 as *const std::os::raw::c_char,\n                            currBlock, bStart[currBlock as usize],\n                            bEnd[currBlock as usize]);\n                }\n            } else { currBlock -= 1 }\n            break ;\n        } else {\n            buffHi = buffHi << 1 as std::os::raw::c_int | buffLo >> 31 as std::os::raw::c_int;\n            buffLo =\n                buffLo << 1 as std::os::raw::c_int |\n                    (b & 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n            if (buffHi & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as\n                   std::os::raw::c_ulong == 0x3141 as std::os::raw::c_ulong &&\n                   buffLo as std::os::raw::c_ulong == 0x59265359 as std::os::raw::c_ulong ||\n                   (buffHi & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as\n                       std::os::raw::c_ulong == 0x1772 as std::os::raw::c_ulong &&\n                       buffLo as std::os::raw::c_ulong == 0x45385090 as std::os::raw::c_ulong\n               {\n                if bitsRead > 49 as std::os::raw::c_int as std::os::raw::c_ulonglong {\n                    bEnd[currBlock as usize] =\n                        bitsRead.wrapping_sub(49 as std::os::raw::c_int as\n                                                  std::os::raw::c_ulonglong)\n                } else {\n                    bEnd[currBlock as usize] = 0 as std::os::raw::c_int as MaybeUInt64\n                }\n                if currBlock > 0 as std::os::raw::c_int &&\n                       bEnd[currBlock as\n                                usize].wrapping_sub(bStart[currBlock as\n                                                               usize]) >=\n                           130 as std::os::raw::c_int as std::os::raw::c_ulonglong {\n                    fprintf(__stderrp,\n                            b\"   block %d runs from %Lu to %Lu\\n\\x00\" as\n                                *const u8 as *const std::os::raw::c_char,\n                            rbCtr + 1 as std::os::raw::c_int,\n                            bStart[currBlock as usize],\n                            bEnd[currBlock as usize]);\n                    rbStart[rbCtr as usize] = bStart[currBlock as usize];\n                    rbEnd[rbCtr as usize] = bEnd[currBlock as usize];\n                    rbCtr += 1\n                }\n                if currBlock >= 50000 as std::os::raw::c_int {\n                    tooManyBlocks(50000 as std::os::raw::c_int);\n                }\n                currBlock += 1;\n                bStart[currBlock as usize] = bitsRead\n            }\n        }\n    }\n    bsClose(bsIn);\n    /*-- identified blocks run from 1 to rbCtr inclusive. --*/\n    if rbCtr < 1 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"%s: sorry, I couldn\\'t find any block boundaries.\\n\\x00\" as\n                    *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());\n        exit(1 as std::os::raw::c_int);\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut argc: i32",
          "mut argv: *mut *mut i8"
        ],
        "live_out": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut inFile: *mut blocksort::__sFILE",
          "mut outFile: *mut blocksort::__sFILE",
          "mut bsIn: *mut bzip2recover::BitStream",
          "mut bsWr: *mut bzip2recover::BitStream",
          "mut b: i32",
          "mut wrBlock: i32",
          "mut currBlock: i32",
          "mut rbCtr: i32",
          "mut bitsRead: u64",
          "mut buffHi: u32",
          "mut buffLo: u32",
          "mut blockCRC: u32",
          "mut p: *mut i8",
          "bsIn: *mut bzip2recover::BitStream"
        ]
      },
      {
        "chunk_id": 1,
        "span": "bzip2recover.rs:442:5: 562:37 (#0)",
        "pieces": [
          "bzip2recover.rs:442:5: 562:37 (#0)"
        ],
        "num_lines": 121,
        "source": "fprintf(__stderrp,\n            b\"%s: splitting into blocks\\n\\x00\" as *const u8 as\n                *const std::os::raw::c_char, progName.as_mut_ptr());\n    inFile =\n        fopen(inFileName.as_mut_ptr(),\n              b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n    if inFile.is_null() {\n        fprintf(__stderrp,\n                b\"%s: can\\'t open `%s\\'\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, progName.as_mut_ptr(),\n                inFileName.as_mut_ptr());\n        exit(1 as std::os::raw::c_int);\n    }\n    bsIn = bsOpenReadStream(inFile);\n    /*-- placate gcc's dataflow analyser --*/\n    blockCRC = 0 as std::os::raw::c_int as UInt32;\n    bsWr = 0 as *mut BitStream;\n    bitsRead = 0 as std::os::raw::c_int as MaybeUInt64;\n    outFile = 0 as *mut FILE;\n    wrBlock = 0 as std::os::raw::c_int;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        b = bsGetBit(bsIn);\n        if b == 2 as std::os::raw::c_int { break ; }\n        buffHi = buffHi << 1 as std::os::raw::c_int | buffLo >> 31 as std::os::raw::c_int;\n        buffLo =\n            buffLo << 1 as std::os::raw::c_int |\n                (b & 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n        if bitsRead ==\n               (47 as std::os::raw::c_int as\n                    std::os::raw::c_ulonglong).wrapping_add(rbStart[wrBlock as usize])\n           {\n            blockCRC =\n                buffHi << 16 as std::os::raw::c_int | buffLo >> 16 as std::os::raw::c_int\n        }\n        if !outFile.is_null() && bitsRead >= rbStart[wrBlock as usize] &&\n               bitsRead <= rbEnd[wrBlock as usize] {\n            bsPutBit(bsWr, b);\n        }\n        bitsRead = bitsRead.wrapping_add(1);\n        if bitsRead ==\n               rbEnd[wrBlock as\n                         usize].wrapping_add(1 as std::os::raw::c_int as\n                                                 std::os::raw::c_ulonglong) {\n            if !outFile.is_null() {\n                bsPutUChar(bsWr, 0x17 as std::os::raw::c_int as UChar);\n                bsPutUChar(bsWr, 0x72 as std::os::raw::c_int as UChar);\n                bsPutUChar(bsWr, 0x45 as std::os::raw::c_int as UChar);\n                bsPutUChar(bsWr, 0x38 as std::os::raw::c_int as UChar);\n                bsPutUChar(bsWr, 0x50 as std::os::raw::c_int as UChar);\n                bsPutUChar(bsWr, 0x90 as std::os::raw::c_int as UChar);\n                bsPutUInt32(bsWr, blockCRC);\n                bsClose(bsWr);\n                outFile = 0 as *mut FILE\n            }\n            if wrBlock >= rbCtr { break ; }\n            wrBlock += 1\n        } else if bitsRead == rbStart[wrBlock as usize] {\n            /* Create the output file name, correctly handling leading paths. \n            (31.10.2001 by Sergey E. Kusikov) */\n            let mut split: *mut Char = 0 as *mut Char;\n            let mut ofs: Int32 = 0;\n            let mut k: Int32 = 0;\n            k = 0 as std::os::raw::c_int;\n            while k < 2000 as std::os::raw::c_int {\n                outFileName[k as usize] = 0 as std::os::raw::c_int as Char;\n                k += 1\n            }\n            strcpy(outFileName.as_mut_ptr(), inFileName.as_mut_ptr());\n            split = strrchr(outFileName.as_mut_ptr(), '/' as i32);\n            if split.is_null() {\n                split = outFileName.as_mut_ptr()\n            } else { split = split.offset(1) }\n            /* Now split points to the start of the basename. */\n            ofs =\n                split.offset_from(outFileName.as_mut_ptr()) as\n                    std::os::raw::c_long as Int32;\n            sprintf(split, b\"rec%5d\\x00\" as *const u8 as *const std::os::raw::c_char,\n                    wrBlock + 1 as std::os::raw::c_int);\n            p = split;\n            while *p as std::os::raw::c_int != 0 as std::os::raw::c_int {\n                if *p as std::os::raw::c_int == ' ' as i32 { *p = '0' as i32 as Char }\n                p = p.offset(1)\n            }\n            strcat(outFileName.as_mut_ptr(),\n                   inFileName.as_mut_ptr().offset(ofs as isize));\n            if endsInBz2(outFileName.as_mut_ptr()) == 0 {\n                strcat(outFileName.as_mut_ptr(),\n                       b\".bz2\\x00\" as *const u8 as *const std::os::raw::c_char);\n            }\n            fprintf(__stderrp,\n                    b\"   writing block %d to `%s\\' ...\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, wrBlock + 1 as std::os::raw::c_int,\n                    outFileName.as_mut_ptr());\n            outFile =\n                fopen(outFileName.as_mut_ptr(),\n                      b\"wb\\x00\" as *const u8 as *const std::os::raw::c_char);\n            if outFile.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: can\\'t write `%s\\'\\n\\x00\" as *const u8 as\n                            *const std::os::raw::c_char, progName.as_mut_ptr(),\n                        outFileName.as_mut_ptr());\n                exit(1 as std::os::raw::c_int);\n            }\n            bsWr = bsOpenWriteStream(outFile);\n            bsPutUChar(bsWr, 0x42 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x5a as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x68 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr,\n                       (0x30 as std::os::raw::c_int + 9 as std::os::raw::c_int) as UChar);\n            bsPutUChar(bsWr, 0x31 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x41 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x59 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x26 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x53 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x59 as std::os::raw::c_int as UChar);\n        }\n    }\n    fprintf(__stderrp,\n            b\"%s: finished\\n\\x00\" as *const u8 as *const std::os::raw::c_char,\n            progName.as_mut_ptr());\n    return 0 as std::os::raw::c_int;",
        "sub_chunks": [],
        "live_in": [
          "mut inFile: *mut blocksort::__sFILE",
          "mut outFile: *mut blocksort::__sFILE",
          "mut bsIn: *mut bzip2recover::BitStream",
          "mut bsWr: *mut bzip2recover::BitStream",
          "mut b: i32",
          "mut wrBlock: i32",
          "mut rbCtr: i32",
          "mut bitsRead: u64",
          "mut buffHi: u32",
          "mut buffLo: u32",
          "mut blockCRC: u32",
          "mut p: *mut i8",
          "bsIn: *mut bzip2recover::BitStream"
        ],
        "live_out": []
      }
    ]
  },
  {
    "func_defid": "DefId(0:20 ~ c2rust_out[3c70]::blocksort::fallbackSimpleSort)",
    "span": "blocksort.rs:152:1: 191:2 (#0)",
    "pieces": [
      "blocksort.rs:152:1: 191:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 40,
    "source": "unsafe extern \"C\" fn fallbackSimpleSort(mut fmap: *mut UInt32,\n                                        mut eclass: *mut UInt32,\n                                        mut lo: Int32, mut hi: Int32) {\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut tmp: Int32 = 0;\n    let mut ec_tmp: UInt32 = 0;\n    if lo == hi { return }\n    if hi - lo > 3 as std::os::raw::c_int {\n        i = hi - 4 as std::os::raw::c_int;\n        while i >= lo {\n            tmp = *fmap.offset(i as isize) as Int32;\n            ec_tmp = *eclass.offset(tmp as isize);\n            j = i + 4 as std::os::raw::c_int;\n            while j <= hi &&\n                      ec_tmp >\n                          *eclass.offset(*fmap.offset(j as isize) as isize) {\n                *fmap.offset((j - 4 as std::os::raw::c_int) as isize) =\n                    *fmap.offset(j as isize);\n                j += 4 as std::os::raw::c_int\n            }\n            *fmap.offset((j - 4 as std::os::raw::c_int) as isize) = tmp as UInt32;\n            i -= 1\n        }\n    }\n    i = hi - 1 as std::os::raw::c_int;\n    while i >= lo {\n        tmp = *fmap.offset(i as isize) as Int32;\n        ec_tmp = *eclass.offset(tmp as isize);\n        j = i + 1 as std::os::raw::c_int;\n        while j <= hi &&\n                  ec_tmp > *eclass.offset(*fmap.offset(j as isize) as isize) {\n            *fmap.offset((j - 1 as std::os::raw::c_int) as isize) =\n                *fmap.offset(j as isize);\n            j += 1\n        }\n        *fmap.offset((j - 1 as std::os::raw::c_int) as isize) = tmp as UInt32;\n        i -= 1\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:21:1: 21:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:277 ~ c2rust_out[3c70]::bzip2::myMalloc)",
    "span": "bzip2.rs:2562:1: 2571:2 (#0)",
    "pieces": [
      "bzip2.rs:2562:1: 2571:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn myMalloc(mut n: Int32) -> *mut std::os::raw::c_void {\n    let mut p: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    p = malloc(n as size_t);\n    if p.is_null() { outOfMemory(); }\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:328 ~ c2rust_out[3c70]::bzip2::snocString)",
        "span": "bzip2.rs:2589:1: 2589:49 (#0)",
        "source": "(*tmp).name = myMalloc(total_size) as *mut Char;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:278 ~ c2rust_out[3c70]::bzip2::mkCell)",
    "span": "bzip2.rs:2574:1: 2580:2 (#0)",
    "pieces": [
      "bzip2.rs:2574:1: 2580:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn mkCell() -> *mut Cell {\n    let mut c: *mut Cell = 0 as *mut Cell;\n    c =\n        myMalloc(::std::mem::size_of::<Cell>() as std::os::raw::c_ulong as Int32) as\n            *mut Cell;\n    (*c).name = 0 as *mut Char;\n    (*c).link = 0 as *mut zzzz;\n    return c;\n}",
    "calls": [
      {
        "caller": "DefId(0:328 ~ c2rust_out[3c70]::bzip2::snocString)",
        "span": "bzip2.rs:2586:9: 2586:39 (#0)",
        "source": "let tmp: *mut Cell = mkCell();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:279 ~ c2rust_out[3c70]::bzip2::snocString)",
    "span": "bzip2.rs:2583:1: 2598:2 (#0)",
    "pieces": [
      "bzip2.rs:2583:1: 2598:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "unsafe extern \"C\" fn snocString(mut root: *mut Cell, mut name: *mut Char)\n -> *mut Cell {\n    if root.is_null() {\n        let mut tmp: *mut Cell = mkCell();\n        (*tmp).name =\n            myMalloc((5 as std::os::raw::c_int as\n                          std::os::raw::c_ulong).wrapping_add(strlen(name)) as Int32)\n                as *mut Char;\n        strcpy((*tmp).name, name);\n        return tmp\n    } else {\n        let mut tmp_0: *mut Cell = root;\n        while !(*tmp_0).link.is_null() { tmp_0 = (*tmp_0).link }\n        (*tmp_0).link = snocString((*tmp_0).link, name);\n        return root\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:328 ~ c2rust_out[3c70]::bzip2::snocString)",
        "span": "bzip2.rs:2595:9: 2595:57 (#0)",
        "source": "(*tmp_0).link = snocString((*tmp_0).link, name);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:26 ~ c2rust_out[3c70]::blocksort::fallbackSort)",
    "span": "blocksort.rs:342:1: 523:2 (#0)",
    "pieces": [
      "blocksort.rs:342:1: 346:4 (#0)",
      "blocksort.rs:436:1: 436:4 (#0)",
      "blocksort.rs:523:1: 523:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn fallbackSort(mut fmap: *mut UInt32,\n                                  mut eclass: *mut UInt32,\n                                  mut bhtab: *mut UInt32, mut nblock: Int32,\n                                  mut verb: Int32) {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:58 ~ c2rust_out[3c70]::blocksort::BZ2_blockSort)",
        "span": "blocksort.rs:1451:13: 1451:62 (#0)",
        "source": "fallbackSort(s.arr1, s.arr2, ftab, nblock, verb);"
      },
      {
        "caller": "DefId(0:58 ~ c2rust_out[3c70]::blocksort::BZ2_blockSort)",
        "span": "blocksort.rs:1479:17: 1479:66 (#0)",
        "source": "fallbackSort(s.arr1, s.arr2, ftab, nblock, verb);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:21:1: 21:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "blocksort.rs:346:5: 435:34 (#0)",
        "pieces": [
          "blocksort.rs:346:5: 435:34 (#0)"
        ],
        "num_lines": 90,
        "source": "let mut ftab: [Int32; 257] = [0; 257];\n    let mut ftabCopy: [Int32; 256] = [0; 256];\n    let mut H: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut k: Int32 = 0;\n    let mut l: Int32 = 0;\n    let mut r: Int32 = 0;\n    let mut cc: Int32 = 0;\n    let mut cc1: Int32 = 0;\n    let mut nNotDone: Int32 = 0;\n    let mut nBhtab: Int32 = 0;\n    let mut eclass8: *mut UChar = eclass as *mut UChar;\n    /*--\n      Initial 1-char radix sort to generate\n      initial fmap and initial BH bits.\n   --*/\n    if verb >= 4 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"        bucket sorting ...\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char);\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 257 as std::os::raw::c_int {\n        ftab[i as usize] = 0 as std::os::raw::c_int;\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < nblock {\n        ftab[*eclass8.offset(i as isize) as usize] += 1;\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 256 as std::os::raw::c_int {\n        ftabCopy[i as usize] = ftab[i as usize];\n        i += 1\n    }\n    i = 1 as std::os::raw::c_int;\n    while i < 257 as std::os::raw::c_int {\n        ftab[i as usize] += ftab[(i - 1 as std::os::raw::c_int) as usize];\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < nblock {\n        j = *eclass8.offset(i as isize) as Int32;\n        k = ftab[j as usize] - 1 as std::os::raw::c_int;\n        ftab[j as usize] = k;\n        *fmap.offset(k as isize) = i as UInt32;\n        i += 1\n    }\n    nBhtab = 2 as std::os::raw::c_int + nblock / 32 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n    while i < nBhtab {\n        *bhtab.offset(i as isize) = 0 as std::os::raw::c_int as UInt32;\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 256 as std::os::raw::c_int {\n        let ref mut fresh0 =\n            *bhtab.offset((ftab[i as usize] >> 5 as std::os::raw::c_int) as isize);\n        *fresh0 |=\n            (1 as std::os::raw::c_int as UInt32) <<\n                (ftab[i as usize] & 31 as std::os::raw::c_int);\n        i += 1\n    }\n    /*--\n      Inductively refine the buckets.  Kind-of an\n      \"exponential radix sort\" (!), inspired by the\n      Manber-Myers suffix array construction algorithm.\n   --*/\n    /*-- set sentinel bits for block-end detection --*/\n    i = 0 as std::os::raw::c_int;\n    while i < 32 as std::os::raw::c_int {\n        let ref mut fresh1 =\n            *bhtab.offset((nblock + 2 as std::os::raw::c_int * i >> 5 as std::os::raw::c_int)\n                              as isize);\n        *fresh1 |=\n            (1 as std::os::raw::c_int as UInt32) <<\n                (nblock + 2 as std::os::raw::c_int * i & 31 as std::os::raw::c_int);\n        let ref mut fresh2 =\n            *bhtab.offset((nblock + 2 as std::os::raw::c_int * i + 1 as std::os::raw::c_int >>\n                               5 as std::os::raw::c_int) as isize);\n        *fresh2 &=\n            !((1 as std::os::raw::c_int as UInt32) <<\n                  (nblock + 2 as std::os::raw::c_int * i + 1 as std::os::raw::c_int &\n                       31 as std::os::raw::c_int));\n        i += 1\n    }\n    /*-- the log(N) loop --*/\n    H = 1 as std::os::raw::c_int;",
        "sub_chunks": [],
        "live_in": [
          "mut fmap: *mut u32",
          "mut eclass: *mut u32",
          "mut bhtab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32"
        ],
        "live_out": [
          "mut fmap: *mut u32",
          "mut eclass: *mut u32",
          "mut bhtab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32",
          "mut ftab: [i32; 257]",
          "mut ftabCopy: [i32; 256]",
          "mut H: i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut l: i32",
          "mut r: i32",
          "mut cc: i32",
          "mut cc1: i32",
          "mut nNotDone: i32",
          "mut nBhtab: i32",
          "mut eclass8: *mut u8"
        ]
      },
      {
        "chunk_id": 1,
        "span": "blocksort.rs:436:5: 521:2 (#0)",
        "pieces": [
          "blocksort.rs:436:5: 521:2 (#0)"
        ],
        "num_lines": 118,
        "source": "loop  {\n        if verb >= 4 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"        depth %6d has \\x00\" as *const u8 as\n                        *const std::os::raw::c_char, H);\n        }\n        j = 0 as std::os::raw::c_int;\n        i = 0 as std::os::raw::c_int;\n        while i < nblock {\n            if *bhtab.offset((i >> 5 as std::os::raw::c_int) as isize) &\n                   (1 as std::os::raw::c_int as UInt32) << (i & 31 as std::os::raw::c_int) !=\n                   0 {\n                j = i\n            }\n            k =\n                (*fmap.offset(i as isize)).wrapping_sub(H as std::os::raw::c_uint) as\n                    Int32;\n            if k < 0 as std::os::raw::c_int { k += nblock }\n            *eclass.offset(k as isize) = j as UInt32;\n            i += 1\n        }\n        nNotDone = 0 as std::os::raw::c_int;\n        r = -(1 as std::os::raw::c_int);\n        loop  {\n            /*-- find the next non-singleton bucket --*/\n            k = r + 1 as std::os::raw::c_int;\n            while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &\n                      (1 as std::os::raw::c_int as UInt32) << (k & 31 as std::os::raw::c_int)\n                      != 0 && k & 0x1f as std::os::raw::c_int != 0 {\n                k += 1\n            }\n            if *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &\n                   (1 as std::os::raw::c_int as UInt32) << (k & 31 as std::os::raw::c_int) !=\n                   0 {\n                while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) ==\n                          0xffffffff as std::os::raw::c_uint {\n                    k += 32 as std::os::raw::c_int\n                }\n                while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &\n                          (1 as std::os::raw::c_int as UInt32) <<\n                              (k & 31 as std::os::raw::c_int) != 0 {\n                    k += 1\n                }\n            }\n            l = k - 1 as std::os::raw::c_int;\n            if l >= nblock { break ; }\n            while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &\n                      (1 as std::os::raw::c_int as UInt32) << (k & 31 as std::os::raw::c_int)\n                      == 0 && k & 0x1f as std::os::raw::c_int != 0 {\n                k += 1\n            }\n            if *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &\n                   (1 as std::os::raw::c_int as UInt32) << (k & 31 as std::os::raw::c_int) ==\n                   0 {\n                while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) ==\n                          0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    k += 32 as std::os::raw::c_int\n                }\n                while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &\n                          (1 as std::os::raw::c_int as UInt32) <<\n                              (k & 31 as std::os::raw::c_int) == 0 {\n                    k += 1\n                }\n            }\n            r = k - 1 as std::os::raw::c_int;\n            if r >= nblock { break ; }\n            /*-- now [l, r] bracket current bucket --*/\n            if r > l {\n                nNotDone += r - l + 1 as std::os::raw::c_int;\n                fallbackQSort3(fmap, eclass, l, r);\n                /*-- scan bucket and generate header bits-- */\n                cc = -(1 as std::os::raw::c_int);\n                i = l;\n                while i <= r {\n                    cc1 =\n                        *eclass.offset(*fmap.offset(i as isize) as isize) as\n                            Int32;\n                    if cc != cc1 {\n                        let ref mut fresh3 =\n                            *bhtab.offset((i >> 5 as std::os::raw::c_int) as isize);\n                        *fresh3 |=\n                            (1 as std::os::raw::c_int as UInt32) <<\n                                (i & 31 as std::os::raw::c_int);\n                        cc = cc1\n                    }\n                    i += 1\n                }\n            }\n        }\n        if verb >= 4 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"%6d unresolved strings\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, nNotDone);\n        }\n        H *= 2 as std::os::raw::c_int;\n        if H > nblock || nNotDone == 0 as std::os::raw::c_int { break ; }\n    }\n    /*-- \n      Reconstruct the original block in\n      eclass8 [0 .. nblock-1], since the\n      previous phase destroyed it.\n   --*/\n    if verb >= 4 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"        reconstructing block ...\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char);\n    }\n    j = 0 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n    while i < nblock {\n        while ftabCopy[j as usize] == 0 as std::os::raw::c_int { j += 1 }\n        ftabCopy[j as usize] -= 1;\n        *eclass8.offset(*fmap.offset(i as isize) as isize) = j as UChar;\n        i += 1\n    }\n    if !(j < 256 as std::os::raw::c_int) {\n        BZ2_bz__AssertH__fail(1005 as std::os::raw::c_int);\n    };",
        "sub_chunks": [],
        "live_in": [
          "mut fmap: *mut u32",
          "mut eclass: *mut u32",
          "mut bhtab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32",
          "mut ftabCopy: [i32; 256]",
          "mut H: i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut l: i32",
          "mut r: i32",
          "mut cc: i32",
          "mut cc1: i32",
          "mut eclass8: *mut u8"
        ],
        "live_out": [
          "mut fmap: *mut u32",
          "mut eclass: *mut u32",
          "mut bhtab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32",
          "mut ftabCopy: [i32; 256]",
          "mut H: i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut l: i32",
          "mut r: i32",
          "mut cc: i32",
          "mut cc1: i32",
          "mut eclass8: *mut u8",
          "mut j: i32",
          "mut i: i32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:267 ~ c2rust_out[3c70]::bzip2::mapSuffix)",
    "span": "bzip2.rs:1905:1: 1913:2 (#0)",
    "pieces": [
      "bzip2.rs:1905:1: 1913:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn mapSuffix(mut name: *mut Char,\n                               mut oldSuffix: *const Char,\n                               mut newSuffix: *const Char) -> Bool {\n    if hasSuffix(name, oldSuffix) == 0 { return 0 as std::os::raw::c_int as Bool }\n    *name.offset(strlen(name).wrapping_sub(strlen(oldSuffix)) as isize) =\n        0 as std::os::raw::c_int as Char;\n    strcat(name, newSuffix);\n    return 1 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:335 ~ c2rust_out[3c70]::bzip2recover::bsPutBit)",
    "span": "bzip2recover.rs:197:1: 210:2 (#0)",
    "pieces": [
      "bzip2recover.rs:197:1: 210:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "unsafe extern \"C\" fn bsPutBit(mut bs: *mut BitStream, mut bit: Int32) {\n    if (*bs).buffLive == 8 as std::os::raw::c_int {\n        let mut retVal: Int32 =\n            putc((*bs).buffer as UChar as std::os::raw::c_int, (*bs).handle);\n        if retVal == -(1 as std::os::raw::c_int) { writeError(); }\n        bytesOut = bytesOut.wrapping_add(1);\n        (*bs).buffLive = 1 as std::os::raw::c_int;\n        (*bs).buffer = bit & 0x1 as std::os::raw::c_int\n    } else {\n        (*bs).buffer =\n            (*bs).buffer << 1 as std::os::raw::c_int | bit & 0x1 as std::os::raw::c_int;\n        (*bs).buffLive += 1\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "bzip2recover.rs:117:1: 117:80 (#0)",
        "source": "pub static mut bytesOut: MaybeUInt64 = 0 as std::os::raw::c_int as MaybeUInt64;"
      }
    ],
    "imports": [
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:31 ~ c2rust_out[3c70]::blocksort::mainGtU)",
    "span": "blocksort.rs:531:1: 728:2 (#0)",
    "pieces": [
      "blocksort.rs:531:1: 535:4 (#0)",
      "blocksort.rs:637:1: 637:4 (#0)",
      "blocksort.rs:728:1: 728:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mainGtU(mut i1: UInt32, mut i2: UInt32,\n                             mut block: *mut UChar, mut quadrant: *mut UInt16,\n                             mut nblock: UInt32, mut budget: *mut Int32)\n -> Bool {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:21:1: 21:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "blocksort.rs:535:5: 636:88 (#0)",
        "pieces": [
          "blocksort.rs:535:5: 636:88 (#0)"
        ],
        "num_lines": 102,
        "source": "let mut k: Int32 = 0;\n    let mut c1: UChar = 0;\n    let mut c2: UChar = 0;\n    let mut s1: UInt16 = 0;\n    let mut s2: UInt16 = 0;\n    /* 1 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 2 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 3 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 4 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 5 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 6 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 7 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 8 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 9 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 10 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 11 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 12 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    k = nblock.wrapping_add(8 as std::os::raw::c_int as std::os::raw::c_uint) as Int32;",
        "sub_chunks": [],
        "live_in": [
          "mut i1: u32",
          "mut i2: u32",
          "mut block: *mut u8",
          "mut nblock: u32"
        ],
        "live_out": [
          "mut i1: u32",
          "mut i2: u32",
          "mut block: *mut u8",
          "mut nblock: u32",
          "mut k: i32",
          "mut c1: u8",
          "mut c2: u8",
          "mut s1: u16",
          "mut s2: u16"
        ]
      },
      {
        "chunk_id": 1,
        "span": "blocksort.rs:637:5: 726:10 (#0)",
        "pieces": [
          "blocksort.rs:637:5: 726:10 (#0)"
        ],
        "num_lines": 132,
        "source": "loop  {\n        /* 1 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 2 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 3 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 4 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 5 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 6 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 7 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 8 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        if i1 >= nblock {\n            i1 = (i1 as std::os::raw::c_uint).wrapping_sub(nblock) as UInt32 as UInt32\n        }\n        if i2 >= nblock {\n            i2 = (i2 as std::os::raw::c_uint).wrapping_sub(nblock) as UInt32 as UInt32\n        }\n        k -= 8 as std::os::raw::c_int;\n        *budget -= 1;\n        if !(k >= 0 as std::os::raw::c_int) { break ; }\n    }\n    return 0 as std::os::raw::c_int as Bool;",
        "sub_chunks": [],
        "live_in": [
          "mut i1: u32",
          "mut i2: u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut nblock: u32",
          "mut budget: *mut i32",
          "mut k: i32",
          "mut c1: u8",
          "mut c2: u8",
          "mut s1: u16",
          "mut s2: u16"
        ],
        "live_out": [
          "mut i1: u32",
          "mut i2: u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut nblock: u32",
          "mut budget: *mut i32",
          "mut k: i32",
          "mut c1: u8",
          "mut c2: u8",
          "mut s1: u16",
          "mut s2: u16",
          "c1: u8",
          "c2: u8",
          "s1: u16",
          "s2: u16",
          "c1: u8",
          "c2: u8",
          "s1: u16",
          "s2: u16",
          "c1: u8",
          "c2: u8",
          "s1: u16",
          "s2: u16",
          "c1: u8",
          "c2: u8",
          "s1: u16",
          "s2: u16",
          "c1: u8",
          "c2: u8",
          "s1: u16",
          "s2: u16"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:427 ~ c2rust_out[3c70]::bzlib::copy_input_until_stop)",
    "span": "bzlib.rs:525:1: 618:2 (#0)",
    "pieces": [
      "bzlib.rs:525:1: 618:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 94,
    "source": "unsafe extern \"C\" fn copy_input_until_stop(mut s: *mut EState) -> Bool {\n    let mut progress_in: Bool = 0 as std::os::raw::c_int as Bool;\n    if (*s).mode == 2 as std::os::raw::c_int {\n        /*-- fast track the common case --*/\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /*-- block full? --*/\n            if (*s).nblock >= (*s).nblockMAX { break ; }\n            /*-- no input? --*/\n            if (*(*s).strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n                break ;\n            }\n            progress_in = 1 as std::os::raw::c_int as Bool;\n            let mut zchh: UInt32 =\n                *((*(*s).strm).next_in as *mut UChar) as UInt32;\n            if zchh != (*s).state_in_ch &&\n                   (*s).state_in_len == 1 as std::os::raw::c_int {\n                let mut ch: UChar = (*s).state_in_ch as UChar;\n                (*s).blockCRC =\n                    (*s).blockCRC << 8 as std::os::raw::c_int ^\n                        BZ2_crc32Table[((*s).blockCRC >> 24 as std::os::raw::c_int ^\n                                            ch as std::os::raw::c_uint) as usize];\n                (*s).inUse[(*s).state_in_ch as usize] =\n                    1 as std::os::raw::c_int as Bool;\n                *(*s).block.offset((*s).nblock as isize) = ch;\n                (*s).nblock += 1;\n                (*s).state_in_ch = zchh\n            } else if zchh != (*s).state_in_ch ||\n                          (*s).state_in_len == 255 as std::os::raw::c_int {\n                if (*s).state_in_ch < 256 as std::os::raw::c_int as std::os::raw::c_uint {\n                    add_pair_to_block(s);\n                }\n                (*s).state_in_ch = zchh;\n                (*s).state_in_len = 1 as std::os::raw::c_int\n            } else { (*s).state_in_len += 1 }\n            (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n            (*(*s).strm).avail_in = (*(*s).strm).avail_in.wrapping_sub(1);\n            (*(*s).strm).total_in_lo32 =\n                (*(*s).strm).total_in_lo32.wrapping_add(1);\n            if (*(*s).strm).total_in_lo32 == 0 as std::os::raw::c_int as std::os::raw::c_uint\n               {\n                (*(*s).strm).total_in_hi32 =\n                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n            }\n        }\n    } else {\n        /*-- general, uncommon case --*/\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /*-- block full? --*/\n            if (*s).nblock >= (*s).nblockMAX { break ; }\n            /*-- no input? --*/\n            if (*(*s).strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n                break ;\n            }\n            /*-- flush/finish end? --*/\n            if (*s).avail_in_expect == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n                break ;\n            }\n            progress_in = 1 as std::os::raw::c_int as Bool;\n            let mut zchh_0: UInt32 =\n                *((*(*s).strm).next_in as *mut UChar) as UInt32;\n            if zchh_0 != (*s).state_in_ch &&\n                   (*s).state_in_len == 1 as std::os::raw::c_int {\n                let mut ch_0: UChar = (*s).state_in_ch as UChar;\n                (*s).blockCRC =\n                    (*s).blockCRC << 8 as std::os::raw::c_int ^\n                        BZ2_crc32Table[((*s).blockCRC >> 24 as std::os::raw::c_int ^\n                                            ch_0 as std::os::raw::c_uint) as usize];\n                (*s).inUse[(*s).state_in_ch as usize] =\n                    1 as std::os::raw::c_int as Bool;\n                *(*s).block.offset((*s).nblock as isize) = ch_0;\n                (*s).nblock += 1;\n                (*s).state_in_ch = zchh_0\n            } else if zchh_0 != (*s).state_in_ch ||\n                          (*s).state_in_len == 255 as std::os::raw::c_int {\n                if (*s).state_in_ch < 256 as std::os::raw::c_int as std::os::raw::c_uint {\n                    add_pair_to_block(s);\n                }\n                (*s).state_in_ch = zchh_0;\n                (*s).state_in_len = 1 as std::os::raw::c_int\n            } else { (*s).state_in_len += 1 }\n            (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n            (*(*s).strm).avail_in = (*(*s).strm).avail_in.wrapping_sub(1);\n            (*(*s).strm).total_in_lo32 =\n                (*(*s).strm).total_in_lo32.wrapping_add(1);\n            if (*(*s).strm).total_in_lo32 == 0 as std::os::raw::c_int as std::os::raw::c_uint\n               {\n                (*(*s).strm).total_in_hi32 =\n                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n            }\n            (*s).avail_in_expect = (*s).avail_in_expect.wrapping_sub(1)\n        }\n    }\n    return progress_in;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:340 ~ c2rust_out[3c70]::bzip2recover::endsInBz2)",
    "span": "bzip2recover.rs:274:1: 281:2 (#0)",
    "pieces": [
      "bzip2recover.rs:274:1: 281:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn endsInBz2(mut name: *mut Char) -> Bool {\n    let mut n: Int32 = strlen(name) as Int32;\n    if n <= 4 as std::os::raw::c_int { return 0 as std::os::raw::c_int as Bool }\n    return (*name.offset((n - 4 as std::os::raw::c_int) as isize) as std::os::raw::c_int ==\n                '.' as i32 &&\n                *name.offset((n - 3 as std::os::raw::c_int) as isize) as std::os::raw::c_int\n                    == 'b' as i32 &&\n                *name.offset((n - 2 as std::os::raw::c_int) as isize) as std::os::raw::c_int\n                    == 'z' as i32 &&\n                *name.offset((n - 1 as std::os::raw::c_int) as isize) as std::os::raw::c_int\n                    == '2' as i32) as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:501 ~ c2rust_out[3c70]::compress::bsPutUChar)",
    "span": "compress.rs:139:1: 143:2 (#0)",
    "pieces": [
      "compress.rs:139:1: 143:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn bsPutUChar(mut s: *mut EState, mut c: UChar) {\n    bsW(s, 8 as std::os::raw::c_int, c as UInt32);\n}",
    "calls": [
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1305:1: 1305:25 (#0)",
        "source": "bsPutUChar(&mut *s, c3);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1315:1: 1315:25 (#0)",
        "source": "bsPutUChar(&mut *s, c6);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1341:1: 1341:26 (#0)",
        "source": "bsPutUChar(&mut *s, c12);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1319:1: 1319:25 (#0)",
        "source": "bsPutUChar(&mut *s, c4);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1343:1: 1343:26 (#0)",
        "source": "bsPutUChar(&mut *s, c14);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1321:1: 1321:26 (#0)",
        "source": "bsPutUChar(&mut *s, c10);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1313:1: 1313:25 (#0)",
        "source": "bsPutUChar(&mut *s, c1);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1345:1: 1345:26 (#0)",
        "source": "bsPutUChar(&mut *s, c11);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1347:1: 1347:26 (#0)",
        "source": "bsPutUChar(&mut *s, c15);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1317:1: 1317:25 (#0)",
        "source": "bsPutUChar(&mut *s, c7);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1351:1: 1351:25 (#0)",
        "source": "bsPutUChar(&mut *s, c5);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1303:1: 1303:25 (#0)",
        "source": "bsPutUChar(&mut *s, c2);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1301:1: 1301:25 (#0)",
        "source": "bsPutUChar(&mut *s, c8);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1311:1: 1311:26 (#0)",
        "source": "bsPutUChar(&mut *s, c13);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1349:1: 1349:25 (#0)",
        "source": "bsPutUChar(&mut *s, c9);"
      },
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1307:1: 1307:26 (#0)",
        "source": "bsPutUChar(&mut *s, c16);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:41:1: 41:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:39:1: 39:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:40:1: 40:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:43:1: 43:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:42:1: 42:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:49 ~ c2rust_out[3c70]::blocksort::mainSort)",
    "span": "blocksort.rs:1023:1: 1423:2 (#0)",
    "pieces": [
      "blocksort.rs:1023:1: 1027:4 (#0)",
      "blocksort.rs:1172:1: 1172:4 (#0)",
      "blocksort.rs:1423:1: 1423:2 (#0)"
    ],
    "sub_chunks": [
      4,
      5
    ],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mainSort(mut ptr: *mut UInt32, mut block: *mut UChar,\n                              mut quadrant: *mut UInt16,\n                              mut ftab: *mut UInt32, mut nblock: Int32,\n                              mut verb: Int32, mut budget: *mut Int32) {\n   <<chunk 4>>   <<chunk 5>>}",
    "calls": [
      {
        "caller": "DefId(0:58 ~ c2rust_out[3c70]::blocksort::BZ2_blockSort)",
        "span": "blocksort.rs:1464:13: 1464:77 (#0)",
        "source": "mainSort(ptr, block, quadrant, ftab, nblock, verb, &mut budget);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:21:1: 21:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "blocksort.rs:1254:5: 1339:2 (#0)",
        "pieces": [
          "blocksort.rs:1254:5: 1339:2 (#0)"
        ],
        "num_lines": 126,
        "source": "ss = runningOrder[i as usize];\n        /*--\n         Step 1:\n         Complete the big bucket [ss] by quicksorting\n         any unsorted small buckets [ss, j], for j != ss.  \n         Hopefully previous pointer-scanning phases have already\n         completed many of the small buckets [ss, j], so\n         we don't have to sort them at all.\n      --*/\n        j = 0 as std::os::raw::c_int;\n        while j <= 255 as std::os::raw::c_int {\n            if j != ss {\n                sb = (ss << 8 as std::os::raw::c_int) + j;\n                if *ftab.offset(sb as isize) &\n                       ((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                           std::os::raw::c_uint == 0 {\n                    let mut lo: Int32 =\n                        (*ftab.offset(sb as isize) &\n                             !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                                 std::os::raw::c_uint) as Int32;\n                    let mut hi: Int32 =\n                        (*ftab.offset((sb + 1 as std::os::raw::c_int) as isize) &\n                             !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                                 std::os::raw::c_uint).wrapping_sub(1 as std::os::raw::c_int\n                                                                as\n                                                                std::os::raw::c_uint)\n                            as Int32;\n                    if hi > lo {\n                        if verb >= 4 as std::os::raw::c_int {\n                            fprintf(__stderrp,\n                                    b\"        qsort [0x%x, 0x%x]   done %d   this %d\\n\\x00\"\n                                        as *const u8 as *const std::os::raw::c_char,\n                                    ss, j, numQSorted,\n                                    hi - lo + 1 as std::os::raw::c_int);\n                        }\n                        mainQSort3(ptr, block, quadrant, nblock, lo, hi,\n                                   2 as std::os::raw::c_int, budget);\n                        numQSorted += hi - lo + 1 as std::os::raw::c_int;\n                        if *budget < 0 as std::os::raw::c_int { return }\n                    }\n                }\n                let ref mut fresh10 = *ftab.offset(sb as isize);\n                *fresh10 |=\n                    ((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as std::os::raw::c_uint\n            }\n            j += 1\n        }\n        if bigDone[ss as usize] != 0 {\n            BZ2_bz__AssertH__fail(1006 as std::os::raw::c_int);\n        }\n        /*--\n         Step 2:\n         Now scan this big bucket [ss] so as to synthesise the\n         sorted order for small buckets [t, ss] for all t,\n         including, magically, the bucket [ss,ss] too.\n         This will avoid doing Real Work in subsequent Step 1's.\n      --*/\n        j = 0 as std::os::raw::c_int;\n        while j <= 255 as std::os::raw::c_int {\n            copyStart[j as usize] =\n                (*ftab.offset(((j << 8 as std::os::raw::c_int) + ss) as isize) &\n                     !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                         std::os::raw::c_uint) as Int32;\n            copyEnd[j as usize] =\n                (*ftab.offset(((j << 8 as std::os::raw::c_int) + ss +\n                                   1 as std::os::raw::c_int) as isize) &\n                     !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                         std::os::raw::c_uint).wrapping_sub(1 as std::os::raw::c_int as\n                                                        std::os::raw::c_uint) as\n                    Int32;\n            j += 1\n        }\n        j =\n            (*ftab.offset((ss << 8 as std::os::raw::c_int) as isize) &\n                 !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as std::os::raw::c_uint)\n                as Int32;\n        while j < copyStart[ss as usize] {\n            k =\n                (*ptr.offset(j as\n                                 isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                          std::os::raw::c_uint) as\n                    Int32;\n            if k < 0 as std::os::raw::c_int { k += nblock }\n            c1 = *block.offset(k as isize);\n            if bigDone[c1 as usize] == 0 {\n                let fresh11 = copyStart[c1 as usize];\n                copyStart[c1 as usize] = copyStart[c1 as usize] + 1;\n                *ptr.offset(fresh11 as isize) = k as UInt32\n            }\n            j += 1\n        }\n        j =\n            (*ftab.offset(((ss + 1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) as\n                              isize) &\n                 !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                     std::os::raw::c_uint).wrapping_sub(1 as std::os::raw::c_int as\n                                                    std::os::raw::c_uint) as Int32;\n        while j > copyEnd[ss as usize] {\n            k =\n                (*ptr.offset(j as\n                                 isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                          std::os::raw::c_uint) as\n                    Int32;\n            if k < 0 as std::os::raw::c_int { k += nblock }\n            c1 = *block.offset(k as isize);\n            if bigDone[c1 as usize] == 0 {\n                let fresh12 = copyEnd[c1 as usize];\n                copyEnd[c1 as usize] = copyEnd[c1 as usize] - 1;\n                *ptr.offset(fresh12 as isize) = k as UInt32\n            }\n            j -= 1\n        }\n        if !(copyStart[ss as usize] - 1 as std::os::raw::c_int == copyEnd[ss as usize]\n                 ||\n                 copyStart[ss as usize] == 0 as std::os::raw::c_int &&\n                     copyEnd[ss as usize] == nblock - 1 as std::os::raw::c_int) {\n            BZ2_bz__AssertH__fail(1007 as std::os::raw::c_int);\n        }\n        j = 0 as std::os::raw::c_int;\n        while j <= 255 as std::os::raw::c_int {\n            let ref mut fresh13 =\n                *ftab.offset(((j << 8 as std::os::raw::c_int) + ss) as isize);\n            *fresh13 |=\n                ((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as std::os::raw::c_uint;\n            j += 1\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut ftab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32",
          "mut budget: *mut i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut ss: i32",
          "mut sb: i32",
          "mut runningOrder: [i32; 256]",
          "mut bigDone: [u8; 256]",
          "mut copyStart: [i32; 256]",
          "mut copyEnd: [i32; 256]",
          "mut c1: u8",
          "mut numQSorted: i32",
          "mut s: u16"
        ],
        "live_out": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut ftab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32",
          "mut budget: *mut i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut ss: i32",
          "mut sb: i32",
          "mut runningOrder: [i32; 256]",
          "mut bigDone: [u8; 256]",
          "mut copyStart: [i32; 256]",
          "mut copyEnd: [i32; 256]",
          "mut c1: u8",
          "mut numQSorted: i32",
          "mut s: u16",
          "ss: i32",
          "mut j: i32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "blocksort.rs:1381:5: 1408:8 (#0)",
        "pieces": [
          "blocksort.rs:1381:5: 1408:8 (#0)"
        ],
        "num_lines": 33,
        "source": "bigDone[ss as usize] = 1 as std::os::raw::c_int as Bool;\n        if i < 255 as std::os::raw::c_int {\n            let mut bbStart: Int32 =\n                (*ftab.offset((ss << 8 as std::os::raw::c_int) as isize) &\n                     !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                         std::os::raw::c_uint) as Int32;\n            let mut bbSize: Int32 =\n                (*ftab.offset(((ss + 1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) as\n                                  isize) &\n                     !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                         std::os::raw::c_uint).wrapping_sub(bbStart as std::os::raw::c_uint)\n                    as Int32;\n            let mut shifts: Int32 = 0 as std::os::raw::c_int;\n            while bbSize >> shifts > 65534 as std::os::raw::c_int { shifts += 1 }\n            j = bbSize - 1 as std::os::raw::c_int;\n            while j >= 0 as std::os::raw::c_int {\n                let mut a2update: Int32 =\n                    *ptr.offset((bbStart + j) as isize) as Int32;\n                let mut qVal: UInt16 = (j >> shifts) as UInt16;\n                *quadrant.offset(a2update as isize) = qVal;\n                if a2update <\n                       2 as std::os::raw::c_int + 12 as std::os::raw::c_int +\n                           18 as std::os::raw::c_int + 2 as std::os::raw::c_int {\n                    *quadrant.offset((a2update + nblock) as isize) = qVal\n                }\n                j -= 1\n            }\n            if !(bbSize - 1 as std::os::raw::c_int >> shifts <= 65535 as std::os::raw::c_int)\n               {\n                BZ2_bz__AssertH__fail(1002 as std::os::raw::c_int);\n            }\n        }\n        i += 1",
        "sub_chunks": [],
        "live_in": [
          "mut ptr: *mut u32",
          "mut quadrant: *mut u16",
          "mut ftab: *mut u32",
          "mut nblock: i32",
          "mut i: i32",
          "mut j: i32",
          "mut ss: i32",
          "mut bigDone: [u8; 256]",
          "ss: i32",
          "mut j: i32"
        ],
        "live_out": [
          "mut ptr: *mut u32",
          "mut quadrant: *mut u16",
          "mut ftab: *mut u32",
          "mut nblock: i32",
          "mut i: i32",
          "mut j: i32",
          "mut ss: i32",
          "mut bigDone: [u8; 256]"
        ]
      },
      {
        "chunk_id": 2,
        "span": "blocksort.rs:1247:5: 1415:3 (#236)",
        "pieces": [
          "blocksort.rs:1247:5: 1254:4 (#0)",
          "blocksort.rs:1341:1: 1381:4 (#0)",
          "blocksort.rs:1410:1: 1415:3 (#0)"
        ],
        "num_lines": 49,
        "source": "while i <= 255 as std::os::raw::c_int {\n        /*--\n         Process big buckets, starting with the least full.\n         Basically this is a 3-step process in which we call\n         mainQSort3 to sort the small buckets [ss, j], but\n         also make a big effort to avoid the calls if we can.\n      --*/\n       <<chunk 0>>        /*--\n         Step 3:\n         The [ss] big bucket is now done.  Record this fact,\n         and update the quadrant descriptors.  Remember to\n         update quadrants in the overshoot area too, if\n         necessary.  The \"if (i < 255)\" test merely skips\n         this updating for the last bucket processed, since\n         updating for the last bucket is pointless.\n\n         The quadrant array provides a way to incrementally\n         cache sort orderings, as they appear, so as to \n         make subsequent comparisons in fullGtU() complete\n         faster.  For repetitive blocks this makes a big\n         difference (but not big enough to be able to avoid\n         the fallback sorting mechanism, exponential radix sort).\n\n         The precise meaning is: at all times:\n\n            for 0 <= i < nblock and 0 <= j <= nblock\n\n            if block[i] != block[j], \n\n               then the relative values of quadrant[i] and \n                    quadrant[j] are meaningless.\n\n               else {\n                  if quadrant[i] < quadrant[j]\n                     then the string starting at i lexicographically\n                     precedes the string starting at j\n\n                  else if quadrant[i] > quadrant[j]\n                     then the string starting at j lexicographically\n                     precedes the string starting at i\n\n                  else\n                     the relative ordering of the strings starting\n                     at i and j has not yet been determined.\n               }\n      --*/\n       <<chunk 1>>    }",
        "sub_chunks": [
          0,
          1
        ],
        "live_in": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut ftab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32",
          "mut budget: *mut i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut ss: i32",
          "mut sb: i32",
          "mut runningOrder: [i32; 256]",
          "mut bigDone: [u8; 256]",
          "mut copyStart: [i32; 256]",
          "mut copyEnd: [i32; 256]",
          "mut c1: u8",
          "mut numQSorted: i32",
          "mut s: u16"
        ],
        "live_out": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut ftab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32",
          "mut budget: *mut i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut ss: i32",
          "mut sb: i32",
          "mut runningOrder: [i32; 256]",
          "mut bigDone: [u8; 256]",
          "mut copyStart: [i32; 256]",
          "mut copyEnd: [i32; 256]",
          "mut c1: u8",
          "mut numQSorted: i32",
          "mut s: u16"
        ]
      },
      {
        "chunk_id": 3,
        "span": "blocksort.rs:1247:5: 1415:3 (#236)",
        "pieces": [
          "blocksort.rs:1247:5: 1254:4 (#0)",
          "blocksort.rs:1341:1: 1381:4 (#0)",
          "blocksort.rs:1410:1: 1415:3 (#0)"
        ],
        "num_lines": 49,
        "source": "while i <= 255 as std::os::raw::c_int {\n        /*--\n         Process big buckets, starting with the least full.\n         Basically this is a 3-step process in which we call\n         mainQSort3 to sort the small buckets [ss, j], but\n         also make a big effort to avoid the calls if we can.\n      --*/\n       <<chunk 0>>        /*--\n         Step 3:\n         The [ss] big bucket is now done.  Record this fact,\n         and update the quadrant descriptors.  Remember to\n         update quadrants in the overshoot area too, if\n         necessary.  The \"if (i < 255)\" test merely skips\n         this updating for the last bucket processed, since\n         updating for the last bucket is pointless.\n\n         The quadrant array provides a way to incrementally\n         cache sort orderings, as they appear, so as to \n         make subsequent comparisons in fullGtU() complete\n         faster.  For repetitive blocks this makes a big\n         difference (but not big enough to be able to avoid\n         the fallback sorting mechanism, exponential radix sort).\n\n         The precise meaning is: at all times:\n\n            for 0 <= i < nblock and 0 <= j <= nblock\n\n            if block[i] != block[j], \n\n               then the relative values of quadrant[i] and \n                    quadrant[j] are meaningless.\n\n               else {\n                  if quadrant[i] < quadrant[j]\n                     then the string starting at i lexicographically\n                     precedes the string starting at j\n\n                  else if quadrant[i] > quadrant[j]\n                     then the string starting at j lexicographically\n                     precedes the string starting at i\n\n                  else\n                     the relative ordering of the strings starting\n                     at i and j has not yet been determined.\n               }\n      --*/\n       <<chunk 1>>    }",
        "sub_chunks": [
          0,
          1
        ],
        "live_in": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut ftab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32",
          "mut budget: *mut i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut ss: i32",
          "mut sb: i32",
          "mut runningOrder: [i32; 256]",
          "mut bigDone: [u8; 256]",
          "mut copyStart: [i32; 256]",
          "mut copyEnd: [i32; 256]",
          "mut c1: u8",
          "mut numQSorted: i32",
          "mut s: u16"
        ],
        "live_out": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut ftab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32",
          "mut budget: *mut i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut ss: i32",
          "mut sb: i32",
          "mut runningOrder: [i32; 256]",
          "mut bigDone: [u8; 256]",
          "mut copyStart: [i32; 256]",
          "mut copyEnd: [i32; 256]",
          "mut c1: u8",
          "mut numQSorted: i32",
          "mut s: u16"
        ]
      },
      {
        "chunk_id": 4,
        "span": "blocksort.rs:1027:5: 1171:6 (#0)",
        "pieces": [
          "blocksort.rs:1027:5: 1171:6 (#0)"
        ],
        "num_lines": 145,
        "source": "let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut k: Int32 = 0;\n    let mut ss: Int32 = 0;\n    let mut sb: Int32 = 0;\n    let mut runningOrder: [Int32; 256] = [0; 256];\n    let mut bigDone: [Bool; 256] = [0; 256];\n    let mut copyStart: [Int32; 256] = [0; 256];\n    let mut copyEnd: [Int32; 256] = [0; 256];\n    let mut c1: UChar = 0;\n    let mut numQSorted: Int32 = 0;\n    let mut s: UInt16 = 0;\n    if verb >= 4 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"        main sort initialise ...\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char);\n    }\n    /*-- set up the 2-byte frequency table --*/\n    i = 65536 as std::os::raw::c_int;\n    while i >= 0 as std::os::raw::c_int {\n        *ftab.offset(i as isize) = 0 as std::os::raw::c_int as UInt32;\n        i -= 1\n    }\n    j =\n        (*block.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int) <<\n            8 as std::os::raw::c_int;\n    i = nblock - 1 as std::os::raw::c_int;\n    while i >= 3 as std::os::raw::c_int {\n        *quadrant.offset(i as isize) = 0 as std::os::raw::c_int as UInt16;\n        j =\n            j >> 8 as std::os::raw::c_int |\n                (*block.offset(i as isize) as UInt16 as std::os::raw::c_int) <<\n                    8 as std::os::raw::c_int;\n        let ref mut fresh4 = *ftab.offset(j as isize);\n        *fresh4 = (*fresh4).wrapping_add(1);\n        *quadrant.offset((i - 1 as std::os::raw::c_int) as isize) =\n            0 as std::os::raw::c_int as UInt16;\n        j =\n            j >> 8 as std::os::raw::c_int |\n                (*block.offset((i - 1 as std::os::raw::c_int) as isize) as UInt16 as\n                     std::os::raw::c_int) << 8 as std::os::raw::c_int;\n        let ref mut fresh5 = *ftab.offset(j as isize);\n        *fresh5 = (*fresh5).wrapping_add(1);\n        *quadrant.offset((i - 2 as std::os::raw::c_int) as isize) =\n            0 as std::os::raw::c_int as UInt16;\n        j =\n            j >> 8 as std::os::raw::c_int |\n                (*block.offset((i - 2 as std::os::raw::c_int) as isize) as UInt16 as\n                     std::os::raw::c_int) << 8 as std::os::raw::c_int;\n        let ref mut fresh6 = *ftab.offset(j as isize);\n        *fresh6 = (*fresh6).wrapping_add(1);\n        *quadrant.offset((i - 3 as std::os::raw::c_int) as isize) =\n            0 as std::os::raw::c_int as UInt16;\n        j =\n            j >> 8 as std::os::raw::c_int |\n                (*block.offset((i - 3 as std::os::raw::c_int) as isize) as UInt16 as\n                     std::os::raw::c_int) << 8 as std::os::raw::c_int;\n        let ref mut fresh7 = *ftab.offset(j as isize);\n        *fresh7 = (*fresh7).wrapping_add(1);\n        i -= 4 as std::os::raw::c_int\n    }\n    while i >= 0 as std::os::raw::c_int {\n        *quadrant.offset(i as isize) = 0 as std::os::raw::c_int as UInt16;\n        j =\n            j >> 8 as std::os::raw::c_int |\n                (*block.offset(i as isize) as UInt16 as std::os::raw::c_int) <<\n                    8 as std::os::raw::c_int;\n        let ref mut fresh8 = *ftab.offset(j as isize);\n        *fresh8 = (*fresh8).wrapping_add(1);\n        i -= 1\n    }\n    /*-- (emphasises close relationship of block & quadrant) --*/\n    i = 0 as std::os::raw::c_int;\n    while i <\n              2 as std::os::raw::c_int + 12 as std::os::raw::c_int + 18 as std::os::raw::c_int +\n                  2 as std::os::raw::c_int {\n        *block.offset((nblock + i) as isize) = *block.offset(i as isize);\n        *quadrant.offset((nblock + i) as isize) = 0 as std::os::raw::c_int as UInt16;\n        i += 1\n    }\n    if verb >= 4 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"        bucket sorting ...\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char);\n    }\n    /*-- Complete the initial radix sort --*/\n    i = 1 as std::os::raw::c_int;\n    while i <= 65536 as std::os::raw::c_int {\n        let ref mut fresh9 = *ftab.offset(i as isize);\n        *fresh9 =\n            (*fresh9 as\n                 std::os::raw::c_uint).wrapping_add(*ftab.offset((i -\n                                                              1 as\n                                                                  std::os::raw::c_int)\n                                                             as isize)) as\n                UInt32 as UInt32;\n        i += 1\n    }\n    s =\n        ((*block.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int) <<\n             8 as std::os::raw::c_int) as UInt16;\n    i = nblock - 1 as std::os::raw::c_int;\n    while i >= 3 as std::os::raw::c_int {\n        s =\n            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |\n                 (*block.offset(i as isize) as std::os::raw::c_int) <<\n                     8 as std::os::raw::c_int) as UInt16;\n        j =\n            (*ftab.offset(s as\n                              isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                       std::os::raw::c_uint) as Int32;\n        *ftab.offset(s as isize) = j as UInt32;\n        *ptr.offset(j as isize) = i as UInt32;\n        s =\n            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |\n                 (*block.offset((i - 1 as std::os::raw::c_int) as isize) as\n                      std::os::raw::c_int) << 8 as std::os::raw::c_int) as UInt16;\n        j =\n            (*ftab.offset(s as\n                              isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                       std::os::raw::c_uint) as Int32;\n        *ftab.offset(s as isize) = j as UInt32;\n        *ptr.offset(j as isize) = (i - 1 as std::os::raw::c_int) as UInt32;\n        s =\n            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |\n                 (*block.offset((i - 2 as std::os::raw::c_int) as isize) as\n                      std::os::raw::c_int) << 8 as std::os::raw::c_int) as UInt16;\n        j =\n            (*ftab.offset(s as\n                              isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                       std::os::raw::c_uint) as Int32;\n        *ftab.offset(s as isize) = j as UInt32;\n        *ptr.offset(j as isize) = (i - 2 as std::os::raw::c_int) as UInt32;\n        s =\n            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |\n                 (*block.offset((i - 3 as std::os::raw::c_int) as isize) as\n                      std::os::raw::c_int) << 8 as std::os::raw::c_int) as UInt16;\n        j =\n            (*ftab.offset(s as\n                              isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                       std::os::raw::c_uint) as Int32;\n        *ftab.offset(s as isize) = j as UInt32;\n        *ptr.offset(j as isize) = (i - 3 as std::os::raw::c_int) as UInt32;\n        i -= 4 as std::os::raw::c_int\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut ftab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32"
        ],
        "live_out": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut ftab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut ss: i32",
          "mut sb: i32",
          "mut runningOrder: [i32; 256]",
          "mut bigDone: [u8; 256]",
          "mut copyStart: [i32; 256]",
          "mut copyEnd: [i32; 256]",
          "mut c1: u8",
          "mut numQSorted: i32",
          "mut s: u16"
        ]
      },
      {
        "chunk_id": 5,
        "span": "blocksort.rs:1172:5: 1422:7 (#0)",
        "pieces": [
          "blocksort.rs:1172:5: 1247:4 (#0)",
          "blocksort.rs:1417:1: 1422:7 (#0)"
        ],
        "num_lines": 82,
        "source": "while i >= 0 as std::os::raw::c_int {\n        s =\n            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |\n                 (*block.offset(i as isize) as std::os::raw::c_int) <<\n                     8 as std::os::raw::c_int) as UInt16;\n        j =\n            (*ftab.offset(s as\n                              isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                       std::os::raw::c_uint) as Int32;\n        *ftab.offset(s as isize) = j as UInt32;\n        *ptr.offset(j as isize) = i as UInt32;\n        i -= 1\n    }\n    /*--\n      Now ftab contains the first loc of every small bucket.\n      Calculate the running order, from smallest to largest\n      big bucket.\n   --*/\n    i = 0 as std::os::raw::c_int;\n    while i <= 255 as std::os::raw::c_int {\n        bigDone[i as usize] = 0 as std::os::raw::c_int as Bool;\n        runningOrder[i as usize] = i;\n        i += 1\n    }\n    let mut vv: Int32 = 0;\n    let mut h: Int32 = 1 as std::os::raw::c_int;\n    loop  {\n        h = 3 as std::os::raw::c_int * h + 1 as std::os::raw::c_int;\n        if !(h <= 256 as std::os::raw::c_int) { break ; }\n    }\n    loop  {\n        h = h / 3 as std::os::raw::c_int;\n        i = h;\n        while i <= 255 as std::os::raw::c_int {\n            vv = runningOrder[i as usize];\n            j = i;\n            while (*ftab.offset(((runningOrder[(j - h) as usize] +\n                                      1 as std::os::raw::c_int) << 8 as std::os::raw::c_int)\n                                    as\n                                    isize)).wrapping_sub(*ftab.offset((runningOrder[(j\n                                                                                         -\n                                                                                         h)\n                                                                                        as\n                                                                                        usize]\n                                                                           <<\n                                                                           8\n                                                                               as\n                                                                               std::os::raw::c_int)\n                                                                          as\n                                                                          isize))\n                      >\n                      (*ftab.offset(((vv + 1 as std::os::raw::c_int) <<\n                                         8 as std::os::raw::c_int) as\n                                        isize)).wrapping_sub(*ftab.offset((vv\n                                                                               <<\n                                                                               8\n                                                                                   as\n                                                                                   std::os::raw::c_int)\n                                                                              as\n                                                                              isize))\n                  {\n                runningOrder[j as usize] = runningOrder[(j - h) as usize];\n                j = j - h;\n                if j <= h - 1 as std::os::raw::c_int { break ; }\n            }\n            runningOrder[j as usize] = vv;\n            i += 1\n        }\n        if !(h != 1 as std::os::raw::c_int) { break ; }\n    }\n    /*--\n      The main sorting loop.\n   --*/\n    numQSorted = 0 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n   <<chunk 2>>    if verb >= 4 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"        %d pointers, %d sorted, %d scanned\\n\\x00\" as\n                    *const u8 as *const std::os::raw::c_char, nblock, numQSorted,\n                nblock - numQSorted);\n    };",
        "sub_chunks": [
          2
        ],
        "live_in": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut ftab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32",
          "mut budget: *mut i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut ss: i32",
          "mut sb: i32",
          "mut runningOrder: [i32; 256]",
          "mut bigDone: [u8; 256]",
          "mut copyStart: [i32; 256]",
          "mut copyEnd: [i32; 256]",
          "mut c1: u8",
          "mut numQSorted: i32",
          "mut s: u16"
        ],
        "live_out": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut ftab: *mut u32",
          "mut nblock: i32",
          "mut verb: i32",
          "mut budget: *mut i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut ss: i32",
          "mut sb: i32",
          "mut runningOrder: [i32; 256]",
          "mut bigDone: [u8; 256]",
          "mut copyStart: [i32; 256]",
          "mut copyEnd: [i32; 256]",
          "mut c1: u8",
          "mut numQSorted: i32",
          "mut s: u16",
          "mut vv: i32",
          "mut h: i32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:58 ~ c2rust_out[3c70]::blocksort::BZ2_blockSort)",
    "span": "blocksort.rs:1438:1: 1495:2 (#0)",
    "pieces": [
      "blocksort.rs:1438:1: 1495:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 69,
    "source": "pub unsafe extern \"C\" fn BZ2_blockSort(mut s: *mut EState) {\n    let mut ptr: *mut UInt32 = (*s).ptr;\n    let mut block: *mut UChar = (*s).block;\n    let mut ftab: *mut UInt32 = (*s).ftab;\n    let mut nblock: Int32 = (*s).nblock;\n    let mut verb: Int32 = (*s).verbosity;\n    let mut wfact: Int32 = (*s).workFactor;\n    let mut quadrant: *mut UInt16 = 0 as *mut UInt16;\n    let mut budget: Int32 = 0;\n    let mut budgetInit: Int32 = 0;\n    let mut i: Int32 = 0;\n    if nblock < 10000 as std::os::raw::c_int {\n        fallbackSort((*s).arr1, (*s).arr2, ftab, nblock, verb);\n    } else {\n        /* Calculate the location for quadrant, remembering to get\n         the alignment right.  Assumes that &(block[0]) is at least\n         2-byte aligned -- this should be ok since block is really\n         the first section of arr2.\n      */\n        i =\n            nblock +\n                (2 as std::os::raw::c_int + 12 as std::os::raw::c_int + 18 as std::os::raw::c_int +\n                     2 as std::os::raw::c_int);\n        if i & 1 as std::os::raw::c_int != 0 { i += 1 }\n        quadrant =\n            &mut *block.offset(i as isize) as *mut UChar as *mut UInt16;\n        /* (wfact-1) / 3 puts the default-factor-30\n         transition point at very roughly the same place as \n         with v0.1 and v0.9.0.  \n         Not that it particularly matters any more, since the\n         resulting compressed stream is now the same regardless\n         of whether or not we use the main sort or fallback sort.\n      */\n        if wfact < 1 as std::os::raw::c_int { wfact = 1 as std::os::raw::c_int }\n        if wfact > 100 as std::os::raw::c_int { wfact = 100 as std::os::raw::c_int }\n        budgetInit = nblock * ((wfact - 1 as std::os::raw::c_int) / 3 as std::os::raw::c_int);\n        budget = budgetInit;\n        mainSort(ptr, block, quadrant, ftab, nblock, verb, &mut budget);\n        if verb >= 3 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"      %d work, %d block, ratio %5.2f\\n\\x00\" as *const u8\n                        as *const std::os::raw::c_char, budgetInit - budget, nblock,\n                    ((budgetInit - budget) as std::os::raw::c_float /\n                         (if nblock == 0 as std::os::raw::c_int {\n                              1 as std::os::raw::c_int\n                          } else { nblock }) as std::os::raw::c_float) as\n                        std::os::raw::c_double);\n        }\n        if budget < 0 as std::os::raw::c_int {\n            if verb >= 2 as std::os::raw::c_int {\n                fprintf(__stderrp,\n                        b\"    too repetitive; using fallback sorting algorithm\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char);\n            }\n            fallbackSort((*s).arr1, (*s).arr2, ftab, nblock, verb);\n        }\n    }\n    (*s).origPtr = -(1 as std::os::raw::c_int);\n    i = 0 as std::os::raw::c_int;\n    while i < (*s).nblock {\n        if *ptr.offset(i as isize) == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            (*s).origPtr = i;\n            break ;\n        } else { i += 1 }\n    }\n    if !((*s).origPtr != -(1 as std::os::raw::c_int)) {\n        BZ2_bz__AssertH__fail(1003 as std::os::raw::c_int);\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:604 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:1292:9: 1292:32 (#0)",
        "source": "BZ2_blockSort(&mut *s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:21:1: 21:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:515 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
    "span": "compress.rs:1277:1: 1360:2 (#0)",
    "pieces": [
      "compress.rs:1277:1: 1360:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 68,
    "source": "pub unsafe extern \"C\" fn BZ2_compressBlock(mut s: *mut EState,\n                                           mut is_last_block: Bool) {\n    if (*s).nblock > 0 as std::os::raw::c_int {\n        (*s).blockCRC = !(*s).blockCRC;\n        (*s).combinedCRC =\n            (*s).combinedCRC << 1 as std::os::raw::c_int |\n                (*s).combinedCRC >> 31 as std::os::raw::c_int;\n        (*s).combinedCRC ^= (*s).blockCRC;\n        if (*s).blockNo > 1 as std::os::raw::c_int { (*s).numZ = 0 as std::os::raw::c_int }\n        if (*s).verbosity >= 2 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"    block %d: crc = 0x%08x, combined CRC = 0x%08x, size = %d\\n\\x00\"\n                        as *const u8 as *const std::os::raw::c_char, (*s).blockNo,\n                    (*s).blockCRC, (*s).combinedCRC, (*s).nblock);\n        }\n        BZ2_blockSort(s);\n    }\n    (*s).zbits =\n        &mut *((*s).arr2 as *mut UChar).offset((*s).nblock as isize) as\n            *mut UChar;\n    /*-- If this is the first block, create the stream header. --*/\n    if (*s).blockNo == 1 as std::os::raw::c_int {\n        BZ2_bsInitWrite(s);\n        bsPutUChar(s, 0x42 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x5a as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x68 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, (0x30 as std::os::raw::c_int + (*s).blockSize100k) as UChar);\n    }\n    if (*s).nblock > 0 as std::os::raw::c_int {\n        bsPutUChar(s, 0x31 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x41 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x59 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x26 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x53 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x59 as std::os::raw::c_int as UChar);\n        /*-- Now the block's CRC, so it is in a known place. --*/\n        bsPutUInt32(s, (*s).blockCRC);\n        /*-- \n         Now a single bit indicating (non-)randomisation. \n         As of version 0.9.5, we use a better sorting algorithm\n         which makes randomisation unnecessary.  So always set\n         the randomised bit to 'no'.  Of course, the decoder\n         still needs to be able to handle randomised blocks\n         so as to maintain backwards compatibility with\n         older versions of bzip2.\n      --*/\n        bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);\n        bsW(s, 24 as std::os::raw::c_int, (*s).origPtr as UInt32);\n        generateMTFValues(s);\n        sendMTFValues(s);\n    }\n    /*-- If this is the last block, add the stream trailer. --*/\n    if is_last_block != 0 {\n        bsPutUChar(s, 0x17 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x72 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x45 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x38 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x50 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x90 as std::os::raw::c_int as UChar);\n        bsPutUInt32(s, (*s).combinedCRC);\n        if (*s).verbosity >= 2 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"    final combined CRC = 0x%08x\\n   \\x00\" as *const u8\n                        as *const std::os::raw::c_char, (*s).combinedCRC);\n        }\n        bsFinishWrite(s);\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:41:1: 41:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:43:1: 43:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:39:1: 39:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "compress.rs:42:1: 42:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:40:1: 40:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:35 ~ c2rust_out[3c70]::blocksort::mmed3)",
    "span": "blocksort.rs:822:2: 833:2 (#0)",
    "pieces": [
      "blocksort.rs:822:2: 833:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "extern \"C\" fn mmed3(mut a: UChar, mut b: UChar, mut c: UChar)\n -> UChar {\n    let mut t: UChar = 0;\n    if a as std::os::raw::c_int > b as std::os::raw::c_int { t = a; a = b; b = t }\n    if b as std::os::raw::c_int > c as std::os::raw::c_int {\n        b = c;\n        if a as std::os::raw::c_int > b as std::os::raw::c_int { b = a }\n    }\n    return b;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:21:1: 21:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:564 ~ c2rust_out[3c70]::huffman::BZ2_hbMakeCodeLengths)",
    "span": "huffman.rs:12:1: 190:2 (#0)",
    "pieces": [
      "huffman.rs:12:1: 20:4 (#0)",
      "huffman.rs:190:1: 190:2 (#0)"
    ],
    "sub_chunks": [
      1
    ],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn BZ2_hbMakeCodeLengths(mut len: *mut UChar,\n                                               mut freq: *mut Int32,\n                                               mut alphaSize: Int32,\n                                               mut maxLen: Int32) {\n    /*--\n      Nodes and heap entries run from 1.  Entry 0\n      for both the heap and nodes is a sentinel.\n   --*/\n   <<chunk 1>>}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "huffman.rs:6:1: 6:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "huffman.rs:40:9: 188:10 (#0)",
        "pieces": [
          "huffman.rs:40:9: 188:10 (#0)"
        ],
        "num_lines": 149,
        "source": "nNodes = alphaSize;\n        nHeap = 0 as std::os::raw::c_int;\n        heap[0 as std::os::raw::c_int as usize] = 0 as std::os::raw::c_int;\n        weight[0 as std::os::raw::c_int as usize] = 0 as std::os::raw::c_int;\n        parent[0 as std::os::raw::c_int as usize] = -(2 as std::os::raw::c_int);\n        i = 1 as std::os::raw::c_int;\n        while i <= alphaSize {\n            parent[i as usize] = -(1 as std::os::raw::c_int);\n            nHeap += 1;\n            heap[nHeap as usize] = i;\n            let mut zz: Int32 = 0;\n            let mut tmp: Int32 = 0;\n            zz = nHeap;\n            tmp = heap[zz as usize];\n            while weight[tmp as usize] <\n                      weight[heap[(zz >> 1 as std::os::raw::c_int) as usize] as usize]\n                  {\n                heap[zz as usize] = heap[(zz >> 1 as std::os::raw::c_int) as usize];\n                zz >>= 1 as std::os::raw::c_int\n            }\n            heap[zz as usize] = tmp;\n            i += 1\n        }\n        if !(nHeap < 258 as std::os::raw::c_int + 2 as std::os::raw::c_int) {\n            BZ2_bz__AssertH__fail(2001 as std::os::raw::c_int);\n        }\n        while nHeap > 1 as std::os::raw::c_int {\n            n1 = heap[1 as std::os::raw::c_int as usize];\n            heap[1 as std::os::raw::c_int as usize] = heap[nHeap as usize];\n            nHeap -= 1;\n            let mut zz_0: Int32 = 0;\n            let mut yy: Int32 = 0;\n            let mut tmp_0: Int32 = 0;\n            zz_0 = 1 as std::os::raw::c_int;\n            tmp_0 = heap[zz_0 as usize];\n            while 1 as std::os::raw::c_int as Bool != 0 {\n                yy = zz_0 << 1 as std::os::raw::c_int;\n                if yy > nHeap { break ; }\n                if yy < nHeap &&\n                       weight[heap[(yy + 1 as std::os::raw::c_int) as usize] as usize]\n                           < weight[heap[yy as usize] as usize] {\n                    yy += 1\n                }\n                if weight[tmp_0 as usize] < weight[heap[yy as usize] as usize]\n                   {\n                    break ;\n                }\n                heap[zz_0 as usize] = heap[yy as usize];\n                zz_0 = yy\n            }\n            heap[zz_0 as usize] = tmp_0;\n            n2 = heap[1 as std::os::raw::c_int as usize];\n            heap[1 as std::os::raw::c_int as usize] = heap[nHeap as usize];\n            nHeap -= 1;\n            let mut zz_1: Int32 = 0;\n            let mut yy_0: Int32 = 0;\n            let mut tmp_1: Int32 = 0;\n            zz_1 = 1 as std::os::raw::c_int;\n            tmp_1 = heap[zz_1 as usize];\n            while 1 as std::os::raw::c_int as Bool != 0 {\n                yy_0 = zz_1 << 1 as std::os::raw::c_int;\n                if yy_0 > nHeap { break ; }\n                if yy_0 < nHeap &&\n                       weight[heap[(yy_0 + 1 as std::os::raw::c_int) as usize] as\n                                  usize] <\n                           weight[heap[yy_0 as usize] as usize] {\n                    yy_0 += 1\n                }\n                if weight[tmp_1 as usize] <\n                       weight[heap[yy_0 as usize] as usize] {\n                    break ;\n                }\n                heap[zz_1 as usize] = heap[yy_0 as usize];\n                zz_1 = yy_0\n            }\n            heap[zz_1 as usize] = tmp_1;\n            nNodes += 1;\n            parent[n2 as usize] = nNodes;\n            parent[n1 as usize] = parent[n2 as usize];\n            weight[nNodes as usize] =\n                ((weight[n1 as usize] as std::os::raw::c_uint &\n                      0xffffff00 as\n                          std::os::raw::c_uint).wrapping_add(weight[n2 as usize] as\n                                                         std::os::raw::c_uint &\n                                                         0xffffff00 as\n                                                             std::os::raw::c_uint) |\n                     (1 as std::os::raw::c_int +\n                          (if weight[n1 as usize] & 0xff as std::os::raw::c_int >\n                                  weight[n2 as usize] & 0xff as std::os::raw::c_int {\n                               (weight[n1 as usize]) & 0xff as std::os::raw::c_int\n                           } else {\n                               (weight[n2 as usize]) & 0xff as std::os::raw::c_int\n                           })) as std::os::raw::c_uint) as Int32;\n            parent[nNodes as usize] = -(1 as std::os::raw::c_int);\n            nHeap += 1;\n            heap[nHeap as usize] = nNodes;\n            let mut zz_2: Int32 = 0;\n            let mut tmp_2: Int32 = 0;\n            zz_2 = nHeap;\n            tmp_2 = heap[zz_2 as usize];\n            while weight[tmp_2 as usize] <\n                      weight[heap[(zz_2 >> 1 as std::os::raw::c_int) as usize] as\n                                 usize] {\n                heap[zz_2 as usize] =\n                    heap[(zz_2 >> 1 as std::os::raw::c_int) as usize];\n                zz_2 >>= 1 as std::os::raw::c_int\n            }\n            heap[zz_2 as usize] = tmp_2\n        }\n        if !(nNodes < 258 as std::os::raw::c_int * 2 as std::os::raw::c_int) {\n            BZ2_bz__AssertH__fail(2002 as std::os::raw::c_int);\n        }\n        tooLong = 0 as std::os::raw::c_int as Bool;\n        i = 1 as std::os::raw::c_int;\n        while i <= alphaSize {\n            j = 0 as std::os::raw::c_int;\n            k = i;\n            while parent[k as usize] >= 0 as std::os::raw::c_int {\n                k = parent[k as usize];\n                j += 1\n            }\n            *len.offset((i - 1 as std::os::raw::c_int) as isize) = j as UChar;\n            if j > maxLen { tooLong = 1 as std::os::raw::c_int as Bool }\n            i += 1\n        }\n        if tooLong == 0 { break ; }\n        /* 17 Oct 04: keep-going condition for the following loop used\n         to be 'i < alphaSize', which missed the last element,\n         theoretically leading to the possibility of the compressor\n         looping.  However, this count-scaling step is only needed if\n         one of the generated Huffman code words is longer than\n         maxLen, which up to and including version 1.0.2 was 20 bits,\n         which is extremely unlikely.  In version 1.0.3 maxLen was\n         changed to 17 bits, which has minimal effect on compression\n         ratio, but does mean this scaling step is used from time to\n         time, enough to verify that it works.\n\n         This means that bzip2-1.0.3 and later will only produce\n         Huffman codes with a maximum length of 17 bits.  However, in\n         order to preserve backwards compatibility with bitstreams\n         produced by versions pre-1.0.3, the decompressor must still\n         handle lengths of up to 20. */\n        i = 1 as std::os::raw::c_int;\n        while i <= alphaSize {\n            j = weight[i as usize] >> 8 as std::os::raw::c_int;\n            j = 1 as std::os::raw::c_int + j / 2 as std::os::raw::c_int;\n            weight[i as usize] = j << 8 as std::os::raw::c_int;\n            i += 1\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut len: *mut u8",
          "mut alphaSize: i32",
          "mut maxLen: i32",
          "mut nNodes: i32",
          "mut nHeap: i32",
          "mut n1: i32",
          "mut n2: i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut tooLong: u8",
          "mut heap: [i32; 260]",
          "mut weight: [i32; 516]",
          "mut parent: [i32; 516]"
        ],
        "live_out": [
          "mut len: *mut u8",
          "mut alphaSize: i32",
          "mut maxLen: i32",
          "mut nNodes: i32",
          "mut nHeap: i32",
          "mut n1: i32",
          "mut n2: i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut tooLong: u8",
          "mut heap: [i32; 260]",
          "mut weight: [i32; 516]",
          "mut parent: [i32; 516]"
        ]
      },
      {
        "chunk_id": 1,
        "span": "huffman.rs:20:5: 189:7 (#0)",
        "pieces": [
          "huffman.rs:20:5: 40:8 (#0)",
          "huffman.rs:189:1: 189:7 (#0)"
        ],
        "num_lines": 22,
        "source": "let mut nNodes: Int32 = 0;\n    let mut nHeap: Int32 = 0;\n    let mut n1: Int32 = 0;\n    let mut n2: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut k: Int32 = 0;\n    let mut tooLong: Bool = 0;\n    let mut heap: [Int32; 260] = [0; 260];\n    let mut weight: [Int32; 516] = [0; 516];\n    let mut parent: [Int32; 516] = [0; 516];\n    i = 0 as std::os::raw::c_int;\n    while i < alphaSize {\n        weight[(i + 1 as std::os::raw::c_int) as usize] =\n            (if *freq.offset(i as isize) == 0 as std::os::raw::c_int {\n                 1 as std::os::raw::c_int\n             } else { *freq.offset(i as isize) }) << 8 as std::os::raw::c_int;\n        i += 1\n    }\n    while 1 as std::os::raw::c_int as Bool != 0 {\n       <<chunk 0>>    };",
        "sub_chunks": [
          0
        ],
        "live_in": [
          "mut len: *mut u8",
          "mut freq: *mut i32",
          "mut alphaSize: i32",
          "mut maxLen: i32"
        ],
        "live_out": [
          "mut len: *mut u8",
          "mut freq: *mut i32",
          "mut alphaSize: i32",
          "mut maxLen: i32",
          "mut nNodes: i32",
          "mut nHeap: i32",
          "mut n1: i32",
          "mut n2: i32",
          "mut i: i32",
          "mut j: i32",
          "mut k: i32",
          "mut tooLong: u8",
          "mut heap: [i32; 260]",
          "mut weight: [i32; 516]",
          "mut parent: [i32; 516]"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:36 ~ c2rust_out[3c70]::blocksort::mainQSort3)",
    "span": "blocksort.rs:835:1: 1022:2 (#0)",
    "pieces": [
      "blocksort.rs:835:1: 839:4 (#0)",
      "blocksort.rs:1022:1: 1022:2 (#0)"
    ],
    "sub_chunks": [
      3
    ],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn mainQSort3(mut ptr: *mut UInt32, mut block: *mut UChar,\n                                mut quadrant: *mut UInt16, mut nblock: Int32,\n                                mut loSt: Int32, mut hiSt: Int32,\n                                mut dSt: Int32, mut budget: *mut Int32) {\n   <<chunk 3>>}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:21:1: 21:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "blocksort.rs:871:9: 933:2 (#0)",
        "pieces": [
          "blocksort.rs:871:9: 933:2 (#0)"
        ],
        "num_lines": 62,
        "source": "med =\n                mmed3(*block.offset((*ptr.offset(lo as\n                                                     isize)).wrapping_add(d as\n                                                                              std::os::raw::c_uint)\n                                        as isize),\n                      *block.offset((*ptr.offset(hi as\n                                                     isize)).wrapping_add(d as\n                                                                              std::os::raw::c_uint)\n                                        as isize),\n                      *block.offset((*ptr.offset((lo + hi >> 1 as std::os::raw::c_int)\n                                                     as\n                                                     isize)).wrapping_add(d as\n                                                                              std::os::raw::c_uint)\n                                        as isize)) as Int32;\n            ltLo = lo;\n            unLo = ltLo;\n            gtHi = hi;\n            unHi = gtHi;\n            while 1 as std::os::raw::c_int as Bool != 0 {\n                while 1 as std::os::raw::c_int as Bool != 0 {\n                    if unLo > unHi { break ; }\n                    n =\n                        *block.offset((*ptr.offset(unLo as\n                                                       isize)).wrapping_add(d\n                                                                                as\n                                                                                std::os::raw::c_uint)\n                                          as isize) as Int32 - med;\n                    if n == 0 as std::os::raw::c_int {\n                        let mut zztmp: Int32 =\n                            *ptr.offset(unLo as isize) as Int32;\n                        *ptr.offset(unLo as isize) =\n                            *ptr.offset(ltLo as isize);\n                        *ptr.offset(ltLo as isize) = zztmp as UInt32;\n                        ltLo += 1;\n                        unLo += 1\n                    } else { if n > 0 as std::os::raw::c_int { break ; } unLo += 1 }\n                }\n                while 1 as std::os::raw::c_int as Bool != 0 {\n                    if unLo > unHi { break ; }\n                    n =\n                        *block.offset((*ptr.offset(unHi as\n                                                       isize)).wrapping_add(d\n                                                                                as\n                                                                                std::os::raw::c_uint)\n                                          as isize) as Int32 - med;\n                    if n == 0 as std::os::raw::c_int {\n                        let mut zztmp_0: Int32 =\n                            *ptr.offset(unHi as isize) as Int32;\n                        *ptr.offset(unHi as isize) =\n                            *ptr.offset(gtHi as isize);\n                        *ptr.offset(gtHi as isize) = zztmp_0 as UInt32;\n                        gtHi -= 1;\n                        unHi -= 1\n                    } else { if n < 0 as std::os::raw::c_int { break ; } unHi -= 1 }\n                }\n                if unLo > unHi { break ; }\n                let mut zztmp_1: Int32 = *ptr.offset(unLo as isize) as Int32;\n                *ptr.offset(unLo as isize) = *ptr.offset(unHi as isize);\n                *ptr.offset(unHi as isize) = zztmp_1 as UInt32;\n                unLo += 1;\n                unHi -= 1\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut n: i32",
          "mut med: i32",
          "mut lo: i32",
          "mut hi: i32",
          "mut d: i32"
        ],
        "live_out": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut n: i32",
          "mut med: i32",
          "mut lo: i32",
          "mut hi: i32",
          "mut d: i32",
          "med: i32",
          "mut lt_lo: i32",
          "mut un_lo: i32",
          "mut gt_hi: i32",
          "mut un_hi: i32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "blocksort.rs:935:12: 1013:2 (#0)",
        "pieces": [
          "blocksort.rs:935:12: 1013:2 (#0)"
        ],
        "num_lines": 117,
        "source": "if gtHi < ltLo {\n                stackLo[sp as usize] = lo;\n                stackHi[sp as usize] = hi;\n                stackD[sp as usize] = d + 1 as std::os::raw::c_int;\n                sp += 1\n            } else {\n                n =\n                    if ltLo - lo < unLo - ltLo {\n                        (ltLo) - lo\n                    } else { (unLo) - ltLo };\n                let mut yyp1: Int32 = lo;\n                let mut yyp2: Int32 = unLo - n;\n                let mut yyn: Int32 = n;\n                while yyn > 0 as std::os::raw::c_int {\n                    let mut zztmp_2: Int32 =\n                        *ptr.offset(yyp1 as isize) as Int32;\n                    *ptr.offset(yyp1 as isize) = *ptr.offset(yyp2 as isize);\n                    *ptr.offset(yyp2 as isize) = zztmp_2 as UInt32;\n                    yyp1 += 1;\n                    yyp2 += 1;\n                    yyn -= 1\n                }\n                m =\n                    if hi - gtHi < gtHi - unHi {\n                        (hi) - gtHi\n                    } else { (gtHi) - unHi };\n                let mut yyp1_0: Int32 = unLo;\n                let mut yyp2_0: Int32 = hi - m + 1 as std::os::raw::c_int;\n                let mut yyn_0: Int32 = m;\n                while yyn_0 > 0 as std::os::raw::c_int {\n                    let mut zztmp_3: Int32 =\n                        *ptr.offset(yyp1_0 as isize) as Int32;\n                    *ptr.offset(yyp1_0 as isize) =\n                        *ptr.offset(yyp2_0 as isize);\n                    *ptr.offset(yyp2_0 as isize) = zztmp_3 as UInt32;\n                    yyp1_0 += 1;\n                    yyp2_0 += 1;\n                    yyn_0 -= 1\n                }\n                n = lo + unLo - ltLo - 1 as std::os::raw::c_int;\n                m = hi - (gtHi - unHi) + 1 as std::os::raw::c_int;\n                nextLo[0 as std::os::raw::c_int as usize] = lo;\n                nextHi[0 as std::os::raw::c_int as usize] = n;\n                nextD[0 as std::os::raw::c_int as usize] = d;\n                nextLo[1 as std::os::raw::c_int as usize] = m;\n                nextHi[1 as std::os::raw::c_int as usize] = hi;\n                nextD[1 as std::os::raw::c_int as usize] = d;\n                nextLo[2 as std::os::raw::c_int as usize] = n + 1 as std::os::raw::c_int;\n                nextHi[2 as std::os::raw::c_int as usize] = m - 1 as std::os::raw::c_int;\n                nextD[2 as std::os::raw::c_int as usize] = d + 1 as std::os::raw::c_int;\n                if nextHi[0 as std::os::raw::c_int as usize] -\n                       nextLo[0 as std::os::raw::c_int as usize] <\n                       nextHi[1 as std::os::raw::c_int as usize] -\n                           nextLo[1 as std::os::raw::c_int as usize] {\n                    let mut tz: Int32 = 0;\n                    tz = nextLo[0 as std::os::raw::c_int as usize];\n                    nextLo[0 as std::os::raw::c_int as usize] =\n                        nextLo[1 as std::os::raw::c_int as usize];\n                    nextLo[1 as std::os::raw::c_int as usize] = tz;\n                    tz = nextHi[0 as std::os::raw::c_int as usize];\n                    nextHi[0 as std::os::raw::c_int as usize] =\n                        nextHi[1 as std::os::raw::c_int as usize];\n                    nextHi[1 as std::os::raw::c_int as usize] = tz;\n                    tz = nextD[0 as std::os::raw::c_int as usize];\n                    nextD[0 as std::os::raw::c_int as usize] =\n                        nextD[1 as std::os::raw::c_int as usize];\n                    nextD[1 as std::os::raw::c_int as usize] = tz\n                }\n                if nextHi[1 as std::os::raw::c_int as usize] -\n                       nextLo[1 as std::os::raw::c_int as usize] <\n                       nextHi[2 as std::os::raw::c_int as usize] -\n                           nextLo[2 as std::os::raw::c_int as usize] {\n                    let mut tz_0: Int32 = 0;\n                    tz_0 = nextLo[1 as std::os::raw::c_int as usize];\n                    nextLo[1 as std::os::raw::c_int as usize] =\n                        nextLo[2 as std::os::raw::c_int as usize];\n                    nextLo[2 as std::os::raw::c_int as usize] = tz_0;\n                    tz_0 = nextHi[1 as std::os::raw::c_int as usize];\n                    nextHi[1 as std::os::raw::c_int as usize] =\n                        nextHi[2 as std::os::raw::c_int as usize];\n                    nextHi[2 as std::os::raw::c_int as usize] = tz_0;\n                    tz_0 = nextD[1 as std::os::raw::c_int as usize];\n                    nextD[1 as std::os::raw::c_int as usize] =\n                        nextD[2 as std::os::raw::c_int as usize];\n                    nextD[2 as std::os::raw::c_int as usize] = tz_0\n                }\n                if nextHi[0 as std::os::raw::c_int as usize] -\n                       nextLo[0 as std::os::raw::c_int as usize] <\n                       nextHi[1 as std::os::raw::c_int as usize] -\n                           nextLo[1 as std::os::raw::c_int as usize] {\n                    let mut tz_1: Int32 = 0;\n                    tz_1 = nextLo[0 as std::os::raw::c_int as usize];\n                    nextLo[0 as std::os::raw::c_int as usize] =\n                        nextLo[1 as std::os::raw::c_int as usize];\n                    nextLo[1 as std::os::raw::c_int as usize] = tz_1;\n                    tz_1 = nextHi[0 as std::os::raw::c_int as usize];\n                    nextHi[0 as std::os::raw::c_int as usize] =\n                        nextHi[1 as std::os::raw::c_int as usize];\n                    nextHi[1 as std::os::raw::c_int as usize] = tz_1;\n                    tz_1 = nextD[0 as std::os::raw::c_int as usize];\n                    nextD[0 as std::os::raw::c_int as usize] =\n                        nextD[1 as std::os::raw::c_int as usize];\n                    nextD[1 as std::os::raw::c_int as usize] = tz_1\n                }\n                stackLo[sp as usize] = nextLo[0 as std::os::raw::c_int as usize];\n                stackHi[sp as usize] = nextHi[0 as std::os::raw::c_int as usize];\n                stackD[sp as usize] = nextD[0 as std::os::raw::c_int as usize];\n                sp += 1;\n                stackLo[sp as usize] = nextLo[1 as std::os::raw::c_int as usize];\n                stackHi[sp as usize] = nextHi[1 as std::os::raw::c_int as usize];\n                stackD[sp as usize] = nextD[1 as std::os::raw::c_int as usize];\n                sp += 1;\n                stackLo[sp as usize] = nextLo[2 as std::os::raw::c_int as usize];\n                stackHi[sp as usize] = nextHi[2 as std::os::raw::c_int as usize];\n                stackD[sp as usize] = nextD[2 as std::os::raw::c_int as usize];\n                sp += 1\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut ptr: *mut u32",
          "mut unLo: i32",
          "mut unHi: i32",
          "mut ltLo: i32",
          "mut gtHi: i32",
          "mut n: i32",
          "mut m: i32",
          "mut sp: i32",
          "mut lo: i32",
          "mut hi: i32",
          "mut d: i32",
          "mut stackLo: [i32; 100]",
          "mut stackHi: [i32; 100]",
          "mut stackD: [i32; 100]",
          "mut nextLo: [i32; 3]",
          "mut nextHi: [i32; 3]",
          "mut nextD: [i32; 3]"
        ],
        "live_out": [
          "mut ptr: *mut u32",
          "mut unLo: i32",
          "mut unHi: i32",
          "mut ltLo: i32",
          "mut gtHi: i32",
          "mut n: i32",
          "mut m: i32",
          "mut sp: i32",
          "mut lo: i32",
          "mut hi: i32",
          "mut d: i32",
          "mut stackLo: [i32; 100]",
          "mut stackHi: [i32; 100]",
          "mut stackD: [i32; 100]",
          "mut nextLo: [i32; 3]",
          "mut nextHi: [i32; 3]",
          "mut nextD: [i32; 3]"
        ]
      },
      {
        "chunk_id": 2,
        "span": "blocksort.rs:862:9: 1019:2 (#0)",
        "pieces": [
          "blocksort.rs:862:9: 871:8 (#0)",
          "blocksort.rs:935:1: 935:11 (#0)",
          "blocksort.rs:1015:1: 1019:2 (#0)"
        ],
        "num_lines": 15,
        "source": "if !(sp < 100 as std::os::raw::c_int - 2 as std::os::raw::c_int) {\n            BZ2_bz__AssertH__fail(1001 as std::os::raw::c_int);\n        }\n        sp -= 1;\n        lo = stackLo[sp as usize];\n        hi = stackHi[sp as usize];\n        d = stackD[sp as usize];\n        if hi - lo < 20 as std::os::raw::c_int ||\n               d > 2 as std::os::raw::c_int + 12 as std::os::raw::c_int {\n            mainSimpleSort(ptr, block, quadrant, nblock, lo, hi, d, budget);\n            if *budget < 0 as std::os::raw::c_int { return }\n        } else {\n           <<chunk 0>>           <<chunk 1>>        }",
        "sub_chunks": [
          0,
          1
        ],
        "live_in": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut nblock: i32",
          "mut budget: *mut i32",
          "mut unLo: i32",
          "mut unHi: i32",
          "mut ltLo: i32",
          "mut gtHi: i32",
          "mut n: i32",
          "mut m: i32",
          "mut med: i32",
          "mut sp: i32",
          "mut lo: i32",
          "mut hi: i32",
          "mut d: i32",
          "mut stackLo: [i32; 100]",
          "mut stackHi: [i32; 100]",
          "mut stackD: [i32; 100]",
          "mut nextLo: [i32; 3]",
          "mut nextHi: [i32; 3]",
          "mut nextD: [i32; 3]"
        ],
        "live_out": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut nblock: i32",
          "mut budget: *mut i32",
          "mut unLo: i32",
          "mut unHi: i32",
          "mut ltLo: i32",
          "mut gtHi: i32",
          "mut n: i32",
          "mut m: i32",
          "mut med: i32",
          "mut sp: i32",
          "mut lo: i32",
          "mut hi: i32",
          "mut d: i32",
          "mut stackLo: [i32; 100]",
          "mut stackHi: [i32; 100]",
          "mut stackD: [i32; 100]",
          "mut nextLo: [i32; 3]",
          "mut nextHi: [i32; 3]",
          "mut nextD: [i32; 3]"
        ]
      },
      {
        "chunk_id": 3,
        "span": "blocksort.rs:839:5: 1021:7 (#0)",
        "pieces": [
          "blocksort.rs:839:5: 862:8 (#0)",
          "blocksort.rs:1021:1: 1021:7 (#0)"
        ],
        "num_lines": 25,
        "source": "let mut unLo: Int32 = 0;\n    let mut unHi: Int32 = 0;\n    let mut ltLo: Int32 = 0;\n    let mut gtHi: Int32 = 0;\n    let mut n: Int32 = 0;\n    let mut m: Int32 = 0;\n    let mut med: Int32 = 0;\n    let mut sp: Int32 = 0;\n    let mut lo: Int32 = 0;\n    let mut hi: Int32 = 0;\n    let mut d: Int32 = 0;\n    let mut stackLo: [Int32; 100] = [0; 100];\n    let mut stackHi: [Int32; 100] = [0; 100];\n    let mut stackD: [Int32; 100] = [0; 100];\n    let mut nextLo: [Int32; 3] = [0; 3];\n    let mut nextHi: [Int32; 3] = [0; 3];\n    let mut nextD: [Int32; 3] = [0; 3];\n    sp = 0 as std::os::raw::c_int;\n    stackLo[sp as usize] = loSt;\n    stackHi[sp as usize] = hiSt;\n    stackD[sp as usize] = dSt;\n    sp += 1;\n    while sp > 0 as std::os::raw::c_int {\n       <<chunk 2>>    };",
        "sub_chunks": [
          2
        ],
        "live_in": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut nblock: i32",
          "mut loSt: i32",
          "mut hiSt: i32",
          "mut dSt: i32",
          "mut budget: *mut i32"
        ],
        "live_out": [
          "mut ptr: *mut u32",
          "mut block: *mut u8",
          "mut quadrant: *mut u16",
          "mut nblock: i32",
          "mut loSt: i32",
          "mut hiSt: i32",
          "mut dSt: i32",
          "mut budget: *mut i32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:354 ~ c2rust_out[3c70]::bzip2recover::main)",
    "span": "bzip2recover.rs:564:1: 576:2 (#0)",
    "pieces": [
      "bzip2recover.rs:564:1: 576:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub fn main() {\n    let mut args: Vec<*mut std::os::raw::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(::std::ffi::CString::new(arg).expect(\"Failed to convert argument into CString.\").into_raw());\n    };\n    args.push(::std::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(main_0((args.len() - 1) as Int32,\n                                    args.as_mut_ptr() as *mut *mut Char) as\n                                 i32)\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:176 ~ c2rust_out[3c70]::bzip2::__istype)",
    "span": "bzip2.rs:364:1: 373:2 (#0)",
    "pieces": [
      "bzip2.rs:364:1: 373:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn __istype(mut _c: __darwin_ct_rune_t,\n                              mut _f: std::os::raw::c_ulong) -> std::os::raw::c_int {\n    return if isascii(_c) != 0 {\n               (_DefaultRuneLocale.__runetype[_c as usize] as std::os::raw::c_ulong &\n                    _f != 0) as std::os::raw::c_int\n           } else { (__maskrune(_c, _f) != 0) as std::os::raw::c_int };\n}",
    "calls": [
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::isspace)",
        "span": "bzip2.rs:378:31: 380:2 (#0)",
        "source": "{\n    __istype(c, 0x4000)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:177 ~ c2rust_out[3c70]::bzip2::isspace)",
    "span": "bzip2.rs:378:1: 380:2 (#0)",
    "pieces": [
      "bzip2.rs:378:1: 380:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn isspace(mut _c: std::os::raw::c_int) -> std::os::raw::c_int {\n    return __istype(_c, 0x4000 as std::os::raw::c_long as std::os::raw::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:336 ~ c2rust_out[3c70]::bzip2recover::bsGetBit)",
    "span": "bzip2recover.rs:215:1: 229:2 (#0)",
    "pieces": [
      "bzip2recover.rs:215:1: 229:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn bsGetBit(mut bs: *mut BitStream) -> Int32 {\n    if (*bs).buffLive > 0 as std::os::raw::c_int {\n        (*bs).buffLive -= 1;\n        return (*bs).buffer >> (*bs).buffLive & 0x1 as std::os::raw::c_int\n    } else {\n        let mut retVal: Int32 = getc((*bs).handle);\n        if retVal == -(1 as std::os::raw::c_int) {\n            if *__error() != 0 as std::os::raw::c_int { readError(); }\n            return 2 as std::os::raw::c_int\n        }\n        (*bs).buffLive = 7 as std::os::raw::c_int;\n        (*bs).buffer = retVal;\n        return (*bs).buffer >> 7 as std::os::raw::c_int & 0x1 as std::os::raw::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:58:1: 58:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2recover.rs:10:1: 10:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "bzip2recover.rs:13:1: 13:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2recover.rs:12:1: 12:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2recover.rs:8:1: 8:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:428 ~ c2rust_out[3c70]::bzlib::copy_output_until_stop)",
    "span": "bzlib.rs:620:1: 643:2 (#0)",
    "pieces": [
      "bzlib.rs:620:1: 643:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 24,
    "source": "unsafe extern \"C\" fn copy_output_until_stop(mut s: *mut EState) -> Bool {\n    let mut progress_out: Bool = 0 as std::os::raw::c_int as Bool;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        /*-- no output space? --*/\n        if (*(*s).strm).avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            break ;\n        }\n        /*-- block done? --*/\n        if (*s).state_out_pos >= (*s).numZ { break ; }\n        progress_out = 1 as std::os::raw::c_int as Bool;\n        *(*(*s).strm).next_out =\n            *(*s).zbits.offset((*s).state_out_pos as isize) as std::os::raw::c_char;\n        (*s).state_out_pos += 1;\n        (*(*s).strm).avail_out = (*(*s).strm).avail_out.wrapping_sub(1);\n        (*(*s).strm).next_out = (*(*s).strm).next_out.offset(1);\n        (*(*s).strm).total_out_lo32 =\n            (*(*s).strm).total_out_lo32.wrapping_add(1);\n        if (*(*s).strm).total_out_lo32 == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            (*(*s).strm).total_out_hi32 =\n                (*(*s).strm).total_out_hi32.wrapping_add(1)\n        }\n    }\n    return progress_out;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:457 ~ c2rust_out[3c70]::bzlib::BZ2_bzdopen)",
    "span": "bzlib.rs:2298:1: 2306:2 (#0)",
    "pieces": [
      "bzlib.rs:2298:1: 2306:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn BZ2_bzdopen(mut fd: std::os::raw::c_int,\n                                     mut mode: *const std::os::raw::c_char)\n -> *mut std::os::raw::c_void {\n    return bzopen_or_bzdopen(0 as *const std::os::raw::c_char, fd, mode,\n                             1 as std::os::raw::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:34 ~ c2rust_out[3c70]::blocksort::mainSimpleSort)",
    "span": "blocksort.rs:742:1: 812:2 (#0)",
    "pieces": [
      "blocksort.rs:742:1: 812:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 71,
    "source": "unsafe extern \"C\" fn mainSimpleSort(mut ptr: *mut UInt32,\n                                    mut block: *mut UChar,\n                                    mut quadrant: *mut UInt16,\n                                    mut nblock: Int32, mut lo: Int32,\n                                    mut hi: Int32, mut d: Int32,\n                                    mut budget: *mut Int32) {\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut h: Int32 = 0;\n    let mut bigN: Int32 = 0;\n    let mut hp: Int32 = 0;\n    let mut v: UInt32 = 0;\n    bigN = hi - lo + 1 as std::os::raw::c_int;\n    if bigN < 2 as std::os::raw::c_int { return }\n    hp = 0 as std::os::raw::c_int;\n    while incs[hp as usize] < bigN { hp += 1 }\n    hp -= 1;\n    while hp >= 0 as std::os::raw::c_int {\n        h = incs[hp as usize];\n        i = lo + h;\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /*-- copy 1 --*/\n            if i > hi { break ; }\n            v = *ptr.offset(i as isize);\n            j = i;\n            while mainGtU((*ptr.offset((j - h) as\n                                           isize)).wrapping_add(d as\n                                                                    std::os::raw::c_uint),\n                          v.wrapping_add(d as std::os::raw::c_uint), block, quadrant,\n                          nblock as UInt32, budget) != 0 {\n                *ptr.offset(j as isize) = *ptr.offset((j - h) as isize);\n                j = j - h;\n                if j <= lo + h - 1 as std::os::raw::c_int { break ; }\n            }\n            *ptr.offset(j as isize) = v;\n            i += 1;\n            /*-- copy 2 --*/\n            if i > hi { break ; }\n            v = *ptr.offset(i as isize);\n            j = i;\n            while mainGtU((*ptr.offset((j - h) as\n                                           isize)).wrapping_add(d as\n                                                                    std::os::raw::c_uint),\n                          v.wrapping_add(d as std::os::raw::c_uint), block, quadrant,\n                          nblock as UInt32, budget) != 0 {\n                *ptr.offset(j as isize) = *ptr.offset((j - h) as isize);\n                j = j - h;\n                if j <= lo + h - 1 as std::os::raw::c_int { break ; }\n            }\n            *ptr.offset(j as isize) = v;\n            i += 1;\n            /*-- copy 3 --*/\n            if i > hi { break ; }\n            v = *ptr.offset(i as isize);\n            j = i;\n            while mainGtU((*ptr.offset((j - h) as\n                                           isize)).wrapping_add(d as\n                                                                    std::os::raw::c_uint),\n                          v.wrapping_add(d as std::os::raw::c_uint), block, quadrant,\n                          nblock as UInt32, budget) != 0 {\n                *ptr.offset(j as isize) = *ptr.offset((j - h) as isize);\n                j = j - h;\n                if j <= lo + h - 1 as std::os::raw::c_int { break ; }\n            }\n            *ptr.offset(j as isize) = v;\n            i += 1;\n            if *budget < 0 as std::os::raw::c_int { return }\n        }\n        hp -= 1\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:21:1: 21:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:282 ~ c2rust_out[3c70]::bzip2::main)",
    "span": "bzip2.rs:2985:1: 2999:2 (#0)",
    "pieces": [
      "bzip2.rs:2985:1: 2999:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub fn main() {\n    let mut args: Vec<*mut std::os::raw::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(::std::ffi::CString::new(arg).expect(\"Failed to convert argument into CString.\").into_raw());\n    };\n    args.push(::std::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(main_0((args.len() - 1) as IntNative,\n                                    args.as_mut_ptr() as *mut *mut Char) as\n                                 i32)\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:433 ~ c2rust_out[3c70]::bzlib::unRLE_obuf_to_output_FAST)",
    "span": "bzlib.rs:828:1: 1160:2 (#0)",
    "pieces": [
      "bzlib.rs:828:1: 829:4 (#0)",
      "bzlib.rs:1160:1: 1160:2 (#0)"
    ],
    "sub_chunks": [
      5
    ],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn unRLE_obuf_to_output_FAST(mut s: *mut DState) -> Bool {\n   <<chunk 5>>}",
    "calls": [
      {
        "caller": "DefId(0:520 ~ c2rust_out[3c70]::bzlib::BZ2_bzDecompress)",
        "span": "bzlib.rs:1581:17: 1581:56 (#0)",
        "source": "unsafe { unRLE_obuf_to_output_FAST(s) }"
      }
    ],
    "globals": [
      {
        "span": "randtable.rs:22:1: 193:62 (#0)",
        "source": "pub static mut BZ2_rNums: [Int32; 512] =\n    [619 as std::os::raw::c_int, 720 as std::os::raw::c_int, 127 as std::os::raw::c_int,\n     481 as std::os::raw::c_int, 931 as std::os::raw::c_int, 816 as std::os::raw::c_int,\n     813 as std::os::raw::c_int, 233 as std::os::raw::c_int, 566 as std::os::raw::c_int,\n     247 as std::os::raw::c_int, 985 as std::os::raw::c_int, 724 as std::os::raw::c_int,\n     205 as std::os::raw::c_int, 454 as std::os::raw::c_int, 863 as std::os::raw::c_int,\n     491 as std::os::raw::c_int, 741 as std::os::raw::c_int, 242 as std::os::raw::c_int,\n     949 as std::os::raw::c_int, 214 as std::os::raw::c_int, 733 as std::os::raw::c_int,\n     859 as std::os::raw::c_int, 335 as std::os::raw::c_int, 708 as std::os::raw::c_int,\n     621 as std::os::raw::c_int, 574 as std::os::raw::c_int, 73 as std::os::raw::c_int,\n     654 as std::os::raw::c_int, 730 as std::os::raw::c_int, 472 as std::os::raw::c_int,\n     419 as std::os::raw::c_int, 436 as std::os::raw::c_int, 278 as std::os::raw::c_int,\n     496 as std::os::raw::c_int, 867 as std::os::raw::c_int, 210 as std::os::raw::c_int,\n     399 as std::os::raw::c_int, 680 as std::os::raw::c_int, 480 as std::os::raw::c_int,\n     51 as std::os::raw::c_int, 878 as std::os::raw::c_int, 465 as std::os::raw::c_int,\n     811 as std::os::raw::c_int, 169 as std::os::raw::c_int, 869 as std::os::raw::c_int,\n     675 as std::os::raw::c_int, 611 as std::os::raw::c_int, 697 as std::os::raw::c_int,\n     867 as std::os::raw::c_int, 561 as std::os::raw::c_int, 862 as std::os::raw::c_int,\n     687 as std::os::raw::c_int, 507 as std::os::raw::c_int, 283 as std::os::raw::c_int,\n     482 as std::os::raw::c_int, 129 as std::os::raw::c_int, 807 as std::os::raw::c_int,\n     591 as std::os::raw::c_int, 733 as std::os::raw::c_int, 623 as std::os::raw::c_int,\n     150 as std::os::raw::c_int, 238 as std::os::raw::c_int, 59 as std::os::raw::c_int,\n     379 as std::os::raw::c_int, 684 as std::os::raw::c_int, 877 as std::os::raw::c_int,\n     625 as std::os::raw::c_int, 169 as std::os::raw::c_int, 643 as std::os::raw::c_int,\n     105 as std::os::raw::c_int, 170 as std::os::raw::c_int, 607 as std::os::raw::c_int,\n     520 as std::os::raw::c_int, 932 as std::os::raw::c_int, 727 as std::os::raw::c_int,\n     476 as std::os::raw::c_int, 693 as std::os::raw::c_int, 425 as std::os::raw::c_int,\n     174 as std::os::raw::c_int, 647 as std::os::raw::c_int, 73 as std::os::raw::c_int,\n     122 as std::os::raw::c_int, 335 as std::os::raw::c_int, 530 as std::os::raw::c_int,\n     442 as std::os::raw::c_int, 853 as std::os::raw::c_int, 695 as std::os::raw::c_int,\n     249 as std::os::raw::c_int, 445 as std::os::raw::c_int, 515 as std::os::raw::c_int,\n     909 as std::os::raw::c_int, 545 as std::os::raw::c_int, 703 as std::os::raw::c_int,\n     919 as std::os::raw::c_int, 874 as std::os::raw::c_int, 474 as std::os::raw::c_int,\n     882 as std::os::raw::c_int, 500 as std::os::raw::c_int, 594 as std::os::raw::c_int,\n     612 as std::os::raw::c_int, 641 as std::os::raw::c_int, 801 as std::os::raw::c_int,\n     220 as std::os::raw::c_int, 162 as std::os::raw::c_int, 819 as std::os::raw::c_int,\n     984 as std::os::raw::c_int, 589 as std::os::raw::c_int, 513 as std::os::raw::c_int,\n     495 as std::os::raw::c_int, 799 as std::os::raw::c_int, 161 as std::os::raw::c_int,\n     604 as std::os::raw::c_int, 958 as std::os::raw::c_int, 533 as std::os::raw::c_int,\n     221 as std::os::raw::c_int, 400 as std::os::raw::c_int, 386 as std::os::raw::c_int,\n     867 as std::os::raw::c_int, 600 as std::os::raw::c_int, 782 as std::os::raw::c_int,\n     382 as std::os::raw::c_int, 596 as std::os::raw::c_int, 414 as std::os::raw::c_int,\n     171 as std::os::raw::c_int, 516 as std::os::raw::c_int, 375 as std::os::raw::c_int,\n     682 as std::os::raw::c_int, 485 as std::os::raw::c_int, 911 as std::os::raw::c_int,\n     276 as std::os::raw::c_int, 98 as std::os::raw::c_int, 553 as std::os::raw::c_int,\n     163 as std::os::raw::c_int, 354 as std::os::raw::c_int, 666 as std::os::raw::c_int,\n     933 as std::os::raw::c_int, 424 as std::os::raw::c_int, 341 as std::os::raw::c_int,\n     533 as std::os::raw::c_int, 870 as std::os::raw::c_int, 227 as std::os::raw::c_int,\n     730 as std::os::raw::c_int, 475 as std::os::raw::c_int, 186 as std::os::raw::c_int,\n     263 as std::os::raw::c_int, 647 as std::os::raw::c_int, 537 as std::os::raw::c_int,\n     686 as std::os::raw::c_int, 600 as std::os::raw::c_int, 224 as std::os::raw::c_int,\n     469 as std::os::raw::c_int, 68 as std::os::raw::c_int, 770 as std::os::raw::c_int,\n     919 as std::os::raw::c_int, 190 as std::os::raw::c_int, 373 as std::os::raw::c_int,\n     294 as std::os::raw::c_int, 822 as std::os::raw::c_int, 808 as std::os::raw::c_int,\n     206 as std::os::raw::c_int, 184 as std::os::raw::c_int, 943 as std::os::raw::c_int,\n     795 as std::os::raw::c_int, 384 as std::os::raw::c_int, 383 as std::os::raw::c_int,\n     461 as std::os::raw::c_int, 404 as std::os::raw::c_int, 758 as std::os::raw::c_int,\n     839 as std::os::raw::c_int, 887 as std::os::raw::c_int, 715 as std::os::raw::c_int,\n     67 as std::os::raw::c_int, 618 as std::os::raw::c_int, 276 as std::os::raw::c_int,\n     204 as std::os::raw::c_int, 918 as std::os::raw::c_int, 873 as std::os::raw::c_int,\n     777 as std::os::raw::c_int, 604 as std::os::raw::c_int, 560 as std::os::raw::c_int,\n     951 as std::os::raw::c_int, 160 as std::os::raw::c_int, 578 as std::os::raw::c_int,\n     722 as std::os::raw::c_int, 79 as std::os::raw::c_int, 804 as std::os::raw::c_int,\n     96 as std::os::raw::c_int, 409 as std::os::raw::c_int, 713 as std::os::raw::c_int,\n     940 as std::os::raw::c_int, 652 as std::os::raw::c_int, 934 as std::os::raw::c_int,\n     970 as std::os::raw::c_int, 447 as std::os::raw::c_int, 318 as std::os::raw::c_int,\n     353 as std::os::raw::c_int, 859 as std::os::raw::c_int, 672 as std::os::raw::c_int,\n     112 as std::os::raw::c_int, 785 as std::os::raw::c_int, 645 as std::os::raw::c_int,\n     863 as std::os::raw::c_int, 803 as std::os::raw::c_int, 350 as std::os::raw::c_int,\n     139 as std::os::raw::c_int, 93 as std::os::raw::c_int, 354 as std::os::raw::c_int,\n     99 as std::os::raw::c_int, 820 as std::os::raw::c_int, 908 as std::os::raw::c_int,\n     609 as std::os::raw::c_int, 772 as std::os::raw::c_int, 154 as std::os::raw::c_int,\n     274 as std::os::raw::c_int, 580 as std::os::raw::c_int, 184 as std::os::raw::c_int,\n     79 as std::os::raw::c_int, 626 as std::os::raw::c_int, 630 as std::os::raw::c_int,\n     742 as std::os::raw::c_int, 653 as std::os::raw::c_int, 282 as std::os::raw::c_int,\n     762 as std::os::raw::c_int, 623 as std::os::raw::c_int, 680 as std::os::raw::c_int,\n     81 as std::os::raw::c_int, 927 as std::os::raw::c_int, 626 as std::os::raw::c_int,\n     789 as std::os::raw::c_int, 125 as std::os::raw::c_int, 411 as std::os::raw::c_int,\n     521 as std::os::raw::c_int, 938 as std::os::raw::c_int, 300 as std::os::raw::c_int,\n     821 as std::os::raw::c_int, 78 as std::os::raw::c_int, 343 as std::os::raw::c_int,\n     175 as std::os::raw::c_int, 128 as std::os::raw::c_int, 250 as std::os::raw::c_int,\n     170 as std::os::raw::c_int, 774 as std::os::raw::c_int, 972 as std::os::raw::c_int,\n     275 as std::os::raw::c_int, 999 as std::os::raw::c_int, 639 as std::os::raw::c_int,\n     495 as std::os::raw::c_int, 78 as std::os::raw::c_int, 352 as std::os::raw::c_int,\n     126 as std::os::raw::c_int, 857 as std::os::raw::c_int, 956 as std::os::raw::c_int,\n     358 as std::os::raw::c_int, 619 as std::os::raw::c_int, 580 as std::os::raw::c_int,\n     124 as std::os::raw::c_int, 737 as std::os::raw::c_int, 594 as std::os::raw::c_int,\n     701 as std::os::raw::c_int, 612 as std::os::raw::c_int, 669 as std::os::raw::c_int,\n     112 as std::os::raw::c_int, 134 as std::os::raw::c_int, 694 as std::os::raw::c_int,\n     363 as std::os::raw::c_int, 992 as std::os::raw::c_int, 809 as std::os::raw::c_int,\n     743 as std::os::raw::c_int, 168 as std::os::raw::c_int, 974 as std::os::raw::c_int,\n     944 as std::os::raw::c_int, 375 as std::os::raw::c_int, 748 as std::os::raw::c_int,\n     52 as std::os::raw::c_int, 600 as std::os::raw::c_int, 747 as std::os::raw::c_int,\n     642 as std::os::raw::c_int, 182 as std::os::raw::c_int, 862 as std::os::raw::c_int,\n     81 as std::os::raw::c_int, 344 as std::os::raw::c_int, 805 as std::os::raw::c_int,\n     988 as std::os::raw::c_int, 739 as std::os::raw::c_int, 511 as std::os::raw::c_int,\n     655 as std::os::raw::c_int, 814 as std::os::raw::c_int, 334 as std::os::raw::c_int,\n     249 as std::os::raw::c_int, 515 as std::os::raw::c_int, 897 as std::os::raw::c_int,\n     955 as std::os::raw::c_int, 664 as std::os::raw::c_int, 981 as std::os::raw::c_int,\n     649 as std::os::raw::c_int, 113 as std::os::raw::c_int, 974 as std::os::raw::c_int,\n     459 as std::os::raw::c_int, 893 as std::os::raw::c_int, 228 as std::os::raw::c_int,\n     433 as std::os::raw::c_int, 837 as std::os::raw::c_int, 553 as std::os::raw::c_int,\n     268 as std::os::raw::c_int, 926 as std::os::raw::c_int, 240 as std::os::raw::c_int,\n     102 as std::os::raw::c_int, 654 as std::os::raw::c_int, 459 as std::os::raw::c_int,\n     51 as std::os::raw::c_int, 686 as std::os::raw::c_int, 754 as std::os::raw::c_int,\n     806 as std::os::raw::c_int, 760 as std::os::raw::c_int, 493 as std::os::raw::c_int,\n     403 as std::os::raw::c_int, 415 as std::os::raw::c_int, 394 as std::os::raw::c_int,\n     687 as std::os::raw::c_int, 700 as std::os::raw::c_int, 946 as std::os::raw::c_int,\n     670 as std::os::raw::c_int, 656 as std::os::raw::c_int, 610 as std::os::raw::c_int,\n     738 as std::os::raw::c_int, 392 as std::os::raw::c_int, 760 as std::os::raw::c_int,\n     799 as std::os::raw::c_int, 887 as std::os::raw::c_int, 653 as std::os::raw::c_int,\n     978 as std::os::raw::c_int, 321 as std::os::raw::c_int, 576 as std::os::raw::c_int,\n     617 as std::os::raw::c_int, 626 as std::os::raw::c_int, 502 as std::os::raw::c_int,\n     894 as std::os::raw::c_int, 679 as std::os::raw::c_int, 243 as std::os::raw::c_int,\n     440 as std::os::raw::c_int, 680 as std::os::raw::c_int, 879 as std::os::raw::c_int,\n     194 as std::os::raw::c_int, 572 as std::os::raw::c_int, 640 as std::os::raw::c_int,\n     724 as std::os::raw::c_int, 926 as std::os::raw::c_int, 56 as std::os::raw::c_int,\n     204 as std::os::raw::c_int, 700 as std::os::raw::c_int, 707 as std::os::raw::c_int,\n     151 as std::os::raw::c_int, 457 as std::os::raw::c_int, 449 as std::os::raw::c_int,\n     797 as std::os::raw::c_int, 195 as std::os::raw::c_int, 791 as std::os::raw::c_int,\n     558 as std::os::raw::c_int, 945 as std::os::raw::c_int, 679 as std::os::raw::c_int,\n     297 as std::os::raw::c_int, 59 as std::os::raw::c_int, 87 as std::os::raw::c_int,\n     824 as std::os::raw::c_int, 713 as std::os::raw::c_int, 663 as std::os::raw::c_int,\n     412 as std::os::raw::c_int, 693 as std::os::raw::c_int, 342 as std::os::raw::c_int,\n     606 as std::os::raw::c_int, 134 as std::os::raw::c_int, 108 as std::os::raw::c_int,\n     571 as std::os::raw::c_int, 364 as std::os::raw::c_int, 631 as std::os::raw::c_int,\n     212 as std::os::raw::c_int, 174 as std::os::raw::c_int, 643 as std::os::raw::c_int,\n     304 as std::os::raw::c_int, 329 as std::os::raw::c_int, 343 as std::os::raw::c_int,\n     97 as std::os::raw::c_int, 430 as std::os::raw::c_int, 751 as std::os::raw::c_int,\n     497 as std::os::raw::c_int, 314 as std::os::raw::c_int, 983 as std::os::raw::c_int,\n     374 as std::os::raw::c_int, 822 as std::os::raw::c_int, 928 as std::os::raw::c_int,\n     140 as std::os::raw::c_int, 206 as std::os::raw::c_int, 73 as std::os::raw::c_int,\n     263 as std::os::raw::c_int, 980 as std::os::raw::c_int, 736 as std::os::raw::c_int,\n     876 as std::os::raw::c_int, 478 as std::os::raw::c_int, 430 as std::os::raw::c_int,\n     305 as std::os::raw::c_int, 170 as std::os::raw::c_int, 514 as std::os::raw::c_int,\n     364 as std::os::raw::c_int, 692 as std::os::raw::c_int, 829 as std::os::raw::c_int,\n     82 as std::os::raw::c_int, 855 as std::os::raw::c_int, 953 as std::os::raw::c_int,\n     676 as std::os::raw::c_int, 246 as std::os::raw::c_int, 369 as std::os::raw::c_int,\n     970 as std::os::raw::c_int, 294 as std::os::raw::c_int, 750 as std::os::raw::c_int,\n     807 as std::os::raw::c_int, 827 as std::os::raw::c_int, 150 as std::os::raw::c_int,\n     790 as std::os::raw::c_int, 288 as std::os::raw::c_int, 923 as std::os::raw::c_int,\n     804 as std::os::raw::c_int, 378 as std::os::raw::c_int, 215 as std::os::raw::c_int,\n     828 as std::os::raw::c_int, 592 as std::os::raw::c_int, 281 as std::os::raw::c_int,\n     565 as std::os::raw::c_int, 555 as std::os::raw::c_int, 710 as std::os::raw::c_int,\n     82 as std::os::raw::c_int, 896 as std::os::raw::c_int, 831 as std::os::raw::c_int,\n     547 as std::os::raw::c_int, 261 as std::os::raw::c_int, 524 as std::os::raw::c_int,\n     462 as std::os::raw::c_int, 293 as std::os::raw::c_int, 465 as std::os::raw::c_int,\n     502 as std::os::raw::c_int, 56 as std::os::raw::c_int, 661 as std::os::raw::c_int,\n     821 as std::os::raw::c_int, 976 as std::os::raw::c_int, 991 as std::os::raw::c_int,\n     658 as std::os::raw::c_int, 869 as std::os::raw::c_int, 905 as std::os::raw::c_int,\n     758 as std::os::raw::c_int, 745 as std::os::raw::c_int, 193 as std::os::raw::c_int,\n     768 as std::os::raw::c_int, 550 as std::os::raw::c_int, 608 as std::os::raw::c_int,\n     933 as std::os::raw::c_int, 378 as std::os::raw::c_int, 286 as std::os::raw::c_int,\n     215 as std::os::raw::c_int, 979 as std::os::raw::c_int, 792 as std::os::raw::c_int,\n     961 as std::os::raw::c_int, 61 as std::os::raw::c_int, 688 as std::os::raw::c_int,\n     793 as std::os::raw::c_int, 644 as std::os::raw::c_int, 986 as std::os::raw::c_int,\n     403 as std::os::raw::c_int, 106 as std::os::raw::c_int, 366 as std::os::raw::c_int,\n     905 as std::os::raw::c_int, 644 as std::os::raw::c_int, 372 as std::os::raw::c_int,\n     567 as std::os::raw::c_int, 466 as std::os::raw::c_int, 434 as std::os::raw::c_int,\n     645 as std::os::raw::c_int, 210 as std::os::raw::c_int, 389 as std::os::raw::c_int,\n     550 as std::os::raw::c_int, 919 as std::os::raw::c_int, 135 as std::os::raw::c_int,\n     780 as std::os::raw::c_int, 773 as std::os::raw::c_int, 635 as std::os::raw::c_int,\n     389 as std::os::raw::c_int, 707 as std::os::raw::c_int, 100 as std::os::raw::c_int,\n     626 as std::os::raw::c_int, 958 as std::os::raw::c_int, 165 as std::os::raw::c_int,\n     504 as std::os::raw::c_int, 920 as std::os::raw::c_int, 176 as std::os::raw::c_int,\n     193 as std::os::raw::c_int, 713 as std::os::raw::c_int, 857 as std::os::raw::c_int,\n     265 as std::os::raw::c_int, 203 as std::os::raw::c_int, 50 as std::os::raw::c_int,\n     668 as std::os::raw::c_int, 108 as std::os::raw::c_int, 645 as std::os::raw::c_int,\n     990 as std::os::raw::c_int, 626 as std::os::raw::c_int, 197 as std::os::raw::c_int,\n     510 as std::os::raw::c_int, 357 as std::os::raw::c_int, 358 as std::os::raw::c_int,\n     850 as std::os::raw::c_int, 858 as std::os::raw::c_int, 364 as std::os::raw::c_int,\n     936 as std::os::raw::c_int, 638 as std::os::raw::c_int];"
      }
    ],
    "imports": [
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "bzlib.rs:835:9: 894:14 (#0)",
        "pieces": [
          "bzlib.rs:835:9: 894:14 (#0)"
        ],
        "num_lines": 60,
        "source": "while 1 as std::os::raw::c_int as Bool != 0 {\n                if (*(*s).strm).avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint\n                   {\n                    return 0 as std::os::raw::c_int as Bool\n                }\n                if (*s).state_out_len == 0 as std::os::raw::c_int { break ; }\n                *((*(*s).strm).next_out as *mut UChar) = (*s).state_out_ch;\n                (*s).calculatedBlockCRC =\n                    (*s).calculatedBlockCRC << 8 as std::os::raw::c_int ^\n                        BZ2_crc32Table[((*s).calculatedBlockCRC >>\n                                            24 as std::os::raw::c_int ^\n                                            (*s).state_out_ch as std::os::raw::c_uint)\n                                           as usize];\n                (*s).state_out_len -= 1;\n                (*(*s).strm).next_out = (*(*s).strm).next_out.offset(1);\n                (*(*s).strm).avail_out =\n                    (*(*s).strm).avail_out.wrapping_sub(1);\n                (*(*s).strm).total_out_lo32 =\n                    (*(*s).strm).total_out_lo32.wrapping_add(1);\n                if (*(*s).strm).total_out_lo32 ==\n                       0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    (*(*s).strm).total_out_hi32 =\n                        (*(*s).strm).total_out_hi32.wrapping_add(1)\n                }\n            }\n            /* can a new run be started? */\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                return 0 as std::os::raw::c_int as Bool\n            }\n            /* Only caused by corrupt data stream? */\n            if (*s).nblock_used > (*s).save_nblock + 1 as std::os::raw::c_int {\n                return 1 as std::os::raw::c_int as Bool\n            }\n            (*s).state_out_len = 1 as std::os::raw::c_int;\n            (*s).state_out_ch = (*s).k0 as UChar;\n            if (*s).tPos >=\n                   (100000 as std::os::raw::c_int as\n                        UInt32).wrapping_mul((*s).blockSize100k as UInt32) {\n                return 1 as std::os::raw::c_int as Bool\n            }\n            (*s).tPos = *(*s).tt.offset((*s).tPos as isize);\n            k1 = ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as UChar;\n            (*s).tPos >>= 8 as std::os::raw::c_int;\n            if (*s).rNToGo == 0 as std::os::raw::c_int {\n                (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                (*s).rTPos += 1;\n                if (*s).rTPos == 512 as std::os::raw::c_int {\n                    (*s).rTPos = 0 as std::os::raw::c_int\n                }\n            }\n            (*s).rNToGo -= 1;\n            k1 =\n                (k1 as std::os::raw::c_int ^\n                     if (*s).rNToGo == 1 as std::os::raw::c_int {\n                         1 as std::os::raw::c_int\n                     } else { 0 as std::os::raw::c_int }) as UChar;\n            (*s).nblock_used += 1;\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                continue ;\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut k1: u8"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut k1: u8"
        ]
      },
      {
        "chunk_id": 1,
        "span": "bzlib.rs:895:12: 988:2 (#0)",
        "pieces": [
          "bzlib.rs:895:12: 988:2 (#0)"
        ],
        "num_lines": 121,
        "source": "if k1 as std::os::raw::c_int != (*s).k0 {\n                (*s).k0 = k1 as Int32\n            } else {\n                (*s).state_out_len = 2 as std::os::raw::c_int;\n                if (*s).tPos >=\n                       (100000 as std::os::raw::c_int as\n                            UInt32).wrapping_mul((*s).blockSize100k as UInt32)\n                   {\n                    return 1 as std::os::raw::c_int as Bool\n                }\n                (*s).tPos = *(*s).tt.offset((*s).tPos as isize);\n                k1 =\n                    ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n                        UChar;\n                (*s).tPos >>= 8 as std::os::raw::c_int;\n                if (*s).rNToGo == 0 as std::os::raw::c_int {\n                    (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                    (*s).rTPos += 1;\n                    if (*s).rTPos == 512 as std::os::raw::c_int {\n                        (*s).rTPos = 0 as std::os::raw::c_int\n                    }\n                }\n                (*s).rNToGo -= 1;\n                k1 =\n                    (k1 as std::os::raw::c_int ^\n                         if (*s).rNToGo == 1 as std::os::raw::c_int {\n                             1 as std::os::raw::c_int\n                         } else { 0 as std::os::raw::c_int }) as UChar;\n                (*s).nblock_used += 1;\n                if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                    continue ;\n                }\n                if k1 as std::os::raw::c_int != (*s).k0 {\n                    (*s).k0 = k1 as Int32\n                } else {\n                    (*s).state_out_len = 3 as std::os::raw::c_int;\n                    if (*s).tPos >=\n                           (100000 as std::os::raw::c_int as\n                                UInt32).wrapping_mul((*s).blockSize100k as\n                                                         UInt32) {\n                        return 1 as std::os::raw::c_int as Bool\n                    }\n                    (*s).tPos = *(*s).tt.offset((*s).tPos as isize);\n                    k1 =\n                        ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n                            UChar;\n                    (*s).tPos >>= 8 as std::os::raw::c_int;\n                    if (*s).rNToGo == 0 as std::os::raw::c_int {\n                        (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                        (*s).rTPos += 1;\n                        if (*s).rTPos == 512 as std::os::raw::c_int {\n                            (*s).rTPos = 0 as std::os::raw::c_int\n                        }\n                    }\n                    (*s).rNToGo -= 1;\n                    k1 =\n                        (k1 as std::os::raw::c_int ^\n                             if (*s).rNToGo == 1 as std::os::raw::c_int {\n                                 1 as std::os::raw::c_int\n                             } else { 0 as std::os::raw::c_int }) as UChar;\n                    (*s).nblock_used += 1;\n                    if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int\n                       {\n                        continue ;\n                    }\n                    if k1 as std::os::raw::c_int != (*s).k0 {\n                        (*s).k0 = k1 as Int32\n                    } else {\n                        if (*s).tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul((*s).blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        (*s).tPos = *(*s).tt.offset((*s).tPos as isize);\n                        k1 =\n                            ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint)\n                                as UChar;\n                        (*s).tPos >>= 8 as std::os::raw::c_int;\n                        if (*s).rNToGo == 0 as std::os::raw::c_int {\n                            (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                            (*s).rTPos += 1;\n                            if (*s).rTPos == 512 as std::os::raw::c_int {\n                                (*s).rTPos = 0 as std::os::raw::c_int\n                            }\n                        }\n                        (*s).rNToGo -= 1;\n                        k1 =\n                            (k1 as std::os::raw::c_int ^\n                                 if (*s).rNToGo == 1 as std::os::raw::c_int {\n                                     1 as std::os::raw::c_int\n                                 } else { 0 as std::os::raw::c_int }) as UChar;\n                        (*s).nblock_used += 1;\n                        (*s).state_out_len = k1 as Int32 + 4 as std::os::raw::c_int;\n                        if (*s).tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul((*s).blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        (*s).tPos = *(*s).tt.offset((*s).tPos as isize);\n                        (*s).k0 =\n                            ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint)\n                                as UChar as Int32;\n                        (*s).tPos >>= 8 as std::os::raw::c_int;\n                        if (*s).rNToGo == 0 as std::os::raw::c_int {\n                            (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                            (*s).rTPos += 1;\n                            if (*s).rTPos == 512 as std::os::raw::c_int {\n                                (*s).rTPos = 0 as std::os::raw::c_int\n                            }\n                        }\n                        (*s).rNToGo -= 1;\n                        (*s).k0 ^=\n                            if (*s).rNToGo == 1 as std::os::raw::c_int {\n                                1 as std::os::raw::c_int\n                            } else { 0 as std::os::raw::c_int };\n                        (*s).nblock_used += 1\n                    }\n                }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut k1: u8"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut k1: u8"
        ]
      },
      {
        "chunk_id": 2,
        "span": "bzlib.rs:1011:17: 1095:2 (#0)",
        "pieces": [
          "bzlib.rs:1011:17: 1095:2 (#0)"
        ],
        "num_lines": 107,
        "source": "if c_state_out_len > 0 as std::os::raw::c_int {\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if cs_avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            break 's_569 ;\n                        }\n                        if c_state_out_len == 1 as std::os::raw::c_int { break ; }\n                        *(cs_next_out as *mut UChar) = c_state_out_ch;\n                        c_calculatedBlockCRC =\n                            c_calculatedBlockCRC << 8 as std::os::raw::c_int ^\n                                BZ2_crc32Table[(c_calculatedBlockCRC >>\n                                                    24 as std::os::raw::c_int ^\n                                                    c_state_out_ch as\n                                                        std::os::raw::c_uint) as\n                                                   usize];\n                        c_state_out_len -= 1;\n                        cs_next_out = cs_next_out.offset(1);\n                        cs_avail_out = cs_avail_out.wrapping_sub(1)\n                    }\n                    current_block = 16910810822589621899;\n                } else { current_block = 3024573345131975588; }\n                loop  {\n                    match current_block {\n                        16910810822589621899 => {\n                            if cs_avail_out ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                c_state_out_len = 1 as std::os::raw::c_int;\n                                break 's_569 ;\n                            } else {\n                                *(cs_next_out as *mut UChar) = c_state_out_ch;\n                                c_calculatedBlockCRC =\n                                    c_calculatedBlockCRC << 8 as std::os::raw::c_int ^\n                                        BZ2_crc32Table[(c_calculatedBlockCRC\n                                                            >>\n                                                            24 as std::os::raw::c_int\n                                                            ^\n                                                            c_state_out_ch as\n                                                                std::os::raw::c_uint)\n                                                           as usize];\n                                cs_next_out = cs_next_out.offset(1);\n                                cs_avail_out = cs_avail_out.wrapping_sub(1);\n                                current_block = 3024573345131975588;\n                            }\n                        }\n                        _ => {\n                            /* Only caused by corrupt data stream? */\n                            if c_nblock_used > s_save_nblockPP {\n                                return 1 as std::os::raw::c_int as Bool\n                            }\n                            /* can a new run be started? */\n                            if c_nblock_used == s_save_nblockPP {\n                                c_state_out_len = 0 as std::os::raw::c_int;\n                                break 's_569 ;\n                            } else {\n                                c_state_out_ch = c_k0 as UChar;\n                                if c_tPos >=\n                                       (100000 as std::os::raw::c_int as\n                                            UInt32).wrapping_mul(ro_blockSize100k\n                                                                     as\n                                                                     UInt32) {\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                                c_tPos = *c_tt.offset(c_tPos as isize);\n                                k1 =\n                                    (c_tPos &\n                                         0xff as std::os::raw::c_int as std::os::raw::c_uint)\n                                        as UChar;\n                                c_tPos >>= 8 as std::os::raw::c_int;\n                                c_nblock_used += 1;\n                                if k1 as std::os::raw::c_int != c_k0 {\n                                    c_k0 = k1 as Int32;\n                                    current_block = 16910810822589621899;\n                                } else {\n                                    if c_nblock_used == s_save_nblockPP {\n                                        current_block = 16910810822589621899;\n                                        continue ;\n                                    }\n                                    c_state_out_len = 2 as std::os::raw::c_int;\n                                    if c_tPos >=\n                                           (100000 as std::os::raw::c_int as\n                                                UInt32).wrapping_mul(ro_blockSize100k\n                                                                         as\n                                                                         UInt32)\n                                       {\n                                        return 1 as std::os::raw::c_int as Bool\n                                    }\n                                    c_tPos = *c_tt.offset(c_tPos as isize);\n                                    k1 =\n                                        (c_tPos &\n                                             0xff as std::os::raw::c_int as\n                                                 std::os::raw::c_uint) as UChar;\n                                    c_tPos >>= 8 as std::os::raw::c_int;\n                                    c_nblock_used += 1;\n                                    if c_nblock_used == s_save_nblockPP {\n                                        continue 's_569 ;\n                                    }\n                                    if k1 as std::os::raw::c_int != c_k0 {\n                                        current_block = 18139099716546303047;\n                                        break ;\n                                    } else {\n                                        current_block = 919396821984190499;\n                                        break ;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut current_block: u64",
          "mut k1: u8",
          "mut c_calculatedBlockCRC: u32",
          "mut c_state_out_ch: u8",
          "mut c_state_out_len: i32",
          "mut c_nblock_used: i32",
          "mut c_k0: i32",
          "mut c_tt: *mut u32",
          "mut c_tPos: u32",
          "mut cs_next_out: *mut i8",
          "mut cs_avail_out: u32",
          "mut ro_blockSize100k: i32",
          "mut s_save_nblockPP: i32"
        ],
        "live_out": [
          "mut current_block: u64",
          "mut k1: u8",
          "mut c_calculatedBlockCRC: u32",
          "mut c_state_out_ch: u8",
          "mut c_state_out_len: i32",
          "mut c_nblock_used: i32",
          "mut c_k0: i32",
          "mut c_tt: *mut u32",
          "mut c_tPos: u32",
          "mut cs_next_out: *mut i8",
          "mut cs_avail_out: u32",
          "mut ro_blockSize100k: i32",
          "mut s_save_nblockPP: i32"
        ]
      },
      {
        "chunk_id": 3,
        "span": "bzlib.rs:1097:17: 1136:2 (#0)",
        "pieces": [
          "bzlib.rs:1097:17: 1136:2 (#0)"
        ],
        "num_lines": 48,
        "source": "match current_block {\n                    18139099716546303047 => { c_k0 = k1 as Int32 }\n                    _ => {\n                        c_state_out_len = 3 as std::os::raw::c_int;\n                        if c_tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul(ro_blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        c_tPos = *c_tt.offset(c_tPos as isize);\n                        k1 =\n                            (c_tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n                                UChar;\n                        c_tPos >>= 8 as std::os::raw::c_int;\n                        c_nblock_used += 1;\n                        if c_nblock_used == s_save_nblockPP { continue ; }\n                        if k1 as std::os::raw::c_int != c_k0 {\n                            c_k0 = k1 as Int32\n                        } else {\n                            if c_tPos >=\n                                   (100000 as std::os::raw::c_int as\n                                        UInt32).wrapping_mul(ro_blockSize100k\n                                                                 as UInt32) {\n                                return 1 as std::os::raw::c_int as Bool\n                            }\n                            c_tPos = *c_tt.offset(c_tPos as isize);\n                            k1 =\n                                (c_tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint)\n                                    as UChar;\n                            c_tPos >>= 8 as std::os::raw::c_int;\n                            c_nblock_used += 1;\n                            c_state_out_len = k1 as Int32 + 4 as std::os::raw::c_int;\n                            if c_tPos >=\n                                   (100000 as std::os::raw::c_int as\n                                        UInt32).wrapping_mul(ro_blockSize100k\n                                                                 as UInt32) {\n                                return 1 as std::os::raw::c_int as Bool\n                            }\n                            c_tPos = *c_tt.offset(c_tPos as isize);\n                            c_k0 =\n                                (c_tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint)\n                                    as UChar as Int32;\n                            c_tPos >>= 8 as std::os::raw::c_int;\n                            c_nblock_used += 1\n                        }\n                    }\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut current_block: u64",
          "mut k1: u8",
          "mut c_state_out_len: i32",
          "mut c_nblock_used: i32",
          "mut c_k0: i32",
          "mut c_tt: *mut u32",
          "mut c_tPos: u32",
          "mut ro_blockSize100k: i32",
          "mut s_save_nblockPP: i32"
        ],
        "live_out": [
          "mut current_block: u64",
          "mut k1: u8",
          "mut c_state_out_len: i32",
          "mut c_nblock_used: i32",
          "mut c_k0: i32",
          "mut c_tt: *mut u32",
          "mut c_tPos: u32",
          "mut ro_blockSize100k: i32",
          "mut s_save_nblockPP: i32"
        ]
      },
      {
        "chunk_id": 4,
        "span": "bzlib.rs:994:5: 1155:46 (#0)",
        "pieces": [
          "bzlib.rs:994:5: 1011:16 (#0)",
          "bzlib.rs:1097:1: 1097:16 (#0)",
          "bzlib.rs:1138:1: 1155:46 (#0)"
        ],
        "num_lines": 37,
        "source": "let mut c_calculatedBlockCRC: UInt32 = (*s).calculatedBlockCRC;\n        let mut c_state_out_ch: UChar = (*s).state_out_ch;\n        let mut c_state_out_len: Int32 = (*s).state_out_len;\n        let mut c_nblock_used: Int32 = (*s).nblock_used;\n        let mut c_k0: Int32 = (*s).k0;\n        let mut c_tt: *mut UInt32 = (*s).tt;\n        let mut c_tPos: UInt32 = (*s).tPos;\n        let mut cs_next_out: *mut std::os::raw::c_char = (*(*s).strm).next_out;\n        let mut cs_avail_out: std::os::raw::c_uint = (*(*s).strm).avail_out;\n        let mut ro_blockSize100k: Int32 = (*s).blockSize100k;\n        /* end restore */\n        let mut avail_out_INIT: UInt32 = cs_avail_out;\n        let mut s_save_nblockPP: Int32 = (*s).save_nblock + 1 as std::os::raw::c_int;\n        let mut total_out_lo32_old: std::os::raw::c_uint = 0;\n        's_569:\n            while 1 as std::os::raw::c_int as Bool != 0 {\n                /* try to finish existing run */\n               <<chunk 2>>               <<chunk 3>>            }\n        total_out_lo32_old = (*(*s).strm).total_out_lo32;\n        (*(*s).strm).total_out_lo32 =\n            (*(*s).strm).total_out_lo32.wrapping_add(avail_out_INIT.wrapping_sub(cs_avail_out));\n        if (*(*s).strm).total_out_lo32 < total_out_lo32_old {\n            (*(*s).strm).total_out_hi32 =\n                (*(*s).strm).total_out_hi32.wrapping_add(1)\n        }\n        /* save */\n        (*s).calculatedBlockCRC = c_calculatedBlockCRC;\n        (*s).state_out_ch = c_state_out_ch;\n        (*s).state_out_len = c_state_out_len;\n        (*s).nblock_used = c_nblock_used;\n        (*s).k0 = c_k0;\n        (*s).tt = c_tt;\n        (*s).tPos = c_tPos;\n        (*(*s).strm).next_out = cs_next_out;\n        (*(*s).strm).avail_out = cs_avail_out",
        "sub_chunks": [
          2,
          3
        ],
        "live_in": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut k1: u8"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut k1: u8",
          "mut c_calculatedBlockCRC: u32",
          "mut c_state_out_ch: u8",
          "mut c_state_out_len: i32",
          "mut c_nblock_used: i32",
          "mut c_k0: i32",
          "mut c_tt: *mut u32",
          "mut c_tPos: u32",
          "mut cs_next_out: *mut i8",
          "mut cs_avail_out: u32",
          "mut ro_blockSize100k: i32",
          "mut avail_out_INIT: u32",
          "mut s_save_nblockPP: i32",
          "mut total_out_lo32_old: u32"
        ]
      },
      {
        "chunk_id": 5,
        "span": "bzlib.rs:829:5: 1158:10 (#0)",
        "pieces": [
          "bzlib.rs:829:5: 835:8 (#0)",
          "bzlib.rs:895:1: 895:11 (#0)",
          "bzlib.rs:990:1: 994:4 (#0)",
          "bzlib.rs:1156:1: 1158:10 (#0)"
        ],
        "num_lines": 14,
        "source": "let mut current_block: u64;\n    let mut k1: UChar = 0;\n    if (*s).blockRandomised != 0 {\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /* try to finish existing run */\n           <<chunk 0>>           <<chunk 1>>        }\n    } else {\n        /* restore */\n       <<chunk 4>>        /* end save */\n    }\n    return 0 as std::os::raw::c_int as Bool;",
        "sub_chunks": [
          0,
          1,
          4
        ],
        "live_in": [
          "mut s: *mut bzlib::DState"
        ],
        "live_out": [
          "mut s: *mut bzlib::DState",
          "mut current_block: u64",
          "mut k1: u8"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:448 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
    "span": "bzlib.rs:2135:1: 2183:2 (#0)",
    "pieces": [
      "bzlib.rs:2135:1: 2183:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 56,
    "source": "pub unsafe extern \"C\" fn BZ2_bzBuffToBuffDecompress(mut dest:\n                                                        *mut std::os::raw::c_char,\n                                                    mut destLen:\n                                                        *mut std::os::raw::c_uint,\n                                                    mut source:\n                                                        *mut std::os::raw::c_char,\n                                                    mut sourceLen:\n                                                        std::os::raw::c_uint,\n                                                    mut small: std::os::raw::c_int,\n                                                    mut verbosity:\n                                                        std::os::raw::c_int)\n -> std::os::raw::c_int {\n    let mut strm: bz_stream =\n        bz_stream{next_in: 0 as *mut std::os::raw::c_char,\n                  avail_in: 0,\n                  total_in_lo32: 0,\n                  total_in_hi32: 0,\n                  next_out: 0 as *mut std::os::raw::c_char,\n                  avail_out: 0,\n                  total_out_lo32: 0,\n                  total_out_hi32: 0,\n                  state: 0 as *mut std::os::raw::c_void,\n                  bzalloc: None,\n                  bzfree: None,\n                  opaque: 0 as *mut std::os::raw::c_void,};\n    let mut ret: std::os::raw::c_int = 0;\n    if dest.is_null() || destLen.is_null() || source.is_null() ||\n           small != 0 as std::os::raw::c_int && small != 1 as std::os::raw::c_int ||\n           verbosity < 0 as std::os::raw::c_int || verbosity > 4 as std::os::raw::c_int {\n        return -(2 as std::os::raw::c_int)\n    }\n    strm.bzalloc = None;\n    strm.bzfree = None;\n    strm.opaque = 0 as *mut std::os::raw::c_void;\n    ret = BZ2_bzDecompressInit(&mut strm, verbosity, small);\n    if ret != 0 as std::os::raw::c_int { return ret }\n    strm.next_in = source;\n    strm.next_out = dest;\n    strm.avail_in = sourceLen;\n    strm.avail_out = *destLen;\n    ret = BZ2_bzDecompress(&mut strm);\n    if ret == 0 as std::os::raw::c_int {\n        if strm.avail_out > 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            BZ2_bzDecompressEnd(&mut strm);\n            return -(7 as std::os::raw::c_int)\n        } else { BZ2_bzDecompressEnd(&mut strm); return -(8 as std::os::raw::c_int) }\n    } else if ret != 4 as std::os::raw::c_int {\n        BZ2_bzDecompressEnd(&mut strm);\n        return ret\n    } else {\n        /* normal termination */\n        *destLen = (*destLen).wrapping_sub(strm.avail_out);\n        BZ2_bzDecompressEnd(&mut strm);\n        return 0 as std::os::raw::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:210 ~ c2rust_out[3c70]::bzip2::uInt64_isZero)",
    "span": "bzip2.rs:453:1: 460:2 (#0)",
    "pieces": [
      "bzip2.rs:453:1: 460:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn uInt64_isZero(mut n: *mut UInt64) -> Bool {\n    let mut i: Int32 = 0;\n    i = 0 as std::os::raw::c_int;\n    while i < 8 as std::os::raw::c_int {\n        if (*n).b[i as usize] as std::os::raw::c_int != 0 as std::os::raw::c_int {\n            return 0 as std::os::raw::c_int as Bool\n        }\n        i += 1\n    }\n    return 1 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:420 ~ c2rust_out[3c70]::bzlib::default_bzfree)",
    "span": "bzlib.rs:293:1: 297:2 (#0)",
    "pieces": [
      "bzlib.rs:293:1: 297:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn default_bzfree(mut opaque: *mut std::os::raw::c_void,\n                                    mut addr: *mut std::os::raw::c_void) {\n    if !addr.is_null() { free(addr); };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:250 ~ c2rust_out[3c70]::bzip2::fileExists)",
    "span": "bzip2.rs:1670:1: 1677:2 (#0)",
    "pieces": [
      "bzip2.rs:1670:1: 1677:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn fileExists(mut name: *mut Char) -> Bool {\n    let mut tmp: *mut FILE =\n        fopen(name, b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n    let mut exists: Bool =\n        (tmp != 0 as *mut std::os::raw::c_void as *mut FILE) as std::os::raw::c_int as Bool;\n    if !tmp.is_null() { fclose(tmp); }\n    return exists;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:460 ~ c2rust_out[3c70]::bzlib::BZ2_bzflush)",
    "span": "bzlib.rs:2345:1: 2348:2 (#0)",
    "pieces": [
      "bzlib.rs:2345:1: 2348:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub extern \"C\" fn BZ2_bzflush(mut b: *mut std::os::raw::c_void)\n -> std::os::raw::c_int {\n    /* do nothing now... */\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:464 ~ c2rust_out[3c70]::bzlib::BZ2_bzerror)",
    "span": "bzlib.rs:2389:1: 2393:2 (#0)",
    "pieces": [
      "bzlib.rs:2389:1: 2393:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn BZ2_bzerror(mut b: *mut std::os::raw::c_void,\n                                     mut errnum: *mut std::os::raw::c_int)\n -> *const std::os::raw::c_char {\n    let mut err: std::os::raw::c_int = (*(b as *mut bzFile)).lastErr;\n    if err > 0 as std::os::raw::c_int { err = 0 as std::os::raw::c_int }\n    *errnum = err;\n    return bzerrorstrings[(err * -(1 as std::os::raw::c_int)) as usize];\n}",
    "calls": [],
    "globals": [
      {
        "span": "bzlib.rs:2371:1: 2387:62 (#0)",
        "source": "static mut bzerrorstrings: [*const std::os::raw::c_char; 16] =\n    [b\"OK\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"SEQUENCE_ERROR\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"PARAM_ERROR\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"MEM_ERROR\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"DATA_ERROR\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"DATA_ERROR_MAGIC\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"IO_ERROR\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"UNEXPECTED_EOF\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"OUTBUFF_FULL\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"CONFIG_ERROR\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"???\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"???\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"???\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"???\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"???\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"???\\x00\" as *const u8 as *const std::os::raw::c_char];"
      }
    ],
    "imports": [
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:461 ~ c2rust_out[3c70]::bzlib::BZ2_bzclose)",
    "span": "bzlib.rs:2352:1: 2366:2 (#0)",
    "pieces": [
      "bzlib.rs:2352:1: 2366:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn BZ2_bzclose(mut b: *mut std::os::raw::c_void) {\n    let mut bzerr: std::os::raw::c_int = 0;\n    let mut fp: *mut FILE = 0 as *mut FILE;\n    if b.is_null() { return }\n    fp = (*(b as *mut bzFile)).handle;\n    if (*(b as *mut bzFile)).writing != 0 {\n        BZ2_bzWriteClose(&mut bzerr, b, 0 as std::os::raw::c_int,\n                         0 as *mut std::os::raw::c_uint, 0 as *mut std::os::raw::c_uint);\n        if bzerr != 0 as std::os::raw::c_int {\n            BZ2_bzWriteClose(0 as *mut std::os::raw::c_int, b, 1 as std::os::raw::c_int,\n                             0 as *mut std::os::raw::c_uint, 0 as *mut std::os::raw::c_uint);\n        }\n    } else { BZ2_bzReadClose(&mut bzerr, b); }\n    if fp != __stdinp && fp != __stdoutp { fclose(fp); };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:24:1: 24:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "bzlib.rs:32:1: 32:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzlib.rs:82:1: 82:41 (#0)",
        "source": "pub use crate::crctable::BZ2_crc32Table;"
      },
      {
        "span": "bzlib.rs:85:1: 85:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:34:1: 34:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzlib.rs:86:1: 86:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:22:1: 22:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzlib.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzlib.rs:26:1: 26:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "bzlib.rs:84:1: 84:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:28:1: 28:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzlib.rs:83:1: 83:37 (#0)",
        "source": "pub use crate::randtable::BZ2_rNums;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:245 ~ c2rust_out[3c70]::bzip2::mySIGSEGVorSIGBUScatcher)",
    "span": "bzip2.rs:1574:1: 1611:2 (#0)",
    "pieces": [
      "bzip2.rs:1574:1: 1611:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "unsafe extern \"C\" fn mySIGSEGVorSIGBUScatcher(mut n: IntNative) {\n    let mut msg: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;\n    if opMode == 1 as std::os::raw::c_int {\n        msg =\n            b\": Caught a SIGSEGV or SIGBUS whilst compressing.\\n\\n   Possible causes are (most likely first):\\n   (1) This computer has unreliable memory or cache hardware\\n       (a surprisingly common problem; try a different machine.)\\n   (2) A bug in the compiler used to create this executable\\n       (unlikely, if you didn\\'t compile bzip2 yourself.)\\n   (3) A real bug in bzip2 -- I hope this should never be the case.\\n   The user\\'s manual, Section 4.3, has more info on (1) and (2).\\n   \\n   If you suspect this is a bug in bzip2, or are unsure about (1)\\n   or (2), feel free to report it to: bzip2-devel@sourceware.org.\\n   Section 4.3 of the user\\'s manual describes the info a useful\\n   bug report should have.  If the manual is available on your\\n   system, please try and read it before mailing me.  If you don\\'t\\n   have the manual or can\\'t be bothered to read it, mail me anyway.\\n\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char\n    } else {\n        msg =\n            b\": Caught a SIGSEGV or SIGBUS whilst decompressing.\\n\\n   Possible causes are (most likely first):\\n   (1) The compressed data is corrupted, and bzip2\\'s usual checks\\n       failed to detect this.  Try bzip2 -tvv my_file.bz2.\\n   (2) This computer has unreliable memory or cache hardware\\n       (a surprisingly common problem; try a different machine.)\\n   (3) A bug in the compiler used to create this executable\\n       (unlikely, if you didn\\'t compile bzip2 yourself.)\\n   (4) A real bug in bzip2 -- I hope this should never be the case.\\n   The user\\'s manual, Section 4.3, has more info on (2) and (3).\\n   \\n   If you suspect this is a bug in bzip2, or are unsure about (2)\\n   or (3), feel free to report it to: bzip2-devel@sourceware.org.\\n   Section 4.3 of the user\\'s manual describes the info a useful\\n   bug report should have.  If the manual is available on your\\n   system, please try and read it before mailing me.  If you don\\'t\\n   have the manual or can\\'t be bothered to read it, mail me anyway.\\n\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char\n    }\n    write(2 as std::os::raw::c_int,\n          b\"\\n\\x00\" as *const u8 as *const std::os::raw::c_char as\n              *const std::os::raw::c_void, 1 as std::os::raw::c_int as size_t);\n    write(2 as std::os::raw::c_int, progName as *const std::os::raw::c_void,\n          strlen(progName));\n    write(2 as std::os::raw::c_int, msg as *const std::os::raw::c_void, strlen(msg));\n    msg = b\"\\tInput file = \\x00\" as *const u8 as *const std::os::raw::c_char;\n    write(2 as std::os::raw::c_int, msg as *const std::os::raw::c_void, strlen(msg));\n    write(2 as std::os::raw::c_int, inName.as_mut_ptr() as *const std::os::raw::c_void,\n          strlen(inName.as_mut_ptr()));\n    write(2 as std::os::raw::c_int,\n          b\"\\n\\x00\" as *const u8 as *const std::os::raw::c_char as\n              *const std::os::raw::c_void, 1 as std::os::raw::c_int as size_t);\n    msg = b\"\\tOutput file = \\x00\" as *const u8 as *const std::os::raw::c_char;\n    write(2 as std::os::raw::c_int, msg as *const std::os::raw::c_void, strlen(msg));\n    write(2 as std::os::raw::c_int, outName.as_mut_ptr() as *const std::os::raw::c_void,\n          strlen(outName.as_mut_ptr()));\n    write(2 as std::os::raw::c_int,\n          b\"\\n\\x00\" as *const u8 as *const std::os::raw::c_char as\n              *const std::os::raw::c_void, 1 as std::os::raw::c_int as size_t);\n    /* Don't call cleanupAndFail. If we ended up here something went\n      terribly wrong. Trying to clean up might fail spectacularly. */\n    if opMode == 1 as std::os::raw::c_int {\n        setExit(3 as std::os::raw::c_int);\n    } else { setExit(2 as std::os::raw::c_int); }\n    _exit(exitValue);\n}",
    "calls": [],
    "globals": [
      {
        "span": "bzip2.rs:422:1: 422:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      },
      {
        "span": "bzip2.rs:416:1: 416:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:408:1: 408:37 (#0)",
        "source": "pub static mut exitValue: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:418:1: 418:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:64:1: 64:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "bzip2.rs:192:1: 192:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:190:1: 190:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:186:1: 186:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:66:1: 66:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "bzip2.rs:50:1: 50:20 (#0)",
        "source": "use std::io::Error;"
      },
      {
        "span": "bzip2.rs:52:1: 52:21 (#0)",
        "source": "use std::fmt::Write;"
      },
      {
        "span": "bzip2.rs:62:1: 62:19 (#0)",
        "source": "use std::eprintln;"
      },
      {
        "span": "bzip2.rs:56:1: 56:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "bzip2.rs:44:1: 44:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "bzip2.rs:68:1: 68:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "bzip2.rs:59:1: 59:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "bzip2.rs:42:1: 42:26 (#0)",
        "source": "use std::os::raw::c_long;"
      },
      {
        "span": "bzip2.rs:40:1: 40:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "bzip2.rs:187:1: 187:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:57:1: 57:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "bzip2.rs:48:1: 48:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "bzip2.rs:185:1: 185:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:188:1: 188:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:60:1: 60:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "bzip2.rs:189:1: 189:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:193:1: 193:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:191:1: 191:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:46:1: 46:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "bzip2.rs:54:1: 54:17 (#0)",
        "source": "use std::eprint;"
      },
      {
        "span": "bzip2.rs:68:5: 68:13 (#0)",
        "source": "std::env"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:571 ~ c2rust_out[3c70]::huffman::BZ2_hbAssignCodes)",
    "span": "huffman.rs:193:1: 215:2 (#0)",
    "pieces": [
      "huffman.rs:193:1: 215:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn BZ2_hbAssignCodes(mut code: *mut Int32,\n                                           mut length: *mut UChar,\n                                           mut minLen: Int32,\n                                           mut maxLen: Int32,\n                                           mut alphaSize: Int32) {\n    let mut n: Int32 = 0;\n    let mut vec: Int32 = 0;\n    let mut i: Int32 = 0;\n    vec = 0 as std::os::raw::c_int;\n    n = minLen;\n    while n <= maxLen {\n        i = 0 as std::os::raw::c_int;\n        while i < alphaSize {\n            if *length.offset(i as isize) as std::os::raw::c_int == n {\n                *code.offset(i as isize) = vec;\n                vec += 1\n            }\n            i += 1\n        }\n        vec <<= 1 as std::os::raw::c_int;\n        n += 1\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "huffman.rs:6:1: 6:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  }
]