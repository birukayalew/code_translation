[
  {
    "func_defid": "DefId(0:549 ~ c2rust_out[3c70]::decompress::makeMaps_d)",
    "span": "decompress.rs:60:1: 71:2 (#0)",
    "pieces": [
      "decompress.rs:60:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn makeMaps_d(mut s: *mut DState) {\n    let mut i: Int32 = 0;\n    (*s).nInUse = 0 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n    while i < 256 as std::os::raw::c_int {\n        if (*s).inUse[i as usize] != 0 {\n            (*s).seqToUnseq[(*s).nInUse as usize] = i as UChar;\n            (*s).nInUse += 1\n        }\n        i += 1\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:550 ~ c2rust_out[3c70]::decompress::BZ2_decompress)",
        "span": "decompress.rs:3138:29: 3138:43 (#0)",
        "source": "makeMaps_d(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "decompress.rs:17:1: 17:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "decompress.rs:20:1: 20:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "decompress.rs:19:1: 19:50 (#0)",
        "source": "pub use crate::huffman::BZ2_hbCreateDecodeTables;"
      },
      {
        "span": "decompress.rs:18:1: 18:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_indexIntoF;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:413 ~ c2rust_out[3c70]::bzlib::__isctype)",
    "span": "bzlib.rs:177:1: 186:2 (#0)",
    "pieces": [
      "bzlib.rs:177:1: 186:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "unsafe extern \"C\" fn __isctype(mut _c: __darwin_ct_rune_t,\n                               mut _f: std::os::raw::c_ulong) -> __darwin_ct_rune_t {\n    return if _c < 0 as std::os::raw::c_int ||\n                  _c >= (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int {\n               0 as std::os::raw::c_int\n           } else {\n               (_DefaultRuneLocale.__runetype[_c as usize] as std::os::raw::c_ulong &\n                    _f != 0) as std::os::raw::c_int\n           };\n}",
    "calls": [
      {
        "caller": "DefId(0:414 ~ c2rust_out[3c70]::bzlib::isdigit)",
        "span": "bzlib.rs:191:5: 191:82 (#0)",
        "source": "return __isctype(_c, 0x400 as std::os::raw::c_long as std::os::raw::c_ulong);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:414 ~ c2rust_out[3c70]::bzlib::isdigit)",
    "span": "bzlib.rs:190:1: 192:2 (#0)",
    "pieces": [
      "bzlib.rs:190:1: 192:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn isdigit(mut _c: std::os::raw::c_int) -> std::os::raw::c_int {\n    return __isctype(_c, 0x400 as std::os::raw::c_long as std::os::raw::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:447 ~ c2rust_out[3c70]::bzlib::BZ2_bzlibVersion)",
    "span": "bzlib.rs:2231:1: 2233:2 (#0)",
    "pieces": [
      "bzlib.rs:2231:1: 2233:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub extern \"C\" fn BZ2_bzlibVersion() -> *const std::os::raw::c_char {\n    return b\"1.0.8, 13-Jul-2019\\x00\" as *const u8 as *const std::os::raw::c_char;\n}",
    "calls": [
      {
        "caller": "DefId(0:274 ~ c2rust_out[3c70]::bzip2::license)",
        "span": "bzip2.rs:2653:5: 2655:82 (#0)",
        "source": "fprintf(__stderrp,\n            b\"bzip2, a block-sorting file compressor.  Version %s.\\n   \\n   Copyright (C) 1996-2019 by Julian Seward.\\n   \\n   This program is free software; you can redistribute it and/or modify\\n   it under the terms set out in the LICENSE file, which is included\\n   in the bzip2 source distribution.\\n   \\n   This program is distributed in the hope that it will be useful,\\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n   LICENSE file for more details.\\n   \\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, BZ2_bzlibVersion());"
      },
      {
        "caller": "DefId(0:275 ~ c2rust_out[3c70]::bzip2::usage)",
        "span": "bzip2.rs:2659:5: 2662:27 (#0)",
        "source": "fprintf(__stderrp,\n            b\"bzip2, a block-sorting file compressor.  Version %s.\\n\\n   usage: %s [flags and input files in any order]\\n\\n   -h --help           print this message\\n   -d --decompress     force decompression\\n   -z --compress       force compression\\n   -k --keep           keep (don\\'t delete) input files\\n   -f --force          overwrite existing output files\\n   -t --test           test compressed file integrity\\n   -c --stdout         output to standard out\\n   -q --quiet          suppress noncritical error messages\\n   -v --verbose        be verbose (a 2nd -v gives more)\\n   -L --license        display software version & license\\n   -V --version        display software version & license\\n   -s --small          use less memory (at most 2500k)\\n   -1 .. -9            set block size to 100k .. 900k\\n   --fast              alias for -1\\n   --best              alias for -9\\n\\n   If invoked as `bzip2\\', default action is to compress.\\n              as `bunzip2\\',  default action is to decompress.\\n              as `bzcat\\', default action is to decompress to stdout.\\n\\n   If no file names are given, bzip2 compresses or decompresses\\n   from standard input to standard output.  You can combine\\n   short flags, so `-v -4\\' means the same as -v4 or -4v, &c.\\n\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, BZ2_bzlibVersion(),\n            fullProgName);"
      },
      {
        "caller": "DefId(0:415 ~ c2rust_out[3c70]::bzlib::BZ2_bz__AssertH__fail)",
        "span": "bzlib.rs:225:5: 228:33 (#0)",
        "source": "fprintf(__stderrp,\n            b\"\\n\\nbzip2/libbzip2: internal error number %d.\\nThis is a bug in bzip2/libbzip2, %s.\\nPlease report it to: bzip2-devel@sourceware.org.  If this happened\\nwhen you were using some program which uses libbzip2 as a\\ncomponent, you should also report this bug to the author(s)\\nof that program.  Please make an effort to report this bug;\\ntimely and accurate bug reports eventually lead to higher\\nquality software.  Thanks.\\n\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, errcode,\n            BZ2_bzlibVersion());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:274 ~ c2rust_out[3c70]::bzip2::license)",
    "span": "bzip2.rs:2652:1: 2656:2 (#0)",
    "pieces": [
      "bzip2.rs:2652:1: 2656:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn license() {\n    fprintf(__stderrp,\n            b\"bzip2, a block-sorting file compressor.  Version %s.\\n   \\n   Copyright (C) 1996-2019 by Julian Seward.\\n   \\n   This program is free software; you can redistribute it and/or modify\\n   it under the terms set out in the LICENSE file, which is included\\n   in the bzip2 source distribution.\\n   \\n   This program is distributed in the hope that it will be useful,\\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n   LICENSE file for more details.\\n   \\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, BZ2_bzlibVersion());\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:427 ~ c2rust_out[3c70]::bzlib::handle_compress)",
    "span": "bzlib.rs:600:1: 643:2 (#0)",
    "pieces": [
      "bzlib.rs:600:1: 643:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 44,
    "source": "unsafe extern \"C\" fn handle_compress(mut strm: *mut bz_stream) -> Bool {\n    let mut progress_in: Bool = 0 as std::os::raw::c_int as Bool;\n    let mut progress_out: Bool = 0 as std::os::raw::c_int as Bool;\n    let mut s: *mut EState = (*strm).state as *mut EState;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        if (*s).state == 1 as std::os::raw::c_int {\n            progress_out =\n                (progress_out as std::os::raw::c_int |\n                     copy_output_until_stop(s) as std::os::raw::c_int) as Bool;\n            if (*s).state_out_pos < (*s).numZ { break ; }\n            if (*s).mode == 4 as std::os::raw::c_int &&\n                   (*s).avail_in_expect == 0 as std::os::raw::c_int as std::os::raw::c_uint &&\n                   isempty_RL(s) as std::os::raw::c_int != 0 {\n                break ;\n            }\n            prepare_new_block(s);\n            (*s).state = 2 as std::os::raw::c_int;\n            if (*s).mode == 3 as std::os::raw::c_int &&\n                   (*s).avail_in_expect == 0 as std::os::raw::c_int as std::os::raw::c_uint &&\n                   isempty_RL(s) as std::os::raw::c_int != 0 {\n                break ;\n            }\n        }\n        if !((*s).state == 2 as std::os::raw::c_int) { continue ; }\n        progress_in =\n            (progress_in as std::os::raw::c_int |\n                 copy_input_until_stop(s) as std::os::raw::c_int) as Bool;\n        if (*s).mode != 2 as std::os::raw::c_int &&\n               (*s).avail_in_expect == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            flush_RL(s);\n            BZ2_compressBlock(s,\n                              ((*s).mode == 4 as std::os::raw::c_int) as std::os::raw::c_int\n                                  as Bool);\n            (*s).state = 1 as std::os::raw::c_int\n        } else if (*s).nblock >= (*s).nblockMAX {\n            BZ2_compressBlock(s, 0 as std::os::raw::c_int as Bool);\n            (*s).state = 1 as std::os::raw::c_int\n        } else if (*(*s).strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            break ;\n        }\n    }\n    return (progress_in as std::os::raw::c_int != 0 ||\n                progress_out as std::os::raw::c_int != 0) as std::os::raw::c_int as Bool;\n}",
    "calls": [
      {
        "caller": "DefId(0:428 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompress)",
        "span": "bzlib.rs:690:17: 690:50 (#0)",
        "source": "progress = handle_compress(strm);"
      },
      {
        "caller": "DefId(0:428 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompress)",
        "span": "bzlib.rs:660:21: 660:54 (#0)",
        "source": "progress = handle_compress(strm);"
      },
      {
        "caller": "DefId(0:428 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompress)",
        "span": "bzlib.rs:677:17: 677:50 (#0)",
        "source": "progress = handle_compress(strm);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:415 ~ c2rust_out[3c70]::bzlib::BZ2_bz__AssertH__fail)",
    "span": "bzlib.rs:224:1: 235:2 (#0)",
    "pieces": [
      "bzlib.rs:224:1: 235:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn BZ2_bz__AssertH__fail(mut errcode: std::os::raw::c_int) {\n    fprintf(__stderrp,\n            b\"\\n\\nbzip2/libbzip2: internal error number %d.\\nThis is a bug in bzip2/libbzip2, %s.\\nPlease report it to: bzip2-devel@sourceware.org.  If this happened\\nwhen you were using some program which uses libbzip2 as a\\ncomponent, you should also report this bug to the author(s)\\nof that program.  Please make an effort to report this bug;\\ntimely and accurate bug reports eventually lead to higher\\nquality software.  Thanks.\\n\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, errcode,\n            BZ2_bzlibVersion());\n    if errcode == 1007 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"\\n*** A special note about internal error number 1007 ***\\n\\nExperience suggests that a common cause of i.e. 1007\\nis unreliable memory or other hardware.  The 1007 assertion\\njust happens to cross-check the results of huge numbers of\\nmemory reads/writes, and so acts (unintendedly) as a stress\\ntest of your memory system.\\n\\nI suggest the following: try compressing the file again,\\npossibly monitoring progress in detail with the -vv flag.\\n\\n* If the error cannot be reproduced, and/or happens at different\\n  points in compression, you may have a flaky memory system.\\n  Try a memory-test program.  I have used Memtest86\\n  (www.memtest86.com).  At the time of writing it is free (GPLd).\\n  Memtest86 tests memory much more thorougly than your BIOSs\\n  power-on test, and may find failures that the BIOS doesn\\'t.\\n\\n* If the error can be repeatably reproduced, this is a bug in\\n  bzip2, and I would very much like to hear about it.  Please\\n  let me know, and, ideally, save a copy of the file causing the\\n  problem -- without which I will be unable to investigate it.\\n\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char);\n    }\n    exit(3 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:550 ~ c2rust_out[3c70]::decompress::BZ2_decompress)",
        "span": "decompress.rs:257:17: 257:68 (#0)",
        "source": "BZ2_bz__AssertH__fail(4002 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:58 ~ c2rust_out[3c70]::blocksort::BZ2_blockSort)",
        "span": "blocksort.rs:1632:9: 1632:60 (#0)",
        "source": "BZ2_bz__AssertH__fail(1003 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:504 ~ c2rust_out[3c70]::compress::sendMTFValues)",
        "span": "compress.rs:2084:9: 2084:60 (#0)",
        "source": "BZ2_bz__AssertH__fail(3002 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:434 ~ c2rust_out[3c70]::bzlib::BZ2_bzDecompress)",
        "span": "bzlib.rs:1638:40: 1638:91 (#0)",
        "source": "BZ2_bz__AssertH__fail(6001 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:504 ~ c2rust_out[3c70]::compress::sendMTFValues)",
        "span": "compress.rs:2090:9: 2090:60 (#0)",
        "source": "BZ2_bz__AssertH__fail(3003 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:26 ~ c2rust_out[3c70]::blocksort::fallbackSort)",
        "span": "blocksort.rs:542:9: 542:60 (#0)",
        "source": "BZ2_bz__AssertH__fail(1005 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:504 ~ c2rust_out[3c70]::compress::sendMTFValues)",
        "span": "compress.rs:2444:34: 2444:85 (#0)",
        "source": "BZ2_bz__AssertH__fail(3007 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:504 ~ c2rust_out[3c70]::compress::sendMTFValues)",
        "span": "compress.rs:306:9: 306:60 (#0)",
        "source": "BZ2_bz__AssertH__fail(3001 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:550 ~ c2rust_out[3c70]::decompress::BZ2_decompress)",
        "span": "decompress.rs:254:17: 254:68 (#0)",
        "source": "BZ2_bz__AssertH__fail(4001 as std::os::raw::c_int);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:434 ~ c2rust_out[3c70]::bzlib::BZ2_bzDecompress)",
    "span": "bzlib.rs:1582:1: 1641:2 (#0)",
    "pieces": [
      "bzlib.rs:1582:1: 1641:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 60,
    "source": "pub unsafe extern \"C\" fn BZ2_bzDecompress(mut strm: *mut bz_stream)\n -> std::os::raw::c_int {\n    let mut corrupt: Bool = 0;\n    let mut s: *mut DState = 0 as *mut DState;\n    if strm.is_null() { return -(2 as std::os::raw::c_int) }\n    s = (*strm).state as *mut DState;\n    if s.is_null() { return -(2 as std::os::raw::c_int) }\n    if (*s).strm != strm { return -(2 as std::os::raw::c_int) }\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        if (*s).state == 1 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }\n        if (*s).state == 2 as std::os::raw::c_int {\n            if (*s).smallDecompress != 0 {\n                corrupt = unRLE_obuf_to_output_SMALL(s)\n            } else { corrupt = unRLE_obuf_to_output_FAST(s) }\n            if corrupt != 0 { return -(4 as std::os::raw::c_int) }\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int &&\n                   (*s).state_out_len == 0 as std::os::raw::c_int {\n                (*s).calculatedBlockCRC = !(*s).calculatedBlockCRC;\n                if (*s).verbosity >= 3 as std::os::raw::c_int {\n                    fprintf(__stderrp,\n                            b\" {0x%08x, 0x%08x}\\x00\" as *const u8 as\n                                *const std::os::raw::c_char, (*s).storedBlockCRC,\n                            (*s).calculatedBlockCRC);\n                }\n                if (*s).verbosity >= 2 as std::os::raw::c_int {\n                    fprintf(__stderrp,\n                            b\"]\\x00\" as *const u8 as *const std::os::raw::c_char);\n                }\n                if (*s).calculatedBlockCRC != (*s).storedBlockCRC {\n                    return -(4 as std::os::raw::c_int)\n                }\n                (*s).calculatedCombinedCRC =\n                    (*s).calculatedCombinedCRC << 1 as std::os::raw::c_int |\n                        (*s).calculatedCombinedCRC >> 31 as std::os::raw::c_int;\n                (*s).calculatedCombinedCRC ^= (*s).calculatedBlockCRC;\n                (*s).state = 14 as std::os::raw::c_int\n            } else { return 0 as std::os::raw::c_int }\n        }\n        if (*s).state >= 10 as std::os::raw::c_int {\n            let mut r: Int32 = BZ2_decompress(s);\n            if r == 4 as std::os::raw::c_int {\n                if (*s).verbosity >= 3 as std::os::raw::c_int {\n                    fprintf(__stderrp,\n                            b\"\\n    combined CRCs: stored = 0x%08x, computed = 0x%08x\\x00\"\n                                as *const u8 as *const std::os::raw::c_char,\n                            (*s).storedCombinedCRC,\n                            (*s).calculatedCombinedCRC);\n                }\n                if (*s).calculatedCombinedCRC != (*s).storedCombinedCRC {\n                    return -(4 as std::os::raw::c_int)\n                }\n                return r\n            }\n            if (*s).state != 2 as std::os::raw::c_int { return r }\n        }\n    }\n    if 0 as std::os::raw::c_int == 0 { BZ2_bz__AssertH__fail(6001 as std::os::raw::c_int); }\n    return 0 as std::os::raw::c_int;\n    /*NOTREACHED*/\n}",
    "calls": [
      {
        "caller": "DefId(0:446 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
        "span": "bzlib.rs:2200:5: 2200:39 (#0)",
        "source": "ret = BZ2_bzDecompress(&mut strm);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:435 ~ c2rust_out[3c70]::bzlib::BZ2_bzDecompressEnd)",
    "span": "bzlib.rs:1644:1: 1670:2 (#0)",
    "pieces": [
      "bzlib.rs:1644:1: 1670:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn BZ2_bzDecompressEnd(mut strm: *mut bz_stream)\n -> std::os::raw::c_int {\n    let mut s: *mut DState = 0 as *mut DState;\n    if strm.is_null() { return -(2 as std::os::raw::c_int) }\n    s = (*strm).state as *mut DState;\n    if s.is_null() { return -(2 as std::os::raw::c_int) }\n    if (*s).strm != strm { return -(2 as std::os::raw::c_int) }\n    if !(*s).tt.is_null() {\n        (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                           (*s).tt as\n                                                               *mut std::os::raw::c_void);\n    }\n    if !(*s).ll16.is_null() {\n        (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                           (*s).ll16 as\n                                                               *mut std::os::raw::c_void);\n    }\n    if !(*s).ll4.is_null() {\n        (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                           (*s).ll4 as\n                                                               *mut std::os::raw::c_void);\n    }\n    (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                       (*strm).state);\n    (*strm).state = 0 as *mut std::os::raw::c_void;\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:446 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
        "span": "bzlib.rs:2203:13: 2203:44 (#0)",
        "source": "BZ2_bzDecompressEnd(&mut strm);"
      },
      {
        "caller": "DefId(0:446 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
        "span": "bzlib.rs:2207:9: 2207:40 (#0)",
        "source": "BZ2_bzDecompressEnd(&mut strm);"
      },
      {
        "caller": "DefId(0:446 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
        "span": "bzlib.rs:2205:18: 2205:49 (#0)",
        "source": "BZ2_bzDecompressEnd(&mut strm);"
      },
      {
        "caller": "DefId(0:446 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
        "span": "bzlib.rs:2212:9: 2212:40 (#0)",
        "source": "BZ2_bzDecompressEnd(&mut strm);"
      },
      {
        "caller": "DefId(0:442 ~ c2rust_out[3c70]::bzlib::BZ2_bzReadClose)",
        "span": "bzlib.rs:1987:36: 1987:74 (#0)",
        "source": "BZ2_bzDecompressEnd(&mut (*bzf).strm);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:430 ~ c2rust_out[3c70]::bzlib::BZ2_bzDecompressInit)",
    "span": "bzlib.rs:738:1: 790:2 (#0)",
    "pieces": [
      "bzlib.rs:738:1: 790:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 53,
    "source": "pub unsafe extern \"C\" fn BZ2_bzDecompressInit(mut strm: *mut bz_stream,\n                                              mut verbosity: std::os::raw::c_int,\n                                              mut small: std::os::raw::c_int)\n -> std::os::raw::c_int {\n    let mut s: *mut DState = 0 as *mut DState;\n    if bz_config_ok() == 0 { return -(9 as std::os::raw::c_int) }\n    if strm.is_null() { return -(2 as std::os::raw::c_int) }\n    if small != 0 as std::os::raw::c_int && small != 1 as std::os::raw::c_int {\n        return -(2 as std::os::raw::c_int)\n    }\n    if verbosity < 0 as std::os::raw::c_int || verbosity > 4 as std::os::raw::c_int {\n        return -(2 as std::os::raw::c_int)\n    }\n    if (*strm).bzalloc.is_none() {\n        (*strm).bzalloc =\n            Some(default_bzalloc as\n                     unsafe extern \"C\" fn(_: *mut std::os::raw::c_void, _: Int32,\n                                          _: Int32) -> *mut std::os::raw::c_void)\n    }\n    if (*strm).bzfree.is_none() {\n        (*strm).bzfree =\n            Some(default_bzfree as\n                     unsafe extern \"C\" fn(_: *mut std::os::raw::c_void,\n                                          _: *mut std::os::raw::c_void) -> ())\n    }\n    s =\n        (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                            ::std::mem::size_of::<DState>()\n                                                                as\n                                                                std::os::raw::c_ulong\n                                                                as\n                                                                std::os::raw::c_int,\n                                                            1 as std::os::raw::c_int)\n            as *mut DState;\n    if s.is_null() { return -(3 as std::os::raw::c_int) }\n    (*s).strm = strm;\n    (*strm).state = s as *mut std::os::raw::c_void;\n    (*s).state = 10 as std::os::raw::c_int;\n    (*s).bsLive = 0 as std::os::raw::c_int;\n    (*s).bsBuff = 0 as std::os::raw::c_int as UInt32;\n    (*s).calculatedCombinedCRC = 0 as std::os::raw::c_int as UInt32;\n    (*strm).total_in_lo32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*strm).total_in_hi32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*strm).total_out_lo32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*strm).total_out_hi32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*s).smallDecompress = small as Bool;\n    (*s).ll4 = 0 as *mut UChar;\n    (*s).ll16 = 0 as *mut UInt16;\n    (*s).tt = 0 as *mut UInt32;\n    (*s).currBlockNo = 0 as std::os::raw::c_int;\n    (*s).verbosity = verbosity;\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:446 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
        "span": "bzlib.rs:2194:5: 2194:61 (#0)",
        "source": "ret = BZ2_bzDecompressInit(&mut strm, verbosity, small);"
      },
      {
        "caller": "DefId(0:441 ~ c2rust_out[3c70]::bzlib::BZ2_bzReadOpen)",
        "span": "bzlib.rs:1958:5: 1958:68 (#0)",
        "source": "ret = BZ2_bzDecompressInit(&mut (*bzf).strm, verbosity, small);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:446 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffDecompress)",
    "span": "bzlib.rs:2160:1: 2215:2 (#0)",
    "pieces": [
      "bzlib.rs:2160:1: 2215:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 56,
    "source": "pub unsafe extern \"C\" fn BZ2_bzBuffToBuffDecompress(mut dest:\n                                                        *mut std::os::raw::c_char,\n                                                    mut destLen:\n                                                        *mut std::os::raw::c_uint,\n                                                    mut source:\n                                                        *mut std::os::raw::c_char,\n                                                    mut sourceLen:\n                                                        std::os::raw::c_uint,\n                                                    mut small: std::os::raw::c_int,\n                                                    mut verbosity:\n                                                        std::os::raw::c_int)\n -> std::os::raw::c_int {\n    let mut strm: bz_stream =\n        bz_stream{next_in: 0 as *mut std::os::raw::c_char,\n                  avail_in: 0,\n                  total_in_lo32: 0,\n                  total_in_hi32: 0,\n                  next_out: 0 as *mut std::os::raw::c_char,\n                  avail_out: 0,\n                  total_out_lo32: 0,\n                  total_out_hi32: 0,\n                  state: 0 as *mut std::os::raw::c_void,\n                  bzalloc: None,\n                  bzfree: None,\n                  opaque: 0 as *mut std::os::raw::c_void,};\n    let mut ret: std::os::raw::c_int = 0;\n    if dest.is_null() || destLen.is_null() || source.is_null() ||\n           small != 0 as std::os::raw::c_int && small != 1 as std::os::raw::c_int ||\n           verbosity < 0 as std::os::raw::c_int || verbosity > 4 as std::os::raw::c_int {\n        return -(2 as std::os::raw::c_int)\n    }\n    strm.bzalloc = None;\n    strm.bzfree = None;\n    strm.opaque = 0 as *mut std::os::raw::c_void;\n    ret = BZ2_bzDecompressInit(&mut strm, verbosity, small);\n    if ret != 0 as std::os::raw::c_int { return ret }\n    strm.next_in = source;\n    strm.next_out = dest;\n    strm.avail_in = sourceLen;\n    strm.avail_out = *destLen;\n    ret = BZ2_bzDecompress(&mut strm);\n    if ret == 0 as std::os::raw::c_int {\n        if strm.avail_out > 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            BZ2_bzDecompressEnd(&mut strm);\n            return -(7 as std::os::raw::c_int)\n        } else { BZ2_bzDecompressEnd(&mut strm); return -(8 as std::os::raw::c_int) }\n    } else if ret != 4 as std::os::raw::c_int {\n        BZ2_bzDecompressEnd(&mut strm);\n        return ret\n    } else {\n        /* normal termination */\n        *destLen = (*destLen).wrapping_sub(strm.avail_out);\n        BZ2_bzDecompressEnd(&mut strm);\n        return 0 as std::os::raw::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:441 ~ c2rust_out[3c70]::bzlib::BZ2_bzReadOpen)",
    "span": "bzlib.rs:1908:1: 1969:2 (#0)",
    "pieces": [
      "bzlib.rs:1908:1: 1969:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 62,
    "source": "pub unsafe extern \"C\" fn BZ2_bzReadOpen(mut bzerror: *mut std::os::raw::c_int,\n                                        mut f: *mut FILE,\n                                        mut verbosity: std::os::raw::c_int,\n                                        mut small: std::os::raw::c_int,\n                                        mut unused: *mut std::os::raw::c_void,\n                                        mut nUnused: std::os::raw::c_int)\n -> *mut std::os::raw::c_void {\n    let mut bzf: *mut bzFile = 0 as *mut bzFile;\n    let mut ret: std::os::raw::c_int = 0;\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    if f.is_null() || small != 0 as std::os::raw::c_int && small != 1 as std::os::raw::c_int\n           || (verbosity < 0 as std::os::raw::c_int || verbosity > 4 as std::os::raw::c_int)\n           || unused.is_null() && nUnused != 0 as std::os::raw::c_int ||\n           !unused.is_null() &&\n               (nUnused < 0 as std::os::raw::c_int || nUnused > 5000 as std::os::raw::c_int) {\n        if !bzerror.is_null() { *bzerror = -(2 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(2 as std::os::raw::c_int) }\n        return 0 as *mut std::os::raw::c_void\n    }\n    if ferror(f) != 0 {\n        if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n        return 0 as *mut std::os::raw::c_void\n    }\n    bzf =\n        malloc(::std::mem::size_of::<bzFile>() as std::os::raw::c_ulong) as\n            *mut bzFile;\n    if bzf.is_null() {\n        if !bzerror.is_null() { *bzerror = -(3 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(3 as std::os::raw::c_int) }\n        return 0 as *mut std::os::raw::c_void\n    }\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    (*bzf).initialisedOk = 0 as std::os::raw::c_int as Bool;\n    (*bzf).handle = f;\n    (*bzf).bufN = 0 as std::os::raw::c_int;\n    (*bzf).writing = 0 as std::os::raw::c_int as Bool;\n    (*bzf).strm.bzalloc = None;\n    (*bzf).strm.bzfree = None;\n    (*bzf).strm.opaque = 0 as *mut std::os::raw::c_void;\n    while nUnused > 0 as std::os::raw::c_int {\n        (*bzf).buf[(*bzf).bufN as usize] = *(unused as *mut UChar) as Char;\n        (*bzf).bufN += 1;\n        unused =\n            (unused as *mut UChar).offset(1 as std::os::raw::c_int as isize) as\n                *mut std::os::raw::c_void;\n        nUnused -= 1\n    }\n    ret = BZ2_bzDecompressInit(&mut (*bzf).strm, verbosity, small);\n    if ret != 0 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = ret }\n        if !bzf.is_null() { (*bzf).lastErr = ret }\n        free(bzf as *mut std::os::raw::c_void);\n        return 0 as *mut std::os::raw::c_void\n    }\n    (*bzf).strm.avail_in = (*bzf).bufN as std::os::raw::c_uint;\n    (*bzf).strm.next_in = (*bzf).buf.as_mut_ptr();\n    (*bzf).initialisedOk = 1 as std::os::raw::c_int as Bool;\n    return bzf as *mut std::os::raw::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:729:21: 733:80 (#0)",
        "source": "bzf =\n                        BZ2_bzReadOpen(&mut bzerr, zStream, verbosity,\n                                       smallMode as std::os::raw::c_int,\n                                       unused.as_mut_ptr() as\n                                           *mut std::os::raw::c_void, nUnused);"
      },
      {
        "caller": "DefId(0:448 ~ c2rust_out[3c70]::bzlib::bzopen_or_bzdopen)",
        "span": "bzlib.rs:2293:12: 2297:6 (#0)",
        "source": "{\n        bzfp =\n            BZ2_bzReadOpen(&mut bzerr, fp, verbosity, smallMode,\n                           unused.as_mut_ptr() as *mut std::os::raw::c_void, nUnused)\n    }"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1275:17: 1279:45 (#0)",
        "source": "bzf =\n                    BZ2_bzReadOpen(&mut bzerr, zStream, verbosity,\n                                   smallMode as std::os::raw::c_int,\n                                   unused.as_mut_ptr() as *mut std::os::raw::c_void,\n                                   nUnused);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:419 ~ c2rust_out[3c70]::bzlib::prepare_new_block)",
    "span": "bzlib.rs:264:1: 276:2 (#0)",
    "pieces": [
      "bzlib.rs:264:1: 276:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn prepare_new_block(mut s: *mut EState) {\n    let mut i: Int32 = 0;\n    (*s).nblock = 0 as std::os::raw::c_int;\n    (*s).numZ = 0 as std::os::raw::c_int;\n    (*s).state_out_pos = 0 as std::os::raw::c_int;\n    (*s).blockCRC = 0xffffffff as std::os::raw::c_long as UInt32;\n    i = 0 as std::os::raw::c_int;\n    while i < 256 as std::os::raw::c_int {\n        (*s).inUse[i as usize] = 0 as std::os::raw::c_int as Bool;\n        i += 1\n    }\n    (*s).blockNo += 1;\n}",
    "calls": [
      {
        "caller": "DefId(0:422 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompressInit)",
        "span": "bzlib.rs:417:5: 417:26 (#0)",
        "source": "prepare_new_block(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:420 ~ c2rust_out[3c70]::bzlib::init_RL)",
    "span": "bzlib.rs:278:1: 281:2 (#0)",
    "pieces": [
      "bzlib.rs:278:1: 281:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn init_RL(mut s: *mut EState) {\n    (*s).state_in_ch = 256 as std::os::raw::c_int as UInt32;\n    (*s).state_in_len = 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:422 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompressInit)",
        "span": "bzlib.rs:416:5: 416:16 (#0)",
        "source": "init_RL(s);"
      },
      {
        "caller": "DefId(0:424 ~ c2rust_out[3c70]::bzlib::flush_RL)",
        "span": "bzlib.rs:474:5: 474:16 (#0)",
        "source": "init_RL(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:422 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompressInit)",
    "span": "bzlib.rs:290:1: 419:2 (#0)",
    "pieces": [
      "bzlib.rs:290:1: 419:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 130,
    "source": "pub unsafe extern \"C\" fn BZ2_bzCompressInit(mut strm: *mut bz_stream,\n                                            mut blockSize100k: std::os::raw::c_int,\n                                            mut verbosity: std::os::raw::c_int,\n                                            mut workFactor: std::os::raw::c_int)\n -> std::os::raw::c_int {\n    let mut n: Int32 = 0;\n    let mut s: *mut EState = 0 as *mut EState;\n    if bz_config_ok() == 0 { return -(9 as std::os::raw::c_int) }\n    if strm.is_null() || blockSize100k < 1 as std::os::raw::c_int ||\n           blockSize100k > 9 as std::os::raw::c_int || workFactor < 0 as std::os::raw::c_int\n           || workFactor > 250 as std::os::raw::c_int {\n        return -(2 as std::os::raw::c_int)\n    }\n    if workFactor == 0 as std::os::raw::c_int { workFactor = 30 as std::os::raw::c_int }\n    if (*strm).bzalloc.is_none() {\n        (*strm).bzalloc =\n            Some(default_bzalloc as\n                     unsafe extern \"C\" fn(_: *mut std::os::raw::c_void, _: Int32,\n                                          _: Int32) -> *mut std::os::raw::c_void)\n    }\n    if (*strm).bzfree.is_none() {\n        (*strm).bzfree =\n            Some(default_bzfree as\n                     unsafe extern \"C\" fn(_: *mut std::os::raw::c_void,\n                                          _: *mut std::os::raw::c_void) -> ())\n    }\n    s =\n        (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                            ::std::mem::size_of::<EState>()\n                                                                as\n                                                                std::os::raw::c_ulong\n                                                                as\n                                                                std::os::raw::c_int,\n                                                            1 as std::os::raw::c_int)\n            as *mut EState;\n    if s.is_null() { return -(3 as std::os::raw::c_int) }\n    (*s).strm = strm;\n    (*s).arr1 = 0 as *mut UInt32;\n    (*s).arr2 = 0 as *mut UInt32;\n    (*s).ftab = 0 as *mut UInt32;\n    n = 100000 as std::os::raw::c_int * blockSize100k;\n    (*s).arr1 =\n        (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                            (n as\n                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UInt32>()\n                                                                                                 as\n                                                                                                 std::os::raw::c_ulong)\n                                                                as\n                                                                std::os::raw::c_int,\n                                                            1 as std::os::raw::c_int)\n            as *mut UInt32;\n    (*s).arr2 =\n        (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                            ((n +\n                                                                  (2 as\n                                                                       std::os::raw::c_int\n                                                                       +\n                                                                       12 as\n                                                                           std::os::raw::c_int\n                                                                       +\n                                                                       18 as\n                                                                           std::os::raw::c_int\n                                                                       +\n                                                                       2 as\n                                                                           std::os::raw::c_int))\n                                                                 as\n                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UInt32>()\n                                                                                                 as\n                                                                                                 std::os::raw::c_ulong)\n                                                                as\n                                                                std::os::raw::c_int,\n                                                            1 as std::os::raw::c_int)\n            as *mut UInt32;\n    (*s).ftab =\n        (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                            (65537 as\n                                                                 std::os::raw::c_int\n                                                                 as\n                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UInt32>()\n                                                                                                 as\n                                                                                                 std::os::raw::c_ulong)\n                                                                as\n                                                                std::os::raw::c_int,\n                                                            1 as std::os::raw::c_int)\n            as *mut UInt32;\n    if (*s).arr1.is_null() || (*s).arr2.is_null() || (*s).ftab.is_null() {\n        if !(*s).arr1.is_null() {\n            (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                               (*s).arr1 as\n                                                                   *mut std::os::raw::c_void);\n        }\n        if !(*s).arr2.is_null() {\n            (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                               (*s).arr2 as\n                                                                   *mut std::os::raw::c_void);\n        }\n        if !(*s).ftab.is_null() {\n            (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                               (*s).ftab as\n                                                                   *mut std::os::raw::c_void);\n        }\n        if !s.is_null() {\n            (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                               s as\n                                                                   *mut std::os::raw::c_void);\n        }\n        return -(3 as std::os::raw::c_int)\n    }\n    (*s).blockNo = 0 as std::os::raw::c_int;\n    (*s).state = 2 as std::os::raw::c_int;\n    (*s).mode = 2 as std::os::raw::c_int;\n    (*s).combinedCRC = 0 as std::os::raw::c_int as UInt32;\n    (*s).blockSize100k = blockSize100k;\n    (*s).nblockMAX =\n        100000 as std::os::raw::c_int * blockSize100k - 19 as std::os::raw::c_int;\n    (*s).verbosity = verbosity;\n    (*s).workFactor = workFactor;\n    (*s).block = (*s).arr2 as *mut UChar;\n    (*s).mtfv = (*s).arr1 as *mut UInt16;\n    (*s).zbits = 0 as *mut UChar;\n    (*s).ptr = (*s).arr1;\n    (*strm).state = s as *mut std::os::raw::c_void;\n    (*strm).total_in_lo32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*strm).total_in_hi32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*strm).total_out_lo32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*strm).total_out_hi32 = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    init_RL(s);\n    prepare_new_block(s);\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:445 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffCompress)",
        "span": "bzlib.rs:2138:5: 2138:79 (#0)",
        "source": "ret = BZ2_bzCompressInit(&mut strm, blockSize100k, verbosity, workFactor);"
      },
      {
        "caller": "DefId(0:437 ~ c2rust_out[3c70]::bzlib::BZ2_bzWriteOpen)",
        "span": "bzlib.rs:1722:5: 1724:40 (#0)",
        "source": "ret =\n        BZ2_bzCompressInit(&mut (*bzf).strm, blockSize100k, verbosity,\n                           workFactor);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:437 ~ c2rust_out[3c70]::bzlib::BZ2_bzWriteOpen)",
    "span": "bzlib.rs:1680:1: 1734:2 (#0)",
    "pieces": [
      "bzlib.rs:1680:1: 1734:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 55,
    "source": "pub unsafe extern \"C\" fn BZ2_bzWriteOpen(mut bzerror: *mut std::os::raw::c_int,\n                                         mut f: *mut FILE,\n                                         mut blockSize100k: std::os::raw::c_int,\n                                         mut verbosity: std::os::raw::c_int,\n                                         mut workFactor: std::os::raw::c_int)\n -> *mut std::os::raw::c_void {\n    let mut ret: Int32 = 0;\n    let mut bzf: *mut bzFile = 0 as *mut bzFile;\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    if f.is_null() ||\n           (blockSize100k < 1 as std::os::raw::c_int ||\n                blockSize100k > 9 as std::os::raw::c_int) ||\n           (workFactor < 0 as std::os::raw::c_int || workFactor > 250 as std::os::raw::c_int)\n           || (verbosity < 0 as std::os::raw::c_int || verbosity > 4 as std::os::raw::c_int) {\n        if !bzerror.is_null() { *bzerror = -(2 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(2 as std::os::raw::c_int) }\n        return 0 as *mut std::os::raw::c_void\n    }\n    if ferror(f) != 0 {\n        if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n        return 0 as *mut std::os::raw::c_void\n    }\n    bzf =\n        malloc(::std::mem::size_of::<bzFile>() as std::os::raw::c_ulong) as\n            *mut bzFile;\n    if bzf.is_null() {\n        if !bzerror.is_null() { *bzerror = -(3 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(3 as std::os::raw::c_int) }\n        return 0 as *mut std::os::raw::c_void\n    }\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    (*bzf).initialisedOk = 0 as std::os::raw::c_int as Bool;\n    (*bzf).bufN = 0 as std::os::raw::c_int;\n    (*bzf).handle = f;\n    (*bzf).writing = 1 as std::os::raw::c_int as Bool;\n    (*bzf).strm.bzalloc = None;\n    (*bzf).strm.bzfree = None;\n    (*bzf).strm.opaque = 0 as *mut std::os::raw::c_void;\n    if workFactor == 0 as std::os::raw::c_int { workFactor = 30 as std::os::raw::c_int }\n    ret =\n        BZ2_bzCompressInit(&mut (*bzf).strm, blockSize100k, verbosity,\n                           workFactor);\n    if ret != 0 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = ret }\n        if !bzf.is_null() { (*bzf).lastErr = ret }\n        free(bzf as *mut std::os::raw::c_void);\n        return 0 as *mut std::os::raw::c_void\n    }\n    (*bzf).strm.avail_in = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    (*bzf).initialisedOk = 1 as std::os::raw::c_int as Bool;\n    return bzf as *mut std::os::raw::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:474:13: 476:45 (#0)",
        "source": "bzf =\n                BZ2_bzWriteOpen(&mut bzerr, zStream, blockSize100k, verbosity,\n                                workFactor);"
      },
      {
        "caller": "DefId(0:448 ~ c2rust_out[3c70]::bzlib::bzopen_or_bzdopen)",
        "span": "bzlib.rs:2282:21: 2293:6 (#0)",
        "source": "{\n        /* Guard against total chaos and anarchy -- JRS */\n        if blockSize100k < 1 as std::os::raw::c_int {\n            blockSize100k = 1 as std::os::raw::c_int\n        }\n        if blockSize100k > 9 as std::os::raw::c_int {\n            blockSize100k = 9 as std::os::raw::c_int\n        }\n        bzfp =\n            BZ2_bzWriteOpen(&mut bzerr, fp, blockSize100k, verbosity,\n                            workFactor)\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:448 ~ c2rust_out[3c70]::bzlib::bzopen_or_bzdopen)",
    "span": "bzlib.rs:2235:1: 2303:2 (#0)",
    "pieces": [
      "bzlib.rs:2235:1: 2303:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 69,
    "source": "unsafe extern \"C\" fn bzopen_or_bzdopen(mut path: *const std::os::raw::c_char,\n                                       mut fd: std::os::raw::c_int,\n                                       mut mode: *const std::os::raw::c_char,\n                                       mut open_mode: std::os::raw::c_int)\n -> *mut std::os::raw::c_void \n /* bzopen: 0, bzdopen:1 */\n {\n    let mut bzerr: std::os::raw::c_int = 0; /* binary mode */\n    let mut unused: [std::os::raw::c_char; 5000] = [0; 5000];\n    let mut blockSize100k: std::os::raw::c_int = 9 as std::os::raw::c_int;\n    let mut writing: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut mode2: [std::os::raw::c_char; 10] =\n        *::std::mem::transmute::<&[u8; 10],\n                                 &mut [std::os::raw::c_char; 10]>(b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");\n    let mut fp: *mut FILE = 0 as *mut FILE;\n    let mut bzfp: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    let mut verbosity: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut workFactor: std::os::raw::c_int = 30 as std::os::raw::c_int;\n    let mut smallMode: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut nUnused: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    if mode.is_null() { return 0 as *mut std::os::raw::c_void }\n    while *mode != 0 {\n        match *mode as std::os::raw::c_int {\n            114 => { writing = 0 as std::os::raw::c_int }\n            119 => { writing = 1 as std::os::raw::c_int }\n            115 => { smallMode = 1 as std::os::raw::c_int }\n            _ => {\n                if isdigit(*mode as std::os::raw::c_int) != 0 {\n                    blockSize100k = *mode as std::os::raw::c_int - 0x30 as std::os::raw::c_int\n                }\n            }\n        }\n        mode = mode.offset(1)\n    }\n    strcat(mode2.as_mut_ptr(),\n           if writing != 0 {\n               b\"w\\x00\" as *const u8 as *const std::os::raw::c_char\n           } else { b\"r\\x00\" as *const u8 as *const std::os::raw::c_char });\n    strcat(mode2.as_mut_ptr(), b\"b\\x00\" as *const u8 as *const std::os::raw::c_char);\n    if open_mode == 0 as std::os::raw::c_int {\n        if path.is_null() ||\n               strcmp(path, b\"\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                   0 as std::os::raw::c_int {\n            fp = if writing != 0 { __stdoutp } else { __stdinp }\n        } else { fp = fopen(path, mode2.as_mut_ptr()) }\n    } else { fp = fdopen(fd, mode2.as_mut_ptr()) }\n    if fp.is_null() { return 0 as *mut std::os::raw::c_void }\n    if writing != 0 {\n        /* Guard against total chaos and anarchy -- JRS */\n        if blockSize100k < 1 as std::os::raw::c_int {\n            blockSize100k = 1 as std::os::raw::c_int\n        }\n        if blockSize100k > 9 as std::os::raw::c_int {\n            blockSize100k = 9 as std::os::raw::c_int\n        }\n        bzfp =\n            BZ2_bzWriteOpen(&mut bzerr, fp, blockSize100k, verbosity,\n                            workFactor)\n    } else {\n        bzfp =\n            BZ2_bzReadOpen(&mut bzerr, fp, verbosity, smallMode,\n                           unused.as_mut_ptr() as *mut std::os::raw::c_void, nUnused)\n    }\n    if bzfp.is_null() {\n        if fp != __stdinp && fp != __stdoutp { fclose(fp); }\n        return 0 as *mut std::os::raw::c_void\n    }\n    return bzfp;\n}",
    "calls": [
      {
        "caller": "DefId(0:455 ~ c2rust_out[3c70]::bzlib::BZ2_bzdopen)",
        "span": "bzlib.rs:2322:5: 2323:56 (#0)",
        "source": "return bzopen_or_bzdopen(0 as *const std::os::raw::c_char, fd, mode,\n                             1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:454 ~ c2rust_out[3c70]::bzlib::BZ2_bzopen)",
        "span": "bzlib.rs:2314:5: 2315:56 (#0)",
        "source": "return bzopen_or_bzdopen(path, -(1 as std::os::raw::c_int), mode,\n                             0 as std::os::raw::c_int);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:454 ~ c2rust_out[3c70]::bzlib::BZ2_bzopen)",
    "span": "bzlib.rs:2311:1: 2316:2 (#0)",
    "pieces": [
      "bzlib.rs:2311:1: 2316:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn BZ2_bzopen(mut path: *const std::os::raw::c_char,\n                                    mut mode: *const std::os::raw::c_char)\n -> *mut std::os::raw::c_void {\n    return bzopen_or_bzdopen(path, -(1 as std::os::raw::c_int), mode,\n                             0 as std::os::raw::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:500 ~ c2rust_out[3c70]::compress::makeMaps_e)",
    "span": "compress.rs:121:1: 132:2 (#0)",
    "pieces": [
      "compress.rs:121:1: 132:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn makeMaps_e(mut s: *mut EState) {\n    let mut i: Int32 = 0;\n    (*s).nInUse = 0 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n    while i < 256 as std::os::raw::c_int {\n        if (*s).inUse[i as usize] != 0 {\n            (*s).unseqToSeq[i as usize] = (*s).nInUse as UChar;\n            (*s).nInUse += 1\n        }\n        i += 1\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:501 ~ c2rust_out[3c70]::compress::generateMTFValues)",
        "span": "compress.rs:166:5: 166:19 (#0)",
        "source": "makeMaps_e(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:20:1: 20:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:17:1: 17:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:21:1: 21:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:18:1: 18:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:19:1: 19:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:501 ~ c2rust_out[3c70]::compress::generateMTFValues)",
    "span": "compress.rs:134:1: 257:2 (#0)",
    "pieces": [
      "compress.rs:134:1: 257:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 124,
    "source": "unsafe extern \"C\" fn generateMTFValues(mut s: *mut EState) {\n    let mut yy: [UChar; 256] = [0; 256];\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut zPend: Int32 = 0;\n    let mut wr: Int32 = 0;\n    let mut EOB: Int32 = 0;\n    /* \n      After sorting (eg, here),\n         s->arr1 [ 0 .. s->nblock-1 ] holds sorted order,\n         and\n         ((UChar*)s->arr2) [ 0 .. s->nblock-1 ] \n         holds the original block data.\n\n      The first thing to do is generate the MTF values,\n      and put them in\n         ((UInt16*)s->arr1) [ 0 .. s->nblock-1 ].\n      Because there are strictly fewer or equal MTF values\n      than block values, ptr values in this area are overwritten\n      with MTF values only when they are no longer needed.\n\n      The final compressed bitstream is generated into the\n      area starting at\n         (UChar*) (&((UChar*)s->arr2)[s->nblock])\n\n      These storage aliases are set up in bzCompressInit(),\n      except for the last one, which is arranged in \n      compressBlock().\n   */\n    let mut ptr: *mut UInt32 = (*s).ptr;\n    let mut block: *mut UChar = (*s).block;\n    let mut mtfv: *mut UInt16 = (*s).mtfv;\n    makeMaps_e(s);\n    EOB = (*s).nInUse + 1 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n    while i <= EOB { (*s).mtfFreq[i as usize] = 0 as std::os::raw::c_int; i += 1 }\n    wr = 0 as std::os::raw::c_int;\n    zPend = 0 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n    while i < (*s).nInUse { yy[i as usize] = i as UChar; i += 1 }\n    i = 0 as std::os::raw::c_int;\n    while i < (*s).nblock {\n        let mut ll_i: UChar = 0;\n        j =\n            (*ptr.offset(i as\n                             isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                      std::os::raw::c_uint) as Int32;\n        if j < 0 as std::os::raw::c_int { j += (*s).nblock }\n        ll_i = (*s).unseqToSeq[*block.offset(j as isize) as usize];\n        if yy[0 as std::os::raw::c_int as usize] as std::os::raw::c_int == ll_i as std::os::raw::c_int\n           {\n            zPend += 1\n        } else {\n            if zPend > 0 as std::os::raw::c_int {\n                zPend -= 1;\n                while 1 as std::os::raw::c_int as Bool != 0 {\n                    if zPend & 1 as std::os::raw::c_int != 0 {\n                        *mtfv.offset(wr as isize) =\n                            1 as std::os::raw::c_int as UInt16;\n                        wr += 1;\n                        (*s).mtfFreq[1 as std::os::raw::c_int as usize] += 1\n                    } else {\n                        *mtfv.offset(wr as isize) =\n                            0 as std::os::raw::c_int as UInt16;\n                        wr += 1;\n                        (*s).mtfFreq[0 as std::os::raw::c_int as usize] += 1\n                    }\n                    if zPend < 2 as std::os::raw::c_int { break ; }\n                    zPend = (zPend - 2 as std::os::raw::c_int) / 2 as std::os::raw::c_int\n                }\n                zPend = 0 as std::os::raw::c_int\n            }\n            let mut rtmp: UChar = 0;\n            let mut ryy_j: *mut UChar = 0 as *mut UChar;\n            let mut rll_i: UChar = 0;\n            rtmp = yy[1 as std::os::raw::c_int as usize];\n            yy[1 as std::os::raw::c_int as usize] = yy[0 as std::os::raw::c_int as usize];\n            ryy_j =\n                &mut *yy.as_mut_ptr().offset(1 as std::os::raw::c_int as isize) as\n                    *mut UChar;\n            rll_i = ll_i;\n            while rll_i as std::os::raw::c_int != rtmp as std::os::raw::c_int {\n                let mut rtmp2: UChar = 0;\n                ryy_j = ryy_j.offset(1);\n                rtmp2 = rtmp;\n                rtmp = *ryy_j;\n                *ryy_j = rtmp2\n            }\n            yy[0 as std::os::raw::c_int as usize] = rtmp;\n            j =\n                ryy_j.offset_from(&mut *yy.as_mut_ptr().offset(0 as\n                                                                            std::os::raw::c_int\n                                                                            as\n                                                                            isize)\n                                               as *mut UChar) as std::os::raw::c_long\n                    as Int32;\n            *mtfv.offset(wr as isize) = (j + 1 as std::os::raw::c_int) as UInt16;\n            wr += 1;\n            (*s).mtfFreq[(j + 1 as std::os::raw::c_int) as usize] += 1\n        }\n        i += 1\n    }\n    if zPend > 0 as std::os::raw::c_int {\n        zPend -= 1;\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            if zPend & 1 as std::os::raw::c_int != 0 {\n                *mtfv.offset(wr as isize) = 1 as std::os::raw::c_int as UInt16;\n                wr += 1;\n                (*s).mtfFreq[1 as std::os::raw::c_int as usize] += 1\n            } else {\n                *mtfv.offset(wr as isize) = 0 as std::os::raw::c_int as UInt16;\n                wr += 1;\n                (*s).mtfFreq[0 as std::os::raw::c_int as usize] += 1\n            }\n            if zPend < 2 as std::os::raw::c_int { break ; }\n            zPend = (zPend - 2 as std::os::raw::c_int) / 2 as std::os::raw::c_int\n        }\n        zPend = 0 as std::os::raw::c_int\n    }\n    *mtfv.offset(wr as isize) = EOB as UInt16;\n    wr += 1;\n    (*s).mtfFreq[EOB as usize] += 1;\n    (*s).nMTF = wr;\n}",
    "calls": [
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2501:9: 2501:30 (#0)",
        "source": "generateMTFValues(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:20:1: 20:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:18:1: 18:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:17:1: 17:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:19:1: 19:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:21:1: 21:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:267 ~ c2rust_out[3c70]::bzip2::mapSuffix)",
    "span": "bzip2.rs:2024:1: 2032:2 (#0)",
    "pieces": [
      "bzip2.rs:2024:1: 2032:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn mapSuffix(mut name: *mut Char,\n                               mut oldSuffix: *const Char,\n                               mut newSuffix: *const Char) -> Bool {\n    if hasSuffix(name, oldSuffix) == 0 { return 0 as std::os::raw::c_int as Bool }\n    *name.offset(strlen(name).wrapping_sub(strlen(oldSuffix)) as isize) =\n        0 as std::os::raw::c_int as Char;\n    strcat(name, newSuffix);\n    return 1 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:329 ~ c2rust_out[3c70]::bzip2recover::readError)",
    "span": "bzip2recover.rs:112:1: 122:2 (#0)",
    "pieces": [
      "bzip2recover.rs:112:1: 122:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn readError() {\n    fprintf(__stderrp,\n            b\"%s: I/O error reading `%s\\', possible reason follows.\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr(),\n            inFileName.as_mut_ptr());\n    perror(progName.as_mut_ptr());\n    fprintf(__stderrp,\n            b\"%s: warning: output file(s) may be incomplete.\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());\n    exit(1 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:337 ~ c2rust_out[3c70]::bzip2recover::bsClose)",
        "span": "bzip2recover.rs:243:18: 243:30 (#0)",
        "source": "readError();"
      },
      {
        "caller": "DefId(0:336 ~ c2rust_out[3c70]::bzip2recover::bsGetBit)",
        "span": "bzip2recover.rs:217:57: 217:69 (#0)",
        "source": "readError();"
      }
    ],
    "globals": [
      {
        "span": "bzip2recover.rs:99:1: 99:53 (#0)",
        "source": "pub static mut inFileName: [Char; 2000] = [0; 2000];"
      },
      {
        "span": "bzip2recover.rs:102:1: 102:51 (#0)",
        "source": "pub static mut progName: [Char; 2000] = [0; 2000];"
      }
    ],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:336 ~ c2rust_out[3c70]::bzip2recover::bsGetBit)",
    "span": "bzip2recover.rs:210:1: 224:2 (#0)",
    "pieces": [
      "bzip2recover.rs:210:1: 224:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn bsGetBit(mut bs: *mut BitStream) -> Int32 {\n    if (*bs).buffLive > 0 as std::os::raw::c_int {\n        (*bs).buffLive -= 1;\n        return (*bs).buffer >> (*bs).buffLive & 0x1 as std::os::raw::c_int\n    } else {\n        let mut retVal: Int32 = getc((*bs).handle);\n        if retVal == -(1 as std::os::raw::c_int) {\n            if *__error() != 0 as std::os::raw::c_int { readError(); }\n            return 2 as std::os::raw::c_int\n        }\n        (*bs).buffLive = 7 as std::os::raw::c_int;\n        (*bs).buffer = retVal;\n        return (*bs).buffer >> 7 as std::os::raw::c_int & 0x1 as std::os::raw::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:235 ~ c2rust_out[3c70]::bzip2::setExit)",
    "span": "bzip2.rs:1608:1: 1610:2 (#0)",
    "pieces": [
      "bzip2.rs:1608:1: 1610:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn setExit(mut v: Int32) {\n    if v > exitValue { exitValue = v };\n}",
    "calls": [
      {
        "caller": "DefId(0:245 ~ c2rust_out[3c70]::bzip2::mySIGSEGVorSIGBUScatcher)",
        "span": "bzip2.rs:1780:14: 1780:48 (#0)",
        "source": "setExit(2 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2183:17: 2183:51 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2381:9: 2381:43 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:245 ~ c2rust_out[3c70]::bzip2::mySIGSEGVorSIGBUScatcher)",
        "span": "bzip2.rs:1779:9: 1779:43 (#0)",
        "source": "setExit(3 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2209:17: 2209:51 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2227:17: 2227:51 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2614:17: 2614:51 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2468:17: 2468:51 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2138:9: 2138:43 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2236:17: 2236:51 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2477:17: 2477:51 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2450:17: 2450:51 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2402:13: 2402:47 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2201:17: 2201:51 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2628:17: 2628:51 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2369:13: 2369:47 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2359:9: 2359:43 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2351:9: 2351:43 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:249 ~ c2rust_out[3c70]::bzip2::copyFileName)",
        "span": "bzip2.rs:1824:9: 1824:43 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:281 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:3113:13: 3113:47 (#0)",
        "source": "setExit(2 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2163:9: 2163:43 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:247 ~ c2rust_out[3c70]::bzip2::configError)",
        "span": "bzip2.rs:1796:5: 1796:39 (#0)",
        "source": "setExit(3 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2582:9: 2582:43 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2126:13: 2126:47 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2415:9: 2415:43 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2435:17: 2435:51 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:281 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:3085:33: 3085:67 (#0)",
        "source": "setExit(2 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2600:13: 2600:47 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2102:9: 2102:43 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2150:13: 2150:47 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2590:9: 2590:43 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:238 ~ c2rust_out[3c70]::bzip2::cleanUpAndFail)",
        "span": "bzip2.rs:1696:5: 1696:17 (#0)",
        "source": "setExit(ec);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2522:9: 2522:43 (#0)",
        "source": "setExit(2 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2094:9: 2094:43 (#0)",
        "source": "setExit(1 as std::os::raw::c_int);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:334:1: 334:37 (#0)",
        "source": "pub static mut exitValue: Int32 = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:238 ~ c2rust_out[3c70]::bzip2::cleanUpAndFail)",
    "span": "bzip2.rs:1629:1: 1698:2 (#0)",
    "pieces": [
      "bzip2.rs:1629:1: 1698:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 70,
    "source": "unsafe extern \"C\" fn cleanUpAndFail(mut ec: Int32) -> ! {\n    let mut retVal: IntNative = 0;\n    let mut statBuf: stat =\n        stat{st_dev: 0,\n             st_mode: 0,\n             st_nlink: 0,\n             st_ino: 0,\n             st_uid: 0,\n             st_gid: 0,\n             st_rdev: 0,\n             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_size: 0,\n             st_blocks: 0,\n             st_blksize: 0,\n             st_flags: 0,\n             st_gen: 0,\n             st_lspare: 0,\n             st_qspare: [0; 2],};\n    if srcMode == 3 as std::os::raw::c_int && opMode != 3 as std::os::raw::c_int &&\n           deleteOutputOnInterrupt as std::os::raw::c_int != 0 {\n        /* Check whether input file still exists.  Delete output file\n         only if input exists to avoid loss of data.  Joerg Prante, 5\n         January 2002.  (JRS 06-Jan-2002: other changes in 1.0.2 mean\n         this is less likely to happen.  But to be ultra-paranoid, we\n         do the check anyway.)  */\n        retVal = stat(inName.as_mut_ptr(), &mut statBuf);\n        if retVal == 0 as std::os::raw::c_int {\n            if noisy != 0 {\n                fprintf(__stderrp,\n                        b\"%s: Deleting output file %s, if it exists.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        outName.as_mut_ptr());\n            }\n            if !outputHandleJustInCase.is_null() {\n                fclose(outputHandleJustInCase);\n            }\n            retVal = remove(outName.as_mut_ptr());\n            if retVal != 0 as std::os::raw::c_int {\n                fprintf(__stderrp,\n                        b\"%s: WARNING: deletion of output file (apparently) failed.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char, progName);\n            }\n        } else {\n            fprintf(__stderrp,\n                    b\"%s: WARNING: deletion of output file suppressed\\n\\x00\"\n                        as *const u8 as *const std::os::raw::c_char, progName);\n            fprintf(__stderrp,\n                    b\"%s:    since input file no longer exists.  Output file\\n\\x00\"\n                        as *const u8 as *const std::os::raw::c_char, progName);\n            fprintf(__stderrp,\n                    b\"%s:    `%s\\' may be incomplete.\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, progName, outName.as_mut_ptr());\n            fprintf(__stderrp,\n                    b\"%s:    I suggest doing an integrity test (bzip2 -tv) of it.\\n\\x00\"\n                        as *const u8 as *const std::os::raw::c_char, progName);\n        }\n    }\n    if noisy as std::os::raw::c_int != 0 && numFileNames > 0 as std::os::raw::c_int &&\n           numFilesProcessed < numFileNames {\n        fprintf(__stderrp,\n                b\"%s: WARNING: some files have not been processed:\\n%s:    %d specified on command line, %d not processed yet.\\n\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char, progName, progName,\n                numFileNames, numFileNames - numFilesProcessed);\n    }\n    setExit(ec);\n    exit(exitValue);\n}",
    "calls": [
      {
        "caller": "DefId(0:244 ~ c2rust_out[3c70]::bzip2::mySignalCatcher)",
        "span": "bzip2.rs:1742:5: 1742:46 (#0)",
        "source": "cleanUpAndFail(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:240 ~ c2rust_out[3c70]::bzip2::panic)",
        "span": "bzip2.rs:1705:5: 1705:46 (#0)",
        "source": "cleanUpAndFail(3 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:243 ~ c2rust_out[3c70]::bzip2::ioError)",
        "span": "bzip2.rs:1735:5: 1735:46 (#0)",
        "source": "cleanUpAndFail(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:241 ~ c2rust_out[3c70]::bzip2::crcError)",
        "span": "bzip2.rs:1714:5: 1714:46 (#0)",
        "source": "cleanUpAndFail(2 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:246 ~ c2rust_out[3c70]::bzip2::outOfMemory)",
        "span": "bzip2.rs:1789:5: 1789:46 (#0)",
        "source": "cleanUpAndFail(1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:242 ~ c2rust_out[3c70]::bzip2::compressedStreamEOF)",
        "span": "bzip2.rs:1726:5: 1726:46 (#0)",
        "source": "cleanUpAndFail(2 as std::os::raw::c_int);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:344:1: 344:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:328:1: 328:40 (#0)",
        "source": "pub static mut numFileNames: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:342:1: 342:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      },
      {
        "span": "bzip2.rs:352:1: 353:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      },
      {
        "span": "bzip2.rs:330:1: 330:45 (#0)",
        "source": "pub static mut numFilesProcessed: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:334:1: 334:37 (#0)",
        "source": "pub static mut exitValue: Int32 = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:237 ~ c2rust_out[3c70]::bzip2::showFileNames)",
    "span": "bzip2.rs:1620:1: 1627:2 (#0)",
    "pieces": [
      "bzip2.rs:1620:1: 1627:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn showFileNames() {\n    if noisy != 0 {\n        fprintf(__stderrp,\n                b\"\\tInput file = %s, output file = %s\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, inName.as_mut_ptr(),\n                outName.as_mut_ptr());\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:242 ~ c2rust_out[3c70]::bzip2::compressedStreamEOF)",
        "span": "bzip2.rs:1723:9: 1723:25 (#0)",
        "source": "showFileNames();"
      },
      {
        "caller": "DefId(0:240 ~ c2rust_out[3c70]::bzip2::panic)",
        "span": "bzip2.rs:1704:5: 1704:21 (#0)",
        "source": "showFileNames();"
      },
      {
        "caller": "DefId(0:243 ~ c2rust_out[3c70]::bzip2::ioError)",
        "span": "bzip2.rs:1734:5: 1734:21 (#0)",
        "source": "showFileNames();"
      },
      {
        "caller": "DefId(0:241 ~ c2rust_out[3c70]::bzip2::crcError)",
        "span": "bzip2.rs:1712:5: 1712:21 (#0)",
        "source": "showFileNames();"
      },
      {
        "caller": "DefId(0:246 ~ c2rust_out[3c70]::bzip2::outOfMemory)",
        "span": "bzip2.rs:1788:5: 1788:21 (#0)",
        "source": "showFileNames();"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:342:1: 342:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:344:1: 344:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:243 ~ c2rust_out[3c70]::bzip2::ioError)",
    "span": "bzip2.rs:1729:1: 1736:2 (#0)",
    "pieces": [
      "bzip2.rs:1729:1: 1736:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn ioError() -> ! {\n    fprintf(__stderrp,\n            b\"\\n%s: I/O or other error, bailing out.  Possible reason follows.\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, progName);\n    perror(progName);\n    showFileNames();\n    cleanUpAndFail(1 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1601:5: 1601:15 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2504:57: 2504:67 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:260 ~ c2rust_out[3c70]::bzip2::applySavedFileAttrToOutputFile)",
        "span": "bzip2.rs:1986:45: 1986:55 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:258 ~ c2rust_out[3c70]::bzip2::saveInputFileMetaInfo)",
        "span": "bzip2.rs:1973:45: 1973:55 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:259 ~ c2rust_out[3c70]::bzip2::applySavedTimeInfoToOutputFile)",
        "span": "bzip2.rs:1981:45: 1981:55 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:700:5: 700:15 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2512:55: 2512:65 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1249:5: 1249:15 (#0)",
        "source": "ioError();"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2262:53: 2262:63 (#0)",
        "source": "ioError();"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:254 ~ c2rust_out[3c70]::bzip2::countHardLinks)",
    "span": "bzip2.rs:1902:1: 1926:2 (#0)",
    "pieces": [
      "bzip2.rs:1902:1: 1926:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 25,
    "source": "unsafe extern \"C\" fn countHardLinks(mut name: *mut Char) -> Int32 {\n    let mut i: IntNative = 0;\n    let mut statBuf: stat =\n        stat{st_dev: 0,\n             st_mode: 0,\n             st_nlink: 0,\n             st_ino: 0,\n             st_uid: 0,\n             st_gid: 0,\n             st_rdev: 0,\n             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_size: 0,\n             st_blocks: 0,\n             st_blksize: 0,\n             st_flags: 0,\n             st_gen: 0,\n             st_lspare: 0,\n             st_qspare: [0; 2],};\n    i = lstat(name, &mut statBuf);\n    if i != 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }\n    return statBuf.st_nlink as std::os::raw::c_int - 1 as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:444 ~ c2rust_out[3c70]::bzlib::BZ2_bzReadGetUnused)",
    "span": "bzlib.rs:2071:1: 2096:2 (#0)",
    "pieces": [
      "bzlib.rs:2071:1: 2096:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 26,
    "source": "pub unsafe extern \"C\" fn BZ2_bzReadGetUnused(mut bzerror: *mut std::os::raw::c_int,\n                                             mut b: *mut std::os::raw::c_void,\n                                             mut unused:\n                                                 *mut *mut std::os::raw::c_void,\n                                             mut nUnused: *mut std::os::raw::c_int) {\n    let mut bzf: *mut bzFile = b as *mut bzFile;\n    if bzf.is_null() {\n        if !bzerror.is_null() { *bzerror = -(2 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(2 as std::os::raw::c_int) }\n        return\n    }\n    if (*bzf).lastErr != 4 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = -(1 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(1 as std::os::raw::c_int) }\n        return\n    }\n    if unused.is_null() || nUnused.is_null() {\n        if !bzerror.is_null() { *bzerror = -(2 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(2 as std::os::raw::c_int) }\n        return\n    }\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    *nUnused = (*bzf).strm.avail_in as std::os::raw::c_int;\n    *unused = (*bzf).strm.next_in as *mut std::os::raw::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1298:17: 1299:51 (#0)",
        "source": "BZ2_bzReadGetUnused(&mut bzerr, bzf, &mut unusedTmpV,\n                                    &mut nUnused);"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:765:21: 766:55 (#0)",
        "source": "BZ2_bzReadGetUnused(&mut bzerr, bzf, &mut unusedTmpV,\n                                        &mut nUnused);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:251 ~ c2rust_out[3c70]::bzip2::fopen_output_safely)",
    "span": "bzip2.rs:1851:1: 1864:2 (#0)",
    "pieces": [
      "bzip2.rs:1851:1: 1864:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "unsafe extern \"C\" fn fopen_output_safely(mut name: *mut Char,\n                                         mut mode: *const std::os::raw::c_char)\n -> *mut FILE {\n    let mut fp: *mut FILE = 0 as *mut FILE;\n    let mut fh: IntNative = 0;\n    fh =\n        open(name,\n             0x1 as std::os::raw::c_int | 0x200 as std::os::raw::c_int | 0x800 as std::os::raw::c_int,\n             0o200 as std::os::raw::c_int | 0o400 as std::os::raw::c_int);\n    if fh == -(1 as std::os::raw::c_int) { return 0 as *mut FILE }\n    fp = fdopen(fh, mode);\n    if fp.is_null() { close(fh); }\n    return fp;\n}",
    "calls": [
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2458:13: 2461:70 (#0)",
        "source": "outStr =\n                fopen_output_safely(outName.as_mut_ptr(),\n                                    b\"wb\\x00\" as *const u8 as\n                                        *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2217:13: 2220:70 (#0)",
        "source": "outStr =\n                fopen_output_safely(outName.as_mut_ptr(),\n                                    b\"wb\\x00\" as *const u8 as\n                                        *const std::os::raw::c_char);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:330 ~ c2rust_out[3c70]::bzip2recover::writeError)",
    "span": "bzip2recover.rs:124:1: 134:2 (#0)",
    "pieces": [
      "bzip2recover.rs:124:1: 134:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn writeError() {\n    fprintf(__stderrp,\n            b\"%s: I/O error reading `%s\\', possible reason follows.\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr(),\n            inFileName.as_mut_ptr());\n    perror(progName.as_mut_ptr());\n    fprintf(__stderrp,\n            b\"%s: warning: output file(s) may be incomplete.\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());\n    exit(1 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:337 ~ c2rust_out[3c70]::bzip2recover::bsClose)",
        "span": "bzip2recover.rs:237:52: 237:65 (#0)",
        "source": "writeError();"
      },
      {
        "caller": "DefId(0:337 ~ c2rust_out[3c70]::bzip2recover::bsClose)",
        "span": "bzip2recover.rs:234:52: 234:65 (#0)",
        "source": "writeError();"
      },
      {
        "caller": "DefId(0:335 ~ c2rust_out[3c70]::bzip2recover::bsPutBit)",
        "span": "bzip2recover.rs:196:52: 196:65 (#0)",
        "source": "writeError();"
      },
      {
        "caller": "DefId(0:337 ~ c2rust_out[3c70]::bzip2recover::bsClose)",
        "span": "bzip2recover.rs:242:13: 242:26 (#0)",
        "source": "writeError();"
      }
    ],
    "globals": [
      {
        "span": "bzip2recover.rs:99:1: 99:53 (#0)",
        "source": "pub static mut inFileName: [Char; 2000] = [0; 2000];"
      },
      {
        "span": "bzip2recover.rs:102:1: 102:51 (#0)",
        "source": "pub static mut progName: [Char; 2000] = [0; 2000];"
      }
    ],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:335 ~ c2rust_out[3c70]::bzip2recover::bsPutBit)",
    "span": "bzip2recover.rs:192:1: 205:2 (#0)",
    "pieces": [
      "bzip2recover.rs:192:1: 205:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "unsafe extern \"C\" fn bsPutBit(mut bs: *mut BitStream, mut bit: Int32) {\n    if (*bs).buffLive == 8 as std::os::raw::c_int {\n        let mut retVal: Int32 =\n            putc((*bs).buffer as UChar as std::os::raw::c_int, (*bs).handle);\n        if retVal == -(1 as std::os::raw::c_int) { writeError(); }\n        bytesOut = bytesOut.wrapping_add(1);\n        (*bs).buffLive = 1 as std::os::raw::c_int;\n        (*bs).buffer = bit & 0x1 as std::os::raw::c_int\n    } else {\n        (*bs).buffer =\n            (*bs).buffer << 1 as std::os::raw::c_int | bit & 0x1 as std::os::raw::c_int;\n        (*bs).buffLive += 1\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "bzip2recover.rs:104:1: 104:80 (#0)",
        "source": "pub static mut bytesOut: MaybeUInt64 = 0 as std::os::raw::c_int as MaybeUInt64;"
      }
    ],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:35 ~ c2rust_out[3c70]::blocksort::mmed3)",
    "span": "blocksort.rs:884:2: 893:2 (#0)",
    "pieces": [
      "blocksort.rs:884:2: 893:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "extern \"C\" fn mmed3(mut a: UChar, mut b: UChar, mut c: UChar)\n -> UChar {\n    let mut t: UChar = 0;\n    if a as std::os::raw::c_int > b as std::os::raw::c_int { t = a; a = b; b = t }\n    if b as std::os::raw::c_int > c as std::os::raw::c_int {\n        b = c;\n        if a as std::os::raw::c_int > b as std::os::raw::c_int { b = a }\n    }\n    return b;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:11:1: 11:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:259 ~ c2rust_out[3c70]::bzip2::applySavedTimeInfoToOutputFile)",
    "span": "bzip2.rs:1975:1: 1982:2 (#0)",
    "pieces": [
      "bzip2.rs:1975:1: 1982:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn applySavedTimeInfoToOutputFile(mut dstName: *mut Char) {\n    let mut retVal: IntNative = 0;\n    let mut uTimBuf: utimbuf = utimbuf{actime: 0, modtime: 0,};\n    uTimBuf.actime = fileMetaInfo.st_atimespec.tv_sec;\n    uTimBuf.modtime = fileMetaInfo.st_mtimespec.tv_sec;\n    retVal = utime(dstName, &mut uTimBuf);\n    if retVal != 0 as std::os::raw::c_int { ioError(); };\n}",
    "calls": [
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2500:13: 2500:66 (#0)",
        "source": "applySavedTimeInfoToOutputFile(outName.as_mut_ptr());"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2258:9: 2258:62 (#0)",
        "source": "applySavedTimeInfoToOutputFile(outName.as_mut_ptr());"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:1950:1: 1968:30 (#0)",
        "source": "static mut fileMetaInfo: stat =\n    stat{st_dev: 0,\n         st_mode: 0,\n         st_nlink: 0,\n         st_ino: 0,\n         st_uid: 0,\n         st_gid: 0,\n         st_rdev: 0,\n         st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_size: 0,\n         st_blocks: 0,\n         st_blksize: 0,\n         st_flags: 0,\n         st_gen: 0,\n         st_lspare: 0,\n         st_qspare: [0; 2],};"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:260 ~ c2rust_out[3c70]::bzip2::applySavedFileAttrToOutputFile)",
    "span": "bzip2.rs:1983:1: 1991:2 (#0)",
    "pieces": [
      "bzip2.rs:1983:1: 1991:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn applySavedFileAttrToOutputFile(mut fd: IntNative) {\n    let mut retVal: IntNative = 0;\n    retVal = fchmod(fd, fileMetaInfo.st_mode);\n    if retVal != 0 as std::os::raw::c_int { ioError(); }\n    fchown(fd, fileMetaInfo.st_uid, fileMetaInfo.st_gid);\n    /* chown() will in many cases return with EPERM, which can\n      be safely ignored.\n   */\n}",
    "calls": [
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:535:41: 535:76 (#0)",
        "source": "applySavedFileAttrToOutputFile(fd);"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1158:49: 1158:84 (#0)",
        "source": "applySavedFileAttrToOutputFile(fd);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:1950:1: 1968:30 (#0)",
        "source": "static mut fileMetaInfo: stat =\n    stat{st_dev: 0,\n         st_mode: 0,\n         st_nlink: 0,\n         st_ino: 0,\n         st_uid: 0,\n         st_gid: 0,\n         st_rdev: 0,\n         st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_size: 0,\n         st_blocks: 0,\n         st_blksize: 0,\n         st_flags: 0,\n         st_gen: 0,\n         st_lspare: 0,\n         st_qspare: [0; 2],};"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:249 ~ c2rust_out[3c70]::bzip2::copyFileName)",
    "span": "bzip2.rs:1817:1: 1831:2 (#0)",
    "pieces": [
      "bzip2.rs:1817:1: 1831:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn copyFileName(mut to: *mut Char, mut from: *mut Char) {\n    if strlen(from) >\n           (1034 as std::os::raw::c_int - 10 as std::os::raw::c_int) as std::os::raw::c_ulong {\n        fprintf(__stderrp,\n                b\"bzip2: file name\\n`%s\\'\\nis suspiciously (more than %d chars) long.\\nTry using a reasonable file name instead.  Sorry! :-)\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char, from,\n                1034 as std::os::raw::c_int - 10 as std::os::raw::c_int);\n        setExit(1 as std::os::raw::c_int);\n        exit(exitValue);\n    }\n    strncpy(to, from,\n            (1034 as std::os::raw::c_int - 10 as std::os::raw::c_int) as std::os::raw::c_ulong);\n    *to.offset((1034 as std::os::raw::c_int - 10 as std::os::raw::c_int) as isize) =\n        '\\u{0}' as i32 as Char;\n}",
    "calls": [
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2311:13: 2311:53 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2571:16: 2571:56 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2080:13: 2082:44 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);"
      },
      {
        "caller": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2570:16: 2570:56 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2312:13: 2312:54 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2337:13: 2339:44 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);"
      },
      {
        "caller": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2566:13: 2568:41 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(),\n                         b\"(stdin)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                             *mut Char);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2068:13: 2070:44 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);"
      },
      {
        "caller": "DefId(0:281 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2797:5: 2799:33 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(),\n                 b\"(none)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                     *mut Char);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2336:13: 2336:53 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2306:13: 2308:44 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);"
      },
      {
        "caller": "DefId(0:281 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2794:5: 2796:33 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(),\n                 b\"(none)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                     *mut Char);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2074:13: 2074:54 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2073:13: 2073:53 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2303:13: 2305:41 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(),\n                         b\"(stdin)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                             *mut Char);"
      },
      {
        "caller": "DefId(0:281 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2800:5: 2801:67 (#0)",
        "source": "copyFileName(progNameReally.as_mut_ptr(),\n                 *argv.offset(0 as std::os::raw::c_int as isize));"
      },
      {
        "caller": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2561:5: 2563:33 (#0)",
        "source": "copyFileName(outName.as_mut_ptr(),\n                 b\"(none)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                     *mut Char);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2079:13: 2079:53 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(), name);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2065:13: 2067:41 (#0)",
        "source": "copyFileName(inName.as_mut_ptr(),\n                         b\"(stdin)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                             *mut Char);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:334:1: 334:37 (#0)",
        "source": "pub static mut exitValue: Int32 = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:275 ~ c2rust_out[3c70]::bzip2::usage)",
    "span": "bzip2.rs:2658:1: 2663:2 (#0)",
    "pieces": [
      "bzip2.rs:2658:1: 2663:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn usage(mut fullProgName: *mut Char) {\n    fprintf(__stderrp,\n            b\"bzip2, a block-sorting file compressor.  Version %s.\\n\\n   usage: %s [flags and input files in any order]\\n\\n   -h --help           print this message\\n   -d --decompress     force decompression\\n   -z --compress       force compression\\n   -k --keep           keep (don\\'t delete) input files\\n   -f --force          overwrite existing output files\\n   -t --test           test compressed file integrity\\n   -c --stdout         output to standard out\\n   -q --quiet          suppress noncritical error messages\\n   -v --verbose        be verbose (a 2nd -v gives more)\\n   -L --license        display software version & license\\n   -V --version        display software version & license\\n   -s --small          use less memory (at most 2500k)\\n   -1 .. -9            set block size to 100k .. 900k\\n   --fast              alias for -1\\n   --best              alias for -9\\n\\n   If invoked as `bzip2\\', default action is to compress.\\n              as `bunzip2\\',  default action is to decompress.\\n              as `bzcat\\', default action is to decompress to stdout.\\n\\n   If no file names are given, bzip2 compresses or decompresses\\n   from standard input to standard output.  You can combine\\n   short flags, so `-v -4\\' means the same as -v4 or -4v, &c.\\n\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, BZ2_bzlibVersion(),\n            fullProgName);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:433 ~ c2rust_out[3c70]::bzlib::unRLE_obuf_to_output_SMALL)",
    "span": "bzlib.rs:1201:1: 1579:2 (#0)",
    "pieces": [
      "bzlib.rs:1201:1: 1579:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 379,
    "source": "unsafe extern \"C\" fn unRLE_obuf_to_output_SMALL(mut s: *mut DState) -> Bool {\n    let mut k1: UChar = 0;\n    if (*s).blockRandomised != 0 {\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /* try to finish existing run */\n            while 1 as std::os::raw::c_int as Bool != 0 {\n                if (*(*s).strm).avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint\n                   {\n                    return 0 as std::os::raw::c_int as Bool\n                }\n                if (*s).state_out_len == 0 as std::os::raw::c_int { break ; }\n                *((*(*s).strm).next_out as *mut UChar) = (*s).state_out_ch;\n                (*s).calculatedBlockCRC =\n                    (*s).calculatedBlockCRC << 8 as std::os::raw::c_int ^\n                        BZ2_crc32Table[((*s).calculatedBlockCRC >>\n                                            24 as std::os::raw::c_int ^\n                                            (*s).state_out_ch as std::os::raw::c_uint)\n                                           as usize];\n                (*s).state_out_len -= 1;\n                (*(*s).strm).next_out = (*(*s).strm).next_out.offset(1);\n                (*(*s).strm).avail_out =\n                    (*(*s).strm).avail_out.wrapping_sub(1);\n                (*(*s).strm).total_out_lo32 =\n                    (*(*s).strm).total_out_lo32.wrapping_add(1);\n                if (*(*s).strm).total_out_lo32 ==\n                       0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    (*(*s).strm).total_out_hi32 =\n                        (*(*s).strm).total_out_hi32.wrapping_add(1)\n                }\n            }\n            /* can a new run be started? */\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                return 0 as std::os::raw::c_int as Bool\n            }\n            /* Only caused by corrupt data stream? */\n            if (*s).nblock_used > (*s).save_nblock + 1 as std::os::raw::c_int {\n                return 1 as std::os::raw::c_int as Bool\n            }\n            (*s).state_out_len = 1 as std::os::raw::c_int;\n            (*s).state_out_ch = (*s).k0 as UChar;\n            if (*s).tPos >=\n                   (100000 as std::os::raw::c_int as\n                        UInt32).wrapping_mul((*s).blockSize100k as UInt32) {\n                return 1 as std::os::raw::c_int as Bool\n            }\n            k1 =\n                BZ2_indexIntoF((*s).tPos as Int32, (*s).cftab.as_mut_ptr()) as\n                    UChar;\n            (*s).tPos =\n                *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                    (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int) as\n                                          isize) as UInt32 >>\n                         ((*s).tPos << 2 as std::os::raw::c_int &\n                              0x4 as std::os::raw::c_int as std::os::raw::c_uint) &\n                         0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                        16 as std::os::raw::c_int;\n            if (*s).rNToGo == 0 as std::os::raw::c_int {\n                (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                (*s).rTPos += 1;\n                if (*s).rTPos == 512 as std::os::raw::c_int {\n                    (*s).rTPos = 0 as std::os::raw::c_int\n                }\n            }\n            (*s).rNToGo -= 1;\n            k1 =\n                (k1 as std::os::raw::c_int ^\n                     if (*s).rNToGo == 1 as std::os::raw::c_int {\n                         1 as std::os::raw::c_int\n                     } else { 0 as std::os::raw::c_int }) as UChar;\n            (*s).nblock_used += 1;\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                continue ;\n            }\n            if k1 as std::os::raw::c_int != (*s).k0 {\n                (*s).k0 = k1 as Int32\n            } else {\n                (*s).state_out_len = 2 as std::os::raw::c_int;\n                if (*s).tPos >=\n                       (100000 as std::os::raw::c_int as\n                            UInt32).wrapping_mul((*s).blockSize100k as UInt32)\n                   {\n                    return 1 as std::os::raw::c_int as Bool\n                }\n                k1 =\n                    BZ2_indexIntoF((*s).tPos as Int32,\n                                   (*s).cftab.as_mut_ptr()) as UChar;\n                (*s).tPos =\n                    *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                        (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int) as\n                                              isize) as UInt32 >>\n                             ((*s).tPos << 2 as std::os::raw::c_int &\n                                  0x4 as std::os::raw::c_int as std::os::raw::c_uint) &\n                             0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                            16 as std::os::raw::c_int;\n                if (*s).rNToGo == 0 as std::os::raw::c_int {\n                    (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                    (*s).rTPos += 1;\n                    if (*s).rTPos == 512 as std::os::raw::c_int {\n                        (*s).rTPos = 0 as std::os::raw::c_int\n                    }\n                }\n                (*s).rNToGo -= 1;\n                k1 =\n                    (k1 as std::os::raw::c_int ^\n                         if (*s).rNToGo == 1 as std::os::raw::c_int {\n                             1 as std::os::raw::c_int\n                         } else { 0 as std::os::raw::c_int }) as UChar;\n                (*s).nblock_used += 1;\n                if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                    continue ;\n                }\n                if k1 as std::os::raw::c_int != (*s).k0 {\n                    (*s).k0 = k1 as Int32\n                } else {\n                    (*s).state_out_len = 3 as std::os::raw::c_int;\n                    if (*s).tPos >=\n                           (100000 as std::os::raw::c_int as\n                                UInt32).wrapping_mul((*s).blockSize100k as\n                                                         UInt32) {\n                        return 1 as std::os::raw::c_int as Bool\n                    }\n                    k1 =\n                        BZ2_indexIntoF((*s).tPos as Int32,\n                                       (*s).cftab.as_mut_ptr()) as UChar;\n                    (*s).tPos =\n                        *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                            (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int)\n                                                  as isize) as UInt32 >>\n                                 ((*s).tPos << 2 as std::os::raw::c_int &\n                                      0x4 as std::os::raw::c_int as std::os::raw::c_uint) &\n                                 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                                16 as std::os::raw::c_int;\n                    if (*s).rNToGo == 0 as std::os::raw::c_int {\n                        (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                        (*s).rTPos += 1;\n                        if (*s).rTPos == 512 as std::os::raw::c_int {\n                            (*s).rTPos = 0 as std::os::raw::c_int\n                        }\n                    }\n                    (*s).rNToGo -= 1;\n                    k1 =\n                        (k1 as std::os::raw::c_int ^\n                             if (*s).rNToGo == 1 as std::os::raw::c_int {\n                                 1 as std::os::raw::c_int\n                             } else { 0 as std::os::raw::c_int }) as UChar;\n                    (*s).nblock_used += 1;\n                    if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int\n                       {\n                        continue ;\n                    }\n                    if k1 as std::os::raw::c_int != (*s).k0 {\n                        (*s).k0 = k1 as Int32\n                    } else {\n                        if (*s).tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul((*s).blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        k1 =\n                            BZ2_indexIntoF((*s).tPos as Int32,\n                                           (*s).cftab.as_mut_ptr()) as UChar;\n                        (*s).tPos =\n                            *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                                (*(*s).ll4.offset(((*s).tPos >>\n                                                       1 as std::os::raw::c_int) as\n                                                      isize) as UInt32 >>\n                                     ((*s).tPos << 2 as std::os::raw::c_int &\n                                          0x4 as std::os::raw::c_int as std::os::raw::c_uint)\n                                     & 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                                    16 as std::os::raw::c_int;\n                        if (*s).rNToGo == 0 as std::os::raw::c_int {\n                            (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                            (*s).rTPos += 1;\n                            if (*s).rTPos == 512 as std::os::raw::c_int {\n                                (*s).rTPos = 0 as std::os::raw::c_int\n                            }\n                        }\n                        (*s).rNToGo -= 1;\n                        k1 =\n                            (k1 as std::os::raw::c_int ^\n                                 if (*s).rNToGo == 1 as std::os::raw::c_int {\n                                     1 as std::os::raw::c_int\n                                 } else { 0 as std::os::raw::c_int }) as UChar;\n                        (*s).nblock_used += 1;\n                        (*s).state_out_len = k1 as Int32 + 4 as std::os::raw::c_int;\n                        if (*s).tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul((*s).blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        (*s).k0 =\n                            BZ2_indexIntoF((*s).tPos as Int32,\n                                           (*s).cftab.as_mut_ptr());\n                        (*s).tPos =\n                            *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                                (*(*s).ll4.offset(((*s).tPos >>\n                                                       1 as std::os::raw::c_int) as\n                                                      isize) as UInt32 >>\n                                     ((*s).tPos << 2 as std::os::raw::c_int &\n                                          0x4 as std::os::raw::c_int as std::os::raw::c_uint)\n                                     & 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                                    16 as std::os::raw::c_int;\n                        if (*s).rNToGo == 0 as std::os::raw::c_int {\n                            (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                            (*s).rTPos += 1;\n                            if (*s).rTPos == 512 as std::os::raw::c_int {\n                                (*s).rTPos = 0 as std::os::raw::c_int\n                            }\n                        }\n                        (*s).rNToGo -= 1;\n                        (*s).k0 ^=\n                            if (*s).rNToGo == 1 as std::os::raw::c_int {\n                                1 as std::os::raw::c_int\n                            } else { 0 as std::os::raw::c_int };\n                        (*s).nblock_used += 1\n                    }\n                }\n            }\n        }\n    } else {\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /* try to finish existing run */\n            while 1 as std::os::raw::c_int as Bool != 0 {\n                if (*(*s).strm).avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint\n                   {\n                    return 0 as std::os::raw::c_int as Bool\n                }\n                if (*s).state_out_len == 0 as std::os::raw::c_int { break ; }\n                *((*(*s).strm).next_out as *mut UChar) = (*s).state_out_ch;\n                (*s).calculatedBlockCRC =\n                    (*s).calculatedBlockCRC << 8 as std::os::raw::c_int ^\n                        BZ2_crc32Table[((*s).calculatedBlockCRC >>\n                                            24 as std::os::raw::c_int ^\n                                            (*s).state_out_ch as std::os::raw::c_uint)\n                                           as usize];\n                (*s).state_out_len -= 1;\n                (*(*s).strm).next_out = (*(*s).strm).next_out.offset(1);\n                (*(*s).strm).avail_out =\n                    (*(*s).strm).avail_out.wrapping_sub(1);\n                (*(*s).strm).total_out_lo32 =\n                    (*(*s).strm).total_out_lo32.wrapping_add(1);\n                if (*(*s).strm).total_out_lo32 ==\n                       0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    (*(*s).strm).total_out_hi32 =\n                        (*(*s).strm).total_out_hi32.wrapping_add(1)\n                }\n            }\n            /* can a new run be started? */\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                return 0 as std::os::raw::c_int as Bool\n            }\n            /* Only caused by corrupt data stream? */\n            if (*s).nblock_used > (*s).save_nblock + 1 as std::os::raw::c_int {\n                return 1 as std::os::raw::c_int as Bool\n            }\n            (*s).state_out_len = 1 as std::os::raw::c_int;\n            (*s).state_out_ch = (*s).k0 as UChar;\n            if (*s).tPos >=\n                   (100000 as std::os::raw::c_int as\n                        UInt32).wrapping_mul((*s).blockSize100k as UInt32) {\n                return 1 as std::os::raw::c_int as Bool\n            }\n            k1 =\n                BZ2_indexIntoF((*s).tPos as Int32, (*s).cftab.as_mut_ptr()) as\n                    UChar;\n            (*s).tPos =\n                *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                    (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int) as\n                                          isize) as UInt32 >>\n                         ((*s).tPos << 2 as std::os::raw::c_int &\n                              0x4 as std::os::raw::c_int as std::os::raw::c_uint) &\n                         0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                        16 as std::os::raw::c_int;\n            (*s).nblock_used += 1;\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                continue ;\n            }\n            if k1 as std::os::raw::c_int != (*s).k0 {\n                (*s).k0 = k1 as Int32\n            } else {\n                (*s).state_out_len = 2 as std::os::raw::c_int;\n                if (*s).tPos >=\n                       (100000 as std::os::raw::c_int as\n                            UInt32).wrapping_mul((*s).blockSize100k as UInt32)\n                   {\n                    return 1 as std::os::raw::c_int as Bool\n                }\n                k1 =\n                    BZ2_indexIntoF((*s).tPos as Int32,\n                                   (*s).cftab.as_mut_ptr()) as UChar;\n                (*s).tPos =\n                    *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                        (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int) as\n                                              isize) as UInt32 >>\n                             ((*s).tPos << 2 as std::os::raw::c_int &\n                                  0x4 as std::os::raw::c_int as std::os::raw::c_uint) &\n                             0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                            16 as std::os::raw::c_int;\n                (*s).nblock_used += 1;\n                if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                    continue ;\n                }\n                if k1 as std::os::raw::c_int != (*s).k0 {\n                    (*s).k0 = k1 as Int32\n                } else {\n                    (*s).state_out_len = 3 as std::os::raw::c_int;\n                    if (*s).tPos >=\n                           (100000 as std::os::raw::c_int as\n                                UInt32).wrapping_mul((*s).blockSize100k as\n                                                         UInt32) {\n                        return 1 as std::os::raw::c_int as Bool\n                    }\n                    k1 =\n                        BZ2_indexIntoF((*s).tPos as Int32,\n                                       (*s).cftab.as_mut_ptr()) as UChar;\n                    (*s).tPos =\n                        *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                            (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int)\n                                                  as isize) as UInt32 >>\n                                 ((*s).tPos << 2 as std::os::raw::c_int &\n                                      0x4 as std::os::raw::c_int as std::os::raw::c_uint) &\n                                 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                                16 as std::os::raw::c_int;\n                    (*s).nblock_used += 1;\n                    if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int\n                       {\n                        continue ;\n                    }\n                    if k1 as std::os::raw::c_int != (*s).k0 {\n                        (*s).k0 = k1 as Int32\n                    } else {\n                        if (*s).tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul((*s).blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        k1 =\n                            BZ2_indexIntoF((*s).tPos as Int32,\n                                           (*s).cftab.as_mut_ptr()) as UChar;\n                        (*s).tPos =\n                            *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                                (*(*s).ll4.offset(((*s).tPos >>\n                                                       1 as std::os::raw::c_int) as\n                                                      isize) as UInt32 >>\n                                     ((*s).tPos << 2 as std::os::raw::c_int &\n                                          0x4 as std::os::raw::c_int as std::os::raw::c_uint)\n                                     & 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                                    16 as std::os::raw::c_int;\n                        (*s).nblock_used += 1;\n                        (*s).state_out_len = k1 as Int32 + 4 as std::os::raw::c_int;\n                        if (*s).tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul((*s).blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        (*s).k0 =\n                            BZ2_indexIntoF((*s).tPos as Int32,\n                                           (*s).cftab.as_mut_ptr());\n                        (*s).tPos =\n                            *(*s).ll16.offset((*s).tPos as isize) as UInt32 |\n                                (*(*s).ll4.offset(((*s).tPos >>\n                                                       1 as std::os::raw::c_int) as\n                                                      isize) as UInt32 >>\n                                     ((*s).tPos << 2 as std::os::raw::c_int &\n                                          0x4 as std::os::raw::c_int as std::os::raw::c_uint)\n                                     & 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<\n                                    16 as std::os::raw::c_int;\n                        (*s).nblock_used += 1\n                    }\n                }\n            }\n        }\n    }\n    panic!(\"Reached end of non-void function without returning\");\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:438 ~ c2rust_out[3c70]::bzlib::BZ2_bzWrite)",
    "span": "bzlib.rs:1737:1: 1799:2 (#0)",
    "pieces": [
      "bzlib.rs:1737:1: 1799:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 63,
    "source": "pub unsafe extern \"C\" fn BZ2_bzWrite(mut bzerror: *mut std::os::raw::c_int,\n                                     mut b: *mut std::os::raw::c_void,\n                                     mut buf: *mut std::os::raw::c_void,\n                                     mut len: std::os::raw::c_int) {\n    let mut n: Int32 = 0;\n    let mut n2: Int32 = 0;\n    let mut ret: Int32 = 0;\n    let mut bzf: *mut bzFile = b as *mut bzFile;\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    if bzf.is_null() || buf.is_null() || len < 0 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = -(2 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(2 as std::os::raw::c_int) }\n        return\n    }\n    if (*bzf).writing == 0 {\n        if !bzerror.is_null() { *bzerror = -(1 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(1 as std::os::raw::c_int) }\n        return\n    }\n    if ferror((*bzf).handle) != 0 {\n        if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n        return\n    }\n    if len == 0 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n        if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n        return\n    }\n    (*bzf).strm.avail_in = len as std::os::raw::c_uint;\n    (*bzf).strm.next_in = buf as *mut std::os::raw::c_char;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        (*bzf).strm.avail_out = 5000 as std::os::raw::c_int as std::os::raw::c_uint;\n        (*bzf).strm.next_out = (*bzf).buf.as_mut_ptr();\n        ret = BZ2_bzCompress(&mut (*bzf).strm, 0 as std::os::raw::c_int);\n        if ret != 1 as std::os::raw::c_int {\n            if !bzerror.is_null() { *bzerror = ret }\n            if !bzf.is_null() { (*bzf).lastErr = ret }\n            return\n        }\n        if (*bzf).strm.avail_out < 5000 as std::os::raw::c_int as std::os::raw::c_uint {\n            n =\n                (5000 as std::os::raw::c_int as\n                     std::os::raw::c_uint).wrapping_sub((*bzf).strm.avail_out) as\n                    Int32;\n            n2 =\n                fwrite((*bzf).buf.as_mut_ptr() as *mut std::os::raw::c_void,\n                       ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong,\n                       n as std::os::raw::c_ulong, (*bzf).handle) as Int32;\n            if n != n2 || ferror((*bzf).handle) != 0 {\n                if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n                if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n                return\n            }\n        }\n        if (*bzf).strm.avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n            if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n            return\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:503:25: 505:44 (#0)",
        "source": "BZ2_bzWrite(&mut bzerr, bzf,\n                                    ibuf.as_mut_ptr() as *mut std::os::raw::c_void,\n                                    nIbuf);"
      },
      {
        "caller": "DefId(0:457 ~ c2rust_out[3c70]::bzlib::BZ2_bzwrite)",
        "span": "bzlib.rs:2346:5: 2346:42 (#0)",
        "source": "BZ2_bzWrite(&mut bzerr, b, buf, len);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:458 ~ c2rust_out[3c70]::bzlib::BZ2_bzflush)",
    "span": "bzlib.rs:2353:1: 2357:2 (#0)",
    "pieces": [
      "bzlib.rs:2353:1: 2357:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub extern \"C\" fn BZ2_bzflush(mut b: *mut std::os::raw::c_void)\n -> std::os::raw::c_int {\n    /* do nothing now... */\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:432 ~ c2rust_out[3c70]::bzlib::BZ2_indexIntoF)",
    "span": "bzlib.rs:1183:1: 1196:2 (#0)",
    "pieces": [
      "bzlib.rs:1183:1: 1196:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn BZ2_indexIntoF(mut indx: Int32,\n                                        mut cftab: *mut Int32) -> Int32 {\n    let mut nb: Int32 = 0;\n    let mut na: Int32 = 0;\n    let mut mid: Int32 = 0;\n    nb = 0 as std::os::raw::c_int;\n    na = 256 as std::os::raw::c_int;\n    loop  {\n        mid = nb + na >> 1 as std::os::raw::c_int;\n        if indx >= *cftab.offset(mid as isize) { nb = mid } else { na = mid }\n        if !(na - nb != 1 as std::os::raw::c_int) { break ; }\n    }\n    return nb;\n}",
    "calls": [
      {
        "caller": "DefId(0:550 ~ c2rust_out[3c70]::decompress::BZ2_decompress)",
        "span": "decompress.rs:2842:41: 2844:85 (#0)",
        "source": "(*s).k0 =\n                                            BZ2_indexIntoF((*s).tPos as Int32,\n                                                           (*s).cftab.as_mut_ptr());"
      },
      {
        "caller": "DefId(0:550 ~ c2rust_out[3c70]::decompress::BZ2_decompress)",
        "span": "decompress.rs:2891:41: 2893:85 (#0)",
        "source": "(*s).k0 =\n                                            BZ2_indexIntoF((*s).tPos as Int32,\n                                                           (*s).cftab.as_mut_ptr());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:550 ~ c2rust_out[3c70]::decompress::BZ2_decompress)",
    "span": "decompress.rs:77:1: 3365:2 (#0)",
    "pieces": [
      "decompress.rs:77:1: 3365:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3289,
    "source": "pub unsafe extern \"C\" fn BZ2_decompress(mut s: *mut DState) -> Int32 {\n    let mut current_block: u64;\n    let mut uc: UChar = 0;\n    let mut retVal: Int32 = 0;\n    let mut minLen: Int32 = 0;\n    let mut maxLen: Int32 = 0;\n    let mut strm: *mut bz_stream = (*s).strm;\n    /* stuff that needs to be saved/restored */\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut t: Int32 = 0;\n    let mut alphaSize: Int32 = 0;\n    let mut nGroups: Int32 = 0;\n    let mut nSelectors: Int32 = 0;\n    let mut EOB: Int32 = 0;\n    let mut groupNo: Int32 = 0;\n    let mut groupPos: Int32 = 0;\n    let mut nextSym: Int32 = 0;\n    let mut nblockMAX: Int32 = 0;\n    let mut nblock: Int32 = 0;\n    let mut es: Int32 = 0;\n    let mut N: Int32 = 0;\n    let mut curr: Int32 = 0;\n    let mut zt: Int32 = 0;\n    let mut zn: Int32 = 0;\n    let mut zvec: Int32 = 0;\n    let mut zj: Int32 = 0;\n    let mut gSel: Int32 = 0;\n    let mut gMinlen: Int32 = 0;\n    let mut gLimit: *mut Int32 = 0 as *mut Int32;\n    let mut gBase: *mut Int32 = 0 as *mut Int32;\n    let mut gPerm: *mut Int32 = 0 as *mut Int32;\n    if (*s).state == 10 as std::os::raw::c_int {\n        /*initialise the save area*/\n        (*s).save_i = 0 as std::os::raw::c_int;\n        (*s).save_j = 0 as std::os::raw::c_int;\n        (*s).save_t = 0 as std::os::raw::c_int;\n        (*s).save_alphaSize = 0 as std::os::raw::c_int;\n        (*s).save_nGroups = 0 as std::os::raw::c_int;\n        (*s).save_nSelectors = 0 as std::os::raw::c_int;\n        (*s).save_EOB = 0 as std::os::raw::c_int;\n        (*s).save_groupNo = 0 as std::os::raw::c_int;\n        (*s).save_groupPos = 0 as std::os::raw::c_int;\n        (*s).save_nextSym = 0 as std::os::raw::c_int;\n        (*s).save_nblockMAX = 0 as std::os::raw::c_int;\n        (*s).save_nblock = 0 as std::os::raw::c_int;\n        (*s).save_es = 0 as std::os::raw::c_int;\n        (*s).save_N = 0 as std::os::raw::c_int;\n        (*s).save_curr = 0 as std::os::raw::c_int;\n        (*s).save_zt = 0 as std::os::raw::c_int;\n        (*s).save_zn = 0 as std::os::raw::c_int;\n        (*s).save_zvec = 0 as std::os::raw::c_int;\n        (*s).save_zj = 0 as std::os::raw::c_int;\n        (*s).save_gSel = 0 as std::os::raw::c_int;\n        (*s).save_gMinlen = 0 as std::os::raw::c_int;\n        (*s).save_gLimit = 0 as *mut Int32;\n        (*s).save_gBase = 0 as *mut Int32;\n        (*s).save_gPerm = 0 as *mut Int32\n    }\n    /*restore from the save area*/\n    i = (*s).save_i;\n    j = (*s).save_j;\n    t = (*s).save_t;\n    alphaSize = (*s).save_alphaSize;\n    nGroups = (*s).save_nGroups;\n    nSelectors = (*s).save_nSelectors;\n    EOB = (*s).save_EOB;\n    groupNo = (*s).save_groupNo;\n    groupPos = (*s).save_groupPos;\n    nextSym = (*s).save_nextSym;\n    nblockMAX = (*s).save_nblockMAX;\n    nblock = (*s).save_nblock;\n    es = (*s).save_es;\n    N = (*s).save_N;\n    curr = (*s).save_curr;\n    zt = (*s).save_zt;\n    zn = (*s).save_zn;\n    zvec = (*s).save_zvec;\n    zj = (*s).save_zj;\n    gSel = (*s).save_gSel;\n    gMinlen = (*s).save_gMinlen;\n    gLimit = (*s).save_gLimit;\n    gBase = (*s).save_gBase;\n    gPerm = (*s).save_gPerm;\n    retVal = 0 as std::os::raw::c_int;\n    match (*s).state {\n        10 => {\n            (*s).state = 10 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 5658374378798827547;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v: UInt32 = 0;\n                    v =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v as UChar;\n                    current_block = 5658374378798827547;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x42 as std::os::raw::c_int {\n                        retVal = -(5 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 12259750428863723923; }\n                }\n            }\n        }\n        11 => { current_block = 12259750428863723923; }\n        12 => { current_block = 15146946972525368609; }\n        13 => { current_block = 13504760517129887221; }\n        14 => { current_block = 7948568793456312728; }\n        15 => { current_block = 16703841960874917807; }\n        16 => { current_block = 12231332282017165356; }\n        17 => { current_block = 7286555771988341860; }\n        18 => { current_block = 6656868271313165664; }\n        19 => { current_block = 15902903523132075486; }\n        20 => { current_block = 16204949703499709801; }\n        21 => { current_block = 5505795673017046993; }\n        22 => { current_block = 14563596112884461881; }\n        23 => { current_block = 12051594319698232578; }\n        24 => { current_block = 14315698657705028467; }\n        25 => { current_block = 640681092829779800; }\n        26 => { current_block = 588075840077989673; }\n        27 => { current_block = 34749046854646975; }\n        28 => { current_block = 16487873541482693172; }\n        29 => { current_block = 1422779171932145779; }\n        30 => { current_block = 3906616468301123675; }\n        31 => { current_block = 5769007513321684282; }\n        32 => { current_block = 4874723077730206021; }\n        33 => { current_block = 10945178116989557996; }\n        34 => { current_block = 1736021991379636935; }\n        35 => { current_block = 5008197131544113214; }\n        36 => { current_block = 16722720626876144162; }\n        37 => { current_block = 14744029255125744966; }\n        38 => { current_block = 5374617794059532979; }\n        39 => { current_block = 13999925517074022731; }\n        40 => { current_block = 2629672494974161066; }\n        41 => { current_block = 1050378859040334210; }\n        42 => { current_block = 10200488719709598753; }\n        43 => { current_block = 9864403379770423142; }\n        44 => { current_block = 8489059574810375089; }\n        45 => { current_block = 12998570369541158573; }\n        46 => { current_block = 10541196509243133637; }\n        47 => { current_block = 8760950161942609538; }\n        48 => { current_block = 3131443096645543054; }\n        49 => { current_block = 1975408140333322065; }\n        50 => { current_block = 15818179691129344165; }\n        _ => {\n            if 0 as std::os::raw::c_int as Bool == 0 {\n                BZ2_bz__AssertH__fail(4001 as std::os::raw::c_int);\n            }\n            if 0 as std::os::raw::c_int as Bool == 0 {\n                BZ2_bz__AssertH__fail(4002 as std::os::raw::c_int);\n            }\n            current_block = 15885526978618306830;\n        }\n    }\n    match current_block {\n        12259750428863723923 => {\n            (*s).state = 11 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 1658462350791934405;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_0: UInt32 = 0;\n                    v_0 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_0 as UChar;\n                    current_block = 1658462350791934405;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x5a as std::os::raw::c_int {\n                        retVal = -(5 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 15146946972525368609; }\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        15146946972525368609 => {\n            (*s).state = 12 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 16314074004867283505;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_1: UInt32 = 0;\n                    v_1 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_1 as UChar;\n                    current_block = 16314074004867283505;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x68 as std::os::raw::c_int {\n                        retVal = -(5 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 13504760517129887221; }\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        13504760517129887221 => {\n            (*s).state = 13 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 1915186496383530739;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_2: UInt32 = 0;\n                    v_2 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    (*s).blockSize100k = v_2 as Int32;\n                    current_block = 1915186496383530739;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if (*s).blockSize100k <\n                           0x30 as std::os::raw::c_int + 1 as std::os::raw::c_int ||\n                           (*s).blockSize100k >\n                               0x30 as std::os::raw::c_int + 9 as std::os::raw::c_int {\n                        retVal = -(5 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else {\n                        (*s).blockSize100k -= 0x30 as std::os::raw::c_int;\n                        if (*s).smallDecompress != 0 {\n                            (*s).ll16 =\n                                (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                                                    (((*s).blockSize100k\n                                                                                          *\n                                                                                          100000\n                                                                                              as\n                                                                                              std::os::raw::c_int)\n                                                                                         as\n                                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UInt16>()\n                                                                                                                         as\n                                                                                                                         std::os::raw::c_ulong)\n                                                                                        as\n                                                                                        std::os::raw::c_int,\n                                                                                    1\n                                                                                        as\n                                                                                        std::os::raw::c_int)\n                                    as *mut UInt16;\n                            (*s).ll4 =\n                                (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                                                    ((1\n                                                                                          as\n                                                                                          std::os::raw::c_int\n                                                                                          +\n                                                                                          (*s).blockSize100k\n                                                                                              *\n                                                                                              100000\n                                                                                                  as\n                                                                                                  std::os::raw::c_int\n                                                                                          >>\n                                                                                          1\n                                                                                              as\n                                                                                              std::os::raw::c_int)\n                                                                                         as\n                                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UChar>()\n                                                                                                                         as\n                                                                                                                         std::os::raw::c_ulong)\n                                                                                        as\n                                                                                        std::os::raw::c_int,\n                                                                                    1\n                                                                                        as\n                                                                                        std::os::raw::c_int)\n                                    as *mut UChar;\n                            if (*s).ll16.is_null() || (*s).ll4.is_null() {\n                                retVal = -(3 as std::os::raw::c_int);\n                                current_block = 15885526978618306830;\n                            } else { current_block = 7948568793456312728; }\n                        } else {\n                            (*s).tt =\n                                (*strm).bzalloc.expect(\"non-null function pointer\")((*strm).opaque,\n                                                                                    (((*s).blockSize100k\n                                                                                          *\n                                                                                          100000\n                                                                                              as\n                                                                                              std::os::raw::c_int)\n                                                                                         as\n                                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<Int32>()\n                                                                                                                         as\n                                                                                                                         std::os::raw::c_ulong)\n                                                                                        as\n                                                                                        std::os::raw::c_int,\n                                                                                    1\n                                                                                        as\n                                                                                        std::os::raw::c_int)\n                                    as *mut UInt32;\n                            if (*s).tt.is_null() {\n                                retVal = -(3 as std::os::raw::c_int);\n                                current_block = 15885526978618306830;\n                            } else { current_block = 7948568793456312728; }\n                        }\n                    }\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        7948568793456312728 => {\n            (*s).state = 14 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 9846950269610550213;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_3: UInt32 = 0;\n                    v_3 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_3 as UChar;\n                    current_block = 9846950269610550213;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int == 0x17 as std::os::raw::c_int {\n                        current_block = 10200488719709598753;\n                    } else if uc as std::os::raw::c_int != 0x31 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 16703841960874917807; }\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        10200488719709598753 => {\n            (*s).state = 42 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 13262463590990658200;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_32: UInt32 = 0;\n                    v_32 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_32 as UChar;\n                    current_block = 13262463590990658200;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x72 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 9864403379770423142; }\n                }\n            }\n        }\n        16703841960874917807 => {\n            (*s).state = 15 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 3569141194949357899;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_4: UInt32 = 0;\n                    v_4 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_4 as UChar;\n                    current_block = 3569141194949357899;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x41 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 12231332282017165356; }\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        9864403379770423142 => {\n            (*s).state = 43 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 10756506701594629759;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_33: UInt32 = 0;\n                    v_33 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_33 as UChar;\n                    current_block = 10756506701594629759;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x45 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 8489059574810375089; }\n                }\n            }\n        }\n        12231332282017165356 => {\n            (*s).state = 16 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 16517180880614114163;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_5: UInt32 = 0;\n                    v_5 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_5 as UChar;\n                    current_block = 16517180880614114163;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x59 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 7286555771988341860; }\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        8489059574810375089 => {\n            (*s).state = 44 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 9819403752380335018;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_34: UInt32 = 0;\n                    v_34 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_34 as UChar;\n                    current_block = 9819403752380335018;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x38 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 12998570369541158573; }\n                }\n            }\n        }\n        7286555771988341860 => {\n            (*s).state = 17 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 2606663910910355487;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_6: UInt32 = 0;\n                    v_6 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_6 as UChar;\n                    current_block = 2606663910910355487;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x26 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 6656868271313165664; }\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        12998570369541158573 => {\n            (*s).state = 45 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 9454797012561717444;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_35: UInt32 = 0;\n                    v_35 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_35 as UChar;\n                    current_block = 9454797012561717444;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x50 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 10541196509243133637; }\n                }\n            }\n        }\n        6656868271313165664 => {\n            (*s).state = 18 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 8125779086361653720;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_7: UInt32 = 0;\n                    v_7 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_7 as UChar;\n                    current_block = 8125779086361653720;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x53 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else { current_block = 15902903523132075486; }\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        10541196509243133637 => {\n            (*s).state = 46 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 724777313732190959;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_36: UInt32 = 0;\n                    v_36 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_36 as UChar;\n                    current_block = 724777313732190959;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x90 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else {\n                        (*s).storedCombinedCRC = 0 as std::os::raw::c_int as UInt32;\n                        current_block = 8760950161942609538;\n                    }\n                }\n            }\n        }\n        15902903523132075486 => {\n            (*s).state = 19 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 958128786106592581;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_8: UInt32 = 0;\n                    v_8 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_8 as UChar;\n                    current_block = 958128786106592581;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    if uc as std::os::raw::c_int != 0x59 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else {\n                        (*s).currBlockNo += 1;\n                        if (*s).verbosity >= 2 as std::os::raw::c_int {\n                            fprintf(__stderrp,\n                                    b\"\\n    [%d: huff+mtf \\x00\" as *const u8\n                                        as *const std::os::raw::c_char,\n                                    (*s).currBlockNo);\n                        }\n                        (*s).storedBlockCRC = 0 as std::os::raw::c_int as UInt32;\n                        current_block = 16204949703499709801;\n                    }\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        8760950161942609538 => {\n            (*s).state = 47 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 14486187473704332379;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_37: UInt32 = 0;\n                    v_37 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_37 as UChar;\n                    current_block = 14486187473704332379;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedCombinedCRC =\n                        (*s).storedCombinedCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 3131443096645543054;\n                }\n            }\n        }\n        16204949703499709801 => {\n            (*s).state = 20 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 3790734079518302164;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_9: UInt32 = 0;\n                    v_9 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_9 as UChar;\n                    current_block = 3790734079518302164;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedBlockCRC =\n                        (*s).storedBlockCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 5505795673017046993;\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        3131443096645543054 => {\n            (*s).state = 48 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 3659807904093622879;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_38: UInt32 = 0;\n                    v_38 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_38 as UChar;\n                    current_block = 3659807904093622879;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedCombinedCRC =\n                        (*s).storedCombinedCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 1975408140333322065;\n                }\n            }\n        }\n        5505795673017046993 => {\n            (*s).state = 21 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 16711521214030637000;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_10: UInt32 = 0;\n                    v_10 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_10 as UChar;\n                    current_block = 16711521214030637000;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedBlockCRC =\n                        (*s).storedBlockCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 14563596112884461881;\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        1975408140333322065 => {\n            (*s).state = 49 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 2394045633138979148;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_39: UInt32 = 0;\n                    v_39 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_39 as UChar;\n                    current_block = 2394045633138979148;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedCombinedCRC =\n                        (*s).storedCombinedCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 15818179691129344165;\n                }\n            }\n        }\n        14563596112884461881 => {\n            (*s).state = 22 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 17870985093275900527;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_11: UInt32 = 0;\n                    v_11 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_11 as UChar;\n                    current_block = 17870985093275900527;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedBlockCRC =\n                        (*s).storedBlockCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 12051594319698232578;\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        12051594319698232578 => {\n            (*s).state = 23 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 13734492969709581318;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_12: UInt32 = 0;\n                    v_12 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_12 as UChar;\n                    current_block = 13734492969709581318;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedBlockCRC =\n                        (*s).storedBlockCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    current_block = 14315698657705028467;\n                }\n            }\n        }\n        15818179691129344165 => {\n            (*s).state = 50 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 1904329045571868869;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_40: UInt32 = 0;\n                    v_40 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_40 as UChar;\n                    current_block = 1904329045571868869;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).storedCombinedCRC =\n                        (*s).storedCombinedCRC << 8 as std::os::raw::c_int |\n                            uc as UInt32;\n                    (*s).state = 1 as std::os::raw::c_int;\n                    retVal = 4 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        14315698657705028467 => {\n            (*s).state = 24 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 15030729790988239748;\n                    break ;\n                }\n                if (*s).bsLive >= 1 as std::os::raw::c_int {\n                    let mut v_13: UInt32 = 0;\n                    v_13 =\n                        (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 1 as std::os::raw::c_int;\n                    (*s).blockRandomised = v_13 as Bool;\n                    current_block = 15030729790988239748;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).origPtr = 0 as std::os::raw::c_int;\n                    current_block = 640681092829779800;\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        640681092829779800 => {\n            (*s).state = 25 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 8260322496947496197;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_14: UInt32 = 0;\n                    v_14 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_14 as UChar;\n                    current_block = 8260322496947496197;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).origPtr =\n                        (*s).origPtr << 8 as std::os::raw::c_int | uc as Int32;\n                    current_block = 588075840077989673;\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        588075840077989673 => {\n            (*s).state = 26 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 5561851013817067674;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_15: UInt32 = 0;\n                    v_15 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_15 as UChar;\n                    current_block = 5561851013817067674;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).origPtr =\n                        (*s).origPtr << 8 as std::os::raw::c_int | uc as Int32;\n                    current_block = 34749046854646975;\n                }\n            }\n        }\n        _ => { }\n    }\n    match current_block {\n        34749046854646975 => {\n            (*s).state = 27 as std::os::raw::c_int;\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 10471999855724930313;\n                    break ;\n                }\n                if (*s).bsLive >= 8 as std::os::raw::c_int {\n                    let mut v_16: UInt32 = 0;\n                    v_16 =\n                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &\n                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -\n                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                    (*s).bsLive -= 8 as std::os::raw::c_int;\n                    uc = v_16 as UChar;\n                    current_block = 10471999855724930313;\n                    break ;\n                } else if (*(*s).strm).avail_in ==\n                              0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    retVal = 0 as std::os::raw::c_int;\n                    current_block = 15885526978618306830;\n                    break ;\n                } else {\n                    (*s).bsBuff =\n                        (*s).bsBuff << 8 as std::os::raw::c_int |\n                            *((*(*s).strm).next_in as *mut UChar) as UInt32;\n                    (*s).bsLive += 8 as std::os::raw::c_int;\n                    (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n                    (*(*s).strm).avail_in =\n                        (*(*s).strm).avail_in.wrapping_sub(1);\n                    (*(*s).strm).total_in_lo32 =\n                        (*(*s).strm).total_in_lo32.wrapping_add(1);\n                    if (*(*s).strm).total_in_lo32 ==\n                           0 as std::os::raw::c_int as std::os::raw::c_uint {\n                        (*(*s).strm).total_in_hi32 =\n                            (*(*s).strm).total_in_hi32.wrapping_add(1)\n                    }\n                }\n            }\n            match current_block {\n                15885526978618306830 => { }\n                _ => {\n                    (*s).origPtr =\n                        (*s).origPtr << 8 as std::os::raw::c_int | uc as Int32;\n                    if (*s).origPtr < 0 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else if (*s).origPtr >\n                                  10 as std::os::raw::c_int +\n                                      100000 as std::os::raw::c_int *\n                                          (*s).blockSize100k {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                    } else {\n                        /*--- Receive the mapping table ---*/\n                        i = 0 as std::os::raw::c_int;\n                        current_block = 17262312153619709241;\n                    }\n                }\n            }\n        }\n        _ => { }\n    }\n    'c_10532:\n        loop  {\n            match current_block {\n                15885526978618306830 => { (*s).save_i = i; break ; }\n                2629672494974161066 => {\n                    (*s).state = 40 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= zn {\n                            let mut v_30: UInt32 = 0;\n                            v_30 =\n                                (*s).bsBuff >> (*s).bsLive - zn &\n                                    (((1 as std::os::raw::c_int) << zn) -\n                                         1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= zn;\n                            zvec = v_30 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    current_block = 9078889872071895942;\n                }\n                13999925517074022731 => {\n                    (*s).state = 39 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_29: UInt32 = 0;\n                            v_29 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            zj = v_29 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    zvec = zvec << 1 as std::os::raw::c_int | zj;\n                    current_block = 13605767259572914371;\n                }\n                5374617794059532979 => {\n                    (*s).state = 38 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= zn {\n                            let mut v_28: UInt32 = 0;\n                            v_28 =\n                                (*s).bsBuff >> (*s).bsLive - zn &\n                                    (((1 as std::os::raw::c_int) << zn) -\n                                         1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= zn;\n                            zvec = v_28 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    current_block = 13605767259572914371;\n                }\n                14744029255125744966 => {\n                    (*s).state = 37 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_27: UInt32 = 0;\n                            v_27 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            zj = v_27 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    zvec = zvec << 1 as std::os::raw::c_int | zj;\n                    current_block = 1550405138573481750;\n                }\n                16722720626876144162 => {\n                    (*s).state = 36 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= zn {\n                            let mut v_26: UInt32 = 0;\n                            v_26 =\n                                (*s).bsBuff >> (*s).bsLive - zn &\n                                    (((1 as std::os::raw::c_int) << zn) -\n                                         1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= zn;\n                            zvec = v_26 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    current_block = 1550405138573481750;\n                }\n                5008197131544113214 => {\n                    (*s).state = 35 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_25: UInt32 = 0;\n                            v_25 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            uc = v_25 as UChar;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if uc as std::os::raw::c_int == 0 as std::os::raw::c_int {\n                        curr += 1\n                    } else { curr -= 1 }\n                    current_block = 11858046780433112516;\n                }\n                1736021991379636935 => {\n                    (*s).state = 34 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_24: UInt32 = 0;\n                            v_24 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            uc = v_24 as UChar;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if !(uc as std::os::raw::c_int == 0 as std::os::raw::c_int) {\n                        current_block = 5008197131544113214;\n                        continue ;\n                    }\n                    current_block = 17503523010989424999;\n                }\n                10945178116989557996 => {\n                    (*s).state = 33 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 5 as std::os::raw::c_int {\n                            let mut v_23: UInt32 = 0;\n                            v_23 =\n                                (*s).bsBuff >> (*s).bsLive - 5 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 5 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 5 as std::os::raw::c_int;\n                            curr = v_23 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    i = 0 as std::os::raw::c_int;\n                    current_block = 3770765986603902964;\n                }\n                4874723077730206021 => {\n                    (*s).state = 32 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_21: UInt32 = 0;\n                            v_21 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            uc = v_21 as UChar;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if uc as std::os::raw::c_int == 0 as std::os::raw::c_int {\n                        current_block = 5281038271658253520;\n                    } else {\n                        j += 1;\n                        if j >= nGroups {\n                            retVal = -(4 as std::os::raw::c_int);\n                            current_block = 15885526978618306830;\n                            continue ;\n                        } else { current_block = 6927328446518169316; }\n                    }\n                }\n                5769007513321684282 => {\n                    (*s).state = 31 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 15 as std::os::raw::c_int {\n                            let mut v_20: UInt32 = 0;\n                            v_20 =\n                                (*s).bsBuff >> (*s).bsLive - 15 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 15 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 15 as std::os::raw::c_int;\n                            nSelectors = v_20 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if nSelectors < 1 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                        continue ;\n                    } else { i = 0 as std::os::raw::c_int }\n                    current_block = 6591141407893725683;\n                }\n                3906616468301123675 =>\n                /*--- Now the selectors ---*/\n                {\n                    (*s).state = 30 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 3 as std::os::raw::c_int {\n                            let mut v_19: UInt32 = 0;\n                            v_19 =\n                                (*s).bsBuff >> (*s).bsLive - 3 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 3 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 3 as std::os::raw::c_int;\n                            nGroups = v_19 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if !(nGroups < 2 as std::os::raw::c_int ||\n                             nGroups > 6 as std::os::raw::c_int) {\n                        current_block = 5769007513321684282;\n                        continue ;\n                    }\n                    retVal = -(4 as std::os::raw::c_int);\n                    current_block = 15885526978618306830;\n                    continue ;\n                }\n                1422779171932145779 => {\n                    (*s).state = 29 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_18: UInt32 = 0;\n                            v_18 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            uc = v_18 as UChar;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if uc as std::os::raw::c_int == 1 as std::os::raw::c_int {\n                        (*s).inUse[(i * 16 as std::os::raw::c_int + j) as usize] =\n                            1 as std::os::raw::c_int as Bool\n                    }\n                    j += 1;\n                    current_block = 3854024847017804838;\n                }\n                17262312153619709241 => {\n                    if i < 16 as std::os::raw::c_int {\n                        current_block = 16487873541482693172;\n                        continue ;\n                    }\n                    i = 0 as std::os::raw::c_int;\n                    while i < 256 as std::os::raw::c_int {\n                        (*s).inUse[i as usize] = 0 as std::os::raw::c_int as Bool;\n                        i += 1\n                    }\n                    i = 0 as std::os::raw::c_int;\n                    current_block = 3472349144349095221;\n                }\n                16487873541482693172 => {\n                    (*s).state = 28 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_17: UInt32 = 0;\n                            v_17 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            uc = v_17 as UChar;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    if uc as std::os::raw::c_int == 1 as std::os::raw::c_int {\n                        (*s).inUse16[i as usize] = 1 as std::os::raw::c_int as Bool\n                    } else {\n                        (*s).inUse16[i as usize] = 0 as std::os::raw::c_int as Bool\n                    }\n                    i += 1;\n                    current_block = 17262312153619709241;\n                    continue ;\n                }\n                _ => {\n                    (*s).state = 41 as std::os::raw::c_int;\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if (*s).bsLive >= 1 as std::os::raw::c_int {\n                            let mut v_31: UInt32 = 0;\n                            v_31 =\n                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int\n                                    &\n                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)\n                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n                            (*s).bsLive -= 1 as std::os::raw::c_int;\n                            zj = v_31 as Int32;\n                            break ;\n                        } else if (*(*s).strm).avail_in ==\n                                      0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            retVal = 0 as std::os::raw::c_int;\n                            current_block = 15885526978618306830;\n                            continue 'c_10532 ;\n                        } else {\n                            (*s).bsBuff =\n                                (*s).bsBuff << 8 as std::os::raw::c_int |\n                                    *((*(*s).strm).next_in as *mut UChar) as\n                                        UInt32;\n                            (*s).bsLive += 8 as std::os::raw::c_int;\n                            (*(*s).strm).next_in =\n                                (*(*s).strm).next_in.offset(1);\n                            (*(*s).strm).avail_in =\n                                (*(*s).strm).avail_in.wrapping_sub(1);\n                            (*(*s).strm).total_in_lo32 =\n                                (*(*s).strm).total_in_lo32.wrapping_add(1);\n                            if (*(*s).strm).total_in_lo32 ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                (*(*s).strm).total_in_hi32 =\n                                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n                            }\n                        }\n                    }\n                    zvec = zvec << 1 as std::os::raw::c_int | zj;\n                    current_block = 9078889872071895942;\n                }\n            }\n            match current_block {\n                9078889872071895942 => {\n                    if zn > 20 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                        continue ;\n                    } else if zvec <= *gLimit.offset(zn as isize) {\n                        if zvec - *gBase.offset(zn as isize) <\n                               0 as std::os::raw::c_int ||\n                               zvec - *gBase.offset(zn as isize) >=\n                                   258 as std::os::raw::c_int {\n                            retVal = -(4 as std::os::raw::c_int);\n                            current_block = 15885526978618306830;\n                            continue ;\n                        } else {\n                            nextSym =\n                                *gPerm.offset((zvec -\n                                                   *gBase.offset(zn as isize))\n                                                  as isize)\n                        }\n                    } else {\n                        zn += 1;\n                        current_block = 1050378859040334210;\n                        continue ;\n                    }\n                    current_block = 15093386068129942558;\n                }\n                13605767259572914371 => {\n                    if zn > 20 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                        continue ;\n                    } else if zvec <= *gLimit.offset(zn as isize) {\n                        if zvec - *gBase.offset(zn as isize) <\n                               0 as std::os::raw::c_int ||\n                               zvec - *gBase.offset(zn as isize) >=\n                                   258 as std::os::raw::c_int {\n                            retVal = -(4 as std::os::raw::c_int);\n                            current_block = 15885526978618306830;\n                            continue ;\n                        } else {\n                            nextSym =\n                                *gPerm.offset((zvec -\n                                                   *gBase.offset(zn as isize))\n                                                  as isize);\n                            if nextSym == 0 as std::os::raw::c_int ||\n                                   nextSym == 1 as std::os::raw::c_int {\n                                current_block = 4550729491376650574;\n                            } else {\n                                es += 1;\n                                uc =\n                                    (*s).seqToUnseq[(*s).mtfa[(*s).mtfbase[0\n                                                                               as\n                                                                               std::os::raw::c_int\n                                                                               as\n                                                                               usize]\n                                                                  as usize] as\n                                                        usize];\n                                (*s).unzftab[uc as usize] += es;\n                                if (*s).smallDecompress != 0 {\n                                    while es > 0 as std::os::raw::c_int {\n                                        if nblock >= nblockMAX {\n                                            retVal = -(4 as std::os::raw::c_int);\n                                            current_block =\n                                                15885526978618306830;\n                                            continue 'c_10532 ;\n                                        } else {\n                                            *(*s).ll16.offset(nblock as isize)\n                                                = uc as UInt16;\n                                            nblock += 1;\n                                            es -= 1\n                                        }\n                                    }\n                                } else {\n                                    while es > 0 as std::os::raw::c_int {\n                                        if nblock >= nblockMAX {\n                                            retVal = -(4 as std::os::raw::c_int);\n                                            current_block =\n                                                15885526978618306830;\n                                            continue 'c_10532 ;\n                                        } else {\n                                            *(*s).tt.offset(nblock as isize) =\n                                                uc as UInt32;\n                                            nblock += 1;\n                                            es -= 1\n                                        }\n                                    }\n                                }\n                                current_block = 15093386068129942558;\n                            }\n                        }\n                    } else {\n                        zn += 1;\n                        current_block = 13999925517074022731;\n                        continue ;\n                    }\n                }\n                1550405138573481750 => {\n                    if zn > 20 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                        continue ;\n                    } else if zvec <= *gLimit.offset(zn as isize) {\n                        if zvec - *gBase.offset(zn as isize) <\n                               0 as std::os::raw::c_int ||\n                               zvec - *gBase.offset(zn as isize) >=\n                                   258 as std::os::raw::c_int {\n                            retVal = -(4 as std::os::raw::c_int);\n                            current_block = 15885526978618306830;\n                            continue ;\n                        } else {\n                            nextSym =\n                                *gPerm.offset((zvec -\n                                                   *gBase.offset(zn as isize))\n                                                  as isize)\n                        }\n                    } else {\n                        zn += 1;\n                        current_block = 14744029255125744966;\n                        continue ;\n                    }\n                    current_block = 15093386068129942558;\n                }\n                _ => { }\n            }\n            match current_block {\n                15093386068129942558 => {\n                    if 1 as std::os::raw::c_int as Bool != 0 {\n                        if nextSym == EOB {\n                            current_block = 12118509005321596519;\n                        } else {\n                            if nextSym == 0 as std::os::raw::c_int ||\n                                   nextSym == 1 as std::os::raw::c_int {\n                                es = -(1 as std::os::raw::c_int);\n                                N = 1 as std::os::raw::c_int\n                            } else if nblock >= nblockMAX {\n                                retVal = -(4 as std::os::raw::c_int);\n                                current_block = 15885526978618306830;\n                                continue ;\n                            } else {\n                                /*-- uc = MTF ( nextSym-1 ) --*/\n                                let mut ii_0: Int32 = 0;\n                                let mut jj_0: Int32 = 0;\n                                let mut kk_0: Int32 = 0;\n                                let mut pp: Int32 = 0;\n                                let mut lno: Int32 = 0;\n                                let mut off: Int32 = 0;\n                                let mut nn: UInt32 = 0;\n                                nn = (nextSym - 1 as std::os::raw::c_int) as UInt32;\n                                if nn < 16 as std::os::raw::c_int as std::os::raw::c_uint {\n                                    /* avoid general-case expense */\n                                    pp =\n                                        (*s).mtfbase[0 as std::os::raw::c_int as\n                                                         usize];\n                                    uc =\n                                        (*s).mtfa[(pp as\n                                                       std::os::raw::c_uint).wrapping_add(nn)\n                                                      as usize];\n                                    while nn >\n                                              3 as std::os::raw::c_int as std::os::raw::c_uint\n                                          {\n                                        let mut z: Int32 =\n                                            (pp as\n                                                 std::os::raw::c_uint).wrapping_add(nn)\n                                                as Int32;\n                                        (*s).mtfa[z as usize] =\n                                            (*s).mtfa[(z - 1 as std::os::raw::c_int)\n                                                          as usize];\n                                        (*s).mtfa[(z - 1 as std::os::raw::c_int) as\n                                                      usize] =\n                                            (*s).mtfa[(z - 2 as std::os::raw::c_int)\n                                                          as usize];\n                                        (*s).mtfa[(z - 2 as std::os::raw::c_int) as\n                                                      usize] =\n                                            (*s).mtfa[(z - 3 as std::os::raw::c_int)\n                                                          as usize];\n                                        (*s).mtfa[(z - 3 as std::os::raw::c_int) as\n                                                      usize] =\n                                            (*s).mtfa[(z - 4 as std::os::raw::c_int)\n                                                          as usize];\n                                        nn =\n                                            (nn as\n                                                 std::os::raw::c_uint).wrapping_sub(4\n                                                                                as\n                                                                                std::os::raw::c_int\n                                                                                as\n                                                                                std::os::raw::c_uint)\n                                                as UInt32 as UInt32\n                                    }\n                                    while nn >\n                                              0 as std::os::raw::c_int as std::os::raw::c_uint\n                                          {\n                                        (*s).mtfa[(pp as\n                                                       std::os::raw::c_uint).wrapping_add(nn)\n                                                      as usize] =\n                                            (*s).mtfa[(pp as\n                                                           std::os::raw::c_uint).wrapping_add(nn).wrapping_sub(1\n                                                                                                           as\n                                                                                                           std::os::raw::c_int\n                                                                                                           as\n                                                                                                           std::os::raw::c_uint)\n                                                          as usize];\n                                        nn = nn.wrapping_sub(1)\n                                    }\n                                    (*s).mtfa[pp as usize] = uc\n                                } else {\n                                    /* general case */\n                                    lno =\n                                        nn.wrapping_div(16 as std::os::raw::c_int as\n                                                            std::os::raw::c_uint) as\n                                            Int32;\n                                    off =\n                                        nn.wrapping_rem(16 as std::os::raw::c_int as\n                                                            std::os::raw::c_uint) as\n                                            Int32;\n                                    pp = (*s).mtfbase[lno as usize] + off;\n                                    uc = (*s).mtfa[pp as usize];\n                                    while pp > (*s).mtfbase[lno as usize] {\n                                        (*s).mtfa[pp as usize] =\n                                            (*s).mtfa[(pp - 1 as std::os::raw::c_int)\n                                                          as usize];\n                                        pp -= 1\n                                    }\n                                    (*s).mtfbase[lno as usize] += 1;\n                                    while lno > 0 as std::os::raw::c_int {\n                                        (*s).mtfbase[lno as usize] -= 1;\n                                        (*s).mtfa[(*s).mtfbase[lno as usize]\n                                                      as usize] =\n                                            (*s).mtfa[((*s).mtfbase[(lno -\n                                                                         1 as\n                                                                             std::os::raw::c_int)\n                                                                        as\n                                                                        usize]\n                                                           + 16 as std::os::raw::c_int\n                                                           - 1 as std::os::raw::c_int)\n                                                          as usize];\n                                        lno -= 1\n                                    }\n                                    (*s).mtfbase[0 as std::os::raw::c_int as usize] -=\n                                        1;\n                                    (*s).mtfa[(*s).mtfbase[0 as std::os::raw::c_int as\n                                                               usize] as\n                                                  usize] = uc;\n                                    if (*s).mtfbase[0 as std::os::raw::c_int as usize]\n                                           == 0 as std::os::raw::c_int {\n                                        kk_0 =\n                                            4096 as std::os::raw::c_int -\n                                                1 as std::os::raw::c_int;\n                                        ii_0 =\n                                            256 as std::os::raw::c_int /\n                                                16 as std::os::raw::c_int -\n                                                1 as std::os::raw::c_int;\n                                        while ii_0 >= 0 as std::os::raw::c_int {\n                                            jj_0 =\n                                                16 as std::os::raw::c_int -\n                                                    1 as std::os::raw::c_int;\n                                            while jj_0 >= 0 as std::os::raw::c_int {\n                                                (*s).mtfa[kk_0 as usize] =\n                                                    (*s).mtfa[((*s).mtfbase[ii_0\n                                                                                as\n                                                                                usize]\n                                                                   + jj_0) as\n                                                                  usize];\n                                                kk_0 -= 1;\n                                                jj_0 -= 1\n                                            }\n                                            (*s).mtfbase[ii_0 as usize] =\n                                                kk_0 + 1 as std::os::raw::c_int;\n                                            ii_0 -= 1\n                                        }\n                                    }\n                                }\n                                /*-- end uc = MTF ( nextSym-1 ) --*/\n                                (*s).unzftab[(*s).seqToUnseq[uc as usize] as\n                                                 usize] += 1;\n                                if (*s).smallDecompress != 0 {\n                                    *(*s).ll16.offset(nblock as isize) =\n                                        (*s).seqToUnseq[uc as usize] as UInt16\n                                } else {\n                                    *(*s).tt.offset(nblock as isize) =\n                                        (*s).seqToUnseq[uc as usize] as UInt32\n                                }\n                                nblock += 1;\n                                if groupPos == 0 as std::os::raw::c_int {\n                                    groupNo += 1;\n                                    if groupNo >= nSelectors {\n                                        retVal = -(4 as std::os::raw::c_int);\n                                        current_block = 15885526978618306830;\n                                        continue ;\n                                    } else {\n                                        groupPos = 50 as std::os::raw::c_int;\n                                        gSel =\n                                            (*s).selector[groupNo as usize] as\n                                                Int32;\n                                        gMinlen = (*s).minLens[gSel as usize];\n                                        gLimit =\n                                            &mut *(*(*s).limit.as_mut_ptr().offset(gSel\n                                                                                       as\n                                                                                       isize)).as_mut_ptr().offset(0\n                                                                                                                       as\n                                                                                                                       std::os::raw::c_int\n                                                                                                                       as\n                                                                                                                       isize)\n                                                as *mut Int32;\n                                        gPerm =\n                                            &mut *(*(*s).perm.as_mut_ptr().offset(gSel\n                                                                                      as\n                                                                                      isize)).as_mut_ptr().offset(0\n                                                                                                                      as\n                                                                                                                      std::os::raw::c_int\n                                                                                                                      as\n                                                                                                                      isize)\n                                                as *mut Int32;\n                                        gBase =\n                                            &mut *(*(*s).base.as_mut_ptr().offset(gSel\n                                                                                      as\n                                                                                      isize)).as_mut_ptr().offset(0\n                                                                                                                      as\n                                                                                                                      std::os::raw::c_int\n                                                                                                                      as\n                                                                                                                      isize)\n                                                as *mut Int32\n                                    }\n                                }\n                                groupPos -= 1;\n                                zn = gMinlen;\n                                current_block = 2629672494974161066;\n                                continue ;\n                            }\n                            current_block = 4550729491376650574;\n                        }\n                    } else { current_block = 12118509005321596519; }\n                    match current_block {\n                        4550729491376650574 => { }\n                        _ =>\n                        /* Now we know what nblock is, we can do a better sanity\n         check on s->origPtr.\n      */\n                        {\n                            if (*s).origPtr < 0 as std::os::raw::c_int ||\n                                   (*s).origPtr >= nblock {\n                                retVal = -(4 as std::os::raw::c_int);\n                                current_block = 15885526978618306830;\n                                continue ;\n                            } else {\n                                /*-- Set up cftab to facilitate generation of T^(-1) --*/\n      /* Check: unzftab entries in range. */\n                                i = 0 as std::os::raw::c_int;\n                                while i <= 255 as std::os::raw::c_int {\n                                    if (*s).unzftab[i as usize] <\n                                           0 as std::os::raw::c_int ||\n                                           (*s).unzftab[i as usize] > nblock {\n                                        retVal = -(4 as std::os::raw::c_int);\n                                        current_block = 15885526978618306830;\n                                        continue 'c_10532 ;\n                                    } else { i += 1 }\n                                }\n                                /* Actually generate cftab. */\n                                (*s).cftab[0 as std::os::raw::c_int as usize] =\n                                    0 as std::os::raw::c_int;\n                                i = 1 as std::os::raw::c_int;\n                                while i <= 256 as std::os::raw::c_int {\n                                    (*s).cftab[i as usize] =\n                                        (*s).unzftab[(i - 1 as std::os::raw::c_int) as\n                                                         usize];\n                                    i += 1\n                                }\n                                i = 1 as std::os::raw::c_int;\n                                while i <= 256 as std::os::raw::c_int {\n                                    (*s).cftab[i as usize] +=\n                                        (*s).cftab[(i - 1 as std::os::raw::c_int) as\n                                                       usize];\n                                    i += 1\n                                }\n                                /* Check: cftab entries in range. */\n                                i = 0 as std::os::raw::c_int;\n                                while i <= 256 as std::os::raw::c_int {\n                                    if (*s).cftab[i as usize] <\n                                           0 as std::os::raw::c_int ||\n                                           (*s).cftab[i as usize] > nblock {\n                                        /* s->cftab[i] can legitimately be == nblock */\n                                        retVal = -(4 as std::os::raw::c_int);\n                                        current_block = 15885526978618306830;\n                                        continue 'c_10532 ;\n                                    } else { i += 1 }\n                                }\n                                /* Check: cftab entries non-descending. */\n                                i = 1 as std::os::raw::c_int;\n                                while i <= 256 as std::os::raw::c_int {\n                                    if (*s).cftab[(i - 1 as std::os::raw::c_int) as\n                                                      usize] >\n                                           (*s).cftab[i as usize] {\n                                        retVal = -(4 as std::os::raw::c_int);\n                                        current_block = 15885526978618306830;\n                                        continue 'c_10532 ;\n                                    } else { i += 1 }\n                                }\n                                (*s).state_out_len = 0 as std::os::raw::c_int;\n                                (*s).state_out_ch = 0 as std::os::raw::c_int as UChar;\n                                (*s).calculatedBlockCRC =\n                                    0xffffffff as std::os::raw::c_long as UInt32;\n                                (*s).state = 2 as std::os::raw::c_int;\n                                if (*s).verbosity >= 2 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"rt+rld\\x00\" as *const u8 as\n                                                *const std::os::raw::c_char);\n                                }\n                                if (*s).smallDecompress != 0 {\n                                    /*-- Make a copy of cftab, used in generation of T --*/\n                                    i = 0 as std::os::raw::c_int;\n                                    while i <= 256 as std::os::raw::c_int {\n                                        (*s).cftabCopy[i as usize] =\n                                            (*s).cftab[i as usize];\n                                        i += 1\n                                    }\n                                    /*-- compute the T vector --*/\n                                    i = 0 as std::os::raw::c_int;\n                                    while i < nblock {\n                                        uc =\n                                            *(*s).ll16.offset(i as isize) as\n                                                UChar;\n                                        *(*s).ll16.offset(i as isize) =\n                                            ((*s).cftabCopy[uc as usize] &\n                                                 0xffff as std::os::raw::c_int) as\n                                                UInt16;\n                                        if i & 0x1 as std::os::raw::c_int ==\n                                               0 as std::os::raw::c_int {\n                                            *(*s).ll4.offset((i >>\n                                                                  1 as\n                                                                      std::os::raw::c_int)\n                                                                 as isize) =\n                                                (*(*s).ll4.offset((i >>\n                                                                       1 as\n                                                                           std::os::raw::c_int)\n                                                                      as\n                                                                      isize)\n                                                     as std::os::raw::c_int &\n                                                     0xf0 as std::os::raw::c_int |\n                                                     (*s).cftabCopy[uc as\n                                                                        usize]\n                                                         >> 16 as std::os::raw::c_int)\n                                                    as UChar\n                                        } else {\n                                            *(*s).ll4.offset((i >>\n                                                                  1 as\n                                                                      std::os::raw::c_int)\n                                                                 as isize) =\n                                                (*(*s).ll4.offset((i >>\n                                                                       1 as\n                                                                           std::os::raw::c_int)\n                                                                      as\n                                                                      isize)\n                                                     as std::os::raw::c_int &\n                                                     0xf as std::os::raw::c_int |\n                                                     ((*s).cftabCopy[uc as\n                                                                         usize]\n                                                          >>\n                                                          16 as std::os::raw::c_int)\n                                                         << 4 as std::os::raw::c_int)\n                                                    as UChar\n                                        }\n                                        (*s).cftabCopy[uc as usize] += 1;\n                                        i += 1\n                                    }\n                                    /*-- Compute T^(-1) by pointer reversal on T --*/\n                                    i = (*s).origPtr;\n                                    j =\n                                        (*(*s).ll16.offset(i as isize) as\n                                             UInt32 |\n                                             (*(*s).ll4.offset((i >>\n                                                                    1 as\n                                                                        std::os::raw::c_int)\n                                                                   as isize)\n                                                  as UInt32 >>\n                                                  (i << 2 as std::os::raw::c_int &\n                                                       0x4 as std::os::raw::c_int) &\n                                                  0xf as std::os::raw::c_int as\n                                                      std::os::raw::c_uint) <<\n                                                 16 as std::os::raw::c_int) as Int32;\n                                    loop  {\n                                        let mut tmp_0: Int32 =\n                                            (*(*s).ll16.offset(j as isize) as\n                                                 UInt32 |\n                                                 (*(*s).ll4.offset((j >>\n                                                                        1 as\n                                                                            std::os::raw::c_int)\n                                                                       as\n                                                                       isize)\n                                                      as UInt32 >>\n                                                      (j << 2 as std::os::raw::c_int &\n                                                           0x4 as std::os::raw::c_int)\n                                                      &\n                                                      0xf as std::os::raw::c_int as\n                                                          std::os::raw::c_uint) <<\n                                                     16 as std::os::raw::c_int) as\n                                                Int32;\n                                        *(*s).ll16.offset(j as isize) =\n                                            (i & 0xffff as std::os::raw::c_int) as\n                                                UInt16;\n                                        if j & 0x1 as std::os::raw::c_int ==\n                                               0 as std::os::raw::c_int {\n                                            *(*s).ll4.offset((j >>\n                                                                  1 as\n                                                                      std::os::raw::c_int)\n                                                                 as isize) =\n                                                (*(*s).ll4.offset((j >>\n                                                                       1 as\n                                                                           std::os::raw::c_int)\n                                                                      as\n                                                                      isize)\n                                                     as std::os::raw::c_int &\n                                                     0xf0 as std::os::raw::c_int |\n                                                     i >> 16 as std::os::raw::c_int)\n                                                    as UChar\n                                        } else {\n                                            *(*s).ll4.offset((j >>\n                                                                  1 as\n                                                                      std::os::raw::c_int)\n                                                                 as isize) =\n                                                (*(*s).ll4.offset((j >>\n                                                                       1 as\n                                                                           std::os::raw::c_int)\n                                                                      as\n                                                                      isize)\n                                                     as std::os::raw::c_int &\n                                                     0xf as std::os::raw::c_int |\n                                                     (i >> 16 as std::os::raw::c_int)\n                                                         << 4 as std::os::raw::c_int)\n                                                    as UChar\n                                        }\n                                        i = j;\n                                        j = tmp_0;\n                                        if !(i != (*s).origPtr) { break ; }\n                                    }\n                                    (*s).tPos = (*s).origPtr as UInt32;\n                                    (*s).nblock_used = 0 as std::os::raw::c_int;\n                                    if (*s).blockRandomised != 0 {\n                                        (*s).rNToGo = 0 as std::os::raw::c_int;\n                                        (*s).rTPos = 0 as std::os::raw::c_int;\n                                        if (*s).tPos >=\n                                               (100000 as std::os::raw::c_int as\n                                                    UInt32).wrapping_mul((*s).blockSize100k\n                                                                             as\n                                                                             UInt32)\n                                           {\n                                            return 1 as std::os::raw::c_int as Bool as\n                                                       Int32\n                                        }\n                                        (*s).k0 =\n                                            BZ2_indexIntoF((*s).tPos as Int32,\n                                                           (*s).cftab.as_mut_ptr());\n                                        (*s).tPos =\n                                            *(*s).ll16.offset((*s).tPos as\n                                                                  isize) as\n                                                UInt32 |\n                                                (*(*s).ll4.offset(((*s).tPos\n                                                                       >>\n                                                                       1 as\n                                                                           std::os::raw::c_int)\n                                                                      as\n                                                                      isize)\n                                                     as UInt32 >>\n                                                     ((*s).tPos <<\n                                                          2 as std::os::raw::c_int &\n                                                          0x4 as std::os::raw::c_int\n                                                              as std::os::raw::c_uint)\n                                                     &\n                                                     0xf as std::os::raw::c_int as\n                                                         std::os::raw::c_uint) <<\n                                                    16 as std::os::raw::c_int;\n                                        (*s).nblock_used += 1;\n                                        if (*s).rNToGo == 0 as std::os::raw::c_int {\n                                            (*s).rNToGo =\n                                                BZ2_rNums[(*s).rTPos as\n                                                              usize];\n                                            (*s).rTPos += 1;\n                                            if (*s).rTPos ==\n                                                   512 as std::os::raw::c_int {\n                                                (*s).rTPos = 0 as std::os::raw::c_int\n                                            }\n                                        }\n                                        (*s).rNToGo -= 1;\n                                        (*s).k0 ^=\n                                            if (*s).rNToGo == 1 as std::os::raw::c_int\n                                               {\n                                                1 as std::os::raw::c_int\n                                            } else { 0 as std::os::raw::c_int }\n                                    } else {\n                                        if (*s).tPos >=\n                                               (100000 as std::os::raw::c_int as\n                                                    UInt32).wrapping_mul((*s).blockSize100k\n                                                                             as\n                                                                             UInt32)\n                                           {\n                                            return 1 as std::os::raw::c_int as Bool as\n                                                       Int32\n                                        }\n                                        (*s).k0 =\n                                            BZ2_indexIntoF((*s).tPos as Int32,\n                                                           (*s).cftab.as_mut_ptr());\n                                        (*s).tPos =\n                                            *(*s).ll16.offset((*s).tPos as\n                                                                  isize) as\n                                                UInt32 |\n                                                (*(*s).ll4.offset(((*s).tPos\n                                                                       >>\n                                                                       1 as\n                                                                           std::os::raw::c_int)\n                                                                      as\n                                                                      isize)\n                                                     as UInt32 >>\n                                                     ((*s).tPos <<\n                                                          2 as std::os::raw::c_int &\n                                                          0x4 as std::os::raw::c_int\n                                                              as std::os::raw::c_uint)\n                                                     &\n                                                     0xf as std::os::raw::c_int as\n                                                         std::os::raw::c_uint) <<\n                                                    16 as std::os::raw::c_int;\n                                        (*s).nblock_used += 1\n                                    }\n                                } else {\n                                    /*-- compute the T^(-1) vector --*/\n                                    i = 0 as std::os::raw::c_int;\n                                    while i < nblock {\n                                        uc =\n                                            (*(*s).tt.offset(i as isize) &\n                                                 0xff as std::os::raw::c_int as\n                                                     std::os::raw::c_uint) as UChar;\n                                        let ref mut fresh0 =\n                                            *(*s).tt.offset((*s).cftab[uc as\n                                                                           usize]\n                                                                as isize);\n                                        *fresh0 |=\n                                            (i << 8 as std::os::raw::c_int) as\n                                                std::os::raw::c_uint;\n                                        (*s).cftab[uc as usize] += 1;\n                                        i += 1\n                                    }\n                                    (*s).tPos =\n                                        *(*s).tt.offset((*s).origPtr as isize)\n                                            >> 8 as std::os::raw::c_int;\n                                    (*s).nblock_used = 0 as std::os::raw::c_int;\n                                    if (*s).blockRandomised != 0 {\n                                        (*s).rNToGo = 0 as std::os::raw::c_int;\n                                        (*s).rTPos = 0 as std::os::raw::c_int;\n                                        if (*s).tPos >=\n                                               (100000 as std::os::raw::c_int as\n                                                    UInt32).wrapping_mul((*s).blockSize100k\n                                                                             as\n                                                                             UInt32)\n                                           {\n                                            return 1 as std::os::raw::c_int as Bool as\n                                                       Int32\n                                        }\n                                        (*s).tPos =\n                                            *(*s).tt.offset((*s).tPos as\n                                                                isize);\n                                        (*s).k0 =\n                                            ((*s).tPos &\n                                                 0xff as std::os::raw::c_int as\n                                                     std::os::raw::c_uint) as UChar as\n                                                Int32;\n                                        (*s).tPos >>= 8 as std::os::raw::c_int;\n                                        (*s).nblock_used += 1;\n                                        if (*s).rNToGo == 0 as std::os::raw::c_int {\n                                            (*s).rNToGo =\n                                                BZ2_rNums[(*s).rTPos as\n                                                              usize];\n                                            (*s).rTPos += 1;\n                                            if (*s).rTPos ==\n                                                   512 as std::os::raw::c_int {\n                                                (*s).rTPos = 0 as std::os::raw::c_int\n                                            }\n                                        }\n                                        (*s).rNToGo -= 1;\n                                        (*s).k0 ^=\n                                            if (*s).rNToGo == 1 as std::os::raw::c_int\n                                               {\n                                                1 as std::os::raw::c_int\n                                            } else { 0 as std::os::raw::c_int }\n                                    } else {\n                                        if (*s).tPos >=\n                                               (100000 as std::os::raw::c_int as\n                                                    UInt32).wrapping_mul((*s).blockSize100k\n                                                                             as\n                                                                             UInt32)\n                                           {\n                                            return 1 as std::os::raw::c_int as Bool as\n                                                       Int32\n                                        }\n                                        (*s).tPos =\n                                            *(*s).tt.offset((*s).tPos as\n                                                                isize);\n                                        (*s).k0 =\n                                            ((*s).tPos &\n                                                 0xff as std::os::raw::c_int as\n                                                     std::os::raw::c_uint) as UChar as\n                                                Int32;\n                                        (*s).tPos >>= 8 as std::os::raw::c_int;\n                                        (*s).nblock_used += 1\n                                    }\n                                }\n                                retVal = 0 as std::os::raw::c_int;\n                                current_block = 15885526978618306830;\n                                continue ;\n                            }\n                        }\n                    }\n                }\n                _ => { }\n            }\n            match current_block {\n                4550729491376650574 =>\n                /* Check that N doesn't get too big, so that es doesn't\n                  go negative.  The maximum value that can be\n                  RUNA/RUNB encoded is equal to the block size (post\n                  the initial RLE), viz, 900k, so bounding N at 2\n                  million should guard against overflow without\n                  rejecting any legitimate inputs. */\n                {\n                    if N >=\n                           2 as std::os::raw::c_int * 1024 as std::os::raw::c_int *\n                               1024 as std::os::raw::c_int {\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                        continue ;\n                    } else {\n                        if nextSym == 0 as std::os::raw::c_int {\n                            es =\n                                es + (0 as std::os::raw::c_int + 1 as std::os::raw::c_int) * N\n                        } else if nextSym == 1 as std::os::raw::c_int {\n                            es =\n                                es + (1 as std::os::raw::c_int + 1 as std::os::raw::c_int) * N\n                        }\n                        N = N * 2 as std::os::raw::c_int;\n                        if groupPos == 0 as std::os::raw::c_int {\n                            groupNo += 1;\n                            if groupNo >= nSelectors {\n                                retVal = -(4 as std::os::raw::c_int);\n                                current_block = 15885526978618306830;\n                                continue ;\n                            } else {\n                                groupPos = 50 as std::os::raw::c_int;\n                                gSel =\n                                    (*s).selector[groupNo as usize] as Int32;\n                                gMinlen = (*s).minLens[gSel as usize];\n                                gLimit =\n                                    &mut *(*(*s).limit.as_mut_ptr().offset(gSel\n                                                                               as\n                                                                               isize)).as_mut_ptr().offset(0\n                                                                                                               as\n                                                                                                               std::os::raw::c_int\n                                                                                                               as\n                                                                                                               isize)\n                                        as *mut Int32;\n                                gPerm =\n                                    &mut *(*(*s).perm.as_mut_ptr().offset(gSel\n                                                                              as\n                                                                              isize)).as_mut_ptr().offset(0\n                                                                                                              as\n                                                                                                              std::os::raw::c_int\n                                                                                                              as\n                                                                                                              isize)\n                                        as *mut Int32;\n                                gBase =\n                                    &mut *(*(*s).base.as_mut_ptr().offset(gSel\n                                                                              as\n                                                                              isize)).as_mut_ptr().offset(0\n                                                                                                              as\n                                                                                                              std::os::raw::c_int\n                                                                                                              as\n                                                                                                              isize)\n                                        as *mut Int32\n                            }\n                        }\n                        groupPos -= 1;\n                        zn = gMinlen;\n                        current_block = 5374617794059532979;\n                        continue ;\n                    }\n                }\n                _ => { }\n            }\n            loop  {\n                match current_block {\n                    3854024847017804838 => {\n                        if j < 16 as std::os::raw::c_int {\n                            current_block = 1422779171932145779;\n                            continue 'c_10532 ;\n                        }\n                    }\n                    6591141407893725683 => {\n                        if i < nSelectors {\n                            j = 0 as std::os::raw::c_int;\n                            current_block = 6927328446518169316;\n                            continue ;\n                        } else {\n                            if nSelectors >\n                                   2 as std::os::raw::c_int +\n                                       900000 as std::os::raw::c_int /\n                                           50 as std::os::raw::c_int {\n                                nSelectors =\n                                    2 as std::os::raw::c_int +\n                                        900000 as std::os::raw::c_int /\n                                            50 as std::os::raw::c_int\n                            }\n                            /*--- Undo the MTF values for the selectors. ---*/\n                            let mut pos: [UChar; 6] = [0; 6];\n                            let mut tmp: UChar = 0;\n                            let mut v_22: UChar = 0;\n                            v_22 = 0 as std::os::raw::c_int as UChar;\n                            while (v_22 as std::os::raw::c_int) < nGroups {\n                                pos[v_22 as usize] = v_22;\n                                v_22 = v_22.wrapping_add(1)\n                            }\n                            i = 0 as std::os::raw::c_int;\n                            while i < nSelectors {\n                                v_22 = (*s).selectorMtf[i as usize];\n                                tmp = pos[v_22 as usize];\n                                while v_22 as std::os::raw::c_int > 0 as std::os::raw::c_int {\n                                    pos[v_22 as usize] =\n                                        pos[(v_22 as std::os::raw::c_int -\n                                                 1 as std::os::raw::c_int) as usize];\n                                    v_22 = v_22.wrapping_sub(1)\n                                }\n                                pos[0 as std::os::raw::c_int as usize] = tmp;\n                                (*s).selector[i as usize] = tmp;\n                                i += 1\n                            }\n                            /*--- Now the coding tables ---*/\n                            t = 0 as std::os::raw::c_int;\n                            current_block = 16916874950763617094;\n                            break ;\n                        }\n                    }\n                    3472349144349095221 => {\n                        if i < 16 as std::os::raw::c_int {\n                            if (*s).inUse16[i as usize] != 0 {\n                                j = 0 as std::os::raw::c_int;\n                                current_block = 3854024847017804838;\n                                continue ;\n                            }\n                        } else {\n                            makeMaps_d(s);\n                            if (*s).nInUse == 0 as std::os::raw::c_int {\n                                current_block = 11906008669688594715;\n                                break ;\n                            } else {\n                                current_block = 7606051654693192361;\n                                break ;\n                            }\n                        }\n                    }\n                    17503523010989424999 => {\n                        (*s).len[t as usize][i as usize] = curr as UChar;\n                        i += 1;\n                        current_block = 3770765986603902964;\n                        continue ;\n                    }\n                    3770765986603902964 => {\n                        if i < alphaSize {\n                            current_block = 11858046780433112516;\n                            continue ;\n                        }\n                        t += 1;\n                        current_block = 16916874950763617094;\n                        break ;\n                    }\n                    5281038271658253520 => {\n                        /* Having more than BZ_MAX_SELECTORS doesn't make much sense\n            since they will never be used, but some implementations might\n            \"round up\" the number of selectors, so just ignore those. */\n                        if i <\n                               2 as std::os::raw::c_int +\n                                   900000 as std::os::raw::c_int / 50 as std::os::raw::c_int {\n                            (*s).selectorMtf[i as usize] = j as UChar\n                        }\n                        i += 1;\n                        current_block = 6591141407893725683;\n                        continue ;\n                    }\n                    6927328446518169316 => {\n                        if 1 as std::os::raw::c_int as Bool != 0 {\n                            current_block = 4874723077730206021;\n                            continue 'c_10532 ;\n                        } else {\n                            current_block = 5281038271658253520;\n                            continue ;\n                        }\n                    }\n                    _ => {\n                        if !(1 as std::os::raw::c_int as Bool != 0) {\n                            current_block = 17503523010989424999;\n                            continue ;\n                        }\n                        if !(curr < 1 as std::os::raw::c_int ||\n                                 curr > 20 as std::os::raw::c_int) {\n                            current_block = 1736021991379636935;\n                            continue 'c_10532 ;\n                        }\n                        retVal = -(4 as std::os::raw::c_int);\n                        current_block = 15885526978618306830;\n                        continue 'c_10532 ;\n                    }\n                }\n                i += 1;\n                current_block = 3472349144349095221;\n            }\n            match current_block {\n                7606051654693192361 => {\n                    alphaSize = (*s).nInUse + 2 as std::os::raw::c_int;\n                    current_block = 3906616468301123675;\n                }\n                11906008669688594715 => {\n                    retVal = -(4 as std::os::raw::c_int);\n                    current_block = 15885526978618306830;\n                }\n                _ => {\n                    if t < nGroups {\n                        current_block = 10945178116989557996;\n                        continue ;\n                    }\n                    /*--- Create the Huffman decoding tables ---*/\n                    t = 0 as std::os::raw::c_int;\n                    while t < nGroups {\n                        minLen = 32 as std::os::raw::c_int;\n                        maxLen = 0 as std::os::raw::c_int;\n                        i = 0 as std::os::raw::c_int;\n                        while i < alphaSize {\n                            if (*s).len[t as usize][i as usize] as std::os::raw::c_int\n                                   > maxLen {\n                                maxLen =\n                                    (*s).len[t as usize][i as usize] as Int32\n                            }\n                            if ((*s).len[t as usize][i as usize] as\n                                    std::os::raw::c_int) < minLen {\n                                minLen =\n                                    (*s).len[t as usize][i as usize] as Int32\n                            }\n                            i += 1\n                        }\n                        BZ2_hbCreateDecodeTables(&mut *(*(*s).limit.as_mut_ptr().offset(t\n                                                                                            as\n                                                                                            isize)).as_mut_ptr().offset(0\n                                                                                                                            as\n                                                                                                                            std::os::raw::c_int\n                                                                                                                            as\n                                                                                                                            isize),\n                                                 &mut *(*(*s).base.as_mut_ptr().offset(t\n                                                                                           as\n                                                                                           isize)).as_mut_ptr().offset(0\n                                                                                                                           as\n                                                                                                                           std::os::raw::c_int\n                                                                                                                           as\n                                                                                                                           isize),\n                                                 &mut *(*(*s).perm.as_mut_ptr().offset(t\n                                                                                           as\n                                                                                           isize)).as_mut_ptr().offset(0\n                                                                                                                           as\n                                                                                                                           std::os::raw::c_int\n                                                                                                                           as\n                                                                                                                           isize),\n                                                 &mut *(*(*s).len.as_mut_ptr().offset(t\n                                                                                          as\n                                                                                          isize)).as_mut_ptr().offset(0\n                                                                                                                          as\n                                                                                                                          std::os::raw::c_int\n                                                                                                                          as\n                                                                                                                          isize),\n                                                 minLen, maxLen, alphaSize);\n                        (*s).minLens[t as usize] = minLen;\n                        t += 1\n                    }\n                    /*--- Now the MTF values ---*/\n                    EOB = (*s).nInUse + 1 as std::os::raw::c_int;\n                    nblockMAX = 100000 as std::os::raw::c_int * (*s).blockSize100k;\n                    groupNo = -(1 as std::os::raw::c_int);\n                    groupPos = 0 as std::os::raw::c_int;\n                    i = 0 as std::os::raw::c_int;\n                    while i <= 255 as std::os::raw::c_int {\n                        (*s).unzftab[i as usize] = 0 as std::os::raw::c_int;\n                        i += 1\n                    }\n                    /*-- MTF init --*/\n                    let mut ii: Int32 = 0;\n                    let mut jj: Int32 = 0;\n                    let mut kk: Int32 = 0;\n                    kk = 4096 as std::os::raw::c_int - 1 as std::os::raw::c_int;\n                    ii =\n                        256 as std::os::raw::c_int / 16 as std::os::raw::c_int -\n                            1 as std::os::raw::c_int;\n                    while ii >= 0 as std::os::raw::c_int {\n                        jj = 16 as std::os::raw::c_int - 1 as std::os::raw::c_int;\n                        while jj >= 0 as std::os::raw::c_int {\n                            (*s).mtfa[kk as usize] =\n                                (ii * 16 as std::os::raw::c_int + jj) as UChar;\n                            kk -= 1;\n                            jj -= 1\n                        }\n                        (*s).mtfbase[ii as usize] = kk + 1 as std::os::raw::c_int;\n                        ii -= 1\n                    }\n                    /*-- end MTF init --*/\n                    nblock = 0 as std::os::raw::c_int;\n                    if groupPos == 0 as std::os::raw::c_int {\n                        groupNo += 1;\n                        if groupNo >= nSelectors {\n                            retVal = -(4 as std::os::raw::c_int);\n                            current_block = 15885526978618306830;\n                            continue ;\n                        } else {\n                            groupPos = 50 as std::os::raw::c_int;\n                            gSel = (*s).selector[groupNo as usize] as Int32;\n                            gMinlen = (*s).minLens[gSel as usize];\n                            gLimit =\n                                &mut *(*(*s).limit.as_mut_ptr().offset(gSel as\n                                                                           isize)).as_mut_ptr().offset(0\n                                                                                                           as\n                                                                                                           std::os::raw::c_int\n                                                                                                           as\n                                                                                                           isize)\n                                    as *mut Int32;\n                            gPerm =\n                                &mut *(*(*s).perm.as_mut_ptr().offset(gSel as\n                                                                          isize)).as_mut_ptr().offset(0\n                                                                                                          as\n                                                                                                          std::os::raw::c_int\n                                                                                                          as\n                                                                                                          isize)\n                                    as *mut Int32;\n                            gBase =\n                                &mut *(*(*s).base.as_mut_ptr().offset(gSel as\n                                                                          isize)).as_mut_ptr().offset(0\n                                                                                                          as\n                                                                                                          std::os::raw::c_int\n                                                                                                          as\n                                                                                                          isize)\n                                    as *mut Int32\n                        }\n                    }\n                    groupPos -= 1;\n                    zn = gMinlen;\n                    current_block = 16722720626876144162;\n                }\n            }\n        }\n    (*s).save_j = j;\n    (*s).save_t = t;\n    (*s).save_alphaSize = alphaSize;\n    (*s).save_nGroups = nGroups;\n    (*s).save_nSelectors = nSelectors;\n    (*s).save_EOB = EOB;\n    (*s).save_groupNo = groupNo;\n    (*s).save_groupPos = groupPos;\n    (*s).save_nextSym = nextSym;\n    (*s).save_nblockMAX = nblockMAX;\n    (*s).save_nblock = nblock;\n    (*s).save_es = es;\n    (*s).save_N = N;\n    (*s).save_curr = curr;\n    (*s).save_zt = zt;\n    (*s).save_zn = zn;\n    (*s).save_zvec = zvec;\n    (*s).save_zj = zj;\n    (*s).save_gSel = gSel;\n    (*s).save_gMinlen = gMinlen;\n    (*s).save_gLimit = gLimit;\n    (*s).save_gBase = gBase;\n    (*s).save_gPerm = gPerm;\n    return retVal;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "decompress.rs:18:1: 18:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_indexIntoF;"
      },
      {
        "span": "decompress.rs:19:1: 19:50 (#0)",
        "source": "pub use crate::huffman::BZ2_hbCreateDecodeTables;"
      },
      {
        "span": "decompress.rs:20:1: 20:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "decompress.rs:17:1: 17:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:421 ~ c2rust_out[3c70]::bzlib::isempty_RL)",
    "span": "bzlib.rs:282:1: 287:2 (#0)",
    "pieces": [
      "bzlib.rs:282:1: 287:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn isempty_RL(mut s: *mut EState) -> Bool {\n    if (*s).state_in_ch < 256 as std::os::raw::c_int as std::os::raw::c_uint &&\n           (*s).state_in_len > 0 as std::os::raw::c_int {\n        return 0 as std::os::raw::c_int as Bool\n    } else { return 1 as std::os::raw::c_int as Bool };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:215 ~ c2rust_out[3c70]::bzip2::myfeof)",
    "span": "bzip2.rs:452:1: 457:2 (#0)",
    "pieces": [
      "bzip2.rs:452:1: 457:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn myfeof(mut f: *mut FILE) -> Bool {\n    let mut c: Int32 = fgetc(f);\n    if c == -(1 as std::os::raw::c_int) { return 1 as std::os::raw::c_int as Bool }\n    ungetc(c, f);\n    return 0 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:261 ~ c2rust_out[3c70]::bzip2::containsDubiousChars)",
    "span": "bzip2.rs:1993:2: 2000:2 (#0)",
    "pieces": [
      "bzip2.rs:1993:2: 2000:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "extern \"C\" fn containsDubiousChars(mut name: *mut Char) -> Bool {\n    /* On unix, files can contain any characters and the file expansion\n    * is performed by the shell.\n    */\n    return 0 as std::os::raw::c_int as Bool;\n    /* ! BZ_UNIX */\n    /* BZ_UNIX */\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:247 ~ c2rust_out[3c70]::bzip2::configError)",
    "span": "bzip2.rs:1792:1: 1798:2 (#0)",
    "pieces": [
      "bzip2.rs:1792:1: 1798:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn configError() -> ! {\n    fprintf(__stderrp,\n            b\"bzip2: I\\'m not configured correctly for this platform!\\n\\tI require Int32, Int16 and Char to have sizes\\n\\tof 4, 2 and 1 bytes to run properly, and they don\\'t.\\n\\tProbably you can fix this by defining them correctly,\\n\\tand recompiling.  Bye!\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char);\n    setExit(3 as std::os::raw::c_int);\n    exit(exitValue);\n}",
    "calls": [
      {
        "caller": "DefId(0:281 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2767:9: 2767:23 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1502:55: 1502:69 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1544:55: 1544:69 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1460:55: 1460:69 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1586:55: 1586:69 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1375:55: 1375:69 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:667:40: 667:54 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1418:55: 1418:69 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1004:53: 1004:67 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:692:40: 692:54 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:953:53: 953:67 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1106:53: 1106:67 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:902:53: 902:67 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:679:40: 679:54 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1055:53: 1055:67 (#0)",
        "source": "configError();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:850:53: 850:67 (#0)",
        "source": "configError();"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:334:1: 334:37 (#0)",
        "source": "pub static mut exitValue: Int32 = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:246 ~ c2rust_out[3c70]::bzip2::outOfMemory)",
    "span": "bzip2.rs:1784:1: 1790:2 (#0)",
    "pieces": [
      "bzip2.rs:1784:1: 1790:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn outOfMemory() -> ! {\n    fprintf(__stderrp,\n            b\"\\n%s: couldn\\'t allocate enough memory\\n\\x00\" as *const u8 as\n                *const std::os::raw::c_char, progName);\n    showFileNames();\n    cleanUpAndFail(1 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1376:55: 1376:69 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1587:55: 1587:69 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1112:53: 1112:67 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:908:53: 908:67 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1545:55: 1545:69 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1010:53: 1010:67 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1419:55: 1419:69 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1061:53: 1061:67 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:678:58: 678:72 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:691:58: 691:72 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1461:55: 1461:69 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:666:58: 666:72 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:959:53: 959:67 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:277 ~ c2rust_out[3c70]::bzip2::myMalloc)",
        "span": "bzip2.rs:2674:22: 2674:36 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1503:55: 1503:69 (#0)",
        "source": "outOfMemory();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:856:53: 856:67 (#0)",
        "source": "outOfMemory();"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:240 ~ c2rust_out[3c70]::bzip2::panic)",
    "span": "bzip2.rs:1700:1: 1706:2 (#0)",
    "pieces": [
      "bzip2.rs:1700:1: 1706:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn panic(mut s: *const Char) -> ! {\n    fprintf(__stderrp,\n            b\"\\n%s: PANIC -- internal consistency error:\\n\\t%s\\n\\tThis is a BUG.  Please report it to:\\n\\tbzip2-devel@sourceware.org\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, progName, s);\n    showFileNames();\n    cleanUpAndFail(3 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1433:33: 1434:85 (#0)",
        "source": "panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2241:13: 2242:52 (#0)",
        "source": "panic(b\"compress: bad srcMode\\x00\" as *const u8 as\n                      *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:999:53: 1001:92 (#0)",
        "source": "panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2060:9: 2061:48 (#0)",
        "source": "panic(b\"compress: bad modes\\n\\x00\" as *const u8 as\n                  *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1050:53: 1052:92 (#0)",
        "source": "panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2633:13: 2634:52 (#0)",
        "source": "panic(b\"testf: bad srcMode\\x00\" as *const u8 as\n                      *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:845:53: 847:92 (#0)",
        "source": "panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:897:53: 899:92 (#0)",
        "source": "panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2559:9: 2559:86 (#0)",
        "source": "panic(b\"testf: bad modes\\n\\x00\" as *const u8 as *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:662:37: 664:76 (#0)",
        "source": "panic(b\"compress:unexpected error\\x00\" as\n                                              *const u8 as\n                                              *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1101:53: 1103:92 (#0)",
        "source": "panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:779:25: 780:67 (#0)",
        "source": "panic(b\"decompress:bzReadGetUnused\\x00\" as *const u8\n                                  as *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1301:21: 1302:60 (#0)",
        "source": "panic(b\"test:bzReadGetUnused\\x00\" as *const u8 as\n                              *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1348:33: 1349:85 (#0)",
        "source": "panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2482:13: 2483:52 (#0)",
        "source": "panic(b\"uncompress: bad srcMode\\x00\" as *const u8 as\n                      *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2297:9: 2298:48 (#0)",
        "source": "panic(b\"uncompress: bad modes\\n\\x00\" as *const u8 as\n                  *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:948:53: 950:92 (#0)",
        "source": "panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1475:33: 1476:85 (#0)",
        "source": "panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:674:37: 676:76 (#0)",
        "source": "panic(b\"compress:unexpected error\\x00\" as\n                                              *const u8 as\n                                              *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1517:33: 1518:85 (#0)",
        "source": "panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1559:33: 1560:85 (#0)",
        "source": "panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1312:21: 1313:60 (#0)",
        "source": "panic(b\"test:bzReadGetUnused\\x00\" as *const u8 as\n                              *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:768:25: 769:67 (#0)",
        "source": "panic(b\"decompress:bzReadGetUnused\\x00\" as *const u8\n                                  as *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:687:37: 689:76 (#0)",
        "source": "panic(b\"compress:unexpected error\\x00\" as\n                                              *const u8 as\n                                              *const std::os::raw::c_char);"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1391:33: 1392:85 (#0)",
        "source": "panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:211 ~ c2rust_out[3c70]::bzip2::uInt64_qrm10)",
    "span": "bzip2.rs:405:1: 423:2 (#0)",
    "pieces": [
      "bzip2.rs:405:1: 423:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn uInt64_qrm10(mut n: *mut UInt64) -> Int32 {\n    let mut rem: UInt32 = 0;\n    let mut tmp: UInt32 = 0;\n    let mut i: Int32 = 0;\n    rem = 0 as std::os::raw::c_int as UInt32;\n    i = 7 as std::os::raw::c_int;\n    while i >= 0 as std::os::raw::c_int {\n        tmp =\n            rem.wrapping_mul(256 as std::os::raw::c_int as\n                                 std::os::raw::c_uint).wrapping_add((*n).b[i as usize]\n                                                                as\n                                                                std::os::raw::c_uint);\n        (*n).b[i as usize] =\n            tmp.wrapping_div(10 as std::os::raw::c_int as std::os::raw::c_uint) as UChar;\n        rem = tmp.wrapping_rem(10 as std::os::raw::c_int as std::os::raw::c_uint);\n        i -= 1\n    }\n    return rem as Int32;\n}",
    "calls": [
      {
        "caller": "DefId(0:212 ~ c2rust_out[3c70]::bzip2::uInt64_toAscii)",
        "span": "bzip2.rs:435:9: 435:39 (#0)",
        "source": "q = uInt64_qrm10(&mut n_copy);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:212 ~ c2rust_out[3c70]::bzip2::uInt64_toAscii)",
    "span": "bzip2.rs:427:1: 447:2 (#0)",
    "pieces": [
      "bzip2.rs:427:1: 447:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn uInt64_toAscii(mut outbuf: *mut std::os::raw::c_char,\n                                    mut n: *mut UInt64) {\n    let mut i: Int32 = 0;\n    let mut q: Int32 = 0;\n    let mut buf: [UChar; 32] = [0; 32];\n    let mut nBuf: Int32 = 0 as std::os::raw::c_int;\n    let mut n_copy: UInt64 = *n;\n    loop  {\n        q = uInt64_qrm10(&mut n_copy);\n        buf[nBuf as usize] = (q + '0' as i32) as UChar;\n        nBuf += 1;\n        if !(uInt64_isZero(&mut n_copy) == 0) { break ; }\n    }\n    *outbuf.offset(nBuf as isize) = 0 as std::os::raw::c_int as std::os::raw::c_char;\n    i = 0 as std::os::raw::c_int;\n    while i < nBuf {\n        *outbuf.offset(i as isize) =\n            buf[(nBuf - i - 1 as std::os::raw::c_int) as usize] as std::os::raw::c_char;\n        i += 1\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:614:57: 615:88 (#0)",
        "source": "uInt64_toAscii(buf_nin.as_mut_ptr(),\n                                                                       &mut nbytes_in);"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:616:57: 617:89 (#0)",
        "source": "uInt64_toAscii(buf_nout.as_mut_ptr(),\n                                                                       &mut nbytes_out);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:209 ~ c2rust_out[3c70]::bzip2::uInt64_to_double)",
    "span": "bzip2.rs:381:1: 392:2 (#0)",
    "pieces": [
      "bzip2.rs:381:1: 392:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn uInt64_to_double(mut n: *mut UInt64) -> std::os::raw::c_double {\n    let mut i: Int32 = 0;\n    let mut base: std::os::raw::c_double = 1.0f64;\n    let mut sum: std::os::raw::c_double = 0.0f64;\n    i = 0 as std::os::raw::c_int;\n    while i < 8 as std::os::raw::c_int {\n        sum += base * (*n).b[i as usize] as std::os::raw::c_double;\n        base *= 256.0f64;\n        i += 1\n    }\n    return sum;\n}",
    "calls": [
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:612:57: 613:95 (#0)",
        "source": "nbytes_out_d =\n                                                            uInt64_to_double(&mut nbytes_out);"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:610:57: 611:94 (#0)",
        "source": "nbytes_in_d =\n                                                            uInt64_to_double(&mut nbytes_in);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:208 ~ c2rust_out[3c70]::bzip2::uInt64_from_UInt32s)",
    "span": "bzip2.rs:356:1: 380:2 (#0)",
    "pieces": [
      "bzip2.rs:356:1: 380:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 25,
    "source": "unsafe extern \"C\" fn uInt64_from_UInt32s(mut n: *mut UInt64, mut lo32: UInt32,\n                                         mut hi32: UInt32) {\n    (*n).b[7 as std::os::raw::c_int as usize] =\n        (hi32 >> 24 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n            UChar;\n    (*n).b[6 as std::os::raw::c_int as usize] =\n        (hi32 >> 16 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n            UChar;\n    (*n).b[5 as std::os::raw::c_int as usize] =\n        (hi32 >> 8 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n            UChar;\n    (*n).b[4 as std::os::raw::c_int as usize] =\n        (hi32 & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as UChar;\n    (*n).b[3 as std::os::raw::c_int as usize] =\n        (lo32 >> 24 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n            UChar;\n    (*n).b[2 as std::os::raw::c_int as usize] =\n        (lo32 >> 16 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n            UChar;\n    (*n).b[1 as std::os::raw::c_int as usize] =\n        (lo32 >> 8 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n            UChar;\n    (*n).b[0 as std::os::raw::c_int as usize] =\n        (lo32 & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as UChar;\n}",
    "calls": [
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:604:57: 606:93 (#0)",
        "source": "uInt64_from_UInt32s(&mut nbytes_in,\n                                                                            nbytes_in_lo32,\n                                                                            nbytes_in_hi32);"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:607:57: 609:94 (#0)",
        "source": "uInt64_from_UInt32s(&mut nbytes_out,\n                                                                            nbytes_out_lo32,\n                                                                            nbytes_out_hi32);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:429 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompressEnd)",
    "span": "bzlib.rs:706:1: 732:2 (#0)",
    "pieces": [
      "bzlib.rs:706:1: 732:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn BZ2_bzCompressEnd(mut strm: *mut bz_stream)\n -> std::os::raw::c_int {\n    let mut s: *mut EState = 0 as *mut EState;\n    if strm.is_null() { return -(2 as std::os::raw::c_int) }\n    s = (*strm).state as *mut EState;\n    if s.is_null() { return -(2 as std::os::raw::c_int) }\n    if (*s).strm != strm { return -(2 as std::os::raw::c_int) }\n    if !(*s).arr1.is_null() {\n        (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                           (*s).arr1 as\n                                                               *mut std::os::raw::c_void);\n    }\n    if !(*s).arr2.is_null() {\n        (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                           (*s).arr2 as\n                                                               *mut std::os::raw::c_void);\n    }\n    if !(*s).ftab.is_null() {\n        (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                           (*s).ftab as\n                                                               *mut std::os::raw::c_void);\n    }\n    (*strm).bzfree.expect(\"non-null function pointer\")((*strm).opaque,\n                                                       (*strm).state);\n    (*strm).state = 0 as *mut std::os::raw::c_void;\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:445 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffCompress)",
        "span": "bzlib.rs:2154:9: 2154:38 (#0)",
        "source": "BZ2_bzCompressEnd(&mut strm);"
      },
      {
        "caller": "DefId(0:440 ~ c2rust_out[3c70]::bzlib::BZ2_bzWriteClose64)",
        "span": "bzlib.rs:1903:5: 1903:41 (#0)",
        "source": "BZ2_bzCompressEnd(&mut (*bzf).strm);"
      },
      {
        "caller": "DefId(0:445 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffCompress)",
        "span": "bzlib.rs:2146:9: 2146:38 (#0)",
        "source": "BZ2_bzCompressEnd(&mut strm);"
      },
      {
        "caller": "DefId(0:445 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffCompress)",
        "span": "bzlib.rs:2149:9: 2149:38 (#0)",
        "source": "BZ2_bzCompressEnd(&mut strm);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:440 ~ c2rust_out[3c70]::bzlib::BZ2_bzWriteClose64)",
    "span": "bzlib.rs:1811:1: 1905:2 (#0)",
    "pieces": [
      "bzlib.rs:1811:1: 1905:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 95,
    "source": "pub unsafe extern \"C\" fn BZ2_bzWriteClose64(mut bzerror: *mut std::os::raw::c_int,\n                                            mut b: *mut std::os::raw::c_void,\n                                            mut abandon: std::os::raw::c_int,\n                                            mut nbytes_in_lo32:\n                                                *mut std::os::raw::c_uint,\n                                            mut nbytes_in_hi32:\n                                                *mut std::os::raw::c_uint,\n                                            mut nbytes_out_lo32:\n                                                *mut std::os::raw::c_uint,\n                                            mut nbytes_out_hi32:\n                                                *mut std::os::raw::c_uint) {\n    let mut n: Int32 = 0;\n    let mut n2: Int32 = 0;\n    let mut ret: Int32 = 0;\n    let mut bzf: *mut bzFile = b as *mut bzFile;\n    if bzf.is_null() {\n        if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n        if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n        return\n    }\n    if (*bzf).writing == 0 {\n        if !bzerror.is_null() { *bzerror = -(1 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(1 as std::os::raw::c_int) }\n        return\n    }\n    if ferror((*bzf).handle) != 0 {\n        if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n        return\n    }\n    if !nbytes_in_lo32.is_null() {\n        *nbytes_in_lo32 = 0 as std::os::raw::c_int as std::os::raw::c_uint\n    }\n    if !nbytes_in_hi32.is_null() {\n        *nbytes_in_hi32 = 0 as std::os::raw::c_int as std::os::raw::c_uint\n    }\n    if !nbytes_out_lo32.is_null() {\n        *nbytes_out_lo32 = 0 as std::os::raw::c_int as std::os::raw::c_uint\n    }\n    if !nbytes_out_hi32.is_null() {\n        *nbytes_out_hi32 = 0 as std::os::raw::c_int as std::os::raw::c_uint\n    }\n    if abandon == 0 && (*bzf).lastErr == 0 as std::os::raw::c_int {\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            (*bzf).strm.avail_out = 5000 as std::os::raw::c_int as std::os::raw::c_uint;\n            (*bzf).strm.next_out = (*bzf).buf.as_mut_ptr();\n            ret = BZ2_bzCompress(&mut (*bzf).strm, 2 as std::os::raw::c_int);\n            if ret != 3 as std::os::raw::c_int && ret != 4 as std::os::raw::c_int {\n                if !bzerror.is_null() { *bzerror = ret }\n                if !bzf.is_null() { (*bzf).lastErr = ret }\n                return\n            }\n            if (*bzf).strm.avail_out < 5000 as std::os::raw::c_int as std::os::raw::c_uint {\n                n =\n                    (5000 as std::os::raw::c_int as\n                         std::os::raw::c_uint).wrapping_sub((*bzf).strm.avail_out) as\n                        Int32;\n                n2 =\n                    fwrite((*bzf).buf.as_mut_ptr() as *mut std::os::raw::c_void,\n                           ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong,\n                           n as std::os::raw::c_ulong, (*bzf).handle) as Int32;\n                if n != n2 || ferror((*bzf).handle) != 0 {\n                    if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n                    if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n                    return\n                }\n            }\n            if ret == 4 as std::os::raw::c_int { break ; }\n        }\n    }\n    if abandon == 0 && ferror((*bzf).handle) == 0 {\n        fflush((*bzf).handle);\n        if ferror((*bzf).handle) != 0 {\n            if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n            if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n            return\n        }\n    }\n    if !nbytes_in_lo32.is_null() {\n        *nbytes_in_lo32 = (*bzf).strm.total_in_lo32\n    }\n    if !nbytes_in_hi32.is_null() {\n        *nbytes_in_hi32 = (*bzf).strm.total_in_hi32\n    }\n    if !nbytes_out_lo32.is_null() {\n        *nbytes_out_lo32 = (*bzf).strm.total_out_lo32\n    }\n    if !nbytes_out_hi32.is_null() {\n        *nbytes_out_hi32 = (*bzf).strm.total_out_hi32\n    }\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    BZ2_bzCompressEnd(&mut (*bzf).strm);\n    free(bzf as *mut std::os::raw::c_void);\n}",
    "calls": [
      {
        "caller": "DefId(0:439 ~ c2rust_out[3c70]::bzlib::BZ2_bzWriteClose)",
        "span": "bzlib.rs:1807:5: 1808:68 (#0)",
        "source": "BZ2_bzWriteClose64(bzerror, b, abandon, nbytes_in, 0 as *mut std::os::raw::c_uint,\n                       nbytes_out, 0 as *mut std::os::raw::c_uint);"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:516:25: 520:66 (#0)",
        "source": "BZ2_bzWriteClose64(&mut bzerr, bzf, 0 as std::os::raw::c_int,\n                                           &mut nbytes_in_lo32,\n                                           &mut nbytes_in_hi32,\n                                           &mut nbytes_out_lo32,\n                                           &mut nbytes_out_hi32);"
      },
      {
        "caller": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
        "span": "bzip2.rs:652:21: 656:62 (#0)",
        "source": "BZ2_bzWriteClose64(&mut bzerr_dummy, bzf,\n                                       1 as std::os::raw::c_int, &mut nbytes_in_lo32,\n                                       &mut nbytes_in_hi32,\n                                       &mut nbytes_out_lo32,\n                                       &mut nbytes_out_hi32);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:216 ~ c2rust_out[3c70]::bzip2::compressStream)",
    "span": "bzip2.rs:459:1: 702:2 (#0)",
    "pieces": [
      "bzip2.rs:459:1: 702:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 244,
    "source": "unsafe extern \"C\" fn compressStream(mut stream: *mut FILE,\n                                    mut zStream: *mut FILE) {\n    let mut current_block: u64;\n    let mut bzf: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    let mut ibuf: [UChar; 5000] = [0; 5000];\n    let mut nIbuf: Int32 = 0;\n    let mut nbytes_in_lo32: UInt32 = 0;\n    let mut nbytes_in_hi32: UInt32 = 0;\n    let mut nbytes_out_lo32: UInt32 = 0;\n    let mut nbytes_out_hi32: UInt32 = 0;\n    let mut bzerr: Int32 = 0;\n    let mut bzerr_dummy: Int32 = 0;\n    let mut ret: Int32 = 0;\n    if !(ferror(stream) != 0) {\n        if !(ferror(zStream) != 0) {\n            bzf =\n                BZ2_bzWriteOpen(&mut bzerr, zStream, blockSize100k, verbosity,\n                                workFactor);\n            if bzerr != 0 as std::os::raw::c_int {\n                current_block = 660242869387099075;\n            } else {\n                if verbosity >= 2 as std::os::raw::c_int {\n                    fprintf(__stderrp,\n                            b\"\\n\\x00\" as *const u8 as *const std::os::raw::c_char);\n                }\n                loop  {\n                    if !(1 as std::os::raw::c_int as Bool != 0) {\n                        current_block = 13242334135786603907;\n                        break ;\n                    }\n                    if myfeof(stream) != 0 {\n                        current_block = 13242334135786603907;\n                        break ;\n                    }\n                    nIbuf =\n                        fread(ibuf.as_mut_ptr() as *mut std::os::raw::c_void,\n                              ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong,\n                              5000 as std::os::raw::c_int as std::os::raw::c_ulong, stream) as\n                            Int32;\n                    if ferror(stream) != 0 {\n                        current_block = 18225113528933273530;\n                        break ;\n                    }\n                    if nIbuf > 0 as std::os::raw::c_int {\n                        BZ2_bzWrite(&mut bzerr, bzf,\n                                    ibuf.as_mut_ptr() as *mut std::os::raw::c_void,\n                                    nIbuf);\n                    }\n                    if bzerr != 0 as std::os::raw::c_int {\n                        current_block = 660242869387099075;\n                        break ;\n                    }\n                }\n                match current_block {\n                    18225113528933273530 => { }\n                    660242869387099075 => { }\n                    _ => {\n                        BZ2_bzWriteClose64(&mut bzerr, bzf, 0 as std::os::raw::c_int,\n                                           &mut nbytes_in_lo32,\n                                           &mut nbytes_in_hi32,\n                                           &mut nbytes_out_lo32,\n                                           &mut nbytes_out_hi32);\n                        if bzerr != 0 as std::os::raw::c_int {\n                            current_block = 660242869387099075;\n                        } else if ferror(zStream) != 0 {\n                            current_block = 18225113528933273530;\n                        } else {\n                            ret = fflush(zStream);\n                            if ret == -(1 as std::os::raw::c_int) {\n                                current_block = 18225113528933273530;\n                            } else {\n                                if zStream != __stdoutp {\n                                    let mut fd: Int32 = fileno(zStream);\n                                    if fd < 0 as std::os::raw::c_int {\n                                        current_block = 18225113528933273530;\n                                    } else {\n                                        applySavedFileAttrToOutputFile(fd);\n                                        ret = fclose(zStream);\n                                        outputHandleJustInCase =\n                                            0 as *mut FILE;\n                                        if ret == -(1 as std::os::raw::c_int) {\n                                            current_block =\n                                                18225113528933273530;\n                                        } else {\n                                            current_block =\n                                                17281240262373992796;\n                                        }\n                                    }\n                                } else {\n                                    current_block = 17281240262373992796;\n                                }\n                                match current_block {\n                                    18225113528933273530 => { }\n                                    _ => {\n                                        outputHandleJustInCase =\n                                            0 as *mut FILE;\n                                        if ferror(stream) != 0 {\n                                            current_block =\n                                                18225113528933273530;\n                                        } else {\n                                            ret = fclose(stream);\n                                            if ret == -(1 as std::os::raw::c_int) {\n                                                current_block =\n                                                    18225113528933273530;\n                                            } else {\n                                                if verbosity >=\n                                                       1 as std::os::raw::c_int {\n                                                    if nbytes_in_lo32 ==\n                                                           0 as std::os::raw::c_int as\n                                                               std::os::raw::c_uint &&\n                                                           nbytes_in_hi32 ==\n                                                               0 as\n                                                                   std::os::raw::c_int\n                                                                   as\n                                                                   std::os::raw::c_uint\n                                                       {\n                                                        fprintf(__stderrp,\n                                                                b\" no data compressed.\\n\\x00\"\n                                                                    as\n                                                                    *const u8\n                                                                    as\n                                                                    *const std::os::raw::c_char);\n                                                    } else {\n                                                        let mut buf_nin:\n                                                                [Char; 32] =\n                                                            [0; 32];\n                                                        let mut buf_nout:\n                                                                [Char; 32] =\n                                                            [0; 32];\n                                                        let mut nbytes_in:\n                                                                UInt64 =\n                                                            UInt64{b:\n                                                                       [0;\n                                                                           8],};\n                                                        let mut nbytes_out:\n                                                                UInt64 =\n                                                            UInt64{b:\n                                                                       [0;\n                                                                           8],};\n                                                        let mut nbytes_in_d:\n                                                                std::os::raw::c_double =\n                                                            0.;\n                                                        let mut nbytes_out_d:\n                                                                std::os::raw::c_double =\n                                                            0.;\n                                                        uInt64_from_UInt32s(&mut nbytes_in,\n                                                                            nbytes_in_lo32,\n                                                                            nbytes_in_hi32);\n                                                        uInt64_from_UInt32s(&mut nbytes_out,\n                                                                            nbytes_out_lo32,\n                                                                            nbytes_out_hi32);\n                                                        nbytes_in_d =\n                                                            uInt64_to_double(&mut nbytes_in);\n                                                        nbytes_out_d =\n                                                            uInt64_to_double(&mut nbytes_out);\n                                                        uInt64_toAscii(buf_nin.as_mut_ptr(),\n                                                                       &mut nbytes_in);\n                                                        uInt64_toAscii(buf_nout.as_mut_ptr(),\n                                                                       &mut nbytes_out);\n                                                        fprintf(__stderrp,\n                                                                b\"%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %s in, %s out.\\n\\x00\"\n                                                                    as\n                                                                    *const u8\n                                                                    as\n                                                                    *const std::os::raw::c_char,\n                                                                nbytes_in_d /\n                                                                    nbytes_out_d,\n                                                                8.0f64 *\n                                                                    nbytes_out_d\n                                                                    /\n                                                                    nbytes_in_d,\n                                                                100.0f64 *\n                                                                    (1.0f64 -\n                                                                         nbytes_out_d\n                                                                             /\n                                                                             nbytes_in_d),\n                                                                buf_nin.as_mut_ptr(),\n                                                                buf_nout.as_mut_ptr());\n                                                    }\n                                                }\n                                                return\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            match current_block {\n                18225113528933273530 => { }\n                _ => {\n                    BZ2_bzWriteClose64(&mut bzerr_dummy, bzf,\n                                       1 as std::os::raw::c_int, &mut nbytes_in_lo32,\n                                       &mut nbytes_in_hi32,\n                                       &mut nbytes_out_lo32,\n                                       &mut nbytes_out_hi32);\n                    match bzerr {\n                        -9 => {\n                            current_block = 5122324059762049690;\n                            match current_block {\n                                4323399205346619401 => {\n                                    panic(b\"compress:unexpected error\\x00\" as\n                                              *const u8 as\n                                              *const std::os::raw::c_char);\n                                }\n                                2380987886157893679 => { outOfMemory(); }\n                                _ => { configError(); }\n                            }\n                        }\n                        -3 => {\n                            current_block = 2380987886157893679;\n                            match current_block {\n                                4323399205346619401 => {\n                                    panic(b\"compress:unexpected error\\x00\" as\n                                              *const u8 as\n                                              *const std::os::raw::c_char);\n                                }\n                                2380987886157893679 => { outOfMemory(); }\n                                _ => { configError(); }\n                            }\n                        }\n                        -6 => { }\n                        _ => {\n                            current_block = 4323399205346619401;\n                            match current_block {\n                                4323399205346619401 => {\n                                    panic(b\"compress:unexpected error\\x00\" as\n                                              *const u8 as\n                                              *const std::os::raw::c_char);\n                                }\n                                2380987886157893679 => { outOfMemory(); }\n                                _ => { configError(); }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ioError();\n    /*notreached*/\n}",
    "calls": [
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2254:5: 2254:35 (#0)",
        "source": "compressStream(inStr, outStr);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:312:1: 312:37 (#0)",
        "source": "pub static mut verbosity: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:332:1: 332:41 (#0)",
        "source": "pub static mut blockSize100k: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:352:1: 353:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      },
      {
        "span": "bzip2.rs:355:1: 355:38 (#0)",
        "source": "pub static mut workFactor: Int32 = 0;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:495 ~ c2rust_out[3c70]::compress::BZ2_bsInitWrite)",
    "span": "compress.rs:71:1: 74:2 (#0)",
    "pieces": [
      "compress.rs:71:1: 74:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn BZ2_bsInitWrite(mut s: *mut EState) {\n    (*s).bsLive = 0 as std::os::raw::c_int;\n    (*s).bsBuff = 0 as std::os::raw::c_int as UInt32;\n}",
    "calls": [
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2475:9: 2475:28 (#0)",
        "source": "BZ2_bsInitWrite(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:17:1: 17:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:20:1: 20:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:18:1: 18:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:21:1: 21:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:19:1: 19:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:49 ~ c2rust_out[3c70]::blocksort::mainSort)",
    "span": "blocksort.rs:1115:1: 1551:2 (#0)",
    "pieces": [
      "blocksort.rs:1115:1: 1551:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 437,
    "source": "unsafe extern \"C\" fn mainSort(mut ptr: *mut UInt32, mut block: *mut UChar,\n                              mut quadrant: *mut UInt16,\n                              mut ftab: *mut UInt32, mut nblock: Int32,\n                              mut verb: Int32, mut budget: *mut Int32) {\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut k: Int32 = 0;\n    let mut ss: Int32 = 0;\n    let mut sb: Int32 = 0;\n    let mut runningOrder: [Int32; 256] = [0; 256];\n    let mut bigDone: [Bool; 256] = [0; 256];\n    let mut copyStart: [Int32; 256] = [0; 256];\n    let mut copyEnd: [Int32; 256] = [0; 256];\n    let mut c1: UChar = 0;\n    let mut numQSorted: Int32 = 0;\n    let mut s: UInt16 = 0;\n    if verb >= 4 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"        main sort initialise ...\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char);\n    }\n    /*-- set up the 2-byte frequency table --*/\n    i = 65536 as std::os::raw::c_int;\n    while i >= 0 as std::os::raw::c_int {\n        *ftab.offset(i as isize) = 0 as std::os::raw::c_int as UInt32;\n        i -= 1\n    }\n    j =\n        (*block.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int) <<\n            8 as std::os::raw::c_int;\n    i = nblock - 1 as std::os::raw::c_int;\n    while i >= 3 as std::os::raw::c_int {\n        *quadrant.offset(i as isize) = 0 as std::os::raw::c_int as UInt16;\n        j =\n            j >> 8 as std::os::raw::c_int |\n                (*block.offset(i as isize) as UInt16 as std::os::raw::c_int) <<\n                    8 as std::os::raw::c_int;\n        let ref mut fresh4 = *ftab.offset(j as isize);\n        *fresh4 = (*fresh4).wrapping_add(1);\n        *quadrant.offset((i - 1 as std::os::raw::c_int) as isize) =\n            0 as std::os::raw::c_int as UInt16;\n        j =\n            j >> 8 as std::os::raw::c_int |\n                (*block.offset((i - 1 as std::os::raw::c_int) as isize) as UInt16 as\n                     std::os::raw::c_int) << 8 as std::os::raw::c_int;\n        let ref mut fresh5 = *ftab.offset(j as isize);\n        *fresh5 = (*fresh5).wrapping_add(1);\n        *quadrant.offset((i - 2 as std::os::raw::c_int) as isize) =\n            0 as std::os::raw::c_int as UInt16;\n        j =\n            j >> 8 as std::os::raw::c_int |\n                (*block.offset((i - 2 as std::os::raw::c_int) as isize) as UInt16 as\n                     std::os::raw::c_int) << 8 as std::os::raw::c_int;\n        let ref mut fresh6 = *ftab.offset(j as isize);\n        *fresh6 = (*fresh6).wrapping_add(1);\n        *quadrant.offset((i - 3 as std::os::raw::c_int) as isize) =\n            0 as std::os::raw::c_int as UInt16;\n        j =\n            j >> 8 as std::os::raw::c_int |\n                (*block.offset((i - 3 as std::os::raw::c_int) as isize) as UInt16 as\n                     std::os::raw::c_int) << 8 as std::os::raw::c_int;\n        let ref mut fresh7 = *ftab.offset(j as isize);\n        *fresh7 = (*fresh7).wrapping_add(1);\n        i -= 4 as std::os::raw::c_int\n    }\n    while i >= 0 as std::os::raw::c_int {\n        *quadrant.offset(i as isize) = 0 as std::os::raw::c_int as UInt16;\n        j =\n            j >> 8 as std::os::raw::c_int |\n                (*block.offset(i as isize) as UInt16 as std::os::raw::c_int) <<\n                    8 as std::os::raw::c_int;\n        let ref mut fresh8 = *ftab.offset(j as isize);\n        *fresh8 = (*fresh8).wrapping_add(1);\n        i -= 1\n    }\n    /*-- (emphasises close relationship of block & quadrant) --*/\n    i = 0 as std::os::raw::c_int;\n    while i <\n              2 as std::os::raw::c_int + 12 as std::os::raw::c_int + 18 as std::os::raw::c_int +\n                  2 as std::os::raw::c_int {\n        *block.offset((nblock + i) as isize) = *block.offset(i as isize);\n        *quadrant.offset((nblock + i) as isize) = 0 as std::os::raw::c_int as UInt16;\n        i += 1\n    }\n    if verb >= 4 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"        bucket sorting ...\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char);\n    }\n    /*-- Complete the initial radix sort --*/\n    i = 1 as std::os::raw::c_int;\n    while i <= 65536 as std::os::raw::c_int {\n        let ref mut fresh9 = *ftab.offset(i as isize);\n        *fresh9 =\n            (*fresh9 as\n                 std::os::raw::c_uint).wrapping_add(*ftab.offset((i -\n                                                              1 as\n                                                                  std::os::raw::c_int)\n                                                             as isize)) as\n                UInt32 as UInt32;\n        i += 1\n    }\n    s =\n        ((*block.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int) <<\n             8 as std::os::raw::c_int) as UInt16;\n    i = nblock - 1 as std::os::raw::c_int;\n    while i >= 3 as std::os::raw::c_int {\n        s =\n            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |\n                 (*block.offset(i as isize) as std::os::raw::c_int) <<\n                     8 as std::os::raw::c_int) as UInt16;\n        j =\n            (*ftab.offset(s as\n                              isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                       std::os::raw::c_uint) as Int32;\n        *ftab.offset(s as isize) = j as UInt32;\n        *ptr.offset(j as isize) = i as UInt32;\n        s =\n            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |\n                 (*block.offset((i - 1 as std::os::raw::c_int) as isize) as\n                      std::os::raw::c_int) << 8 as std::os::raw::c_int) as UInt16;\n        j =\n            (*ftab.offset(s as\n                              isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                       std::os::raw::c_uint) as Int32;\n        *ftab.offset(s as isize) = j as UInt32;\n        *ptr.offset(j as isize) = (i - 1 as std::os::raw::c_int) as UInt32;\n        s =\n            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |\n                 (*block.offset((i - 2 as std::os::raw::c_int) as isize) as\n                      std::os::raw::c_int) << 8 as std::os::raw::c_int) as UInt16;\n        j =\n            (*ftab.offset(s as\n                              isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                       std::os::raw::c_uint) as Int32;\n        *ftab.offset(s as isize) = j as UInt32;\n        *ptr.offset(j as isize) = (i - 2 as std::os::raw::c_int) as UInt32;\n        s =\n            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |\n                 (*block.offset((i - 3 as std::os::raw::c_int) as isize) as\n                      std::os::raw::c_int) << 8 as std::os::raw::c_int) as UInt16;\n        j =\n            (*ftab.offset(s as\n                              isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                       std::os::raw::c_uint) as Int32;\n        *ftab.offset(s as isize) = j as UInt32;\n        *ptr.offset(j as isize) = (i - 3 as std::os::raw::c_int) as UInt32;\n        i -= 4 as std::os::raw::c_int\n    }\n    while i >= 0 as std::os::raw::c_int {\n        s =\n            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |\n                 (*block.offset(i as isize) as std::os::raw::c_int) <<\n                     8 as std::os::raw::c_int) as UInt16;\n        j =\n            (*ftab.offset(s as\n                              isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                       std::os::raw::c_uint) as Int32;\n        *ftab.offset(s as isize) = j as UInt32;\n        *ptr.offset(j as isize) = i as UInt32;\n        i -= 1\n    }\n    /*--\n      Now ftab contains the first loc of every small bucket.\n      Calculate the running order, from smallest to largest\n      big bucket.\n   --*/\n    i = 0 as std::os::raw::c_int;\n    while i <= 255 as std::os::raw::c_int {\n        bigDone[i as usize] = 0 as std::os::raw::c_int as Bool;\n        runningOrder[i as usize] = i;\n        i += 1\n    }\n    let mut vv: Int32 = 0;\n    let mut h: Int32 = 1 as std::os::raw::c_int;\n    loop  {\n        h = 3 as std::os::raw::c_int * h + 1 as std::os::raw::c_int;\n        if !(h <= 256 as std::os::raw::c_int) { break ; }\n    }\n    loop  {\n        h = h / 3 as std::os::raw::c_int;\n        i = h;\n        while i <= 255 as std::os::raw::c_int {\n            vv = runningOrder[i as usize];\n            j = i;\n            while (*ftab.offset(((runningOrder[(j - h) as usize] +\n                                      1 as std::os::raw::c_int) << 8 as std::os::raw::c_int)\n                                    as\n                                    isize)).wrapping_sub(*ftab.offset((runningOrder[(j\n                                                                                         -\n                                                                                         h)\n                                                                                        as\n                                                                                        usize]\n                                                                           <<\n                                                                           8\n                                                                               as\n                                                                               std::os::raw::c_int)\n                                                                          as\n                                                                          isize))\n                      >\n                      (*ftab.offset(((vv + 1 as std::os::raw::c_int) <<\n                                         8 as std::os::raw::c_int) as\n                                        isize)).wrapping_sub(*ftab.offset((vv\n                                                                               <<\n                                                                               8\n                                                                                   as\n                                                                                   std::os::raw::c_int)\n                                                                              as\n                                                                              isize))\n                  {\n                runningOrder[j as usize] = runningOrder[(j - h) as usize];\n                j = j - h;\n                if j <= h - 1 as std::os::raw::c_int { break ; }\n            }\n            runningOrder[j as usize] = vv;\n            i += 1\n        }\n        if !(h != 1 as std::os::raw::c_int) { break ; }\n    }\n    /*--\n      The main sorting loop.\n   --*/\n    numQSorted = 0 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n    while i <= 255 as std::os::raw::c_int {\n        /*--\n         Process big buckets, starting with the least full.\n         Basically this is a 3-step process in which we call\n         mainQSort3 to sort the small buckets [ss, j], but\n         also make a big effort to avoid the calls if we can.\n      --*/\n        ss = runningOrder[i as usize];\n        /*--\n         Step 1:\n         Complete the big bucket [ss] by quicksorting\n         any unsorted small buckets [ss, j], for j != ss.  \n         Hopefully previous pointer-scanning phases have already\n         completed many of the small buckets [ss, j], so\n         we don't have to sort them at all.\n      --*/\n        j = 0 as std::os::raw::c_int;\n        while j <= 255 as std::os::raw::c_int {\n            if j != ss {\n                sb = (ss << 8 as std::os::raw::c_int) + j;\n                if *ftab.offset(sb as isize) &\n                       ((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                           std::os::raw::c_uint == 0 {\n                    let mut lo: Int32 =\n                        (*ftab.offset(sb as isize) &\n                             !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                                 std::os::raw::c_uint) as Int32;\n                    let mut hi: Int32 =\n                        (*ftab.offset((sb + 1 as std::os::raw::c_int) as isize) &\n                             !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                                 std::os::raw::c_uint).wrapping_sub(1 as std::os::raw::c_int\n                                                                as\n                                                                std::os::raw::c_uint)\n                            as Int32;\n                    if hi > lo {\n                        if verb >= 4 as std::os::raw::c_int {\n                            fprintf(__stderrp,\n                                    b\"        qsort [0x%x, 0x%x]   done %d   this %d\\n\\x00\"\n                                        as *const u8 as *const std::os::raw::c_char,\n                                    ss, j, numQSorted,\n                                    hi - lo + 1 as std::os::raw::c_int);\n                        }\n                        mainQSort3(ptr, block, quadrant, nblock, lo, hi,\n                                   2 as std::os::raw::c_int, budget);\n                        numQSorted += hi - lo + 1 as std::os::raw::c_int;\n                        if *budget < 0 as std::os::raw::c_int { return }\n                    }\n                }\n                let ref mut fresh10 = *ftab.offset(sb as isize);\n                *fresh10 |=\n                    ((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as std::os::raw::c_uint\n            }\n            j += 1\n        }\n        if bigDone[ss as usize] != 0 {\n            BZ2_bz__AssertH__fail(1006 as std::os::raw::c_int);\n        }\n        /*--\n         Step 2:\n         Now scan this big bucket [ss] so as to synthesise the\n         sorted order for small buckets [t, ss] for all t,\n         including, magically, the bucket [ss,ss] too.\n         This will avoid doing Real Work in subsequent Step 1's.\n      --*/\n        j = 0 as std::os::raw::c_int;\n        while j <= 255 as std::os::raw::c_int {\n            copyStart[j as usize] =\n                (*ftab.offset(((j << 8 as std::os::raw::c_int) + ss) as isize) &\n                     !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                         std::os::raw::c_uint) as Int32;\n            copyEnd[j as usize] =\n                (*ftab.offset(((j << 8 as std::os::raw::c_int) + ss +\n                                   1 as std::os::raw::c_int) as isize) &\n                     !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                         std::os::raw::c_uint).wrapping_sub(1 as std::os::raw::c_int as\n                                                        std::os::raw::c_uint) as\n                    Int32;\n            j += 1\n        }\n        j =\n            (*ftab.offset((ss << 8 as std::os::raw::c_int) as isize) &\n                 !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as std::os::raw::c_uint)\n                as Int32;\n        while j < copyStart[ss as usize] {\n            k =\n                (*ptr.offset(j as\n                                 isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                          std::os::raw::c_uint) as\n                    Int32;\n            if k < 0 as std::os::raw::c_int { k += nblock }\n            c1 = *block.offset(k as isize);\n            if bigDone[c1 as usize] == 0 {\n                let fresh11 = copyStart[c1 as usize];\n                copyStart[c1 as usize] = copyStart[c1 as usize] + 1;\n                *ptr.offset(fresh11 as isize) = k as UInt32\n            }\n            j += 1\n        }\n        j =\n            (*ftab.offset(((ss + 1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) as\n                              isize) &\n                 !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                     std::os::raw::c_uint).wrapping_sub(1 as std::os::raw::c_int as\n                                                    std::os::raw::c_uint) as Int32;\n        while j > copyEnd[ss as usize] {\n            k =\n                (*ptr.offset(j as\n                                 isize)).wrapping_sub(1 as std::os::raw::c_int as\n                                                          std::os::raw::c_uint) as\n                    Int32;\n            if k < 0 as std::os::raw::c_int { k += nblock }\n            c1 = *block.offset(k as isize);\n            if bigDone[c1 as usize] == 0 {\n                let fresh12 = copyEnd[c1 as usize];\n                copyEnd[c1 as usize] = copyEnd[c1 as usize] - 1;\n                *ptr.offset(fresh12 as isize) = k as UInt32\n            }\n            j -= 1\n        }\n        if !(copyStart[ss as usize] - 1 as std::os::raw::c_int == copyEnd[ss as usize]\n                 ||\n                 copyStart[ss as usize] == 0 as std::os::raw::c_int &&\n                     copyEnd[ss as usize] == nblock - 1 as std::os::raw::c_int) {\n            BZ2_bz__AssertH__fail(1007 as std::os::raw::c_int);\n        }\n        j = 0 as std::os::raw::c_int;\n        while j <= 255 as std::os::raw::c_int {\n            let ref mut fresh13 =\n                *ftab.offset(((j << 8 as std::os::raw::c_int) + ss) as isize);\n            *fresh13 |=\n                ((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as std::os::raw::c_uint;\n            j += 1\n        }\n        /*--\n         Step 3:\n         The [ss] big bucket is now done.  Record this fact,\n         and update the quadrant descriptors.  Remember to\n         update quadrants in the overshoot area too, if\n         necessary.  The \"if (i < 255)\" test merely skips\n         this updating for the last bucket processed, since\n         updating for the last bucket is pointless.\n\n         The quadrant array provides a way to incrementally\n         cache sort orderings, as they appear, so as to \n         make subsequent comparisons in fullGtU() complete\n         faster.  For repetitive blocks this makes a big\n         difference (but not big enough to be able to avoid\n         the fallback sorting mechanism, exponential radix sort).\n\n         The precise meaning is: at all times:\n\n            for 0 <= i < nblock and 0 <= j <= nblock\n\n            if block[i] != block[j], \n\n               then the relative values of quadrant[i] and \n                    quadrant[j] are meaningless.\n\n               else {\n                  if quadrant[i] < quadrant[j]\n                     then the string starting at i lexicographically\n                     precedes the string starting at j\n\n                  else if quadrant[i] > quadrant[j]\n                     then the string starting at j lexicographically\n                     precedes the string starting at i\n\n                  else\n                     the relative ordering of the strings starting\n                     at i and j has not yet been determined.\n               }\n      --*/\n        bigDone[ss as usize] = 1 as std::os::raw::c_int as Bool;\n        if i < 255 as std::os::raw::c_int {\n            let mut bbStart: Int32 =\n                (*ftab.offset((ss << 8 as std::os::raw::c_int) as isize) &\n                     !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                         std::os::raw::c_uint) as Int32;\n            let mut bbSize: Int32 =\n                (*ftab.offset(((ss + 1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) as\n                                  isize) &\n                     !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as\n                         std::os::raw::c_uint).wrapping_sub(bbStart as std::os::raw::c_uint)\n                    as Int32;\n            let mut shifts: Int32 = 0 as std::os::raw::c_int;\n            while bbSize >> shifts > 65534 as std::os::raw::c_int { shifts += 1 }\n            j = bbSize - 1 as std::os::raw::c_int;\n            while j >= 0 as std::os::raw::c_int {\n                let mut a2update: Int32 =\n                    *ptr.offset((bbStart + j) as isize) as Int32;\n                let mut qVal: UInt16 = (j >> shifts) as UInt16;\n                *quadrant.offset(a2update as isize) = qVal;\n                if a2update <\n                       2 as std::os::raw::c_int + 12 as std::os::raw::c_int +\n                           18 as std::os::raw::c_int + 2 as std::os::raw::c_int {\n                    *quadrant.offset((a2update + nblock) as isize) = qVal\n                }\n                j -= 1\n            }\n            if !(bbSize - 1 as std::os::raw::c_int >> shifts <= 65535 as std::os::raw::c_int)\n               {\n                BZ2_bz__AssertH__fail(1002 as std::os::raw::c_int);\n            }\n        }\n        i += 1\n    }\n    if verb >= 4 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"        %d pointers, %d sorted, %d scanned\\n\\x00\" as\n                    *const u8 as *const std::os::raw::c_char, nblock, numQSorted,\n                nblock - numQSorted);\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:58 ~ c2rust_out[3c70]::blocksort::BZ2_blockSort)",
        "span": "blocksort.rs:1603:9: 1603:73 (#0)",
        "source": "mainSort(ptr, block, quadrant, ftab, nblock, verb, &mut budget);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:11:1: 11:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:332 ~ c2rust_out[3c70]::bzip2recover::tooManyBlocks)",
    "span": "bzip2recover.rs:146:1: 158:2 (#0)",
    "pieces": [
      "bzip2recover.rs:146:1: 158:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn tooManyBlocks(mut max_handled_blocks: Int32) {\n    fprintf(__stderrp,\n            b\"%s: `%s\\' appears to contain more than %d blocks\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr(),\n            inFileName.as_mut_ptr(), max_handled_blocks);\n    fprintf(__stderrp,\n            b\"%s: and cannot be handled.  To fix, increase\\n\\x00\" as *const u8\n                as *const std::os::raw::c_char, progName.as_mut_ptr());\n    fprintf(__stderrp,\n            b\"%s: BZ_MAX_HANDLED_BLOCKS in bzip2recover.c, and recompile.\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());\n    exit(1 as std::os::raw::c_int);\n}",
    "calls": [],
    "globals": [
      {
        "span": "bzip2recover.rs:102:1: 102:51 (#0)",
        "source": "pub static mut progName: [Char; 2000] = [0; 2000];"
      },
      {
        "span": "bzip2recover.rs:99:1: 99:53 (#0)",
        "source": "pub static mut inFileName: [Char; 2000] = [0; 2000];"
      }
    ],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:337 ~ c2rust_out[3c70]::bzip2recover::bsClose)",
    "span": "bzip2recover.rs:226:1: 246:2 (#0)",
    "pieces": [
      "bzip2recover.rs:226:1: 246:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn bsClose(mut bs: *mut BitStream) {\n    let mut retVal: Int32 = 0;\n    if (*bs).mode as std::os::raw::c_int == 'w' as i32 {\n        while (*bs).buffLive < 8 as std::os::raw::c_int {\n            (*bs).buffLive += 1;\n            (*bs).buffer <<= 1 as std::os::raw::c_int\n        }\n        retVal = putc((*bs).buffer as UChar as std::os::raw::c_int, (*bs).handle);\n        if retVal == -(1 as std::os::raw::c_int) { writeError(); }\n        bytesOut = bytesOut.wrapping_add(1);\n        retVal = fflush((*bs).handle);\n        if retVal == -(1 as std::os::raw::c_int) { writeError(); }\n    }\n    retVal = fclose((*bs).handle);\n    if retVal == -(1 as std::os::raw::c_int) {\n        if (*bs).mode as std::os::raw::c_int == 'w' as i32 {\n            writeError();\n        } else { readError(); }\n    }\n    free(bs as *mut std::os::raw::c_void);\n}",
    "calls": [
      {
        "caller": "DefId(0:353 ~ c2rust_out[3c70]::bzip2recover::main_0)",
        "span": "bzip2recover.rs:431:5: 431:19 (#0)",
        "source": "bsClose(bsIn);"
      }
    ],
    "globals": [
      {
        "span": "bzip2recover.rs:104:1: 104:80 (#0)",
        "source": "pub static mut bytesOut: MaybeUInt64 = 0 as std::os::raw::c_int as MaybeUInt64;"
      }
    ],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:331 ~ c2rust_out[3c70]::bzip2recover::mallocFail)",
    "span": "bzip2recover.rs:136:1: 144:2 (#0)",
    "pieces": [
      "bzip2recover.rs:136:1: 144:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn mallocFail(mut n: Int32) {\n    fprintf(__stderrp,\n            b\"%s: malloc failed on request for %d bytes.\\n\\x00\" as *const u8\n                as *const std::os::raw::c_char, progName.as_mut_ptr(), n);\n    fprintf(__stderrp,\n            b\"%s: warning: output file(s) may be incomplete.\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());\n    exit(1 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:334 ~ c2rust_out[3c70]::bzip2recover::bsOpenWriteStream)",
        "span": "bzip2recover.rs:182:9: 183:31 (#0)",
        "source": "mallocFail(::std::mem::size_of::<BitStream>() as std::os::raw::c_ulong as\n                       Int32);"
      },
      {
        "caller": "DefId(0:333 ~ c2rust_out[3c70]::bzip2recover::bsOpenReadStream)",
        "span": "bzip2recover.rs:166:9: 167:31 (#0)",
        "source": "mallocFail(::std::mem::size_of::<BitStream>() as std::os::raw::c_ulong as\n                       Int32);"
      }
    ],
    "globals": [
      {
        "span": "bzip2recover.rs:102:1: 102:51 (#0)",
        "source": "pub static mut progName: [Char; 2000] = [0; 2000];"
      }
    ],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:333 ~ c2rust_out[3c70]::bzip2recover::bsOpenReadStream)",
    "span": "bzip2recover.rs:160:1: 174:2 (#0)",
    "pieces": [
      "bzip2recover.rs:160:1: 174:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn bsOpenReadStream(mut stream: *mut FILE)\n -> *mut BitStream {\n    let mut bs: *mut BitStream =\n        malloc(::std::mem::size_of::<BitStream>() as std::os::raw::c_ulong) as\n            *mut BitStream;\n    if bs.is_null() {\n        mallocFail(::std::mem::size_of::<BitStream>() as std::os::raw::c_ulong as\n                       Int32);\n    }\n    (*bs).handle = stream;\n    (*bs).buffer = 0 as std::os::raw::c_int;\n    (*bs).buffLive = 0 as std::os::raw::c_int;\n    (*bs).mode = 'r' as i32 as Char;\n    return bs;\n}",
    "calls": [
      {
        "caller": "DefId(0:353 ~ c2rust_out[3c70]::bzip2recover::main_0)",
        "span": "bzip2recover.rs:360:5: 360:37 (#0)",
        "source": "bsIn = bsOpenReadStream(inFile);"
      },
      {
        "caller": "DefId(0:353 ~ c2rust_out[3c70]::bzip2recover::main_0)",
        "span": "bzip2recover.rs:452:5: 452:37 (#0)",
        "source": "bsIn = bsOpenReadStream(inFile);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:353 ~ c2rust_out[3c70]::bzip2recover::main_0)",
    "span": "bzip2recover.rs:288:1: 560:2 (#0)",
    "pieces": [
      "bzip2recover.rs:288:1: 560:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 273,
    "source": "unsafe fn main_0(mut argc: Int32, mut argv: *mut *mut Char) -> Int32 {\n    let mut inFile: *mut FILE = 0 as *mut FILE;\n    let mut outFile: *mut FILE = 0 as *mut FILE;\n    let mut bsIn: *mut BitStream = 0 as *mut BitStream;\n    let mut bsWr: *mut BitStream = 0 as *mut BitStream;\n    let mut b: Int32 = 0;\n    let mut wrBlock: Int32 = 0;\n    let mut currBlock: Int32 = 0;\n    let mut rbCtr: Int32 = 0;\n    let mut bitsRead: MaybeUInt64 = 0;\n    let mut buffHi: UInt32 = 0;\n    let mut buffLo: UInt32 = 0;\n    let mut blockCRC: UInt32 = 0;\n    let mut p: *mut Char = 0 as *mut Char;\n    strncpy(progName.as_mut_ptr(), *argv.offset(0 as std::os::raw::c_int as isize),\n            (2000 as std::os::raw::c_int - 1 as std::os::raw::c_int) as std::os::raw::c_ulong);\n    progName[(2000 as std::os::raw::c_int - 1 as std::os::raw::c_int) as usize] =\n        '\\u{0}' as i32 as Char;\n    outFileName[0 as std::os::raw::c_int as usize] = 0 as std::os::raw::c_int as Char;\n    inFileName[0 as std::os::raw::c_int as usize] =\n        outFileName[0 as std::os::raw::c_int as usize];\n    fprintf(__stderrp,\n            b\"bzip2recover 1.0.8: extracts blocks from damaged .bz2 files.\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char);\n    if argc != 2 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"%s: usage is `%s damaged_file_name\\'.\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, progName.as_mut_ptr(),\n                progName.as_mut_ptr());\n        match ::std::mem::size_of::<MaybeUInt64>() as std::os::raw::c_ulong {\n            8 => {\n                fprintf(__stderrp,\n                        b\"\\trestrictions on size of recovered file: None\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char);\n            }\n            4 => {\n                fprintf(__stderrp,\n                        b\"\\trestrictions on size of recovered file: 512 MB\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char);\n                fprintf(__stderrp,\n                        b\"\\tto circumvent, recompile with MaybeUInt64 as an\\n\\tunsigned 64-bit int.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char);\n            }\n            _ => {\n                fprintf(__stderrp,\n                        b\"\\tsizeof(MaybeUInt64) is not 4 or 8 -- configuration error.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char);\n            }\n        }\n        exit(1 as std::os::raw::c_int);\n    }\n    if strlen(*argv.offset(1 as std::os::raw::c_int as isize)) >=\n           (2000 as std::os::raw::c_int - 20 as std::os::raw::c_int) as std::os::raw::c_ulong {\n        fprintf(__stderrp,\n                b\"%s: supplied filename is suspiciously (>= %d chars) long.  Bye!\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char,\n                progName.as_mut_ptr(),\n                strlen(*argv.offset(1 as std::os::raw::c_int as isize)) as\n                    std::os::raw::c_int);\n        exit(1 as std::os::raw::c_int);\n    }\n    strcpy(inFileName.as_mut_ptr(), *argv.offset(1 as std::os::raw::c_int as isize));\n    inFile =\n        fopen(inFileName.as_mut_ptr(),\n              b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n    if inFile.is_null() {\n        fprintf(__stderrp,\n                b\"%s: can\\'t read `%s\\'\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, progName.as_mut_ptr(),\n                inFileName.as_mut_ptr());\n        exit(1 as std::os::raw::c_int);\n    }\n    bsIn = bsOpenReadStream(inFile);\n    fprintf(__stderrp,\n            b\"%s: searching for block boundaries ...\\n\\x00\" as *const u8 as\n                *const std::os::raw::c_char, progName.as_mut_ptr());\n    bitsRead = 0 as std::os::raw::c_int as MaybeUInt64;\n    buffLo = 0 as std::os::raw::c_int as UInt32;\n    buffHi = buffLo;\n    currBlock = 0 as std::os::raw::c_int;\n    bStart[currBlock as usize] = 0 as std::os::raw::c_int as MaybeUInt64;\n    rbCtr = 0 as std::os::raw::c_int;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        b = bsGetBit(bsIn);\n        bitsRead = bitsRead.wrapping_add(1);\n        if b == 2 as std::os::raw::c_int {\n            if bitsRead >= bStart[currBlock as usize] &&\n                   bitsRead.wrapping_sub(bStart[currBlock as usize]) >=\n                       40 as std::os::raw::c_int as std::os::raw::c_ulonglong {\n                bEnd[currBlock as usize] =\n                    bitsRead.wrapping_sub(1 as std::os::raw::c_int as\n                                              std::os::raw::c_ulonglong);\n                if currBlock > 0 as std::os::raw::c_int {\n                    fprintf(__stderrp,\n                            b\"   block %d runs from %Lu to %Lu (incomplete)\\n\\x00\"\n                                as *const u8 as *const std::os::raw::c_char,\n                            currBlock, bStart[currBlock as usize],\n                            bEnd[currBlock as usize]);\n                }\n            } else { currBlock -= 1 }\n            break ;\n        } else {\n            buffHi = buffHi << 1 as std::os::raw::c_int | buffLo >> 31 as std::os::raw::c_int;\n            buffLo =\n                buffLo << 1 as std::os::raw::c_int |\n                    (b & 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n            if (buffHi & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as\n                   std::os::raw::c_ulong == 0x3141 as std::os::raw::c_ulong &&\n                   buffLo as std::os::raw::c_ulong == 0x59265359 as std::os::raw::c_ulong ||\n                   (buffHi & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as\n                       std::os::raw::c_ulong == 0x1772 as std::os::raw::c_ulong &&\n                       buffLo as std::os::raw::c_ulong == 0x45385090 as std::os::raw::c_ulong\n               {\n                if bitsRead > 49 as std::os::raw::c_int as std::os::raw::c_ulonglong {\n                    bEnd[currBlock as usize] =\n                        bitsRead.wrapping_sub(49 as std::os::raw::c_int as\n                                                  std::os::raw::c_ulonglong)\n                } else {\n                    bEnd[currBlock as usize] = 0 as std::os::raw::c_int as MaybeUInt64\n                }\n                if currBlock > 0 as std::os::raw::c_int &&\n                       bEnd[currBlock as\n                                usize].wrapping_sub(bStart[currBlock as\n                                                               usize]) >=\n                           130 as std::os::raw::c_int as std::os::raw::c_ulonglong {\n                    fprintf(__stderrp,\n                            b\"   block %d runs from %Lu to %Lu\\n\\x00\" as\n                                *const u8 as *const std::os::raw::c_char,\n                            rbCtr + 1 as std::os::raw::c_int,\n                            bStart[currBlock as usize],\n                            bEnd[currBlock as usize]);\n                    rbStart[rbCtr as usize] = bStart[currBlock as usize];\n                    rbEnd[rbCtr as usize] = bEnd[currBlock as usize];\n                    rbCtr += 1\n                }\n                if currBlock >= 50000 as std::os::raw::c_int {\n                    tooManyBlocks(50000 as std::os::raw::c_int);\n                }\n                currBlock += 1;\n                bStart[currBlock as usize] = bitsRead\n            }\n        }\n    }\n    bsClose(bsIn);\n    /*-- identified blocks run from 1 to rbCtr inclusive. --*/\n    if rbCtr < 1 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"%s: sorry, I couldn\\'t find any block boundaries.\\n\\x00\" as\n                    *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());\n        exit(1 as std::os::raw::c_int);\n    }\n    fprintf(__stderrp,\n            b\"%s: splitting into blocks\\n\\x00\" as *const u8 as\n                *const std::os::raw::c_char, progName.as_mut_ptr());\n    inFile =\n        fopen(inFileName.as_mut_ptr(),\n              b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n    if inFile.is_null() {\n        fprintf(__stderrp,\n                b\"%s: can\\'t open `%s\\'\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, progName.as_mut_ptr(),\n                inFileName.as_mut_ptr());\n        exit(1 as std::os::raw::c_int);\n    }\n    bsIn = bsOpenReadStream(inFile);\n    /*-- placate gcc's dataflow analyser --*/\n    blockCRC = 0 as std::os::raw::c_int as UInt32;\n    bsWr = 0 as *mut BitStream;\n    bitsRead = 0 as std::os::raw::c_int as MaybeUInt64;\n    outFile = 0 as *mut FILE;\n    wrBlock = 0 as std::os::raw::c_int;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        b = bsGetBit(bsIn);\n        if b == 2 as std::os::raw::c_int { break ; }\n        buffHi = buffHi << 1 as std::os::raw::c_int | buffLo >> 31 as std::os::raw::c_int;\n        buffLo =\n            buffLo << 1 as std::os::raw::c_int |\n                (b & 1 as std::os::raw::c_int) as std::os::raw::c_uint;\n        if bitsRead ==\n               (47 as std::os::raw::c_int as\n                    std::os::raw::c_ulonglong).wrapping_add(rbStart[wrBlock as usize])\n           {\n            blockCRC =\n                buffHi << 16 as std::os::raw::c_int | buffLo >> 16 as std::os::raw::c_int\n        }\n        if !outFile.is_null() && bitsRead >= rbStart[wrBlock as usize] &&\n               bitsRead <= rbEnd[wrBlock as usize] {\n            bsPutBit(bsWr, b);\n        }\n        bitsRead = bitsRead.wrapping_add(1);\n        if bitsRead ==\n               rbEnd[wrBlock as\n                         usize].wrapping_add(1 as std::os::raw::c_int as\n                                                 std::os::raw::c_ulonglong) {\n            if !outFile.is_null() {\n                bsPutUChar(bsWr, 0x17 as std::os::raw::c_int as UChar);\n                bsPutUChar(bsWr, 0x72 as std::os::raw::c_int as UChar);\n                bsPutUChar(bsWr, 0x45 as std::os::raw::c_int as UChar);\n                bsPutUChar(bsWr, 0x38 as std::os::raw::c_int as UChar);\n                bsPutUChar(bsWr, 0x50 as std::os::raw::c_int as UChar);\n                bsPutUChar(bsWr, 0x90 as std::os::raw::c_int as UChar);\n                bsPutUInt32(bsWr, blockCRC);\n                bsClose(bsWr);\n                outFile = 0 as *mut FILE\n            }\n            if wrBlock >= rbCtr { break ; }\n            wrBlock += 1\n        } else if bitsRead == rbStart[wrBlock as usize] {\n            /* Create the output file name, correctly handling leading paths. \n            (31.10.2001 by Sergey E. Kusikov) */\n            let mut split: *mut Char = 0 as *mut Char;\n            let mut ofs: Int32 = 0;\n            let mut k: Int32 = 0;\n            k = 0 as std::os::raw::c_int;\n            while k < 2000 as std::os::raw::c_int {\n                outFileName[k as usize] = 0 as std::os::raw::c_int as Char;\n                k += 1\n            }\n            strcpy(outFileName.as_mut_ptr(), inFileName.as_mut_ptr());\n            split = strrchr(outFileName.as_mut_ptr(), '/' as i32);\n            if split.is_null() {\n                split = outFileName.as_mut_ptr()\n            } else { split = split.offset(1) }\n            /* Now split points to the start of the basename. */\n            ofs =\n                split.offset_from(outFileName.as_mut_ptr()) as\n                    std::os::raw::c_long as Int32;\n            sprintf(split, b\"rec%5d\\x00\" as *const u8 as *const std::os::raw::c_char,\n                    wrBlock + 1 as std::os::raw::c_int);\n            p = split;\n            while *p as std::os::raw::c_int != 0 as std::os::raw::c_int {\n                if *p as std::os::raw::c_int == ' ' as i32 { *p = '0' as i32 as Char }\n                p = p.offset(1)\n            }\n            strcat(outFileName.as_mut_ptr(),\n                   inFileName.as_mut_ptr().offset(ofs as isize));\n            if endsInBz2(outFileName.as_mut_ptr()) == 0 {\n                strcat(outFileName.as_mut_ptr(),\n                       b\".bz2\\x00\" as *const u8 as *const std::os::raw::c_char);\n            }\n            fprintf(__stderrp,\n                    b\"   writing block %d to `%s\\' ...\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, wrBlock + 1 as std::os::raw::c_int,\n                    outFileName.as_mut_ptr());\n            outFile =\n                fopen(outFileName.as_mut_ptr(),\n                      b\"wb\\x00\" as *const u8 as *const std::os::raw::c_char);\n            if outFile.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: can\\'t write `%s\\'\\n\\x00\" as *const u8 as\n                            *const std::os::raw::c_char, progName.as_mut_ptr(),\n                        outFileName.as_mut_ptr());\n                exit(1 as std::os::raw::c_int);\n            }\n            bsWr = bsOpenWriteStream(outFile);\n            bsPutUChar(bsWr, 0x42 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x5a as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x68 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr,\n                       (0x30 as std::os::raw::c_int + 9 as std::os::raw::c_int) as UChar);\n            bsPutUChar(bsWr, 0x31 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x41 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x59 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x26 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x53 as std::os::raw::c_int as UChar);\n            bsPutUChar(bsWr, 0x59 as std::os::raw::c_int as UChar);\n        }\n    }\n    fprintf(__stderrp,\n            b\"%s: finished\\n\\x00\" as *const u8 as *const std::os::raw::c_char,\n            progName.as_mut_ptr());\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:354 ~ c2rust_out[3c70]::bzip2recover::main)",
        "span": "bzip2recover.rs:567:5: 571:6 (#0)",
        "source": "unsafe {\n        ::std::process::exit(main_0((args.len() - 1) as Int32,\n                                    args.as_mut_ptr() as *mut *mut Char) as\n                                 i32)\n    }"
      }
    ],
    "globals": [
      {
        "span": "bzip2recover.rs:101:1: 101:54 (#0)",
        "source": "pub static mut outFileName: [Char; 2000] = [0; 2000];"
      },
      {
        "span": "bzip2recover.rs:99:1: 99:53 (#0)",
        "source": "pub static mut inFileName: [Char; 2000] = [0; 2000];"
      },
      {
        "span": "bzip2recover.rs:102:1: 102:51 (#0)",
        "source": "pub static mut progName: [Char; 2000] = [0; 2000];"
      },
      {
        "span": "bzip2recover.rs:281:1: 281:58 (#0)",
        "source": "pub static mut bStart: [MaybeUInt64; 50000] = [0; 50000];"
      }
    ],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:176 ~ c2rust_out[3c70]::bzip2::__istype)",
    "span": "bzip2.rs:295:1: 301:2 (#0)",
    "pieces": [
      "bzip2.rs:295:1: 301:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn __istype(mut _c: __darwin_ct_rune_t,\n                              mut _f: std::os::raw::c_ulong) -> std::os::raw::c_int {\n    return if isascii(_c) != 0 {\n               (_DefaultRuneLocale.__runetype[_c as usize] as std::os::raw::c_ulong &\n                    _f != 0) as std::os::raw::c_int\n           } else { (__maskrune(_c, _f) != 0) as std::os::raw::c_int };\n}",
    "calls": [
      {
        "caller": "DefId(0:177 ~ c2rust_out[3c70]::bzip2::isspace)",
        "span": "bzip2.rs:306:5: 306:82 (#0)",
        "source": "return __istype(_c, 0x4000 as std::os::raw::c_long as std::os::raw::c_ulong);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:277 ~ c2rust_out[3c70]::bzip2::myMalloc)",
    "span": "bzip2.rs:2671:1: 2676:2 (#0)",
    "pieces": [
      "bzip2.rs:2671:1: 2676:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn myMalloc(mut n: Int32) -> *mut std::os::raw::c_void {\n    let mut p: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    p = malloc(n as size_t);\n    if p.is_null() { outOfMemory(); }\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:279 ~ c2rust_out[3c70]::bzip2::snocString)",
        "span": "bzip2.rs:2692:9: 2695:30 (#0)",
        "source": "(*tmp).name =\n            myMalloc((5 as std::os::raw::c_int as\n                          std::os::raw::c_ulong).wrapping_add(strlen(name)) as Int32)\n                as *mut Char;"
      },
      {
        "caller": "DefId(0:278 ~ c2rust_out[3c70]::bzip2::mkCell)",
        "span": "bzip2.rs:2680:5: 2682:23 (#0)",
        "source": "c =\n        myMalloc(::std::mem::size_of::<Cell>() as std::os::raw::c_ulong as Int32) as\n            *mut Cell;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:177 ~ c2rust_out[3c70]::bzip2::isspace)",
    "span": "bzip2.rs:305:1: 307:2 (#0)",
    "pieces": [
      "bzip2.rs:305:1: 307:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn isspace(mut _c: std::os::raw::c_int) -> std::os::raw::c_int {\n    return __istype(_c, 0x4000 as std::os::raw::c_long as std::os::raw::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:417 ~ c2rust_out[3c70]::bzlib::default_bzalloc)",
    "span": "bzlib.rs:253:1: 258:2 (#0)",
    "pieces": [
      "bzlib.rs:253:1: 258:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn default_bzalloc(mut opaque: *mut std::os::raw::c_void,\n                                     mut items: Int32, mut size: Int32)\n -> *mut std::os::raw::c_void {\n    let mut v: *mut std::os::raw::c_void = malloc((items * size) as std::os::raw::c_ulong);\n    return v;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:276 ~ c2rust_out[3c70]::bzip2::redundant)",
    "span": "bzip2.rs:2665:1: 2669:2 (#0)",
    "pieces": [
      "bzip2.rs:2665:1: 2669:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn redundant(mut flag: *mut Char) {\n    fprintf(__stderrp,\n            b\"%s: %s is redundant in versions 0.9.5 and above\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName, flag);\n}",
    "calls": [],
    "globals": [
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:236 ~ c2rust_out[3c70]::bzip2::cadvise)",
    "span": "bzip2.rs:1612:1: 1618:2 (#0)",
    "pieces": [
      "bzip2.rs:1612:1: 1618:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn cadvise() {\n    if noisy != 0 {\n        fprintf(__stderrp,\n                b\"\\nIt is possible that the compressed file(s) have become corrupted.\\nYou can use the -tvv option to test integrity of such files.\\n\\nYou can use the `bzip2recover\\' program to attempt to recover\\ndata from undamaged sections of corrupted files.\\n\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char);\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:241 ~ c2rust_out[3c70]::bzip2::crcError)",
        "span": "bzip2.rs:1713:5: 1713:15 (#0)",
        "source": "cadvise();"
      },
      {
        "caller": "DefId(0:242 ~ c2rust_out[3c70]::bzip2::compressedStreamEOF)",
        "span": "bzip2.rs:1724:9: 1724:19 (#0)",
        "source": "cadvise();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:242 ~ c2rust_out[3c70]::bzip2::compressedStreamEOF)",
    "span": "bzip2.rs:1717:1: 1727:2 (#0)",
    "pieces": [
      "bzip2.rs:1717:1: 1727:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn compressedStreamEOF() -> ! {\n    if noisy != 0 {\n        fprintf(__stderrp,\n                b\"\\n%s: Compressed file ends unexpectedly;\\n\\tperhaps it is corrupted?  *Possible* reason follows.\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char, progName);\n        perror(progName);\n        showFileNames();\n        cadvise();\n    }\n    cleanUpAndFail(2 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1115:53: 1115:75 (#0)",
        "source": "compressedStreamEOF();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:911:53: 911:75 (#0)",
        "source": "compressedStreamEOF();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1013:53: 1013:75 (#0)",
        "source": "compressedStreamEOF();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:962:53: 962:75 (#0)",
        "source": "compressedStreamEOF();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:859:53: 859:75 (#0)",
        "source": "compressedStreamEOF();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1064:53: 1064:75 (#0)",
        "source": "compressedStreamEOF();"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:241 ~ c2rust_out[3c70]::bzip2::crcError)",
    "span": "bzip2.rs:1708:1: 1715:2 (#0)",
    "pieces": [
      "bzip2.rs:1708:1: 1715:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn crcError() -> ! {\n    fprintf(__stderrp,\n            b\"\\n%s: Data integrity error when decompressing.\\n\\x00\" as\n                *const u8 as *const std::os::raw::c_char, progName);\n    showFileNames();\n    cadvise();\n    cleanUpAndFail(2 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1007:53: 1007:64 (#0)",
        "source": "crcError();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:905:53: 905:64 (#0)",
        "source": "crcError();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:853:53: 853:64 (#0)",
        "source": "crcError();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:956:53: 956:64 (#0)",
        "source": "crcError();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1109:53: 1109:64 (#0)",
        "source": "crcError();"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:1058:53: 1058:64 (#0)",
        "source": "crcError();"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:442 ~ c2rust_out[3c70]::bzlib::BZ2_bzReadClose)",
    "span": "bzlib.rs:1972:1: 1989:2 (#0)",
    "pieces": [
      "bzlib.rs:1972:1: 1989:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn BZ2_bzReadClose(mut bzerror: *mut std::os::raw::c_int,\n                                         mut b: *mut std::os::raw::c_void) {\n    let mut bzf: *mut bzFile = b as *mut bzFile;\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    if bzf.is_null() {\n        if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n        if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n        return\n    }\n    if (*bzf).writing != 0 {\n        if !bzerror.is_null() { *bzerror = -(1 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(1 as std::os::raw::c_int) }\n        return\n    }\n    if (*bzf).initialisedOk != 0 { BZ2_bzDecompressEnd(&mut (*bzf).strm); }\n    free(bzf as *mut std::os::raw::c_void);\n}",
    "calls": [
      {
        "caller": "DefId(0:459 ~ c2rust_out[3c70]::bzlib::BZ2_bzclose)",
        "span": "bzlib.rs:2372:14: 2372:45 (#0)",
        "source": "BZ2_bzReadClose(&mut bzerr, b);"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:777:21: 777:54 (#0)",
        "source": "BZ2_bzReadClose(&mut bzerr, bzf);"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1336:17: 1336:56 (#0)",
        "source": "BZ2_bzReadClose(&mut bzerr_dummy, bzf);"
      },
      {
        "caller": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
        "span": "bzip2.rs:838:37: 838:76 (#0)",
        "source": "BZ2_bzReadClose(&mut bzerr_dummy, bzf);"
      },
      {
        "caller": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
        "span": "bzip2.rs:1310:17: 1310:50 (#0)",
        "source": "BZ2_bzReadClose(&mut bzerr, bzf);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:225 ~ c2rust_out[3c70]::bzip2::uncompressStream)",
    "span": "bzip2.rs:704:1: 1251:2 (#0)",
    "pieces": [
      "bzip2.rs:704:1: 1251:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 548,
    "source": "unsafe extern \"C\" fn uncompressStream(mut zStream: *mut FILE,\n                                      mut stream: *mut FILE) -> Bool {\n    let mut current_block: u64;\n    let mut bzf: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    let mut bzerr: Int32 = 0;\n    let mut bzerr_dummy: Int32 = 0;\n    let mut ret: Int32 = 0;\n    let mut nread: Int32 = 0;\n    let mut streamNo: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut obuf: [UChar; 5000] = [0; 5000];\n    let mut unused: [UChar; 5000] = [0; 5000];\n    let mut nUnused: Int32 = 0;\n    let mut unusedTmpV: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    let mut unusedTmp: *mut UChar = 0 as *mut UChar;\n    nUnused = 0 as std::os::raw::c_int;\n    streamNo = 0 as std::os::raw::c_int;\n    if !(ferror(stream) != 0) {\n        if !(ferror(zStream) != 0) {\n            's_51:\n                loop  {\n                    if !(1 as std::os::raw::c_int as Bool != 0) {\n                        current_block = 926243229934402080;\n                        break ;\n                    }\n                    bzf =\n                        BZ2_bzReadOpen(&mut bzerr, zStream, verbosity,\n                                       smallMode as std::os::raw::c_int,\n                                       unused.as_mut_ptr() as\n                                           *mut std::os::raw::c_void, nUnused);\n                    if bzf.is_null() || bzerr != 0 as std::os::raw::c_int {\n                        current_block = 673979509383251364;\n                        break ;\n                    }\n                    streamNo += 1;\n                    while bzerr == 0 as std::os::raw::c_int {\n                        nread =\n                            BZ2_bzRead(&mut bzerr, bzf,\n                                       obuf.as_mut_ptr() as *mut std::os::raw::c_void,\n                                       5000 as std::os::raw::c_int);\n                        if bzerr == -(5 as std::os::raw::c_int) {\n                            current_block = 18063049917807660484;\n                            break 's_51 ;\n                        }\n                        if (bzerr == 0 as std::os::raw::c_int ||\n                                bzerr == 4 as std::os::raw::c_int) &&\n                               nread > 0 as std::os::raw::c_int {\n                            fwrite(obuf.as_mut_ptr() as *const std::os::raw::c_void,\n                                   ::std::mem::size_of::<UChar>() as\n                                       std::os::raw::c_ulong, nread as std::os::raw::c_ulong,\n                                   stream);\n                        }\n                        if ferror(stream) != 0 {\n                            current_block = 5049394217699438129;\n                            break 's_51 ;\n                        }\n                    }\n                    if bzerr != 4 as std::os::raw::c_int {\n                        current_block = 673979509383251364;\n                        break ;\n                    }\n                    BZ2_bzReadGetUnused(&mut bzerr, bzf, &mut unusedTmpV,\n                                        &mut nUnused);\n                    if bzerr != 0 as std::os::raw::c_int {\n                        panic(b\"decompress:bzReadGetUnused\\x00\" as *const u8\n                                  as *const std::os::raw::c_char);\n                    }\n                    unusedTmp = unusedTmpV as *mut UChar;\n                    i = 0 as std::os::raw::c_int;\n                    while i < nUnused {\n                        unused[i as usize] = *unusedTmp.offset(i as isize);\n                        i += 1\n                    }\n                    BZ2_bzReadClose(&mut bzerr, bzf);\n                    if bzerr != 0 as std::os::raw::c_int {\n                        panic(b\"decompress:bzReadGetUnused\\x00\" as *const u8\n                                  as *const std::os::raw::c_char);\n                    }\n                    if nUnused == 0 as std::os::raw::c_int &&\n                           myfeof(zStream) as std::os::raw::c_int != 0 {\n                        current_block = 926243229934402080;\n                        break ;\n                    }\n                }\n            match current_block {\n                5049394217699438129 => { }\n                _ => {\n                    match current_block {\n                        18063049917807660484 => {\n                            if forceOverwrite != 0 {\n                                rewind(zStream);\n                                loop  {\n                                    if !(1 as std::os::raw::c_int as Bool != 0) {\n                                        current_block = 926243229934402080;\n                                        break ;\n                                    }\n                                    if myfeof(zStream) != 0 {\n                                        current_block = 926243229934402080;\n                                        break ;\n                                    }\n                                    nread =\n                                        fread(obuf.as_mut_ptr() as\n                                                  *mut std::os::raw::c_void,\n                                              ::std::mem::size_of::<UChar>()\n                                                  as std::os::raw::c_ulong,\n                                              5000 as std::os::raw::c_int as\n                                                  std::os::raw::c_ulong, zStream) as\n                                            Int32;\n                                    if ferror(zStream) != 0 {\n                                        current_block = 5049394217699438129;\n                                        break ;\n                                    }\n                                    if nread > 0 as std::os::raw::c_int {\n                                        fwrite(obuf.as_mut_ptr() as\n                                                   *const std::os::raw::c_void,\n                                               ::std::mem::size_of::<UChar>()\n                                                   as std::os::raw::c_ulong,\n                                               nread as std::os::raw::c_ulong,\n                                               stream);\n                                    }\n                                    if ferror(stream) != 0 {\n                                        current_block = 5049394217699438129;\n                                        break ;\n                                    }\n                                }\n                            } else { current_block = 673979509383251364; }\n                        }\n                        _ => { }\n                    }\n                    match current_block {\n                        5049394217699438129 => { }\n                        _ => {\n                            match current_block {\n                                673979509383251364 => {\n                                    BZ2_bzReadClose(&mut bzerr_dummy, bzf);\n                                    match bzerr {\n                                        -9 => {\n                                            current_block =\n                                                3642457097893642164;\n                                            match current_block {\n                                                6455255476181645667 => {\n                                                    panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);\n                                                }\n                                                3642457097893642164 => {\n                                                    configError();\n                                                }\n                                                10766414566319669440 => {\n                                                    crcError();\n                                                }\n                                                16178635849926953562 => {\n                                                    outOfMemory();\n                                                }\n                                                5517467152645906530 => {\n                                                    compressedStreamEOF();\n                                                }\n                                                _ => {\n                                                    if zStream != __stdinp {\n                                                        fclose(zStream);\n                                                    }\n                                                    if stream != __stdoutp {\n                                                        fclose(stream);\n                                                    }\n                                                    if streamNo ==\n                                                           1 as std::os::raw::c_int {\n                                                        return 0 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    } else {\n                                                        if noisy != 0 {\n                                                            fprintf(__stderrp,\n                                                                    b\"\\n%s: %s: trailing garbage after EOF ignored\\n\\x00\"\n                                                                        as\n                                                                        *const u8\n                                                                        as\n                                                                        *const std::os::raw::c_char,\n                                                                    progName,\n                                                                    inName.as_mut_ptr());\n                                                        }\n                                                        return 1 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        -6 => { }\n                                        -4 => {\n                                            current_block =\n                                                10766414566319669440;\n                                            match current_block {\n                                                6455255476181645667 => {\n                                                    panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);\n                                                }\n                                                3642457097893642164 => {\n                                                    configError();\n                                                }\n                                                10766414566319669440 => {\n                                                    crcError();\n                                                }\n                                                16178635849926953562 => {\n                                                    outOfMemory();\n                                                }\n                                                5517467152645906530 => {\n                                                    compressedStreamEOF();\n                                                }\n                                                _ => {\n                                                    if zStream != __stdinp {\n                                                        fclose(zStream);\n                                                    }\n                                                    if stream != __stdoutp {\n                                                        fclose(stream);\n                                                    }\n                                                    if streamNo ==\n                                                           1 as std::os::raw::c_int {\n                                                        return 0 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    } else {\n                                                        if noisy != 0 {\n                                                            fprintf(__stderrp,\n                                                                    b\"\\n%s: %s: trailing garbage after EOF ignored\\n\\x00\"\n                                                                        as\n                                                                        *const u8\n                                                                        as\n                                                                        *const std::os::raw::c_char,\n                                                                    progName,\n                                                                    inName.as_mut_ptr());\n                                                        }\n                                                        return 1 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        -3 => {\n                                            current_block =\n                                                16178635849926953562;\n                                            match current_block {\n                                                6455255476181645667 => {\n                                                    panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);\n                                                }\n                                                3642457097893642164 => {\n                                                    configError();\n                                                }\n                                                10766414566319669440 => {\n                                                    crcError();\n                                                }\n                                                16178635849926953562 => {\n                                                    outOfMemory();\n                                                }\n                                                5517467152645906530 => {\n                                                    compressedStreamEOF();\n                                                }\n                                                _ => {\n                                                    if zStream != __stdinp {\n                                                        fclose(zStream);\n                                                    }\n                                                    if stream != __stdoutp {\n                                                        fclose(stream);\n                                                    }\n                                                    if streamNo ==\n                                                           1 as std::os::raw::c_int {\n                                                        return 0 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    } else {\n                                                        if noisy != 0 {\n                                                            fprintf(__stderrp,\n                                                                    b\"\\n%s: %s: trailing garbage after EOF ignored\\n\\x00\"\n                                                                        as\n                                                                        *const u8\n                                                                        as\n                                                                        *const std::os::raw::c_char,\n                                                                    progName,\n                                                                    inName.as_mut_ptr());\n                                                        }\n                                                        return 1 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        -7 => {\n                                            current_block =\n                                                5517467152645906530;\n                                            match current_block {\n                                                6455255476181645667 => {\n                                                    panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);\n                                                }\n                                                3642457097893642164 => {\n                                                    configError();\n                                                }\n                                                10766414566319669440 => {\n                                                    crcError();\n                                                }\n                                                16178635849926953562 => {\n                                                    outOfMemory();\n                                                }\n                                                5517467152645906530 => {\n                                                    compressedStreamEOF();\n                                                }\n                                                _ => {\n                                                    if zStream != __stdinp {\n                                                        fclose(zStream);\n                                                    }\n                                                    if stream != __stdoutp {\n                                                        fclose(stream);\n                                                    }\n                                                    if streamNo ==\n                                                           1 as std::os::raw::c_int {\n                                                        return 0 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    } else {\n                                                        if noisy != 0 {\n                                                            fprintf(__stderrp,\n                                                                    b\"\\n%s: %s: trailing garbage after EOF ignored\\n\\x00\"\n                                                                        as\n                                                                        *const u8\n                                                                        as\n                                                                        *const std::os::raw::c_char,\n                                                                    progName,\n                                                                    inName.as_mut_ptr());\n                                                        }\n                                                        return 1 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        -5 => {\n                                            current_block =\n                                                7372986856480808103;\n                                            match current_block {\n                                                6455255476181645667 => {\n                                                    panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);\n                                                }\n                                                3642457097893642164 => {\n                                                    configError();\n                                                }\n                                                10766414566319669440 => {\n                                                    crcError();\n                                                }\n                                                16178635849926953562 => {\n                                                    outOfMemory();\n                                                }\n                                                5517467152645906530 => {\n                                                    compressedStreamEOF();\n                                                }\n                                                _ => {\n                                                    if zStream != __stdinp {\n                                                        fclose(zStream);\n                                                    }\n                                                    if stream != __stdoutp {\n                                                        fclose(stream);\n                                                    }\n                                                    if streamNo ==\n                                                           1 as std::os::raw::c_int {\n                                                        return 0 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    } else {\n                                                        if noisy != 0 {\n                                                            fprintf(__stderrp,\n                                                                    b\"\\n%s: %s: trailing garbage after EOF ignored\\n\\x00\"\n                                                                        as\n                                                                        *const u8\n                                                                        as\n                                                                        *const std::os::raw::c_char,\n                                                                    progName,\n                                                                    inName.as_mut_ptr());\n                                                        }\n                                                        return 1 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        _ => {\n                                            current_block =\n                                                6455255476181645667;\n                                            match current_block {\n                                                6455255476181645667 => {\n                                                    panic(b\"decompress:unexpected error\\x00\"\n                                                              as *const u8 as\n                                                              *const std::os::raw::c_char);\n                                                }\n                                                3642457097893642164 => {\n                                                    configError();\n                                                }\n                                                10766414566319669440 => {\n                                                    crcError();\n                                                }\n                                                16178635849926953562 => {\n                                                    outOfMemory();\n                                                }\n                                                5517467152645906530 => {\n                                                    compressedStreamEOF();\n                                                }\n                                                _ => {\n                                                    if zStream != __stdinp {\n                                                        fclose(zStream);\n                                                    }\n                                                    if stream != __stdoutp {\n                                                        fclose(stream);\n                                                    }\n                                                    if streamNo ==\n                                                           1 as std::os::raw::c_int {\n                                                        return 0 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    } else {\n                                                        if noisy != 0 {\n                                                            fprintf(__stderrp,\n                                                                    b\"\\n%s: %s: trailing garbage after EOF ignored\\n\\x00\"\n                                                                        as\n                                                                        *const u8\n                                                                        as\n                                                                        *const std::os::raw::c_char,\n                                                                    progName,\n                                                                    inName.as_mut_ptr());\n                                                        }\n                                                        return 1 as\n                                                                   std::os::raw::c_int\n                                                                   as Bool\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                _ => {\n                                    if !(ferror(zStream) != 0) {\n                                        if stream != __stdoutp {\n                                            let mut fd: Int32 =\n                                                fileno(stream);\n                                            if fd < 0 as std::os::raw::c_int {\n                                                current_block =\n                                                    5049394217699438129;\n                                            } else {\n                                                applySavedFileAttrToOutputFile(fd);\n                                                current_block =\n                                                    14832935472441733737;\n                                            }\n                                        } else {\n                                            current_block =\n                                                14832935472441733737;\n                                        }\n                                        match current_block {\n                                            5049394217699438129 => { }\n                                            _ => {\n                                                ret = fclose(zStream);\n                                                if !(ret ==\n                                                         -(1 as std::os::raw::c_int))\n                                                   {\n                                                    if !(ferror(stream) != 0)\n                                                       {\n                                                        ret = fflush(stream);\n                                                        if !(ret !=\n                                                                 0 as\n                                                                     std::os::raw::c_int)\n                                                           {\n                                                            if stream !=\n                                                                   __stdoutp {\n                                                                ret =\n                                                                    fclose(stream);\n                                                                outputHandleJustInCase\n                                                                    =\n                                                                    0 as\n                                                                        *mut FILE;\n                                                                if ret ==\n                                                                       -(1 as\n                                                                             std::os::raw::c_int)\n                                                                   {\n                                                                    current_block\n                                                                        =\n                                                                        5049394217699438129;\n                                                                } else {\n                                                                    current_block\n                                                                        =\n                                                                        14775119014532381840;\n                                                                }\n                                                            } else {\n                                                                current_block\n                                                                    =\n                                                                    14775119014532381840;\n                                                            }\n                                                            match current_block\n                                                                {\n                                                                5049394217699438129\n                                                                => {\n                                                                }\n                                                                _ => {\n                                                                    outputHandleJustInCase\n                                                                        =\n                                                                        0 as\n                                                                            *mut FILE;\n                                                                    if verbosity\n                                                                           >=\n                                                                           2\n                                                                               as\n                                                                               std::os::raw::c_int\n                                                                       {\n                                                                        fprintf(__stderrp,\n                                                                                b\"\\n    \\x00\"\n                                                                                    as\n                                                                                    *const u8\n                                                                                    as\n                                                                                    *const std::os::raw::c_char);\n                                                                    }\n                                                                    return 1\n                                                                               as\n                                                                               std::os::raw::c_int\n                                                                               as\n                                                                               Bool\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ioError();\n    /*notreached*/\n}",
    "calls": [
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2495:5: 2495:53 (#0)",
        "source": "magicNumberOK = uncompressStream(inStr, outStr);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:352:1: 353:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      },
      {
        "span": "bzip2.rs:342:1: 342:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:312:1: 312:37 (#0)",
        "source": "pub static mut verbosity: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:316:1: 316:36 (#0)",
        "source": "pub static mut smallMode: Bool = 0;"
      },
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:248 ~ c2rust_out[3c70]::bzip2::pad)",
    "span": "bzip2.rs:1807:1: 1815:2 (#0)",
    "pieces": [
      "bzip2.rs:1807:1: 1815:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn pad(mut s: *mut Char) {\n    let mut i: Int32 = 0;\n    if strlen(s) as Int32 >= longestFileName { return }\n    i = 1 as std::os::raw::c_int;\n    while i <= longestFileName - strlen(s) as Int32 {\n        fprintf(__stderrp, b\" \\x00\" as *const u8 as *const std::os::raw::c_char);\n        i += 1\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2640:9: 2640:34 (#0)",
        "source": "pad(inName.as_mut_ptr());"
      },
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2489:9: 2489:34 (#0)",
        "source": "pad(inName.as_mut_ptr());"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2248:9: 2248:34 (#0)",
        "source": "pad(inName.as_mut_ptr());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:258 ~ c2rust_out[3c70]::bzip2::saveInputFileMetaInfo)",
    "span": "bzip2.rs:1969:1: 1974:2 (#0)",
    "pieces": [
      "bzip2.rs:1969:1: 1974:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn saveInputFileMetaInfo(mut srcName: *mut Char) {\n    let mut retVal: IntNative = 0;\n    /* Note use of stat here, not lstat. */\n    retVal = stat(srcName, &mut fileMetaInfo);\n    if retVal != 0 as std::os::raw::c_int { ioError(); };\n}",
    "calls": [
      {
        "caller": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
        "span": "bzip2.rs:2421:9: 2421:52 (#0)",
        "source": "saveInputFileMetaInfo(inName.as_mut_ptr());"
      },
      {
        "caller": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
        "span": "bzip2.rs:2169:9: 2169:52 (#0)",
        "source": "saveInputFileMetaInfo(inName.as_mut_ptr());"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:1950:1: 1968:30 (#0)",
        "source": "static mut fileMetaInfo: stat =\n    stat{st_dev: 0,\n         st_mode: 0,\n         st_nlink: 0,\n         st_ino: 0,\n         st_uid: 0,\n         st_gid: 0,\n         st_rdev: 0,\n         st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n         st_size: 0,\n         st_blocks: 0,\n         st_blksize: 0,\n         st_flags: 0,\n         st_gen: 0,\n         st_lspare: 0,\n         st_qspare: [0; 2],};"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:270 ~ c2rust_out[3c70]::bzip2::uncompress)",
    "span": "bzip2.rs:2268:1: 2533:2 (#0)",
    "pieces": [
      "bzip2.rs:2268:1: 2533:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 266,
    "source": "unsafe extern \"C\" fn uncompress(mut name: *mut Char) {\n    let mut current_block: u64;\n    let mut inStr: *mut FILE = 0 as *mut FILE;\n    let mut outStr: *mut FILE = 0 as *mut FILE;\n    let mut n: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut magicNumberOK: Bool = 0;\n    let mut cantGuess: Bool = 0;\n    let mut statBuf: stat =\n        stat{st_dev: 0,\n             st_mode: 0,\n             st_nlink: 0,\n             st_ino: 0,\n             st_uid: 0,\n             st_gid: 0,\n             st_rdev: 0,\n             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_size: 0,\n             st_blocks: 0,\n             st_blksize: 0,\n             st_flags: 0,\n             st_gen: 0,\n             st_lspare: 0,\n             st_qspare: [0; 2],};\n    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n    if name.is_null() && srcMode != 1 as std::os::raw::c_int {\n        panic(b\"uncompress: bad modes\\n\\x00\" as *const u8 as\n                  *const std::os::raw::c_char);\n    }\n    cantGuess = 0 as std::os::raw::c_int as Bool;\n    match srcMode {\n        1 => {\n            copyFileName(inName.as_mut_ptr(),\n                         b\"(stdin)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                             *mut Char);\n            copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);\n        }\n        3 => {\n            copyFileName(inName.as_mut_ptr(), name);\n            copyFileName(outName.as_mut_ptr(), name);\n            i = 0 as std::os::raw::c_int;\n            loop  {\n                if !(i < 4 as std::os::raw::c_int) {\n                    current_block = 17860125682698302841;\n                    break ;\n                }\n                if mapSuffix(outName.as_mut_ptr(), zSuffix[i as usize],\n                             unzSuffix[i as usize]) != 0 {\n                    current_block = 15314513098708193206;\n                    break ;\n                }\n                i += 1\n            }\n            match current_block {\n                15314513098708193206 => { }\n                _ => {\n                    cantGuess = 1 as std::os::raw::c_int as Bool;\n                    strcat(outName.as_mut_ptr(),\n                           b\".out\\x00\" as *const u8 as *const std::os::raw::c_char);\n                }\n            }\n        }\n        2 => {\n            copyFileName(inName.as_mut_ptr(), name);\n            copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);\n        }\n        _ => { }\n    }\n    if srcMode != 1 as std::os::raw::c_int &&\n           containsDubiousChars(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if noisy != 0 {\n            fprintf(__stderrp,\n                    b\"%s: There are no files matching `%s\\'.\\n\\x00\" as\n                        *const u8 as *const std::os::raw::c_char, progName,\n                    inName.as_mut_ptr());\n        }\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode != 1 as std::os::raw::c_int && fileExists(inName.as_mut_ptr()) == 0 {\n        fprintf(__stderrp,\n                b\"%s: Can\\'t open input file %s: %s.\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, progName, inName.as_mut_ptr(),\n                strerror(*__error()));\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode == 3 as std::os::raw::c_int || srcMode == 2 as std::os::raw::c_int {\n        stat(inName.as_mut_ptr(), &mut statBuf);\n        if statBuf.st_mode as std::os::raw::c_int & 0o170000 as std::os::raw::c_int ==\n               0o40000 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"%s: Input file %s is a directory.\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, progName, inName.as_mut_ptr());\n            setExit(1 as std::os::raw::c_int);\n            return\n        }\n    }\n    if srcMode == 3 as std::os::raw::c_int && forceOverwrite == 0 &&\n           notAStandardFile(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if noisy != 0 {\n            fprintf(__stderrp,\n                    b\"%s: Input file %s is not a normal file.\\n\\x00\" as\n                        *const u8 as *const std::os::raw::c_char, progName,\n                    inName.as_mut_ptr());\n        }\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if cantGuess != 0 {\n        if noisy != 0 {\n            fprintf(__stderrp,\n                    b\"%s: Can\\'t guess original name for %s -- using %s\\n\\x00\"\n                        as *const u8 as *const std::os::raw::c_char, progName,\n                    inName.as_mut_ptr(), outName.as_mut_ptr());\n        }\n        /* just a warning, no return */\n    }\n    if srcMode == 3 as std::os::raw::c_int &&\n           fileExists(outName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if forceOverwrite != 0 {\n            remove(outName.as_mut_ptr());\n        } else {\n            fprintf(__stderrp,\n                    b\"%s: Output file %s already exists.\\n\\x00\" as *const u8\n                        as *const std::os::raw::c_char, progName,\n                    outName.as_mut_ptr());\n            setExit(1 as std::os::raw::c_int);\n            return\n        }\n    }\n    if srcMode == 3 as std::os::raw::c_int && forceOverwrite == 0 &&\n           { n = countHardLinks(inName.as_mut_ptr()); (n) > 0 as std::os::raw::c_int }\n       {\n        fprintf(__stderrp,\n                b\"%s: Input file %s has %d other link%s.\\n\\x00\" as *const u8\n                    as *const std::os::raw::c_char, progName, inName.as_mut_ptr(), n,\n                if n > 1 as std::os::raw::c_int {\n                    b\"s\\x00\" as *const u8 as *const std::os::raw::c_char\n                } else { b\"\\x00\" as *const u8 as *const std::os::raw::c_char });\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode == 3 as std::os::raw::c_int {\n        /* Save the file's meta-info before we open it.  Doing it later\n         means we mess up the access times. */\n        saveInputFileMetaInfo(inName.as_mut_ptr());\n    }\n    match srcMode {\n        1 => {\n            inStr = __stdinp;\n            outStr = __stdoutp;\n            if isatty(fileno(__stdinp)) != 0 {\n                fprintf(__stderrp,\n                        b\"%s: I won\\'t read compressed data from a terminal.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char, progName);\n                fprintf(__stderrp,\n                        b\"%s: For help, type: `%s --help\\'.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        progName);\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        2 => {\n            inStr =\n                fopen(inName.as_mut_ptr(),\n                      b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n            outStr = __stdoutp;\n            if inStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t open input file %s:%s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        inName.as_mut_ptr(), strerror(*__error()));\n                if !inStr.is_null() { fclose(inStr); }\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        3 => {\n            inStr =\n                fopen(inName.as_mut_ptr(),\n                      b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n            outStr =\n                fopen_output_safely(outName.as_mut_ptr(),\n                                    b\"wb\\x00\" as *const u8 as\n                                        *const std::os::raw::c_char);\n            if outStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t create output file %s: %s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        outName.as_mut_ptr(), strerror(*__error()));\n                if !inStr.is_null() { fclose(inStr); }\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n            if inStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t open input file %s: %s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        inName.as_mut_ptr(), strerror(*__error()));\n                if !outStr.is_null() { fclose(outStr); }\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        _ => {\n            panic(b\"uncompress: bad srcMode\\x00\" as *const u8 as\n                      *const std::os::raw::c_char);\n        }\n    }\n    if verbosity >= 1 as std::os::raw::c_int {\n        fprintf(__stderrp, b\"  %s: \\x00\" as *const u8 as *const std::os::raw::c_char,\n                inName.as_mut_ptr());\n        pad(inName.as_mut_ptr());\n        fflush(__stderrp);\n    }\n    /*--- Now the input and output handles are sane.  Do the Biz. ---*/\n    outputHandleJustInCase = outStr;\n    deleteOutputOnInterrupt = 1 as std::os::raw::c_int as Bool;\n    magicNumberOK = uncompressStream(inStr, outStr);\n    outputHandleJustInCase = 0 as *mut FILE;\n    /*--- If there was an I/O error, we won't get here. ---*/\n    if magicNumberOK != 0 {\n        if srcMode == 3 as std::os::raw::c_int {\n            applySavedTimeInfoToOutputFile(outName.as_mut_ptr());\n            deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n            if keepInputFiles == 0 {\n                let mut retVal: IntNative = remove(inName.as_mut_ptr());\n                if retVal != 0 as std::os::raw::c_int { ioError(); }\n            }\n        }\n    } else {\n        unzFailsExist = 1 as std::os::raw::c_int as Bool;\n        deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n        if srcMode == 3 as std::os::raw::c_int {\n            let mut retVal_0: IntNative = remove(outName.as_mut_ptr());\n            if retVal_0 != 0 as std::os::raw::c_int { ioError(); }\n        }\n    }\n    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n    if magicNumberOK != 0 {\n        if verbosity >= 1 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"done\\n\\x00\" as *const u8 as *const std::os::raw::c_char);\n        }\n    } else {\n        setExit(2 as std::os::raw::c_int);\n        if verbosity >= 1 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"not a bzip2 file.\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char);\n        } else {\n            fprintf(__stderrp,\n                    b\"%s: %s is not a bzip2 file.\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, progName, inName.as_mut_ptr());\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:281 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:3067:13: 3067:40 (#0)",
        "source": "uncompress(0 as *mut Char);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      },
      {
        "span": "bzip2.rs:352:1: 353:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      },
      {
        "span": "bzip2.rs:318:1: 318:50 (#0)",
        "source": "pub static mut deleteOutputOnInterrupt: Bool = 0;"
      },
      {
        "span": "bzip2.rs:338:1: 338:35 (#0)",
        "source": "pub static mut srcMode: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:324:1: 324:40 (#0)",
        "source": "pub static mut unzFailsExist: Bool = 0;"
      },
      {
        "span": "bzip2.rs:342:1: 342:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:344:1: 344:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:462 ~ c2rust_out[3c70]::bzlib::BZ2_bzerror)",
    "span": "bzlib.rs:2397:1: 2404:2 (#0)",
    "pieces": [
      "bzlib.rs:2397:1: 2404:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn BZ2_bzerror(mut b: *mut std::os::raw::c_void,\n                                     mut errnum: *mut std::os::raw::c_int)\n -> *const std::os::raw::c_char {\n    let mut err: std::os::raw::c_int = (*(b as *mut bzFile)).lastErr;\n    if err > 0 as std::os::raw::c_int { err = 0 as std::os::raw::c_int }\n    *errnum = err;\n    return bzerrorstrings[(err * -(1 as std::os::raw::c_int)) as usize];\n}",
    "calls": [],
    "globals": [
      {
        "span": "bzlib.rs:2379:1: 2395:62 (#0)",
        "source": "static mut bzerrorstrings: [*const std::os::raw::c_char; 16] =\n    [b\"OK\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"SEQUENCE_ERROR\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"PARAM_ERROR\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"MEM_ERROR\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"DATA_ERROR\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"DATA_ERROR_MAGIC\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"IO_ERROR\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"UNEXPECTED_EOF\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"OUTBUFF_FULL\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"CONFIG_ERROR\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"???\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"???\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"???\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"???\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"???\\x00\" as *const u8 as *const std::os::raw::c_char,\n     b\"???\\x00\" as *const u8 as *const std::os::raw::c_char];"
      }
    ],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:338 ~ c2rust_out[3c70]::bzip2recover::bsPutUChar)",
    "span": "bzip2recover.rs:248:1: 257:2 (#0)",
    "pieces": [
      "bzip2recover.rs:248:1: 257:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "unsafe extern \"C\" fn bsPutUChar(mut bs: *mut BitStream, mut c: UChar) {\n    let mut i: Int32 = 0;\n    i = 7 as std::os::raw::c_int;\n    while i >= 0 as std::os::raw::c_int {\n        bsPutBit(bs,\n                 (c as UInt32 >> i & 0x1 as std::os::raw::c_int as std::os::raw::c_uint) as\n                     Int32);\n        i -= 1\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:455 ~ c2rust_out[3c70]::bzlib::BZ2_bzdopen)",
    "span": "bzlib.rs:2319:1: 2324:2 (#0)",
    "pieces": [
      "bzlib.rs:2319:1: 2324:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn BZ2_bzdopen(mut fd: std::os::raw::c_int,\n                                     mut mode: *const std::os::raw::c_char)\n -> *mut std::os::raw::c_void {\n    return bzopen_or_bzdopen(0 as *const std::os::raw::c_char, fd, mode,\n                             1 as std::os::raw::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:439 ~ c2rust_out[3c70]::bzlib::BZ2_bzWriteClose)",
    "span": "bzlib.rs:1802:1: 1809:2 (#0)",
    "pieces": [
      "bzlib.rs:1802:1: 1809:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn BZ2_bzWriteClose(mut bzerror: *mut std::os::raw::c_int,\n                                          mut b: *mut std::os::raw::c_void,\n                                          mut abandon: std::os::raw::c_int,\n                                          mut nbytes_in: *mut std::os::raw::c_uint,\n                                          mut nbytes_out: *mut std::os::raw::c_uint) {\n    BZ2_bzWriteClose64(bzerror, b, abandon, nbytes_in, 0 as *mut std::os::raw::c_uint,\n                       nbytes_out, 0 as *mut std::os::raw::c_uint);\n}",
    "calls": [
      {
        "caller": "DefId(0:459 ~ c2rust_out[3c70]::bzlib::BZ2_bzclose)",
        "span": "bzlib.rs:2366:9: 2367:90 (#0)",
        "source": "BZ2_bzWriteClose(&mut bzerr, b, 0 as std::os::raw::c_int,\n                         0 as *mut std::os::raw::c_uint, 0 as *mut std::os::raw::c_uint);"
      },
      {
        "caller": "DefId(0:459 ~ c2rust_out[3c70]::bzlib::BZ2_bzclose)",
        "span": "bzlib.rs:2369:13: 2370:94 (#0)",
        "source": "BZ2_bzWriteClose(0 as *mut std::os::raw::c_int, b, 1 as std::os::raw::c_int,\n                             0 as *mut std::os::raw::c_uint, 0 as *mut std::os::raw::c_uint);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:459 ~ c2rust_out[3c70]::bzlib::BZ2_bzclose)",
    "span": "bzlib.rs:2360:1: 2374:2 (#0)",
    "pieces": [
      "bzlib.rs:2360:1: 2374:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn BZ2_bzclose(mut b: *mut std::os::raw::c_void) {\n    let mut bzerr: std::os::raw::c_int = 0;\n    let mut fp: *mut FILE = 0 as *mut FILE;\n    if b.is_null() { return }\n    fp = (*(b as *mut bzFile)).handle;\n    if (*(b as *mut bzFile)).writing != 0 {\n        BZ2_bzWriteClose(&mut bzerr, b, 0 as std::os::raw::c_int,\n                         0 as *mut std::os::raw::c_uint, 0 as *mut std::os::raw::c_uint);\n        if bzerr != 0 as std::os::raw::c_int {\n            BZ2_bzWriteClose(0 as *mut std::os::raw::c_int, b, 1 as std::os::raw::c_int,\n                             0 as *mut std::os::raw::c_uint, 0 as *mut std::os::raw::c_uint);\n        }\n    } else { BZ2_bzReadClose(&mut bzerr, b); }\n    if fp != __stdinp && fp != __stdoutp { fclose(fp); };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:339 ~ c2rust_out[3c70]::bzip2recover::bsPutUInt32)",
    "span": "bzip2recover.rs:259:1: 266:2 (#0)",
    "pieces": [
      "bzip2recover.rs:259:1: 266:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn bsPutUInt32(mut bs: *mut BitStream, mut c: UInt32) {\n    let mut i: Int32 = 0;\n    i = 31 as std::os::raw::c_int;\n    while i >= 0 as std::os::raw::c_int {\n        bsPutBit(bs, (c >> i & 0x1 as std::os::raw::c_int as std::os::raw::c_uint) as Int32);\n        i -= 1\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:21 ~ c2rust_out[3c70]::blocksort::fallbackQSort3)",
    "span": "blocksort.rs:182:1: 331:2 (#0)",
    "pieces": [
      "blocksort.rs:182:1: 331:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 150,
    "source": "unsafe extern \"C\" fn fallbackQSort3(mut fmap: *mut UInt32,\n                                    mut eclass: *mut UInt32, mut loSt: Int32,\n                                    mut hiSt: Int32) {\n    let mut unLo: Int32 = 0;\n    let mut unHi: Int32 = 0;\n    let mut ltLo: Int32 = 0;\n    let mut gtHi: Int32 = 0;\n    let mut n: Int32 = 0;\n    let mut m: Int32 = 0;\n    let mut sp: Int32 = 0;\n    let mut lo: Int32 = 0;\n    let mut hi: Int32 = 0;\n    let mut med: UInt32 = 0;\n    let mut r: UInt32 = 0;\n    let mut r3: UInt32 = 0;\n    let mut stackLo: [Int32; 100] = [0; 100];\n    let mut stackHi: [Int32; 100] = [0; 100];\n    r = 0 as std::os::raw::c_int as UInt32;\n    sp = 0 as std::os::raw::c_int;\n    stackLo[sp as usize] = loSt;\n    stackHi[sp as usize] = hiSt;\n    sp += 1;\n    while sp > 0 as std::os::raw::c_int {\n        if !(sp < 100 as std::os::raw::c_int - 1 as std::os::raw::c_int) {\n            BZ2_bz__AssertH__fail(1004 as std::os::raw::c_int);\n        }\n        sp -= 1;\n        lo = stackLo[sp as usize];\n        hi = stackHi[sp as usize];\n        if hi - lo < 10 as std::os::raw::c_int {\n            fallbackSimpleSort(fmap, eclass, lo, hi);\n        } else {\n            /* Random partitioning.  Median of 3 sometimes fails to\n         avoid bad cases.  Median of 9 seems to help but \n         looks rather expensive.  This too seems to work but\n         is cheaper.  Guidance for the magic constants \n         7621 and 32768 is taken from Sedgewick's algorithms\n         book, chapter 35.\n      */\n            r =\n                r.wrapping_mul(7621 as std::os::raw::c_int as\n                                   std::os::raw::c_uint).wrapping_add(1 as std::os::raw::c_int\n                                                                  as\n                                                                  std::os::raw::c_uint).wrapping_rem(32768\n                                                                                                 as\n                                                                                                 std::os::raw::c_int\n                                                                                                 as\n                                                                                                 std::os::raw::c_uint);\n            r3 = r.wrapping_rem(3 as std::os::raw::c_int as std::os::raw::c_uint);\n            if r3 == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n                med = *eclass.offset(*fmap.offset(lo as isize) as isize)\n            } else if r3 == 1 as std::os::raw::c_int as std::os::raw::c_uint {\n                med =\n                    *eclass.offset(*fmap.offset((lo + hi >> 1 as std::os::raw::c_int)\n                                                    as isize) as isize)\n            } else {\n                med = *eclass.offset(*fmap.offset(hi as isize) as isize)\n            }\n            ltLo = lo;\n            unLo = ltLo;\n            gtHi = hi;\n            unHi = gtHi;\n            loop  {\n                while !(unLo > unHi) {\n                    n =\n                        *eclass.offset(*fmap.offset(unLo as isize) as isize)\n                            as Int32 - med as Int32;\n                    if n == 0 as std::os::raw::c_int {\n                        let mut zztmp: Int32 =\n                            *fmap.offset(unLo as isize) as Int32;\n                        *fmap.offset(unLo as isize) =\n                            *fmap.offset(ltLo as isize);\n                        *fmap.offset(ltLo as isize) = zztmp as UInt32;\n                        ltLo += 1;\n                        unLo += 1\n                    } else { if n > 0 as std::os::raw::c_int { break ; } unLo += 1 }\n                }\n                while !(unLo > unHi) {\n                    n =\n                        *eclass.offset(*fmap.offset(unHi as isize) as isize)\n                            as Int32 - med as Int32;\n                    if n == 0 as std::os::raw::c_int {\n                        let mut zztmp_0: Int32 =\n                            *fmap.offset(unHi as isize) as Int32;\n                        *fmap.offset(unHi as isize) =\n                            *fmap.offset(gtHi as isize);\n                        *fmap.offset(gtHi as isize) = zztmp_0 as UInt32;\n                        gtHi -= 1;\n                        unHi -= 1\n                    } else { if n < 0 as std::os::raw::c_int { break ; } unHi -= 1 }\n                }\n                if unLo > unHi { break ; }\n                let mut zztmp_1: Int32 = *fmap.offset(unLo as isize) as Int32;\n                *fmap.offset(unLo as isize) = *fmap.offset(unHi as isize);\n                *fmap.offset(unHi as isize) = zztmp_1 as UInt32;\n                unLo += 1;\n                unHi -= 1\n            }\n            if gtHi < ltLo { continue ; }\n            n =\n                if ltLo - lo < unLo - ltLo {\n                    (ltLo) - lo\n                } else { (unLo) - ltLo };\n            let mut yyp1: Int32 = lo;\n            let mut yyp2: Int32 = unLo - n;\n            let mut yyn: Int32 = n;\n            while yyn > 0 as std::os::raw::c_int {\n                let mut zztmp_2: Int32 = *fmap.offset(yyp1 as isize) as Int32;\n                *fmap.offset(yyp1 as isize) = *fmap.offset(yyp2 as isize);\n                *fmap.offset(yyp2 as isize) = zztmp_2 as UInt32;\n                yyp1 += 1;\n                yyp2 += 1;\n                yyn -= 1\n            }\n            m =\n                if hi - gtHi < gtHi - unHi {\n                    (hi) - gtHi\n                } else { (gtHi) - unHi };\n            let mut yyp1_0: Int32 = unLo;\n            let mut yyp2_0: Int32 = hi - m + 1 as std::os::raw::c_int;\n            let mut yyn_0: Int32 = m;\n            while yyn_0 > 0 as std::os::raw::c_int {\n                let mut zztmp_3: Int32 =\n                    *fmap.offset(yyp1_0 as isize) as Int32;\n                *fmap.offset(yyp1_0 as isize) = *fmap.offset(yyp2_0 as isize);\n                *fmap.offset(yyp2_0 as isize) = zztmp_3 as UInt32;\n                yyp1_0 += 1;\n                yyp2_0 += 1;\n                yyn_0 -= 1\n            }\n            n = lo + unLo - ltLo - 1 as std::os::raw::c_int;\n            m = hi - (gtHi - unHi) + 1 as std::os::raw::c_int;\n            if n - lo > hi - m {\n                stackLo[sp as usize] = lo;\n                stackHi[sp as usize] = n;\n                sp += 1;\n                stackLo[sp as usize] = m;\n                stackHi[sp as usize] = hi;\n                sp += 1\n            } else {\n                stackLo[sp as usize] = m;\n                stackHi[sp as usize] = hi;\n                sp += 1;\n                stackLo[sp as usize] = lo;\n                stackHi[sp as usize] = n;\n                sp += 1\n            }\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:26 ~ c2rust_out[3c70]::blocksort::fallbackSort)",
        "span": "blocksort.rs:495:17: 495:52 (#0)",
        "source": "fallbackQSort3(fmap, eclass, l, r);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:11:1: 11:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:26 ~ c2rust_out[3c70]::blocksort::fallbackSort)",
    "span": "blocksort.rs:332:1: 544:2 (#0)",
    "pieces": [
      "blocksort.rs:332:1: 544:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 213,
    "source": "unsafe extern \"C\" fn fallbackSort(mut fmap: *mut UInt32,\n                                  mut eclass: *mut UInt32,\n                                  mut bhtab: *mut UInt32, mut nblock: Int32,\n                                  mut verb: Int32) {\n    let mut ftab: [Int32; 257] = [0; 257];\n    let mut ftabCopy: [Int32; 256] = [0; 256];\n    let mut H: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut k: Int32 = 0;\n    let mut l: Int32 = 0;\n    let mut r: Int32 = 0;\n    let mut cc: Int32 = 0;\n    let mut cc1: Int32 = 0;\n    let mut nNotDone: Int32 = 0;\n    let mut nBhtab: Int32 = 0;\n    let mut eclass8: *mut UChar = eclass as *mut UChar;\n    /*--\n      Initial 1-char radix sort to generate\n      initial fmap and initial BH bits.\n   --*/\n    if verb >= 4 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"        bucket sorting ...\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char);\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 257 as std::os::raw::c_int {\n        ftab[i as usize] = 0 as std::os::raw::c_int;\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < nblock {\n        ftab[*eclass8.offset(i as isize) as usize] += 1;\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 256 as std::os::raw::c_int {\n        ftabCopy[i as usize] = ftab[i as usize];\n        i += 1\n    }\n    i = 1 as std::os::raw::c_int;\n    while i < 257 as std::os::raw::c_int {\n        ftab[i as usize] += ftab[(i - 1 as std::os::raw::c_int) as usize];\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < nblock {\n        j = *eclass8.offset(i as isize) as Int32;\n        k = ftab[j as usize] - 1 as std::os::raw::c_int;\n        ftab[j as usize] = k;\n        *fmap.offset(k as isize) = i as UInt32;\n        i += 1\n    }\n    nBhtab = 2 as std::os::raw::c_int + nblock / 32 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n    while i < nBhtab {\n        *bhtab.offset(i as isize) = 0 as std::os::raw::c_int as UInt32;\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 256 as std::os::raw::c_int {\n        let ref mut fresh0 =\n            *bhtab.offset((ftab[i as usize] >> 5 as std::os::raw::c_int) as isize);\n        *fresh0 |=\n            (1 as std::os::raw::c_int as UInt32) <<\n                (ftab[i as usize] & 31 as std::os::raw::c_int);\n        i += 1\n    }\n    /*--\n      Inductively refine the buckets.  Kind-of an\n      \"exponential radix sort\" (!), inspired by the\n      Manber-Myers suffix array construction algorithm.\n   --*/\n    /*-- set sentinel bits for block-end detection --*/\n    i = 0 as std::os::raw::c_int;\n    while i < 32 as std::os::raw::c_int {\n        let ref mut fresh1 =\n            *bhtab.offset((nblock + 2 as std::os::raw::c_int * i >> 5 as std::os::raw::c_int)\n                              as isize);\n        *fresh1 |=\n            (1 as std::os::raw::c_int as UInt32) <<\n                (nblock + 2 as std::os::raw::c_int * i & 31 as std::os::raw::c_int);\n        let ref mut fresh2 =\n            *bhtab.offset((nblock + 2 as std::os::raw::c_int * i + 1 as std::os::raw::c_int >>\n                               5 as std::os::raw::c_int) as isize);\n        *fresh2 &=\n            !((1 as std::os::raw::c_int as UInt32) <<\n                  (nblock + 2 as std::os::raw::c_int * i + 1 as std::os::raw::c_int &\n                       31 as std::os::raw::c_int));\n        i += 1\n    }\n    /*-- the log(N) loop --*/\n    H = 1 as std::os::raw::c_int;\n    loop  {\n        if verb >= 4 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"        depth %6d has \\x00\" as *const u8 as\n                        *const std::os::raw::c_char, H);\n        }\n        j = 0 as std::os::raw::c_int;\n        i = 0 as std::os::raw::c_int;\n        while i < nblock {\n            if *bhtab.offset((i >> 5 as std::os::raw::c_int) as isize) &\n                   (1 as std::os::raw::c_int as UInt32) << (i & 31 as std::os::raw::c_int) !=\n                   0 {\n                j = i\n            }\n            k =\n                (*fmap.offset(i as isize)).wrapping_sub(H as std::os::raw::c_uint) as\n                    Int32;\n            if k < 0 as std::os::raw::c_int { k += nblock }\n            *eclass.offset(k as isize) = j as UInt32;\n            i += 1\n        }\n        nNotDone = 0 as std::os::raw::c_int;\n        r = -(1 as std::os::raw::c_int);\n        loop  {\n            /*-- find the next non-singleton bucket --*/\n            k = r + 1 as std::os::raw::c_int;\n            while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &\n                      (1 as std::os::raw::c_int as UInt32) << (k & 31 as std::os::raw::c_int)\n                      != 0 && k & 0x1f as std::os::raw::c_int != 0 {\n                k += 1\n            }\n            if *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &\n                   (1 as std::os::raw::c_int as UInt32) << (k & 31 as std::os::raw::c_int) !=\n                   0 {\n                while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) ==\n                          0xffffffff as std::os::raw::c_uint {\n                    k += 32 as std::os::raw::c_int\n                }\n                while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &\n                          (1 as std::os::raw::c_int as UInt32) <<\n                              (k & 31 as std::os::raw::c_int) != 0 {\n                    k += 1\n                }\n            }\n            l = k - 1 as std::os::raw::c_int;\n            if l >= nblock { break ; }\n            while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &\n                      (1 as std::os::raw::c_int as UInt32) << (k & 31 as std::os::raw::c_int)\n                      == 0 && k & 0x1f as std::os::raw::c_int != 0 {\n                k += 1\n            }\n            if *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &\n                   (1 as std::os::raw::c_int as UInt32) << (k & 31 as std::os::raw::c_int) ==\n                   0 {\n                while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) ==\n                          0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    k += 32 as std::os::raw::c_int\n                }\n                while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &\n                          (1 as std::os::raw::c_int as UInt32) <<\n                              (k & 31 as std::os::raw::c_int) == 0 {\n                    k += 1\n                }\n            }\n            r = k - 1 as std::os::raw::c_int;\n            if r >= nblock { break ; }\n            /*-- now [l, r] bracket current bucket --*/\n            if r > l {\n                nNotDone += r - l + 1 as std::os::raw::c_int;\n                fallbackQSort3(fmap, eclass, l, r);\n                /*-- scan bucket and generate header bits-- */\n                cc = -(1 as std::os::raw::c_int);\n                i = l;\n                while i <= r {\n                    cc1 =\n                        *eclass.offset(*fmap.offset(i as isize) as isize) as\n                            Int32;\n                    if cc != cc1 {\n                        let ref mut fresh3 =\n                            *bhtab.offset((i >> 5 as std::os::raw::c_int) as isize);\n                        *fresh3 |=\n                            (1 as std::os::raw::c_int as UInt32) <<\n                                (i & 31 as std::os::raw::c_int);\n                        cc = cc1\n                    }\n                    i += 1\n                }\n            }\n        }\n        if verb >= 4 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"%6d unresolved strings\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, nNotDone);\n        }\n        H *= 2 as std::os::raw::c_int;\n        if H > nblock || nNotDone == 0 as std::os::raw::c_int { break ; }\n    }\n    /*-- \n      Reconstruct the original block in\n      eclass8 [0 .. nblock-1], since the\n      previous phase destroyed it.\n   --*/\n    if verb >= 4 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"        reconstructing block ...\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char);\n    }\n    j = 0 as std::os::raw::c_int;\n    i = 0 as std::os::raw::c_int;\n    while i < nblock {\n        while ftabCopy[j as usize] == 0 as std::os::raw::c_int { j += 1 }\n        ftabCopy[j as usize] -= 1;\n        *eclass8.offset(*fmap.offset(i as isize) as isize) = j as UChar;\n        i += 1\n    }\n    if !(j < 256 as std::os::raw::c_int) {\n        BZ2_bz__AssertH__fail(1005 as std::os::raw::c_int);\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:58 ~ c2rust_out[3c70]::blocksort::BZ2_blockSort)",
        "span": "blocksort.rs:1620:13: 1620:68 (#0)",
        "source": "fallbackSort((*s).arr1, (*s).arr2, ftab, nblock, verb);"
      },
      {
        "caller": "DefId(0:58 ~ c2rust_out[3c70]::blocksort::BZ2_blockSort)",
        "span": "blocksort.rs:1578:9: 1578:64 (#0)",
        "source": "fallbackSort((*s).arr1, (*s).arr2, ftab, nblock, verb);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:11:1: 11:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:58 ~ c2rust_out[3c70]::blocksort::BZ2_blockSort)",
    "span": "blocksort.rs:1566:1: 1634:2 (#0)",
    "pieces": [
      "blocksort.rs:1566:1: 1634:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 69,
    "source": "pub unsafe extern \"C\" fn BZ2_blockSort(mut s: *mut EState) {\n    let mut ptr: *mut UInt32 = (*s).ptr;\n    let mut block: *mut UChar = (*s).block;\n    let mut ftab: *mut UInt32 = (*s).ftab;\n    let mut nblock: Int32 = (*s).nblock;\n    let mut verb: Int32 = (*s).verbosity;\n    let mut wfact: Int32 = (*s).workFactor;\n    let mut quadrant: *mut UInt16 = 0 as *mut UInt16;\n    let mut budget: Int32 = 0;\n    let mut budgetInit: Int32 = 0;\n    let mut i: Int32 = 0;\n    if nblock < 10000 as std::os::raw::c_int {\n        fallbackSort((*s).arr1, (*s).arr2, ftab, nblock, verb);\n    } else {\n        /* Calculate the location for quadrant, remembering to get\n         the alignment right.  Assumes that &(block[0]) is at least\n         2-byte aligned -- this should be ok since block is really\n         the first section of arr2.\n      */\n        i =\n            nblock +\n                (2 as std::os::raw::c_int + 12 as std::os::raw::c_int + 18 as std::os::raw::c_int +\n                     2 as std::os::raw::c_int);\n        if i & 1 as std::os::raw::c_int != 0 { i += 1 }\n        quadrant =\n            &mut *block.offset(i as isize) as *mut UChar as *mut UInt16;\n        /* (wfact-1) / 3 puts the default-factor-30\n         transition point at very roughly the same place as \n         with v0.1 and v0.9.0.  \n         Not that it particularly matters any more, since the\n         resulting compressed stream is now the same regardless\n         of whether or not we use the main sort or fallback sort.\n      */\n        if wfact < 1 as std::os::raw::c_int { wfact = 1 as std::os::raw::c_int }\n        if wfact > 100 as std::os::raw::c_int { wfact = 100 as std::os::raw::c_int }\n        budgetInit = nblock * ((wfact - 1 as std::os::raw::c_int) / 3 as std::os::raw::c_int);\n        budget = budgetInit;\n        mainSort(ptr, block, quadrant, ftab, nblock, verb, &mut budget);\n        if verb >= 3 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"      %d work, %d block, ratio %5.2f\\n\\x00\" as *const u8\n                        as *const std::os::raw::c_char, budgetInit - budget, nblock,\n                    ((budgetInit - budget) as std::os::raw::c_float /\n                         (if nblock == 0 as std::os::raw::c_int {\n                              1 as std::os::raw::c_int\n                          } else { nblock }) as std::os::raw::c_float) as\n                        std::os::raw::c_double);\n        }\n        if budget < 0 as std::os::raw::c_int {\n            if verb >= 2 as std::os::raw::c_int {\n                fprintf(__stderrp,\n                        b\"    too repetitive; using fallback sorting algorithm\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char);\n            }\n            fallbackSort((*s).arr1, (*s).arr2, ftab, nblock, verb);\n        }\n    }\n    (*s).origPtr = -(1 as std::os::raw::c_int);\n    i = 0 as std::os::raw::c_int;\n    while i < (*s).nblock {\n        if *ptr.offset(i as isize) == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            (*s).origPtr = i;\n            break ;\n        } else { i += 1 }\n    }\n    if !((*s).origPtr != -(1 as std::os::raw::c_int)) {\n        BZ2_bz__AssertH__fail(1003 as std::os::raw::c_int);\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2468:9: 2468:26 (#0)",
        "source": "BZ2_blockSort(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:11:1: 11:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:428 ~ c2rust_out[3c70]::bzlib::BZ2_bzCompress)",
    "span": "bzlib.rs:646:1: 703:2 (#0)",
    "pieces": [
      "bzlib.rs:646:1: 703:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 58,
    "source": "pub unsafe extern \"C\" fn BZ2_bzCompress(mut strm: *mut bz_stream,\n                                        mut action: std::os::raw::c_int)\n -> std::os::raw::c_int {\n    let mut progress: Bool = 0;\n    let mut s: *mut EState = 0 as *mut EState;\n    if strm.is_null() { return -(2 as std::os::raw::c_int) }\n    s = (*strm).state as *mut EState;\n    if s.is_null() { return -(2 as std::os::raw::c_int) }\n    if (*s).strm != strm { return -(2 as std::os::raw::c_int) }\n    loop  {\n        match (*s).mode {\n            1 => { return -(1 as std::os::raw::c_int) }\n            2 => {\n                if action == 0 as std::os::raw::c_int {\n                    progress = handle_compress(strm);\n                    return if progress as std::os::raw::c_int != 0 {\n                               1 as std::os::raw::c_int\n                           } else { -(2 as std::os::raw::c_int) }\n                } else if action == 1 as std::os::raw::c_int {\n                    (*s).avail_in_expect = (*strm).avail_in;\n                    (*s).mode = 3 as std::os::raw::c_int\n                } else if action == 2 as std::os::raw::c_int {\n                    (*s).avail_in_expect = (*strm).avail_in;\n                    (*s).mode = 4 as std::os::raw::c_int\n                } else { return -(2 as std::os::raw::c_int) }\n            }\n            3 => {\n                if action != 1 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }\n                if (*s).avail_in_expect != (*(*s).strm).avail_in {\n                    return -(1 as std::os::raw::c_int)\n                }\n                progress = handle_compress(strm);\n                if (*s).avail_in_expect > 0 as std::os::raw::c_int as std::os::raw::c_uint ||\n                       isempty_RL(s) == 0 || (*s).state_out_pos < (*s).numZ {\n                    return 2 as std::os::raw::c_int\n                }\n                (*s).mode = 2 as std::os::raw::c_int;\n                return 1 as std::os::raw::c_int\n            }\n            4 => {\n                if action != 2 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }\n                if (*s).avail_in_expect != (*(*s).strm).avail_in {\n                    return -(1 as std::os::raw::c_int)\n                }\n                progress = handle_compress(strm);\n                if progress == 0 { return -(1 as std::os::raw::c_int) }\n                if (*s).avail_in_expect > 0 as std::os::raw::c_int as std::os::raw::c_uint ||\n                       isempty_RL(s) == 0 || (*s).state_out_pos < (*s).numZ {\n                    return 3 as std::os::raw::c_int\n                }\n                (*s).mode = 1 as std::os::raw::c_int;\n                return 4 as std::os::raw::c_int\n            }\n            _ => { return 0 as std::os::raw::c_int }\n        }\n    };\n    /*--not reached--*/\n}",
    "calls": [
      {
        "caller": "DefId(0:445 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffCompress)",
        "span": "bzlib.rs:2144:5: 2144:63 (#0)",
        "source": "ret = BZ2_bzCompress(&mut strm, 2 as std::os::raw::c_int);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:445 ~ c2rust_out[3c70]::bzlib::BZ2_bzBuffToBuffCompress)",
    "span": "bzlib.rs:2102:1: 2157:2 (#0)",
    "pieces": [
      "bzlib.rs:2102:1: 2157:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 56,
    "source": "pub unsafe extern \"C\" fn BZ2_bzBuffToBuffCompress(mut dest: *mut std::os::raw::c_char,\n                                                  mut destLen:\n                                                      *mut std::os::raw::c_uint,\n                                                  mut source:\n                                                      *mut std::os::raw::c_char,\n                                                  mut sourceLen: std::os::raw::c_uint,\n                                                  mut blockSize100k:\n                                                      std::os::raw::c_int,\n                                                  mut verbosity: std::os::raw::c_int,\n                                                  mut workFactor: std::os::raw::c_int)\n -> std::os::raw::c_int {\n    let mut strm: bz_stream =\n        bz_stream{next_in: 0 as *mut std::os::raw::c_char,\n                  avail_in: 0,\n                  total_in_lo32: 0,\n                  total_in_hi32: 0,\n                  next_out: 0 as *mut std::os::raw::c_char,\n                  avail_out: 0,\n                  total_out_lo32: 0,\n                  total_out_hi32: 0,\n                  state: 0 as *mut std::os::raw::c_void,\n                  bzalloc: None,\n                  bzfree: None,\n                  opaque: 0 as *mut std::os::raw::c_void,};\n    let mut ret: std::os::raw::c_int = 0;\n    if dest.is_null() || destLen.is_null() || source.is_null() ||\n           blockSize100k < 1 as std::os::raw::c_int ||\n           blockSize100k > 9 as std::os::raw::c_int || verbosity < 0 as std::os::raw::c_int ||\n           verbosity > 4 as std::os::raw::c_int || workFactor < 0 as std::os::raw::c_int ||\n           workFactor > 250 as std::os::raw::c_int {\n        return -(2 as std::os::raw::c_int)\n    }\n    if workFactor == 0 as std::os::raw::c_int { workFactor = 30 as std::os::raw::c_int }\n    strm.bzalloc = None;\n    strm.bzfree = None;\n    strm.opaque = 0 as *mut std::os::raw::c_void;\n    ret = BZ2_bzCompressInit(&mut strm, blockSize100k, verbosity, workFactor);\n    if ret != 0 as std::os::raw::c_int { return ret }\n    strm.next_in = source;\n    strm.next_out = dest;\n    strm.avail_in = sourceLen;\n    strm.avail_out = *destLen;\n    ret = BZ2_bzCompress(&mut strm, 2 as std::os::raw::c_int);\n    if ret == 3 as std::os::raw::c_int {\n        BZ2_bzCompressEnd(&mut strm);\n        return -(8 as std::os::raw::c_int)\n    } else if ret != 4 as std::os::raw::c_int {\n        BZ2_bzCompressEnd(&mut strm);\n        return ret\n    } else {\n        /* normal termination */\n        *destLen = (*destLen).wrapping_sub(strm.avail_out);\n        BZ2_bzCompressEnd(&mut strm);\n        return 0 as std::os::raw::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:34 ~ c2rust_out[3c70]::blocksort::mainSimpleSort)",
    "span": "blocksort.rs:804:1: 874:2 (#0)",
    "pieces": [
      "blocksort.rs:804:1: 874:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 71,
    "source": "unsafe extern \"C\" fn mainSimpleSort(mut ptr: *mut UInt32,\n                                    mut block: *mut UChar,\n                                    mut quadrant: *mut UInt16,\n                                    mut nblock: Int32, mut lo: Int32,\n                                    mut hi: Int32, mut d: Int32,\n                                    mut budget: *mut Int32) {\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut h: Int32 = 0;\n    let mut bigN: Int32 = 0;\n    let mut hp: Int32 = 0;\n    let mut v: UInt32 = 0;\n    bigN = hi - lo + 1 as std::os::raw::c_int;\n    if bigN < 2 as std::os::raw::c_int { return }\n    hp = 0 as std::os::raw::c_int;\n    while incs[hp as usize] < bigN { hp += 1 }\n    hp -= 1;\n    while hp >= 0 as std::os::raw::c_int {\n        h = incs[hp as usize];\n        i = lo + h;\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /*-- copy 1 --*/\n            if i > hi { break ; }\n            v = *ptr.offset(i as isize);\n            j = i;\n            while mainGtU((*ptr.offset((j - h) as\n                                           isize)).wrapping_add(d as\n                                                                    std::os::raw::c_uint),\n                          v.wrapping_add(d as std::os::raw::c_uint), block, quadrant,\n                          nblock as UInt32, budget) != 0 {\n                *ptr.offset(j as isize) = *ptr.offset((j - h) as isize);\n                j = j - h;\n                if j <= lo + h - 1 as std::os::raw::c_int { break ; }\n            }\n            *ptr.offset(j as isize) = v;\n            i += 1;\n            /*-- copy 2 --*/\n            if i > hi { break ; }\n            v = *ptr.offset(i as isize);\n            j = i;\n            while mainGtU((*ptr.offset((j - h) as\n                                           isize)).wrapping_add(d as\n                                                                    std::os::raw::c_uint),\n                          v.wrapping_add(d as std::os::raw::c_uint), block, quadrant,\n                          nblock as UInt32, budget) != 0 {\n                *ptr.offset(j as isize) = *ptr.offset((j - h) as isize);\n                j = j - h;\n                if j <= lo + h - 1 as std::os::raw::c_int { break ; }\n            }\n            *ptr.offset(j as isize) = v;\n            i += 1;\n            /*-- copy 3 --*/\n            if i > hi { break ; }\n            v = *ptr.offset(i as isize);\n            j = i;\n            while mainGtU((*ptr.offset((j - h) as\n                                           isize)).wrapping_add(d as\n                                                                    std::os::raw::c_uint),\n                          v.wrapping_add(d as std::os::raw::c_uint), block, quadrant,\n                          nblock as UInt32, budget) != 0 {\n                *ptr.offset(j as isize) = *ptr.offset((j - h) as isize);\n                j = j - h;\n                if j <= lo + h - 1 as std::os::raw::c_int { break ; }\n            }\n            *ptr.offset(j as isize) = v;\n            i += 1;\n            if *budget < 0 as std::os::raw::c_int { return }\n        }\n        hp -= 1\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:11:1: 11:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:280 ~ c2rust_out[3c70]::bzip2::addFlagsFromEnvVar)",
    "span": "bzip2.rs:2706:1: 2746:2 (#0)",
    "pieces": [
      "bzip2.rs:2706:1: 2746:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "unsafe extern \"C\" fn addFlagsFromEnvVar(mut argList: *mut *mut Cell,\n                                        mut varName: *mut Char) {\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut k: Int32 = 0;\n    let mut envbase: *mut Char = 0 as *mut Char;\n    let mut p: *mut Char = 0 as *mut Char;\n    envbase = getenv(varName);\n    if !envbase.is_null() {\n        p = envbase;\n        i = 0 as std::os::raw::c_int;\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            if *p.offset(i as isize) as std::os::raw::c_int == 0 as std::os::raw::c_int {\n                break ;\n            }\n            p = p.offset(i as isize);\n            i = 0 as std::os::raw::c_int;\n            while isspace(*p.offset(0 as std::os::raw::c_int as isize) as Int32) != 0\n                  {\n                p = p.offset(1)\n            }\n            while *p.offset(i as isize) as std::os::raw::c_int != 0 as std::os::raw::c_int &&\n                      isspace(*p.offset(i as isize) as Int32) == 0 {\n                i += 1\n            }\n            if i > 0 as std::os::raw::c_int {\n                k = i;\n                if k > 1034 as std::os::raw::c_int - 10 as std::os::raw::c_int {\n                    k = 1034 as std::os::raw::c_int - 10 as std::os::raw::c_int\n                }\n                j = 0 as std::os::raw::c_int;\n                while j < k {\n                    tmpName[j as usize] = *p.offset(j as isize);\n                    j += 1\n                }\n                tmpName[k as usize] = 0 as std::os::raw::c_int as Char;\n                *argList = snocString(*argList, tmpName.as_mut_ptr())\n            }\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:281 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2821:5: 2823:39 (#0)",
        "source": "addFlagsFromEnvVar(&mut argList,\n                       b\"BZIP\\x00\" as *const u8 as *const std::os::raw::c_char as\n                           *mut Char);"
      },
      {
        "caller": "DefId(0:281 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:2818:5: 2820:39 (#0)",
        "source": "addFlagsFromEnvVar(&mut argList,\n                       b\"BZIP2\\x00\" as *const u8 as *const std::os::raw::c_char as\n                           *mut Char);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:443 ~ c2rust_out[3c70]::bzlib::BZ2_bzRead)",
    "span": "bzlib.rs:1992:1: 2068:2 (#0)",
    "pieces": [
      "bzlib.rs:1992:1: 2068:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 77,
    "source": "pub unsafe extern \"C\" fn BZ2_bzRead(mut bzerror: *mut std::os::raw::c_int,\n                                    mut b: *mut std::os::raw::c_void,\n                                    mut buf: *mut std::os::raw::c_void,\n                                    mut len: std::os::raw::c_int) -> std::os::raw::c_int {\n    let mut n: Int32 = 0;\n    let mut ret: Int32 = 0;\n    let mut bzf: *mut bzFile = b as *mut bzFile;\n    if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n    if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n    if bzf.is_null() || buf.is_null() || len < 0 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = -(2 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(2 as std::os::raw::c_int) }\n        return 0 as std::os::raw::c_int\n    }\n    if (*bzf).writing != 0 {\n        if !bzerror.is_null() { *bzerror = -(1 as std::os::raw::c_int) }\n        if !bzf.is_null() { (*bzf).lastErr = -(1 as std::os::raw::c_int) }\n        return 0 as std::os::raw::c_int\n    }\n    if len == 0 as std::os::raw::c_int {\n        if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n        if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n        return 0 as std::os::raw::c_int\n    }\n    (*bzf).strm.avail_out = len as std::os::raw::c_uint;\n    (*bzf).strm.next_out = buf as *mut std::os::raw::c_char;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        if ferror((*bzf).handle) != 0 {\n            if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n            if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n            return 0 as std::os::raw::c_int\n        }\n        if (*bzf).strm.avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint &&\n               myfeof((*bzf).handle) == 0 {\n            n =\n                fread((*bzf).buf.as_mut_ptr() as *mut std::os::raw::c_void,\n                      ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong,\n                      5000 as std::os::raw::c_int as std::os::raw::c_ulong, (*bzf).handle) as\n                    Int32;\n            if ferror((*bzf).handle) != 0 {\n                if !bzerror.is_null() { *bzerror = -(6 as std::os::raw::c_int) }\n                if !bzf.is_null() { (*bzf).lastErr = -(6 as std::os::raw::c_int) }\n                return 0 as std::os::raw::c_int\n            }\n            (*bzf).bufN = n;\n            (*bzf).strm.avail_in = (*bzf).bufN as std::os::raw::c_uint;\n            (*bzf).strm.next_in = (*bzf).buf.as_mut_ptr()\n        }\n        ret = BZ2_bzDecompress(&mut (*bzf).strm);\n        if ret != 0 as std::os::raw::c_int && ret != 4 as std::os::raw::c_int {\n            if !bzerror.is_null() { *bzerror = ret }\n            if !bzf.is_null() { (*bzf).lastErr = ret }\n            return 0 as std::os::raw::c_int\n        }\n        if ret == 0 as std::os::raw::c_int &&\n               myfeof((*bzf).handle) as std::os::raw::c_int != 0 &&\n               (*bzf).strm.avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint &&\n               (*bzf).strm.avail_out > 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            if !bzerror.is_null() { *bzerror = -(7 as std::os::raw::c_int) }\n            if !bzf.is_null() { (*bzf).lastErr = -(7 as std::os::raw::c_int) }\n            return 0 as std::os::raw::c_int\n        }\n        if ret == 4 as std::os::raw::c_int {\n            if !bzerror.is_null() { *bzerror = 4 as std::os::raw::c_int }\n            if !bzf.is_null() { (*bzf).lastErr = 4 as std::os::raw::c_int }\n            return (len as std::os::raw::c_uint).wrapping_sub((*bzf).strm.avail_out)\n                       as std::os::raw::c_int\n        }\n        if (*bzf).strm.avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            if !bzerror.is_null() { *bzerror = 0 as std::os::raw::c_int }\n            if !bzf.is_null() { (*bzf).lastErr = 0 as std::os::raw::c_int }\n            return len\n        }\n    }\n    return 0 as std::os::raw::c_int;\n    /*not reached*/\n}",
    "calls": [
      {
        "caller": "DefId(0:456 ~ c2rust_out[3c70]::bzlib::BZ2_bzread)",
        "span": "bzlib.rs:2335:5: 2335:49 (#0)",
        "source": "nread = BZ2_bzRead(&mut bzerr, b, buf, len);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:456 ~ c2rust_out[3c70]::bzlib::BZ2_bzread)",
    "span": "bzlib.rs:2327:1: 2339:2 (#0)",
    "pieces": [
      "bzlib.rs:2327:1: 2339:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "pub unsafe extern \"C\" fn BZ2_bzread(mut b: *mut std::os::raw::c_void,\n                                    mut buf: *mut std::os::raw::c_void,\n                                    mut len: std::os::raw::c_int) -> std::os::raw::c_int {\n    let mut bzerr: std::os::raw::c_int = 0;\n    let mut nread: std::os::raw::c_int = 0;\n    if (*(b as *mut bzFile)).lastErr == 4 as std::os::raw::c_int {\n        return 0 as std::os::raw::c_int\n    }\n    nread = BZ2_bzRead(&mut bzerr, b, buf, len);\n    if bzerr == 0 as std::os::raw::c_int || bzerr == 4 as std::os::raw::c_int {\n        return nread\n    } else { return -(1 as std::os::raw::c_int) };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:230 ~ c2rust_out[3c70]::bzip2::testStream)",
    "span": "bzip2.rs:1253:1: 1603:2 (#0)",
    "pieces": [
      "bzip2.rs:1253:1: 1603:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 351,
    "source": "unsafe extern \"C\" fn testStream(mut zStream: *mut FILE) -> Bool {\n    let mut current_block: u64;\n    let mut bzf: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    let mut bzerr: Int32 = 0;\n    let mut bzerr_dummy: Int32 = 0;\n    let mut ret: Int32 = 0;\n    let mut streamNo: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut obuf: [UChar; 5000] = [0; 5000];\n    let mut unused: [UChar; 5000] = [0; 5000];\n    let mut nUnused: Int32 = 0;\n    let mut unusedTmpV: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    let mut unusedTmp: *mut UChar = 0 as *mut UChar;\n    nUnused = 0 as std::os::raw::c_int;\n    streamNo = 0 as std::os::raw::c_int;\n    if !(ferror(zStream) != 0) {\n        's_41:\n            loop  {\n                if !(1 as std::os::raw::c_int as Bool != 0) {\n                    current_block = 15125582407903384992;\n                    break ;\n                }\n                bzf =\n                    BZ2_bzReadOpen(&mut bzerr, zStream, verbosity,\n                                   smallMode as std::os::raw::c_int,\n                                   unused.as_mut_ptr() as *mut std::os::raw::c_void,\n                                   nUnused);\n                if bzf.is_null() || bzerr != 0 as std::os::raw::c_int {\n                    current_block = 10905486111603547446;\n                    break ;\n                }\n                streamNo += 1;\n                while bzerr == 0 as std::os::raw::c_int {\n                    BZ2_bzRead(&mut bzerr, bzf,\n                               obuf.as_mut_ptr() as *mut std::os::raw::c_void,\n                               5000 as std::os::raw::c_int);\n                    if bzerr == -(5 as std::os::raw::c_int) {\n                        current_block = 10905486111603547446;\n                        break 's_41 ;\n                    }\n                }\n                if bzerr != 4 as std::os::raw::c_int {\n                    current_block = 10905486111603547446;\n                    break ;\n                }\n                BZ2_bzReadGetUnused(&mut bzerr, bzf, &mut unusedTmpV,\n                                    &mut nUnused);\n                if bzerr != 0 as std::os::raw::c_int {\n                    panic(b\"test:bzReadGetUnused\\x00\" as *const u8 as\n                              *const std::os::raw::c_char);\n                }\n                unusedTmp = unusedTmpV as *mut UChar;\n                i = 0 as std::os::raw::c_int;\n                while i < nUnused {\n                    unused[i as usize] = *unusedTmp.offset(i as isize);\n                    i += 1\n                }\n                BZ2_bzReadClose(&mut bzerr, bzf);\n                if bzerr != 0 as std::os::raw::c_int {\n                    panic(b\"test:bzReadGetUnused\\x00\" as *const u8 as\n                              *const std::os::raw::c_char);\n                }\n                if nUnused == 0 as std::os::raw::c_int &&\n                       myfeof(zStream) as std::os::raw::c_int != 0 {\n                    current_block = 15125582407903384992;\n                    break ;\n                }\n            }\n        match current_block {\n            15125582407903384992 => {\n                if !(ferror(zStream) != 0) {\n                    ret = fclose(zStream);\n                    if !(ret == -(1 as std::os::raw::c_int)) {\n                        if verbosity >= 2 as std::os::raw::c_int {\n                            fprintf(__stderrp,\n                                    b\"\\n    \\x00\" as *const u8 as\n                                        *const std::os::raw::c_char);\n                        }\n                        return 1 as std::os::raw::c_int as Bool\n                    }\n                }\n            }\n            _ => {\n                BZ2_bzReadClose(&mut bzerr_dummy, bzf);\n                if verbosity == 0 as std::os::raw::c_int {\n                    fprintf(__stderrp,\n                            b\"%s: %s: \\x00\" as *const u8 as\n                                *const std::os::raw::c_char, progName,\n                            inName.as_mut_ptr());\n                }\n                match bzerr {\n                    -9 => {\n                        current_block = 18238374633732057650;\n                        match current_block {\n                            6101827300316655396 => {\n                                panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);\n                            }\n                            10380742613918245393 => {\n                                fprintf(__stderrp,\n                                        b\"file ends unexpectedly\\n\\x00\" as\n                                            *const u8 as *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                            2539039579982765382 => {\n                                if zStream != __stdinp { fclose(zStream); }\n                                if streamNo == 1 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"bad magic number (file not created by bzip2)\\n\\x00\"\n                                                as *const u8 as\n                                                *const std::os::raw::c_char);\n                                    return 0 as std::os::raw::c_int as Bool\n                                } else {\n                                    if noisy != 0 {\n                                        fprintf(__stderrp,\n                                                b\"trailing garbage after EOF ignored\\n\\x00\"\n                                                    as *const u8 as\n                                                    *const std::os::raw::c_char);\n                                    }\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                            }\n                            18238374633732057650 => { configError(); }\n                            13802719682174684861 => { outOfMemory(); }\n                            _ => {\n                                fprintf(__stderrp,\n                                        b\"data integrity (CRC) error in data\\n\\x00\"\n                                            as *const u8 as\n                                            *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                        }\n                    }\n                    -6 => { }\n                    -4 => {\n                        current_block = 11224962462315262049;\n                        match current_block {\n                            6101827300316655396 => {\n                                panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);\n                            }\n                            10380742613918245393 => {\n                                fprintf(__stderrp,\n                                        b\"file ends unexpectedly\\n\\x00\" as\n                                            *const u8 as *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                            2539039579982765382 => {\n                                if zStream != __stdinp { fclose(zStream); }\n                                if streamNo == 1 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"bad magic number (file not created by bzip2)\\n\\x00\"\n                                                as *const u8 as\n                                                *const std::os::raw::c_char);\n                                    return 0 as std::os::raw::c_int as Bool\n                                } else {\n                                    if noisy != 0 {\n                                        fprintf(__stderrp,\n                                                b\"trailing garbage after EOF ignored\\n\\x00\"\n                                                    as *const u8 as\n                                                    *const std::os::raw::c_char);\n                                    }\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                            }\n                            18238374633732057650 => { configError(); }\n                            13802719682174684861 => { outOfMemory(); }\n                            _ => {\n                                fprintf(__stderrp,\n                                        b\"data integrity (CRC) error in data\\n\\x00\"\n                                            as *const u8 as\n                                            *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                        }\n                    }\n                    -3 => {\n                        current_block = 13802719682174684861;\n                        match current_block {\n                            6101827300316655396 => {\n                                panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);\n                            }\n                            10380742613918245393 => {\n                                fprintf(__stderrp,\n                                        b\"file ends unexpectedly\\n\\x00\" as\n                                            *const u8 as *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                            2539039579982765382 => {\n                                if zStream != __stdinp { fclose(zStream); }\n                                if streamNo == 1 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"bad magic number (file not created by bzip2)\\n\\x00\"\n                                                as *const u8 as\n                                                *const std::os::raw::c_char);\n                                    return 0 as std::os::raw::c_int as Bool\n                                } else {\n                                    if noisy != 0 {\n                                        fprintf(__stderrp,\n                                                b\"trailing garbage after EOF ignored\\n\\x00\"\n                                                    as *const u8 as\n                                                    *const std::os::raw::c_char);\n                                    }\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                            }\n                            18238374633732057650 => { configError(); }\n                            13802719682174684861 => { outOfMemory(); }\n                            _ => {\n                                fprintf(__stderrp,\n                                        b\"data integrity (CRC) error in data\\n\\x00\"\n                                            as *const u8 as\n                                            *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                        }\n                    }\n                    -7 => {\n                        current_block = 10380742613918245393;\n                        match current_block {\n                            6101827300316655396 => {\n                                panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);\n                            }\n                            10380742613918245393 => {\n                                fprintf(__stderrp,\n                                        b\"file ends unexpectedly\\n\\x00\" as\n                                            *const u8 as *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                            2539039579982765382 => {\n                                if zStream != __stdinp { fclose(zStream); }\n                                if streamNo == 1 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"bad magic number (file not created by bzip2)\\n\\x00\"\n                                                as *const u8 as\n                                                *const std::os::raw::c_char);\n                                    return 0 as std::os::raw::c_int as Bool\n                                } else {\n                                    if noisy != 0 {\n                                        fprintf(__stderrp,\n                                                b\"trailing garbage after EOF ignored\\n\\x00\"\n                                                    as *const u8 as\n                                                    *const std::os::raw::c_char);\n                                    }\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                            }\n                            18238374633732057650 => { configError(); }\n                            13802719682174684861 => { outOfMemory(); }\n                            _ => {\n                                fprintf(__stderrp,\n                                        b\"data integrity (CRC) error in data\\n\\x00\"\n                                            as *const u8 as\n                                            *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                        }\n                    }\n                    -5 => {\n                        current_block = 2539039579982765382;\n                        match current_block {\n                            6101827300316655396 => {\n                                panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);\n                            }\n                            10380742613918245393 => {\n                                fprintf(__stderrp,\n                                        b\"file ends unexpectedly\\n\\x00\" as\n                                            *const u8 as *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                            2539039579982765382 => {\n                                if zStream != __stdinp { fclose(zStream); }\n                                if streamNo == 1 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"bad magic number (file not created by bzip2)\\n\\x00\"\n                                                as *const u8 as\n                                                *const std::os::raw::c_char);\n                                    return 0 as std::os::raw::c_int as Bool\n                                } else {\n                                    if noisy != 0 {\n                                        fprintf(__stderrp,\n                                                b\"trailing garbage after EOF ignored\\n\\x00\"\n                                                    as *const u8 as\n                                                    *const std::os::raw::c_char);\n                                    }\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                            }\n                            18238374633732057650 => { configError(); }\n                            13802719682174684861 => { outOfMemory(); }\n                            _ => {\n                                fprintf(__stderrp,\n                                        b\"data integrity (CRC) error in data\\n\\x00\"\n                                            as *const u8 as\n                                            *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                        }\n                    }\n                    _ => {\n                        current_block = 6101827300316655396;\n                        match current_block {\n                            6101827300316655396 => {\n                                panic(b\"test:unexpected error\\x00\" as\n                                          *const u8 as *const std::os::raw::c_char);\n                            }\n                            10380742613918245393 => {\n                                fprintf(__stderrp,\n                                        b\"file ends unexpectedly\\n\\x00\" as\n                                            *const u8 as *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                            2539039579982765382 => {\n                                if zStream != __stdinp { fclose(zStream); }\n                                if streamNo == 1 as std::os::raw::c_int {\n                                    fprintf(__stderrp,\n                                            b\"bad magic number (file not created by bzip2)\\n\\x00\"\n                                                as *const u8 as\n                                                *const std::os::raw::c_char);\n                                    return 0 as std::os::raw::c_int as Bool\n                                } else {\n                                    if noisy != 0 {\n                                        fprintf(__stderrp,\n                                                b\"trailing garbage after EOF ignored\\n\\x00\"\n                                                    as *const u8 as\n                                                    *const std::os::raw::c_char);\n                                    }\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                            }\n                            18238374633732057650 => { configError(); }\n                            13802719682174684861 => { outOfMemory(); }\n                            _ => {\n                                fprintf(__stderrp,\n                                        b\"data integrity (CRC) error in data\\n\\x00\"\n                                            as *const u8 as\n                                            *const std::os::raw::c_char);\n                                return 0 as std::os::raw::c_int as Bool\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ioError();\n    /*notreached*/\n}",
    "calls": [
      {
        "caller": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
        "span": "bzip2.rs:2645:5: 2645:31 (#0)",
        "source": "allOK = testStream(inStr);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:312:1: 312:37 (#0)",
        "source": "pub static mut verbosity: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:342:1: 342:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:316:1: 316:36 (#0)",
        "source": "pub static mut smallMode: Bool = 0;"
      },
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:272 ~ c2rust_out[3c70]::bzip2::testf)",
    "span": "bzip2.rs:2535:1: 2650:2 (#0)",
    "pieces": [
      "bzip2.rs:2535:1: 2650:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 116,
    "source": "unsafe extern \"C\" fn testf(mut name: *mut Char) {\n    let mut inStr: *mut FILE = 0 as *mut FILE;\n    let mut allOK: Bool = 0;\n    let mut statBuf: stat =\n        stat{st_dev: 0,\n             st_mode: 0,\n             st_nlink: 0,\n             st_ino: 0,\n             st_uid: 0,\n             st_gid: 0,\n             st_rdev: 0,\n             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_size: 0,\n             st_blocks: 0,\n             st_blksize: 0,\n             st_flags: 0,\n             st_gen: 0,\n             st_lspare: 0,\n             st_qspare: [0; 2],};\n    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n    if name.is_null() && srcMode != 1 as std::os::raw::c_int {\n        panic(b\"testf: bad modes\\n\\x00\" as *const u8 as *const std::os::raw::c_char);\n    }\n    copyFileName(outName.as_mut_ptr(),\n                 b\"(none)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                     *mut Char);\n    match srcMode {\n        1 => {\n            copyFileName(inName.as_mut_ptr(),\n                         b\"(stdin)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                             *mut Char);\n        }\n        3 => { copyFileName(inName.as_mut_ptr(), name); }\n        2 => { copyFileName(inName.as_mut_ptr(), name); }\n        _ => { }\n    }\n    if srcMode != 1 as std::os::raw::c_int &&\n           containsDubiousChars(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if noisy != 0 {\n            fprintf(__stderrp,\n                    b\"%s: There are no files matching `%s\\'.\\n\\x00\" as\n                        *const u8 as *const std::os::raw::c_char, progName,\n                    inName.as_mut_ptr());\n        }\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode != 1 as std::os::raw::c_int && fileExists(inName.as_mut_ptr()) == 0 {\n        fprintf(__stderrp,\n                b\"%s: Can\\'t open input %s: %s.\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, progName, inName.as_mut_ptr(),\n                strerror(*__error()));\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode != 1 as std::os::raw::c_int {\n        stat(inName.as_mut_ptr(), &mut statBuf);\n        if statBuf.st_mode as std::os::raw::c_int & 0o170000 as std::os::raw::c_int ==\n               0o40000 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"%s: Input file %s is a directory.\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, progName, inName.as_mut_ptr());\n            setExit(1 as std::os::raw::c_int);\n            return\n        }\n    }\n    match srcMode {\n        1 => {\n            if isatty(fileno(__stdinp)) != 0 {\n                fprintf(__stderrp,\n                        b\"%s: I won\\'t read compressed data from a terminal.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char, progName);\n                fprintf(__stderrp,\n                        b\"%s: For help, type: `%s --help\\'.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        progName);\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n            inStr = __stdinp\n        }\n        2 | 3 => {\n            inStr =\n                fopen(inName.as_mut_ptr(),\n                      b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n            if inStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t open input file %s:%s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        inName.as_mut_ptr(), strerror(*__error()));\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        _ => {\n            panic(b\"testf: bad srcMode\\x00\" as *const u8 as\n                      *const std::os::raw::c_char);\n        }\n    }\n    if verbosity >= 1 as std::os::raw::c_int {\n        fprintf(__stderrp, b\"  %s: \\x00\" as *const u8 as *const std::os::raw::c_char,\n                inName.as_mut_ptr());\n        pad(inName.as_mut_ptr());\n        fflush(__stderrp);\n    }\n    /*--- Now the input handle is sane.  Do the Biz. ---*/\n    outputHandleJustInCase = 0 as *mut FILE;\n    allOK = testStream(inStr);\n    if allOK as std::os::raw::c_int != 0 && verbosity >= 1 as std::os::raw::c_int {\n        fprintf(__stderrp, b\"ok\\n\\x00\" as *const u8 as *const std::os::raw::c_char);\n    }\n    if allOK == 0 { testFailsExist = 1 as std::os::raw::c_int as Bool };\n}",
    "calls": [
      {
        "caller": "DefId(0:281 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:3089:13: 3089:35 (#0)",
        "source": "testf(0 as *mut Char);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      },
      {
        "span": "bzip2.rs:322:1: 322:41 (#0)",
        "source": "pub static mut testFailsExist: Bool = 0;"
      },
      {
        "span": "bzip2.rs:344:1: 344:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:338:1: 338:35 (#0)",
        "source": "pub static mut srcMode: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:352:1: 353:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      },
      {
        "span": "bzip2.rs:318:1: 318:50 (#0)",
        "source": "pub static mut deleteOutputOnInterrupt: Bool = 0;"
      },
      {
        "span": "bzip2.rs:342:1: 342:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:250 ~ c2rust_out[3c70]::bzip2::fileExists)",
    "span": "bzip2.rs:1833:1: 1840:2 (#0)",
    "pieces": [
      "bzip2.rs:1833:1: 1840:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn fileExists(mut name: *mut Char) -> Bool {\n    let mut tmp: *mut FILE =\n        fopen(name, b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n    let mut exists: Bool =\n        (tmp != 0 as *mut std::os::raw::c_void as *mut FILE) as std::os::raw::c_int as Bool;\n    if !tmp.is_null() { fclose(tmp); }\n    return exists;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:496 ~ c2rust_out[3c70]::compress::bsFinishWrite)",
    "span": "compress.rs:76:1: 84:2 (#0)",
    "pieces": [
      "compress.rs:76:1: 84:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn bsFinishWrite(mut s: *mut EState) {\n    while (*s).bsLive > 0 as std::os::raw::c_int {\n        *(*s).zbits.offset((*s).numZ as isize) =\n            ((*s).bsBuff >> 24 as std::os::raw::c_int) as UChar;\n        (*s).numZ += 1;\n        (*s).bsBuff <<= 8 as std::os::raw::c_int;\n        (*s).bsLive -= 8 as std::os::raw::c_int\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2518:9: 2518:26 (#0)",
        "source": "bsFinishWrite(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:19:1: 19:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:20:1: 20:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:21:1: 21:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:17:1: 17:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:18:1: 18:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:268 ~ c2rust_out[3c70]::bzip2::compress)",
    "span": "bzip2.rs:2034:1: 2266:2 (#0)",
    "pieces": [
      "bzip2.rs:2034:1: 2266:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 233,
    "source": "unsafe extern \"C\" fn compress(mut name: *mut Char) {\n    let mut inStr: *mut FILE = 0 as *mut FILE;\n    let mut outStr: *mut FILE = 0 as *mut FILE;\n    let mut n: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut statBuf: stat =\n        stat{st_dev: 0,\n             st_mode: 0,\n             st_nlink: 0,\n             st_ino: 0,\n             st_uid: 0,\n             st_gid: 0,\n             st_rdev: 0,\n             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_size: 0,\n             st_blocks: 0,\n             st_blksize: 0,\n             st_flags: 0,\n             st_gen: 0,\n             st_lspare: 0,\n             st_qspare: [0; 2],};\n    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n    if name.is_null() && srcMode != 1 as std::os::raw::c_int {\n        panic(b\"compress: bad modes\\n\\x00\" as *const u8 as\n                  *const std::os::raw::c_char);\n    }\n    match srcMode {\n        1 => {\n            copyFileName(inName.as_mut_ptr(),\n                         b\"(stdin)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                             *mut Char);\n            copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);\n        }\n        3 => {\n            copyFileName(inName.as_mut_ptr(), name);\n            copyFileName(outName.as_mut_ptr(), name);\n            strcat(outName.as_mut_ptr(),\n                   b\".bz2\\x00\" as *const u8 as *const std::os::raw::c_char);\n        }\n        2 => {\n            copyFileName(inName.as_mut_ptr(), name);\n            copyFileName(outName.as_mut_ptr(),\n                         b\"(stdout)\\x00\" as *const u8 as *const std::os::raw::c_char\n                             as *mut Char);\n        }\n        _ => { }\n    }\n    if srcMode != 1 as std::os::raw::c_int &&\n           containsDubiousChars(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if noisy != 0 {\n            fprintf(__stderrp,\n                    b\"%s: There are no files matching `%s\\'.\\n\\x00\" as\n                        *const u8 as *const std::os::raw::c_char, progName,\n                    inName.as_mut_ptr());\n        }\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode != 1 as std::os::raw::c_int && fileExists(inName.as_mut_ptr()) == 0 {\n        fprintf(__stderrp,\n                b\"%s: Can\\'t open input file %s: %s.\\n\\x00\" as *const u8 as\n                    *const std::os::raw::c_char, progName, inName.as_mut_ptr(),\n                strerror(*__error()));\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 4 as std::os::raw::c_int {\n        if hasSuffix(inName.as_mut_ptr(), zSuffix[i as usize]) != 0 {\n            if noisy != 0 {\n                fprintf(__stderrp,\n                        b\"%s: Input file %s already has %s suffix.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        inName.as_mut_ptr(), zSuffix[i as usize]);\n            }\n            setExit(1 as std::os::raw::c_int);\n            return\n        }\n        i += 1\n    }\n    if srcMode == 3 as std::os::raw::c_int || srcMode == 2 as std::os::raw::c_int {\n        stat(inName.as_mut_ptr(), &mut statBuf);\n        if statBuf.st_mode as std::os::raw::c_int & 0o170000 as std::os::raw::c_int ==\n               0o40000 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"%s: Input file %s is a directory.\\n\\x00\" as *const u8 as\n                        *const std::os::raw::c_char, progName, inName.as_mut_ptr());\n            setExit(1 as std::os::raw::c_int);\n            return\n        }\n    }\n    if srcMode == 3 as std::os::raw::c_int && forceOverwrite == 0 &&\n           notAStandardFile(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if noisy != 0 {\n            fprintf(__stderrp,\n                    b\"%s: Input file %s is not a normal file.\\n\\x00\" as\n                        *const u8 as *const std::os::raw::c_char, progName,\n                    inName.as_mut_ptr());\n        }\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode == 3 as std::os::raw::c_int &&\n           fileExists(outName.as_mut_ptr()) as std::os::raw::c_int != 0 {\n        if forceOverwrite != 0 {\n            remove(outName.as_mut_ptr());\n        } else {\n            fprintf(__stderrp,\n                    b\"%s: Output file %s already exists.\\n\\x00\" as *const u8\n                        as *const std::os::raw::c_char, progName,\n                    outName.as_mut_ptr());\n            setExit(1 as std::os::raw::c_int);\n            return\n        }\n    }\n    if srcMode == 3 as std::os::raw::c_int && forceOverwrite == 0 &&\n           { n = countHardLinks(inName.as_mut_ptr()); (n) > 0 as std::os::raw::c_int }\n       {\n        fprintf(__stderrp,\n                b\"%s: Input file %s has %d other link%s.\\n\\x00\" as *const u8\n                    as *const std::os::raw::c_char, progName, inName.as_mut_ptr(), n,\n                if n > 1 as std::os::raw::c_int {\n                    b\"s\\x00\" as *const u8 as *const std::os::raw::c_char\n                } else { b\"\\x00\" as *const u8 as *const std::os::raw::c_char });\n        setExit(1 as std::os::raw::c_int);\n        return\n    }\n    if srcMode == 3 as std::os::raw::c_int {\n        /* Save the file's meta-info before we open it.  Doing it later\n         means we mess up the access times. */\n        saveInputFileMetaInfo(inName.as_mut_ptr());\n    }\n    match srcMode {\n        1 => {\n            inStr = __stdinp;\n            outStr = __stdoutp;\n            if isatty(fileno(__stdoutp)) != 0 {\n                fprintf(__stderrp,\n                        b\"%s: I won\\'t write compressed data to a terminal.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char, progName);\n                fprintf(__stderrp,\n                        b\"%s: For help, type: `%s --help\\'.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        progName);\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        2 => {\n            inStr =\n                fopen(inName.as_mut_ptr(),\n                      b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n            outStr = __stdoutp;\n            if isatty(fileno(__stdoutp)) != 0 {\n                fprintf(__stderrp,\n                        b\"%s: I won\\'t write compressed data to a terminal.\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char, progName);\n                fprintf(__stderrp,\n                        b\"%s: For help, type: `%s --help\\'.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        progName);\n                if !inStr.is_null() { fclose(inStr); }\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n            if inStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t open input file %s: %s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        inName.as_mut_ptr(), strerror(*__error()));\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        3 => {\n            inStr =\n                fopen(inName.as_mut_ptr(),\n                      b\"rb\\x00\" as *const u8 as *const std::os::raw::c_char);\n            outStr =\n                fopen_output_safely(outName.as_mut_ptr(),\n                                    b\"wb\\x00\" as *const u8 as\n                                        *const std::os::raw::c_char);\n            if outStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t create output file %s: %s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        outName.as_mut_ptr(), strerror(*__error()));\n                if !inStr.is_null() { fclose(inStr); }\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n            if inStr.is_null() {\n                fprintf(__stderrp,\n                        b\"%s: Can\\'t open input file %s: %s.\\n\\x00\" as\n                            *const u8 as *const std::os::raw::c_char, progName,\n                        inName.as_mut_ptr(), strerror(*__error()));\n                if !outStr.is_null() { fclose(outStr); }\n                setExit(1 as std::os::raw::c_int);\n                return\n            }\n        }\n        _ => {\n            panic(b\"compress: bad srcMode\\x00\" as *const u8 as\n                      *const std::os::raw::c_char);\n        }\n    }\n    if verbosity >= 1 as std::os::raw::c_int {\n        fprintf(__stderrp, b\"  %s: \\x00\" as *const u8 as *const std::os::raw::c_char,\n                inName.as_mut_ptr());\n        pad(inName.as_mut_ptr());\n        fflush(__stderrp);\n    }\n    /*--- Now the input and output handles are sane.  Do the Biz. ---*/\n    outputHandleJustInCase = outStr;\n    deleteOutputOnInterrupt = 1 as std::os::raw::c_int as Bool;\n    compressStream(inStr, outStr);\n    outputHandleJustInCase = 0 as *mut FILE;\n    /*--- If there was an I/O error, we won't get here. ---*/\n    if srcMode == 3 as std::os::raw::c_int {\n        applySavedTimeInfoToOutputFile(outName.as_mut_ptr());\n        deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n        if keepInputFiles == 0 {\n            let mut retVal: IntNative = remove(inName.as_mut_ptr());\n            if retVal != 0 as std::os::raw::c_int { ioError(); }\n        }\n    }\n    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n}",
    "calls": [
      {
        "caller": "DefId(0:281 ~ c2rust_out[3c70]::bzip2::main_0)",
        "span": "bzip2.rs:3046:13: 3046:38 (#0)",
        "source": "compress(0 as *mut Char);"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:352:1: 353:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      },
      {
        "span": "bzip2.rs:318:1: 318:50 (#0)",
        "source": "pub static mut deleteOutputOnInterrupt: Bool = 0;"
      },
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      },
      {
        "span": "bzip2.rs:344:1: 344:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:338:1: 338:35 (#0)",
        "source": "pub static mut srcMode: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:342:1: 342:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:281 ~ c2rust_out[3c70]::bzip2::main_0)",
    "span": "bzip2.rs:2747:1: 3128:2 (#0)",
    "pieces": [
      "bzip2.rs:2747:1: 3128:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 382,
    "source": "unsafe fn main_0(mut argc: IntNative, mut argv: *mut *mut Char) -> IntNative {\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut tmp: *mut Char = 0 as *mut Char;\n    let mut argList: *mut Cell = 0 as *mut Cell;\n    let mut aa: *mut Cell = 0 as *mut Cell;\n    let mut decode: Bool = 0;\n    /*-- Be really really really paranoid :-) --*/\n    if ::std::mem::size_of::<Int32>() as std::os::raw::c_ulong !=\n           4 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           ::std::mem::size_of::<UInt32>() as std::os::raw::c_ulong !=\n               4 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           ::std::mem::size_of::<Int16>() as std::os::raw::c_ulong !=\n               2 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           ::std::mem::size_of::<UInt16>() as std::os::raw::c_ulong !=\n               2 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           ::std::mem::size_of::<Char>() as std::os::raw::c_ulong !=\n               1 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong !=\n               1 as std::os::raw::c_int as std::os::raw::c_ulong {\n        configError();\n    }\n    /*-- Initialise --*/\n    outputHandleJustInCase =\n        0 as *mut FILE; /* avoid bogus warning from egcs-1.1.X */\n    smallMode = 0 as std::os::raw::c_int as Bool;\n    keepInputFiles = 0 as std::os::raw::c_int as Bool;\n    forceOverwrite = 0 as std::os::raw::c_int as Bool;\n    noisy = 1 as std::os::raw::c_int as Bool;\n    verbosity = 0 as std::os::raw::c_int;\n    blockSize100k = 9 as std::os::raw::c_int;\n    testFailsExist = 0 as std::os::raw::c_int as Bool;\n    unzFailsExist = 0 as std::os::raw::c_int as Bool;\n    numFileNames = 0 as std::os::raw::c_int;\n    numFilesProcessed = 0 as std::os::raw::c_int;\n    workFactor = 30 as std::os::raw::c_int;\n    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;\n    exitValue = 0 as std::os::raw::c_int;\n    j = 0 as std::os::raw::c_int;\n    i = j;\n    /*-- Set up signal handlers for mem access errors --*/\n    signal(11 as std::os::raw::c_int,\n           Some(mySIGSEGVorSIGBUScatcher as\n                    unsafe extern \"C\" fn(_: IntNative) -> ()));\n    signal(10 as std::os::raw::c_int,\n           Some(mySIGSEGVorSIGBUScatcher as\n                    unsafe extern \"C\" fn(_: IntNative) -> ()));\n    copyFileName(inName.as_mut_ptr(),\n                 b\"(none)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                     *mut Char);\n    copyFileName(outName.as_mut_ptr(),\n                 b\"(none)\\x00\" as *const u8 as *const std::os::raw::c_char as\n                     *mut Char);\n    copyFileName(progNameReally.as_mut_ptr(),\n                 *argv.offset(0 as std::os::raw::c_int as isize));\n    progName =\n        &mut *progNameReally.as_mut_ptr().offset(0 as std::os::raw::c_int as isize) as\n            *mut Char;\n    tmp =\n        &mut *progNameReally.as_mut_ptr().offset(0 as std::os::raw::c_int as isize) as\n            *mut Char;\n    while *tmp as std::os::raw::c_int != '\\u{0}' as i32 {\n        if *tmp as std::os::raw::c_int == '/' as i32 {\n            progName = tmp.offset(1 as std::os::raw::c_int as isize)\n        }\n        tmp = tmp.offset(1)\n    }\n    /*-- Copy flags from env var BZIP2, and \n        expand filename wildcards in arg list.\n   --*/\n    argList = 0 as *mut Cell;\n    addFlagsFromEnvVar(&mut argList,\n                       b\"BZIP2\\x00\" as *const u8 as *const std::os::raw::c_char as\n                           *mut Char);\n    addFlagsFromEnvVar(&mut argList,\n                       b\"BZIP\\x00\" as *const u8 as *const std::os::raw::c_char as\n                           *mut Char);\n    i = 1 as std::os::raw::c_int;\n    while i <= argc - 1 as std::os::raw::c_int {\n        argList = snocString(argList, *argv.offset(i as isize));\n        i += 1\n    }\n    /*-- Find the length of the longest filename --*/\n    longestFileName = 7 as std::os::raw::c_int;\n    numFileNames = 0 as std::os::raw::c_int;\n    decode = 1 as std::os::raw::c_int as Bool;\n    aa = argList;\n    while !aa.is_null() {\n        if strcmp((*aa).name, b\"--\\x00\" as *const u8 as *const std::os::raw::c_char)\n               == 0 as std::os::raw::c_int {\n            decode = 0 as std::os::raw::c_int as Bool\n        } else if !(*(*aa).name.offset(0 as std::os::raw::c_int as isize) as\n                        std::os::raw::c_int == '-' as i32 &&\n                        decode as std::os::raw::c_int != 0) {\n            numFileNames += 1;\n            if longestFileName < strlen((*aa).name) as Int32 {\n                longestFileName = strlen((*aa).name) as Int32\n            }\n        }\n        aa = (*aa).link\n    }\n    /*-- Determine source modes; flag handling may change this too. --*/\n    if numFileNames == 0 as std::os::raw::c_int {\n        srcMode = 1 as std::os::raw::c_int\n    } else { srcMode = 3 as std::os::raw::c_int }\n    /*-- Determine what to do (compress/uncompress/test/cat). --*/\n   /*-- Note that subsequent flag handling may change this. --*/\n    opMode = 1 as std::os::raw::c_int;\n    if !strstr(progName,\n               b\"unzip\\x00\" as *const u8 as *const std::os::raw::c_char).is_null() ||\n           !strstr(progName,\n                   b\"UNZIP\\x00\" as *const u8 as *const std::os::raw::c_char).is_null()\n       {\n        opMode = 2 as std::os::raw::c_int\n    }\n    if !strstr(progName,\n               b\"z2cat\\x00\" as *const u8 as *const std::os::raw::c_char).is_null() ||\n           !strstr(progName,\n                   b\"Z2CAT\\x00\" as *const u8 as *const std::os::raw::c_char).is_null()\n           ||\n           !strstr(progName,\n                   b\"zcat\\x00\" as *const u8 as *const std::os::raw::c_char).is_null()\n           ||\n           !strstr(progName,\n                   b\"ZCAT\\x00\" as *const u8 as *const std::os::raw::c_char).is_null()\n       {\n        opMode = 2 as std::os::raw::c_int;\n        srcMode =\n            if numFileNames == 0 as std::os::raw::c_int {\n                1 as std::os::raw::c_int\n            } else { 2 as std::os::raw::c_int }\n    }\n    /*-- Look at the flags. --*/\n    aa = argList;\n    while !aa.is_null() {\n        if strcmp((*aa).name, b\"--\\x00\" as *const u8 as *const std::os::raw::c_char)\n               == 0 as std::os::raw::c_int {\n            break ;\n        }\n        if *(*aa).name.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               '-' as i32 &&\n               *(*aa).name.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int !=\n                   '-' as i32 {\n            j = 1 as std::os::raw::c_int;\n            while *(*aa).name.offset(j as isize) as std::os::raw::c_int !=\n                      '\\u{0}' as i32 {\n                match *(*aa).name.offset(j as isize) as std::os::raw::c_int {\n                    99 => { srcMode = 2 as std::os::raw::c_int }\n                    100 => { opMode = 2 as std::os::raw::c_int }\n                    122 => { opMode = 1 as std::os::raw::c_int }\n                    102 => { forceOverwrite = 1 as std::os::raw::c_int as Bool }\n                    116 => { opMode = 3 as std::os::raw::c_int }\n                    107 => { keepInputFiles = 1 as std::os::raw::c_int as Bool }\n                    115 => { smallMode = 1 as std::os::raw::c_int as Bool }\n                    113 => { noisy = 0 as std::os::raw::c_int as Bool }\n                    49 => { blockSize100k = 1 as std::os::raw::c_int }\n                    50 => { blockSize100k = 2 as std::os::raw::c_int }\n                    51 => { blockSize100k = 3 as std::os::raw::c_int }\n                    52 => { blockSize100k = 4 as std::os::raw::c_int }\n                    53 => { blockSize100k = 5 as std::os::raw::c_int }\n                    54 => { blockSize100k = 6 as std::os::raw::c_int }\n                    55 => { blockSize100k = 7 as std::os::raw::c_int }\n                    56 => { blockSize100k = 8 as std::os::raw::c_int }\n                    57 => { blockSize100k = 9 as std::os::raw::c_int }\n                    86 | 76 => { license(); }\n                    118 => { verbosity += 1 }\n                    104 => { usage(progName); exit(0 as std::os::raw::c_int); }\n                    _ => {\n                        fprintf(__stderrp,\n                                b\"%s: Bad flag `%s\\'\\n\\x00\" as *const u8 as\n                                    *const std::os::raw::c_char, progName,\n                                (*aa).name);\n                        usage(progName);\n                        exit(1 as std::os::raw::c_int);\n                    }\n                }\n                j += 1\n            }\n        }\n        aa = (*aa).link\n    }\n    /*-- And again ... --*/\n    aa = argList;\n    while !aa.is_null() {\n        if strcmp((*aa).name, b\"--\\x00\" as *const u8 as *const std::os::raw::c_char)\n               == 0 as std::os::raw::c_int {\n            break ;\n        }\n        if strcmp((*aa).name,\n                  b\"--stdout\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n               0 as std::os::raw::c_int {\n            srcMode = 2 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--decompress\\x00\" as *const u8 as\n                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {\n            opMode = 2 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--compress\\x00\" as *const u8 as\n                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {\n            opMode = 1 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--force\\x00\" as *const u8 as *const std::os::raw::c_char)\n                      == 0 as std::os::raw::c_int {\n            forceOverwrite = 1 as std::os::raw::c_int as Bool\n        } else if strcmp((*aa).name,\n                         b\"--test\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                      0 as std::os::raw::c_int {\n            opMode = 3 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--keep\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                      0 as std::os::raw::c_int {\n            keepInputFiles = 1 as std::os::raw::c_int as Bool\n        } else if strcmp((*aa).name,\n                         b\"--small\\x00\" as *const u8 as *const std::os::raw::c_char)\n                      == 0 as std::os::raw::c_int {\n            smallMode = 1 as std::os::raw::c_int as Bool\n        } else if strcmp((*aa).name,\n                         b\"--quiet\\x00\" as *const u8 as *const std::os::raw::c_char)\n                      == 0 as std::os::raw::c_int {\n            noisy = 0 as std::os::raw::c_int as Bool\n        } else if strcmp((*aa).name,\n                         b\"--version\\x00\" as *const u8 as *const std::os::raw::c_char)\n                      == 0 as std::os::raw::c_int {\n            license();\n        } else if strcmp((*aa).name,\n                         b\"--license\\x00\" as *const u8 as *const std::os::raw::c_char)\n                      == 0 as std::os::raw::c_int {\n            license();\n        } else if strcmp((*aa).name,\n                         b\"--exponential\\x00\" as *const u8 as\n                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {\n            workFactor = 1 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--repetitive-best\\x00\" as *const u8 as\n                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {\n            redundant((*aa).name);\n        } else if strcmp((*aa).name,\n                         b\"--repetitive-fast\\x00\" as *const u8 as\n                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {\n            redundant((*aa).name);\n        } else if strcmp((*aa).name,\n                         b\"--fast\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                      0 as std::os::raw::c_int {\n            blockSize100k = 1 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--best\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                      0 as std::os::raw::c_int {\n            blockSize100k = 9 as std::os::raw::c_int\n        } else if strcmp((*aa).name,\n                         b\"--verbose\\x00\" as *const u8 as *const std::os::raw::c_char)\n                      == 0 as std::os::raw::c_int {\n            verbosity += 1\n        } else if strcmp((*aa).name,\n                         b\"--help\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                      0 as std::os::raw::c_int {\n            usage(progName);\n            exit(0 as std::os::raw::c_int);\n        } else {\n            if strncmp((*aa).name,\n                       b\"--\\x00\" as *const u8 as *const std::os::raw::c_char,\n                       2 as std::os::raw::c_int as std::os::raw::c_ulong) == 0 as std::os::raw::c_int\n               {\n                fprintf(__stderrp,\n                        b\"%s: Bad flag `%s\\'\\n\\x00\" as *const u8 as\n                            *const std::os::raw::c_char, progName, (*aa).name);\n                usage(progName);\n                exit(1 as std::os::raw::c_int);\n            }\n        }\n        aa = (*aa).link\n    }\n    if verbosity > 4 as std::os::raw::c_int { verbosity = 4 as std::os::raw::c_int }\n    if opMode == 1 as std::os::raw::c_int && smallMode as std::os::raw::c_int != 0 &&\n           blockSize100k > 2 as std::os::raw::c_int {\n        blockSize100k = 2 as std::os::raw::c_int\n    }\n    if opMode == 3 as std::os::raw::c_int && srcMode == 2 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"%s: -c and -t cannot be used together.\\n\\x00\" as *const u8\n                    as *const std::os::raw::c_char, progName);\n        exit(1 as std::os::raw::c_int);\n    }\n    if srcMode == 2 as std::os::raw::c_int && numFileNames == 0 as std::os::raw::c_int {\n        srcMode = 1 as std::os::raw::c_int\n    }\n    if opMode != 1 as std::os::raw::c_int { blockSize100k = 0 as std::os::raw::c_int }\n    if srcMode == 3 as std::os::raw::c_int {\n        signal(2 as std::os::raw::c_int,\n               Some(mySignalCatcher as\n                        unsafe extern \"C\" fn(_: IntNative) -> ()));\n        signal(15 as std::os::raw::c_int,\n               Some(mySignalCatcher as\n                        unsafe extern \"C\" fn(_: IntNative) -> ()));\n        signal(1 as std::os::raw::c_int,\n               Some(mySignalCatcher as\n                        unsafe extern \"C\" fn(_: IntNative) -> ()));\n    }\n    if opMode == 1 as std::os::raw::c_int {\n        if srcMode == 1 as std::os::raw::c_int {\n            compress(0 as *mut Char);\n        } else {\n            decode = 1 as std::os::raw::c_int as Bool;\n            aa = argList;\n            while !aa.is_null() {\n                if strcmp((*aa).name,\n                          b\"--\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                       0 as std::os::raw::c_int {\n                    decode = 0 as std::os::raw::c_int as Bool\n                } else if !(*(*aa).name.offset(0 as std::os::raw::c_int as isize) as\n                                std::os::raw::c_int == '-' as i32 &&\n                                decode as std::os::raw::c_int != 0) {\n                    numFilesProcessed += 1;\n                    compress((*aa).name);\n                }\n                aa = (*aa).link\n            }\n        }\n    } else if opMode == 2 as std::os::raw::c_int {\n        unzFailsExist = 0 as std::os::raw::c_int as Bool;\n        if srcMode == 1 as std::os::raw::c_int {\n            uncompress(0 as *mut Char);\n        } else {\n            decode = 1 as std::os::raw::c_int as Bool;\n            aa = argList;\n            while !aa.is_null() {\n                if strcmp((*aa).name,\n                          b\"--\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                       0 as std::os::raw::c_int {\n                    decode = 0 as std::os::raw::c_int as Bool\n                } else if !(*(*aa).name.offset(0 as std::os::raw::c_int as isize) as\n                                std::os::raw::c_int == '-' as i32 &&\n                                decode as std::os::raw::c_int != 0) {\n                    numFilesProcessed += 1;\n                    uncompress((*aa).name);\n                }\n                aa = (*aa).link\n            }\n        }\n        if unzFailsExist != 0 { setExit(2 as std::os::raw::c_int); exit(exitValue); }\n    } else {\n        testFailsExist = 0 as std::os::raw::c_int as Bool;\n        if srcMode == 1 as std::os::raw::c_int {\n            testf(0 as *mut Char);\n        } else {\n            decode = 1 as std::os::raw::c_int as Bool;\n            aa = argList;\n            while !aa.is_null() {\n                if strcmp((*aa).name,\n                          b\"--\\x00\" as *const u8 as *const std::os::raw::c_char) ==\n                       0 as std::os::raw::c_int {\n                    decode = 0 as std::os::raw::c_int as Bool\n                } else if !(*(*aa).name.offset(0 as std::os::raw::c_int as isize) as\n                                std::os::raw::c_int == '-' as i32 &&\n                                decode as std::os::raw::c_int != 0) {\n                    numFilesProcessed += 1;\n                    testf((*aa).name);\n                }\n                aa = (*aa).link\n            }\n        }\n        if testFailsExist != 0 {\n            if noisy != 0 {\n                fprintf(__stderrp,\n                        b\"\\nYou can use the `bzip2recover\\' program to attempt to recover\\ndata from undamaged sections of corrupted files.\\n\\n\\x00\"\n                            as *const u8 as *const std::os::raw::c_char);\n            }\n            setExit(2 as std::os::raw::c_int);\n            exit(exitValue);\n        }\n    }\n    /* Free the argument list memory to mollify leak detectors \n      (eg) Purify, Checker.  Serves no other useful purpose.\n   */\n    aa = argList;\n    while !aa.is_null() {\n        let mut aa2: *mut Cell = (*aa).link;\n        if !(*aa).name.is_null() { free((*aa).name as *mut std::os::raw::c_void); }\n        free(aa as *mut std::os::raw::c_void);\n        aa = aa2\n    }\n    return exitValue;\n}",
    "calls": [
      {
        "caller": "DefId(0:282 ~ c2rust_out[3c70]::bzip2::main)",
        "span": "bzip2.rs:3135:5: 3139:6 (#0)",
        "source": "unsafe {\n        ::std::process::exit(main_0((args.len() - 1) as IntNative,\n                                    args.as_mut_ptr() as *mut *mut Char) as\n                                 i32)\n    }"
      }
    ],
    "globals": [
      {
        "span": "bzip2.rs:334:1: 334:37 (#0)",
        "source": "pub static mut exitValue: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      },
      {
        "span": "bzip2.rs:342:1: 342:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:336:1: 336:34 (#0)",
        "source": "pub static mut opMode: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:322:1: 322:41 (#0)",
        "source": "pub static mut testFailsExist: Bool = 0;"
      },
      {
        "span": "bzip2.rs:332:1: 332:41 (#0)",
        "source": "pub static mut blockSize100k: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:328:1: 328:40 (#0)",
        "source": "pub static mut numFileNames: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:355:1: 355:38 (#0)",
        "source": "pub static mut workFactor: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:318:1: 318:50 (#0)",
        "source": "pub static mut deleteOutputOnInterrupt: Bool = 0;"
      },
      {
        "span": "bzip2.rs:352:1: 353:35 (#0)",
        "source": "pub static mut outputHandleJustInCase: *mut FILE =\n    0 as *const FILE as *mut FILE;"
      },
      {
        "span": "bzip2.rs:316:1: 316:36 (#0)",
        "source": "pub static mut smallMode: Bool = 0;"
      },
      {
        "span": "bzip2.rs:314:1: 314:41 (#0)",
        "source": "pub static mut keepInputFiles: Bool = 0;"
      },
      {
        "span": "bzip2.rs:326:1: 326:32 (#0)",
        "source": "pub static mut noisy: Bool = 0;"
      },
      {
        "span": "bzip2.rs:350:1: 350:57 (#0)",
        "source": "pub static mut progNameReally: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:340:1: 340:43 (#0)",
        "source": "pub static mut longestFileName: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:338:1: 338:35 (#0)",
        "source": "pub static mut srcMode: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:312:1: 312:37 (#0)",
        "source": "pub static mut verbosity: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:324:1: 324:40 (#0)",
        "source": "pub static mut unzFailsExist: Bool = 0;"
      },
      {
        "span": "bzip2.rs:320:1: 320:41 (#0)",
        "source": "pub static mut forceOverwrite: Bool = 0;"
      },
      {
        "span": "bzip2.rs:330:1: 330:45 (#0)",
        "source": "pub static mut numFilesProcessed: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:344:1: 344:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:278 ~ c2rust_out[3c70]::bzip2::mkCell)",
    "span": "bzip2.rs:2678:1: 2686:2 (#0)",
    "pieces": [
      "bzip2.rs:2678:1: 2686:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn mkCell() -> *mut Cell {\n    let mut c: *mut Cell = 0 as *mut Cell;\n    c =\n        myMalloc(::std::mem::size_of::<Cell>() as std::os::raw::c_ulong as Int32) as\n            *mut Cell;\n    (*c).name = 0 as *mut Char;\n    (*c).link = 0 as *mut zzzz;\n    return c;\n}",
    "calls": [
      {
        "caller": "DefId(0:279 ~ c2rust_out[3c70]::bzip2::snocString)",
        "span": "bzip2.rs:2691:9: 2691:43 (#0)",
        "source": "let mut tmp: *mut Cell = mkCell();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:279 ~ c2rust_out[3c70]::bzip2::snocString)",
    "span": "bzip2.rs:2688:1: 2704:2 (#0)",
    "pieces": [
      "bzip2.rs:2688:1: 2704:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "unsafe extern \"C\" fn snocString(mut root: *mut Cell, mut name: *mut Char)\n -> *mut Cell {\n    if root.is_null() {\n        let mut tmp: *mut Cell = mkCell();\n        (*tmp).name =\n            myMalloc((5 as std::os::raw::c_int as\n                          std::os::raw::c_ulong).wrapping_add(strlen(name)) as Int32)\n                as *mut Char;\n        strcpy((*tmp).name, name);\n        return tmp\n    } else {\n        let mut tmp_0: *mut Cell = root;\n        while !(*tmp_0).link.is_null() { tmp_0 = (*tmp_0).link }\n        (*tmp_0).link = snocString((*tmp_0).link, name);\n        return root\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:279 ~ c2rust_out[3c70]::bzip2::snocString)",
        "span": "bzip2.rs:2701:9: 2701:57 (#0)",
        "source": "(*tmp_0).link = snocString((*tmp_0).link, name);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:568 ~ c2rust_out[3c70]::huffman::BZ2_hbAssignCodes)",
    "span": "huffman.rs:193:1: 215:2 (#0)",
    "pieces": [
      "huffman.rs:193:1: 215:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn BZ2_hbAssignCodes(mut code: *mut Int32,\n                                           mut length: *mut UChar,\n                                           mut minLen: Int32,\n                                           mut maxLen: Int32,\n                                           mut alphaSize: Int32) {\n    let mut n: Int32 = 0;\n    let mut vec: Int32 = 0;\n    let mut i: Int32 = 0;\n    vec = 0 as std::os::raw::c_int;\n    n = minLen;\n    while n <= maxLen {\n        i = 0 as std::os::raw::c_int;\n        while i < alphaSize {\n            if *length.offset(i as isize) as std::os::raw::c_int == n {\n                *code.offset(i as isize) = vec;\n                vec += 1\n            }\n            i += 1\n        }\n        vec <<= 1 as std::os::raw::c_int;\n        n += 1\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "huffman.rs:6:1: 6:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:210 ~ c2rust_out[3c70]::bzip2::uInt64_isZero)",
    "span": "bzip2.rs:393:1: 403:2 (#0)",
    "pieces": [
      "bzip2.rs:393:1: 403:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn uInt64_isZero(mut n: *mut UInt64) -> Bool {\n    let mut i: Int32 = 0;\n    i = 0 as std::os::raw::c_int;\n    while i < 8 as std::os::raw::c_int {\n        if (*n).b[i as usize] as std::os::raw::c_int != 0 as std::os::raw::c_int {\n            return 0 as std::os::raw::c_int as Bool\n        }\n        i += 1\n    }\n    return 1 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:245 ~ c2rust_out[3c70]::bzip2::mySIGSEGVorSIGBUScatcher)",
    "span": "bzip2.rs:1745:1: 1782:2 (#0)",
    "pieces": [
      "bzip2.rs:1745:1: 1782:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "unsafe extern \"C\" fn mySIGSEGVorSIGBUScatcher(mut n: IntNative) {\n    let mut msg: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;\n    if opMode == 1 as std::os::raw::c_int {\n        msg =\n            b\": Caught a SIGSEGV or SIGBUS whilst compressing.\\n\\n   Possible causes are (most likely first):\\n   (1) This computer has unreliable memory or cache hardware\\n       (a surprisingly common problem; try a different machine.)\\n   (2) A bug in the compiler used to create this executable\\n       (unlikely, if you didn\\'t compile bzip2 yourself.)\\n   (3) A real bug in bzip2 -- I hope this should never be the case.\\n   The user\\'s manual, Section 4.3, has more info on (1) and (2).\\n   \\n   If you suspect this is a bug in bzip2, or are unsure about (1)\\n   or (2), feel free to report it to: bzip2-devel@sourceware.org.\\n   Section 4.3 of the user\\'s manual describes the info a useful\\n   bug report should have.  If the manual is available on your\\n   system, please try and read it before mailing me.  If you don\\'t\\n   have the manual or can\\'t be bothered to read it, mail me anyway.\\n\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char\n    } else {\n        msg =\n            b\": Caught a SIGSEGV or SIGBUS whilst decompressing.\\n\\n   Possible causes are (most likely first):\\n   (1) The compressed data is corrupted, and bzip2\\'s usual checks\\n       failed to detect this.  Try bzip2 -tvv my_file.bz2.\\n   (2) This computer has unreliable memory or cache hardware\\n       (a surprisingly common problem; try a different machine.)\\n   (3) A bug in the compiler used to create this executable\\n       (unlikely, if you didn\\'t compile bzip2 yourself.)\\n   (4) A real bug in bzip2 -- I hope this should never be the case.\\n   The user\\'s manual, Section 4.3, has more info on (2) and (3).\\n   \\n   If you suspect this is a bug in bzip2, or are unsure about (2)\\n   or (3), feel free to report it to: bzip2-devel@sourceware.org.\\n   Section 4.3 of the user\\'s manual describes the info a useful\\n   bug report should have.  If the manual is available on your\\n   system, please try and read it before mailing me.  If you don\\'t\\n   have the manual or can\\'t be bothered to read it, mail me anyway.\\n\\n\\x00\"\n                as *const u8 as *const std::os::raw::c_char\n    }\n    write(2 as std::os::raw::c_int,\n          b\"\\n\\x00\" as *const u8 as *const std::os::raw::c_char as\n              *const std::os::raw::c_void, 1 as std::os::raw::c_int as size_t);\n    write(2 as std::os::raw::c_int, progName as *const std::os::raw::c_void,\n          strlen(progName));\n    write(2 as std::os::raw::c_int, msg as *const std::os::raw::c_void, strlen(msg));\n    msg = b\"\\tInput file = \\x00\" as *const u8 as *const std::os::raw::c_char;\n    write(2 as std::os::raw::c_int, msg as *const std::os::raw::c_void, strlen(msg));\n    write(2 as std::os::raw::c_int, inName.as_mut_ptr() as *const std::os::raw::c_void,\n          strlen(inName.as_mut_ptr()));\n    write(2 as std::os::raw::c_int,\n          b\"\\n\\x00\" as *const u8 as *const std::os::raw::c_char as\n              *const std::os::raw::c_void, 1 as std::os::raw::c_int as size_t);\n    msg = b\"\\tOutput file = \\x00\" as *const u8 as *const std::os::raw::c_char;\n    write(2 as std::os::raw::c_int, msg as *const std::os::raw::c_void, strlen(msg));\n    write(2 as std::os::raw::c_int, outName.as_mut_ptr() as *const std::os::raw::c_void,\n          strlen(outName.as_mut_ptr()));\n    write(2 as std::os::raw::c_int,\n          b\"\\n\\x00\" as *const u8 as *const std::os::raw::c_char as\n              *const std::os::raw::c_void, 1 as std::os::raw::c_int as size_t);\n    /* Don't call cleanupAndFail. If we ended up here something went\n      terribly wrong. Trying to clean up might fail spectacularly. */\n    if opMode == 1 as std::os::raw::c_int {\n        setExit(3 as std::os::raw::c_int);\n    } else { setExit(2 as std::os::raw::c_int); }\n    _exit(exitValue);\n}",
    "calls": [],
    "globals": [
      {
        "span": "bzip2.rs:334:1: 334:37 (#0)",
        "source": "pub static mut exitValue: Int32 = 0;"
      },
      {
        "span": "bzip2.rs:342:1: 342:49 (#0)",
        "source": "pub static mut inName: [Char; 1034] = [0; 1034];"
      },
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      },
      {
        "span": "bzip2.rs:344:1: 344:50 (#0)",
        "source": "pub static mut outName: [Char; 1034] = [0; 1034];"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:252 ~ c2rust_out[3c70]::bzip2::notAStandardFile)",
    "span": "bzip2.rs:1869:1: 1897:2 (#0)",
    "pieces": [
      "bzip2.rs:1869:1: 1897:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 29,
    "source": "unsafe extern \"C\" fn notAStandardFile(mut name: *mut Char) -> Bool {\n    let mut i: IntNative = 0;\n    let mut statBuf: stat =\n        stat{st_dev: 0,\n             st_mode: 0,\n             st_nlink: 0,\n             st_ino: 0,\n             st_uid: 0,\n             st_gid: 0,\n             st_rdev: 0,\n             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},\n             st_size: 0,\n             st_blocks: 0,\n             st_blksize: 0,\n             st_flags: 0,\n             st_gen: 0,\n             st_lspare: 0,\n             st_qspare: [0; 2],};\n    i = lstat(name, &mut statBuf);\n    if i != 0 as std::os::raw::c_int { return 1 as std::os::raw::c_int as Bool }\n    if statBuf.st_mode as std::os::raw::c_int & 0o170000 as std::os::raw::c_int ==\n           0o100000 as std::os::raw::c_int {\n        return 0 as std::os::raw::c_int as Bool\n    }\n    return 1 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:340 ~ c2rust_out[3c70]::bzip2recover::endsInBz2)",
    "span": "bzip2recover.rs:268:1: 279:2 (#0)",
    "pieces": [
      "bzip2recover.rs:268:1: 279:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn endsInBz2(mut name: *mut Char) -> Bool {\n    let mut n: Int32 = strlen(name) as Int32;\n    if n <= 4 as std::os::raw::c_int { return 0 as std::os::raw::c_int as Bool }\n    return (*name.offset((n - 4 as std::os::raw::c_int) as isize) as std::os::raw::c_int ==\n                '.' as i32 &&\n                *name.offset((n - 3 as std::os::raw::c_int) as isize) as std::os::raw::c_int\n                    == 'b' as i32 &&\n                *name.offset((n - 2 as std::os::raw::c_int) as isize) as std::os::raw::c_int\n                    == 'z' as i32 &&\n                *name.offset((n - 1 as std::os::raw::c_int) as isize) as std::os::raw::c_int\n                    == '2' as i32) as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:497 ~ c2rust_out[3c70]::compress::bsW)",
    "span": "compress.rs:88:1: 98:2 (#0)",
    "pieces": [
      "compress.rs:88:1: 98:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn bsW(mut s: *mut EState, mut n: Int32, mut v: UInt32) {\n    while (*s).bsLive >= 8 as std::os::raw::c_int {\n        *(*s).zbits.offset((*s).numZ as isize) =\n            ((*s).bsBuff >> 24 as std::os::raw::c_int) as UChar;\n        (*s).numZ += 1;\n        (*s).bsBuff <<= 8 as std::os::raw::c_int;\n        (*s).bsLive -= 8 as std::os::raw::c_int\n    }\n    (*s).bsBuff |= v << 32 as std::os::raw::c_int - (*s).bsLive - n;\n    (*s).bsLive += n;\n}",
    "calls": [
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2500:9: 2500:67 (#0)",
        "source": "bsW(s, 24 as std::os::raw::c_int, (*s).origPtr as UInt32);"
      },
      {
        "caller": "DefId(0:504 ~ c2rust_out[3c70]::compress::sendMTFValues)",
        "span": "compress.rs:2194:5: 2194:57 (#0)",
        "source": "bsW(s, 3 as std::os::raw::c_int, nGroups as UInt32);"
      },
      {
        "caller": "DefId(0:498 ~ c2rust_out[3c70]::compress::bsPutUInt32)",
        "span": "compress.rs:107:5: 109:21 (#0)",
        "source": "bsW(s, 8 as std::os::raw::c_int,\n        ((u >> 8 as std::os::raw::c_int) as std::os::raw::c_long & 0xff as std::os::raw::c_long) as\n            UInt32);"
      },
      {
        "caller": "DefId(0:498 ~ c2rust_out[3c70]::compress::bsPutUInt32)",
        "span": "compress.rs:104:5: 106:21 (#0)",
        "source": "bsW(s, 8 as std::os::raw::c_int,\n        ((u >> 16 as std::os::raw::c_int) as std::os::raw::c_long & 0xff as std::os::raw::c_long) as\n            UInt32);"
      },
      {
        "caller": "DefId(0:498 ~ c2rust_out[3c70]::compress::bsPutUInt32)",
        "span": "compress.rs:101:5: 103:21 (#0)",
        "source": "bsW(s, 8 as std::os::raw::c_int,\n        ((u >> 24 as std::os::raw::c_int) as std::os::raw::c_long & 0xff as std::os::raw::c_long) as\n            UInt32);"
      },
      {
        "caller": "DefId(0:498 ~ c2rust_out[3c70]::compress::bsPutUInt32)",
        "span": "compress.rs:110:5: 111:79 (#0)",
        "source": "bsW(s, 8 as std::os::raw::c_int,\n        (u as std::os::raw::c_long & 0xff as std::os::raw::c_long) as UInt32);"
      },
      {
        "caller": "DefId(0:499 ~ c2rust_out[3c70]::compress::bsPutUChar)",
        "span": "compress.rs:115:5: 115:51 (#0)",
        "source": "bsW(s, 8 as std::os::raw::c_int, c as UInt32);"
      },
      {
        "caller": "DefId(0:504 ~ c2rust_out[3c70]::compress::sendMTFValues)",
        "span": "compress.rs:2195:5: 2195:61 (#0)",
        "source": "bsW(s, 15 as std::os::raw::c_int, nSelectors as UInt32);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2499:9: 2499:78 (#0)",
        "source": "bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:17:1: 17:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:21:1: 21:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:18:1: 18:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:19:1: 19:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:20:1: 20:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:504 ~ c2rust_out[3c70]::compress::sendMTFValues)",
    "span": "compress.rs:258:1: 2450:2 (#0)",
    "pieces": [
      "compress.rs:258:1: 2450:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 2193,
    "source": "unsafe extern \"C\" fn sendMTFValues(mut s: *mut EState) {\n    let mut v: Int32 = 0;\n    let mut t: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut gs: Int32 = 0;\n    let mut ge: Int32 = 0;\n    let mut totc: Int32 = 0;\n    let mut bt: Int32 = 0;\n    let mut bc: Int32 = 0;\n    let mut iter: Int32 = 0;\n    let mut nSelectors: Int32 = 0;\n    let mut alphaSize: Int32 = 0;\n    let mut minLen: Int32 = 0;\n    let mut maxLen: Int32 = 0;\n    let mut selCtr: Int32 = 0;\n    let mut nGroups: Int32 = 0;\n    let mut nBytes: Int32 = 0;\n    /*--\n   UChar  len [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];\n   is a global since the decoder also needs it.\n\n   Int32  code[BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];\n   Int32  rfreq[BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];\n   are also globals only used in this proc.\n   Made global to keep stack frame size small.\n   --*/\n    let mut cost: [UInt16; 6] = [0; 6];\n    let mut fave: [Int32; 6] = [0; 6];\n    let mut mtfv: *mut UInt16 = (*s).mtfv;\n    if (*s).verbosity >= 3 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"      %d in block, %d after MTF & 1-2 coding, %d+2 syms in use\\n\\x00\"\n                    as *const u8 as *const std::os::raw::c_char, (*s).nblock,\n                (*s).nMTF, (*s).nInUse);\n    }\n    alphaSize = (*s).nInUse + 2 as std::os::raw::c_int;\n    t = 0 as std::os::raw::c_int;\n    while t < 6 as std::os::raw::c_int {\n        v = 0 as std::os::raw::c_int;\n        while v < alphaSize {\n            (*s).len[t as usize][v as usize] = 15 as std::os::raw::c_int as UChar;\n            v += 1\n        }\n        t += 1\n    }\n    /*--- Decide how many coding tables to use ---*/\n    if !((*s).nMTF > 0 as std::os::raw::c_int) {\n        BZ2_bz__AssertH__fail(3001 as std::os::raw::c_int);\n    }\n    if (*s).nMTF < 200 as std::os::raw::c_int {\n        nGroups = 2 as std::os::raw::c_int\n    } else if (*s).nMTF < 600 as std::os::raw::c_int {\n        nGroups = 3 as std::os::raw::c_int\n    } else if (*s).nMTF < 1200 as std::os::raw::c_int {\n        nGroups = 4 as std::os::raw::c_int\n    } else if (*s).nMTF < 2400 as std::os::raw::c_int {\n        nGroups = 5 as std::os::raw::c_int\n    } else { nGroups = 6 as std::os::raw::c_int }\n    /*--- Generate an initial set of coding tables ---*/\n    let mut nPart: Int32 = 0;\n    let mut remF: Int32 = 0;\n    let mut tFreq: Int32 = 0;\n    let mut aFreq: Int32 = 0;\n    nPart = nGroups;\n    remF = (*s).nMTF;\n    gs = 0 as std::os::raw::c_int;\n    while nPart > 0 as std::os::raw::c_int {\n        tFreq = remF / nPart;\n        ge = gs - 1 as std::os::raw::c_int;\n        aFreq = 0 as std::os::raw::c_int;\n        while aFreq < tFreq && ge < alphaSize - 1 as std::os::raw::c_int {\n            ge += 1;\n            aFreq += (*s).mtfFreq[ge as usize]\n        }\n        if ge > gs && nPart != nGroups && nPart != 1 as std::os::raw::c_int &&\n               (nGroups - nPart) % 2 as std::os::raw::c_int == 1 as std::os::raw::c_int {\n            aFreq -= (*s).mtfFreq[ge as usize];\n            ge -= 1\n        }\n        if (*s).verbosity >= 3 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"      initial group %d, [%d .. %d], has %d syms (%4.1f%%)\\n\\x00\"\n                        as *const u8 as *const std::os::raw::c_char, nPart, gs, ge,\n                    aFreq,\n                    100.0f64 * aFreq as std::os::raw::c_float as std::os::raw::c_double /\n                        (*s).nMTF as std::os::raw::c_float as std::os::raw::c_double);\n        }\n        v = 0 as std::os::raw::c_int;\n        while v < alphaSize {\n            if v >= gs && v <= ge {\n                (*s).len[(nPart - 1 as std::os::raw::c_int) as usize][v as usize] =\n                    0 as std::os::raw::c_int as UChar\n            } else {\n                (*s).len[(nPart - 1 as std::os::raw::c_int) as usize][v as usize] =\n                    15 as std::os::raw::c_int as UChar\n            }\n            v += 1\n        }\n        nPart -= 1;\n        gs = ge + 1 as std::os::raw::c_int;\n        remF -= aFreq\n    }\n    /*--- \n      Iterate up to BZ_N_ITERS times to improve the tables.\n   ---*/\n    iter = 0 as std::os::raw::c_int;\n    while iter < 4 as std::os::raw::c_int {\n        t = 0 as std::os::raw::c_int;\n        while t < nGroups { fave[t as usize] = 0 as std::os::raw::c_int; t += 1 }\n        t = 0 as std::os::raw::c_int;\n        while t < nGroups {\n            v = 0 as std::os::raw::c_int;\n            while v < alphaSize {\n                (*s).rfreq[t as usize][v as usize] = 0 as std::os::raw::c_int;\n                v += 1\n            }\n            t += 1\n        }\n        /*---\n        Set up an auxiliary length table which is used to fast-track\n\tthe common case (nGroups == 6). \n      ---*/\n        if nGroups == 6 as std::os::raw::c_int {\n            v = 0 as std::os::raw::c_int;\n            while v < alphaSize {\n                (*s).len_pack[v as usize][0 as std::os::raw::c_int as usize] =\n                    (((*s).len[1 as std::os::raw::c_int as usize][v as usize] as\n                          std::os::raw::c_int) << 16 as std::os::raw::c_int |\n                         (*s).len[0 as std::os::raw::c_int as usize][v as usize] as\n                             std::os::raw::c_int) as UInt32;\n                (*s).len_pack[v as usize][1 as std::os::raw::c_int as usize] =\n                    (((*s).len[3 as std::os::raw::c_int as usize][v as usize] as\n                          std::os::raw::c_int) << 16 as std::os::raw::c_int |\n                         (*s).len[2 as std::os::raw::c_int as usize][v as usize] as\n                             std::os::raw::c_int) as UInt32;\n                (*s).len_pack[v as usize][2 as std::os::raw::c_int as usize] =\n                    (((*s).len[5 as std::os::raw::c_int as usize][v as usize] as\n                          std::os::raw::c_int) << 16 as std::os::raw::c_int |\n                         (*s).len[4 as std::os::raw::c_int as usize][v as usize] as\n                             std::os::raw::c_int) as UInt32;\n                v += 1\n            }\n        }\n        nSelectors = 0 as std::os::raw::c_int;\n        totc = 0 as std::os::raw::c_int;\n        gs = 0 as std::os::raw::c_int;\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /*--- Set group start & end marks. --*/\n            if gs >= (*s).nMTF { break ; }\n            ge = gs + 50 as std::os::raw::c_int - 1 as std::os::raw::c_int;\n            if ge >= (*s).nMTF { ge = (*s).nMTF - 1 as std::os::raw::c_int }\n            /*-- \n            Calculate the cost of this group as coded\n            by each of the coding tables.\n         --*/\n            t = 0 as std::os::raw::c_int;\n            while t < nGroups {\n                cost[t as usize] = 0 as std::os::raw::c_int as UInt16;\n                t += 1\n            }\n            if nGroups == 6 as std::os::raw::c_int &&\n                   50 as std::os::raw::c_int == ge - gs + 1 as std::os::raw::c_int {\n                /*--- fast track the common case ---*/\n                let mut cost01: UInt32 = 0;\n                let mut cost23: UInt32 = 0;\n                let mut cost45: UInt32 = 0;\n                let mut icv: UInt16 = 0;\n                cost45 = 0 as std::os::raw::c_int as UInt32;\n                cost23 = cost45;\n                cost01 = cost23;\n                icv = *mtfv.offset((gs + 0 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 1 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 2 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 3 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 4 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 5 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 6 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 7 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 8 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 9 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 10 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 11 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 12 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 13 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 14 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 15 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 16 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 17 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 18 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 19 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 20 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 21 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 22 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 23 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 24 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 25 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 26 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 27 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 28 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 29 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 30 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 31 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 32 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 33 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 34 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 35 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 36 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 37 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 38 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 39 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 40 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 41 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 42 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 43 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 44 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 45 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 46 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 47 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 48 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                icv = *mtfv.offset((gs + 49 as std::os::raw::c_int) as isize);\n                cost01 =\n                    (cost01 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][0\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost23 =\n                    (cost23 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][1\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost45 =\n                    (cost45 as\n                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as\n                                                                      usize][2\n                                                                                 as\n                                                                                 std::os::raw::c_int\n                                                                                 as\n                                                                                 usize])\n                        as UInt32 as UInt32;\n                cost[0 as std::os::raw::c_int as usize] =\n                    (cost01 & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as\n                        UInt16;\n                cost[1 as std::os::raw::c_int as usize] =\n                    (cost01 >> 16 as std::os::raw::c_int) as UInt16;\n                cost[2 as std::os::raw::c_int as usize] =\n                    (cost23 & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as\n                        UInt16;\n                cost[3 as std::os::raw::c_int as usize] =\n                    (cost23 >> 16 as std::os::raw::c_int) as UInt16;\n                cost[4 as std::os::raw::c_int as usize] =\n                    (cost45 & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as\n                        UInt16;\n                cost[5 as std::os::raw::c_int as usize] =\n                    (cost45 >> 16 as std::os::raw::c_int) as UInt16\n            } else {\n                /*--- slow version which correctly handles all situations ---*/\n                i = gs;\n                while i <= ge {\n                    let mut icv_0: UInt16 = *mtfv.offset(i as isize);\n                    t = 0 as std::os::raw::c_int;\n                    while t < nGroups {\n                        cost[t as usize] =\n                            (cost[t as usize] as std::os::raw::c_int +\n                                 (*s).len[t as usize][icv_0 as usize] as\n                                     std::os::raw::c_int) as UInt16;\n                        t += 1\n                    }\n                    i += 1\n                }\n            }\n            /*-- \n            Find the coding table which is best for this group,\n            and record its identity in the selector table.\n         --*/\n            bc = 999999999 as std::os::raw::c_int;\n            bt = -(1 as std::os::raw::c_int);\n            t = 0 as std::os::raw::c_int;\n            while t < nGroups {\n                if (cost[t as usize] as std::os::raw::c_int) < bc {\n                    bc = cost[t as usize] as Int32;\n                    bt = t\n                }\n                t += 1\n            }\n            totc += bc;\n            fave[bt as usize] += 1;\n            (*s).selector[nSelectors as usize] = bt as UChar;\n            nSelectors += 1;\n            /*-- \n            Increment the symbol frequencies for the selected table.\n          --*/\n            if nGroups == 6 as std::os::raw::c_int &&\n                   50 as std::os::raw::c_int == ge - gs + 1 as std::os::raw::c_int {\n                /*--- fast track the common case ---*/\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 0 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 1 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 2 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 3 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 4 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 5 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 6 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 7 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 8 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 9 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 10 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 11 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 12 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 13 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 14 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 15 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 16 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 17 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 18 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 19 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 20 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 21 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 22 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 23 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 24 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 25 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 26 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 27 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 28 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 29 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 30 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 31 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 32 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 33 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 34 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 35 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 36 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 37 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 38 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 39 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 40 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 41 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 42 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 43 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 44 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 45 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 46 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 47 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 48 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1;\n                (*s).rfreq[bt as\n                               usize][*mtfv.offset((gs + 49 as std::os::raw::c_int) as\n                                                       isize) as usize] += 1\n            } else {\n                /*--- slow version which correctly handles all situations ---*/\n                i = gs;\n                while i <= ge {\n                    (*s).rfreq[bt as usize][*mtfv.offset(i as isize) as usize]\n                        += 1;\n                    i += 1\n                }\n            }\n            gs = ge + 1 as std::os::raw::c_int\n        }\n        if (*s).verbosity >= 3 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"      pass %d: size is %d, grp uses are \\x00\" as\n                        *const u8 as *const std::os::raw::c_char,\n                    iter + 1 as std::os::raw::c_int, totc / 8 as std::os::raw::c_int);\n            t = 0 as std::os::raw::c_int;\n            while t < nGroups {\n                fprintf(__stderrp,\n                        b\"%d \\x00\" as *const u8 as *const std::os::raw::c_char,\n                        fave[t as usize]);\n                t += 1\n            }\n            fprintf(__stderrp, b\"\\n\\x00\" as *const u8 as *const std::os::raw::c_char);\n        }\n        /*--\n        Recompute the tables based on the accumulated frequencies.\n      --*/\n      /* maxLen was changed from 20 to 17 in bzip2-1.0.3.  See \n         comment in huffman.c for details. */\n        t = 0 as std::os::raw::c_int;\n        while t < nGroups {\n            BZ2_hbMakeCodeLengths(&mut *(*(*s).len.as_mut_ptr().offset(t as\n                                                                           isize)).as_mut_ptr().offset(0\n                                                                                                           as\n                                                                                                           std::os::raw::c_int\n                                                                                                           as\n                                                                                                           isize),\n                                  &mut *(*(*s).rfreq.as_mut_ptr().offset(t as\n                                                                             isize)).as_mut_ptr().offset(0\n                                                                                                             as\n                                                                                                             std::os::raw::c_int\n                                                                                                             as\n                                                                                                             isize),\n                                  alphaSize, 17 as std::os::raw::c_int);\n            t += 1\n        }\n        iter += 1\n    }\n    if !(nGroups < 8 as std::os::raw::c_int) {\n        BZ2_bz__AssertH__fail(3002 as std::os::raw::c_int);\n    }\n    if !(nSelectors < 32768 as std::os::raw::c_int &&\n             nSelectors <=\n                 2 as std::os::raw::c_int + 900000 as std::os::raw::c_int / 50 as std::os::raw::c_int)\n       {\n        BZ2_bz__AssertH__fail(3003 as std::os::raw::c_int);\n    }\n    /*--- Compute MTF values for the selectors. ---*/\n    let mut pos: [UChar; 6] = [0; 6];\n    let mut ll_i: UChar = 0;\n    let mut tmp2: UChar = 0;\n    let mut tmp: UChar = 0;\n    i = 0 as std::os::raw::c_int;\n    while i < nGroups { pos[i as usize] = i as UChar; i += 1 }\n    i = 0 as std::os::raw::c_int;\n    while i < nSelectors {\n        ll_i = (*s).selector[i as usize];\n        j = 0 as std::os::raw::c_int;\n        tmp = pos[j as usize];\n        while ll_i as std::os::raw::c_int != tmp as std::os::raw::c_int {\n            j += 1;\n            tmp2 = tmp;\n            tmp = pos[j as usize];\n            pos[j as usize] = tmp2\n        }\n        pos[0 as std::os::raw::c_int as usize] = tmp;\n        (*s).selectorMtf[i as usize] = j as UChar;\n        i += 1\n    }\n    /*--- Assign actual codes for the tables. --*/\n    t = 0 as std::os::raw::c_int;\n    while t < nGroups {\n        minLen = 32 as std::os::raw::c_int;\n        maxLen = 0 as std::os::raw::c_int;\n        i = 0 as std::os::raw::c_int;\n        while i < alphaSize {\n            if (*s).len[t as usize][i as usize] as std::os::raw::c_int > maxLen {\n                maxLen = (*s).len[t as usize][i as usize] as Int32\n            }\n            if ((*s).len[t as usize][i as usize] as std::os::raw::c_int) < minLen {\n                minLen = (*s).len[t as usize][i as usize] as Int32\n            }\n            i += 1\n        }\n        if maxLen > 17 as std::os::raw::c_int {\n            BZ2_bz__AssertH__fail(3004 as std::os::raw::c_int);\n        }\n        if minLen < 1 as std::os::raw::c_int {\n            BZ2_bz__AssertH__fail(3005 as std::os::raw::c_int);\n        }\n        BZ2_hbAssignCodes(&mut *(*(*s).code.as_mut_ptr().offset(t as\n                                                                    isize)).as_mut_ptr().offset(0\n                                                                                                    as\n                                                                                                    std::os::raw::c_int\n                                                                                                    as\n                                                                                                    isize),\n                          &mut *(*(*s).len.as_mut_ptr().offset(t as\n                                                                   isize)).as_mut_ptr().offset(0\n                                                                                                   as\n                                                                                                   std::os::raw::c_int\n                                                                                                   as\n                                                                                                   isize),\n                          minLen, maxLen, alphaSize);\n        t += 1\n    }\n    /*--- Transmit the mapping table. ---*/\n    let mut inUse16: [Bool; 16] = [0; 16];\n    i = 0 as std::os::raw::c_int;\n    while i < 16 as std::os::raw::c_int {\n        inUse16[i as usize] = 0 as std::os::raw::c_int as Bool;\n        j = 0 as std::os::raw::c_int;\n        while j < 16 as std::os::raw::c_int {\n            if (*s).inUse[(i * 16 as std::os::raw::c_int + j) as usize] != 0 {\n                inUse16[i as usize] = 1 as std::os::raw::c_int as Bool\n            }\n            j += 1\n        }\n        i += 1\n    }\n    nBytes = (*s).numZ;\n    i = 0 as std::os::raw::c_int;\n    while i < 16 as std::os::raw::c_int {\n        if inUse16[i as usize] != 0 {\n            bsW(s, 1 as std::os::raw::c_int, 1 as std::os::raw::c_int as UInt32);\n        } else { bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32); }\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 16 as std::os::raw::c_int {\n        if inUse16[i as usize] != 0 {\n            j = 0 as std::os::raw::c_int;\n            while j < 16 as std::os::raw::c_int {\n                if (*s).inUse[(i * 16 as std::os::raw::c_int + j) as usize] != 0 {\n                    bsW(s, 1 as std::os::raw::c_int, 1 as std::os::raw::c_int as UInt32);\n                } else {\n                    bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);\n                }\n                j += 1\n            }\n        }\n        i += 1\n    }\n    if (*s).verbosity >= 3 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"      bytes: mapping %d, \\x00\" as *const u8 as\n                    *const std::os::raw::c_char, (*s).numZ - nBytes);\n    }\n    /*--- Now the selectors. ---*/\n    nBytes = (*s).numZ;\n    bsW(s, 3 as std::os::raw::c_int, nGroups as UInt32);\n    bsW(s, 15 as std::os::raw::c_int, nSelectors as UInt32);\n    i = 0 as std::os::raw::c_int;\n    while i < nSelectors {\n        j = 0 as std::os::raw::c_int;\n        while j < (*s).selectorMtf[i as usize] as std::os::raw::c_int {\n            bsW(s, 1 as std::os::raw::c_int, 1 as std::os::raw::c_int as UInt32);\n            j += 1\n        }\n        bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);\n        i += 1\n    }\n    if (*s).verbosity >= 3 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"selectors %d, \\x00\" as *const u8 as *const std::os::raw::c_char,\n                (*s).numZ - nBytes);\n    }\n    /*--- Now the coding tables. ---*/\n    nBytes = (*s).numZ;\n    t = 0 as std::os::raw::c_int;\n    while t < nGroups {\n        let mut curr: Int32 =\n            (*s).len[t as usize][0 as std::os::raw::c_int as usize] as Int32;\n        bsW(s, 5 as std::os::raw::c_int, curr as UInt32);\n        i = 0 as std::os::raw::c_int;\n        while i < alphaSize {\n            while curr < (*s).len[t as usize][i as usize] as std::os::raw::c_int {\n                bsW(s, 2 as std::os::raw::c_int, 2 as std::os::raw::c_int as UInt32);\n                curr += 1\n                /* 10 */\n            }\n            while curr > (*s).len[t as usize][i as usize] as std::os::raw::c_int {\n                bsW(s, 2 as std::os::raw::c_int, 3 as std::os::raw::c_int as UInt32);\n                curr -= 1\n                /* 11 */\n            }\n            bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);\n            i += 1\n        }\n        t += 1\n    }\n    if (*s).verbosity >= 3 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"code lengths %d, \\x00\" as *const u8 as *const std::os::raw::c_char,\n                (*s).numZ - nBytes);\n    }\n    /*--- And finally, the block data proper ---*/\n    nBytes = (*s).numZ;\n    selCtr = 0 as std::os::raw::c_int;\n    gs = 0 as std::os::raw::c_int;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        if gs >= (*s).nMTF { break ; }\n        ge = gs + 50 as std::os::raw::c_int - 1 as std::os::raw::c_int;\n        if ge >= (*s).nMTF { ge = (*s).nMTF - 1 as std::os::raw::c_int }\n        if !(((*s).selector[selCtr as usize] as std::os::raw::c_int) < nGroups) {\n            BZ2_bz__AssertH__fail(3006 as std::os::raw::c_int);\n        }\n        if nGroups == 6 as std::os::raw::c_int &&\n               50 as std::os::raw::c_int == ge - gs + 1 as std::os::raw::c_int {\n            /*--- fast track the common case ---*/\n            let mut mtfv_i: UInt16 = 0;\n            let mut s_len_sel_selCtr: *mut UChar =\n                &mut *(*(*s).len.as_mut_ptr().offset(*(*s).selector.as_mut_ptr().offset(selCtr\n                                                                                            as\n                                                                                            isize)\n                                                         as\n                                                         isize)).as_mut_ptr().offset(0\n                                                                                         as\n                                                                                         std::os::raw::c_int\n                                                                                         as\n                                                                                         isize)\n                    as *mut UChar;\n            let mut s_code_sel_selCtr: *mut Int32 =\n                &mut *(*(*s).code.as_mut_ptr().offset(*(*s).selector.as_mut_ptr().offset(selCtr\n                                                                                             as\n                                                                                             isize)\n                                                          as\n                                                          isize)).as_mut_ptr().offset(0\n                                                                                          as\n                                                                                          std::os::raw::c_int\n                                                                                          as\n                                                                                          isize)\n                    as *mut Int32;\n            mtfv_i = *mtfv.offset((gs + 0 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 1 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 2 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 3 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 4 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 5 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 6 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 7 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 8 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 9 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 10 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 11 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 12 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 13 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 14 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 15 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 16 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 17 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 18 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 19 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 20 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 21 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 22 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 23 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 24 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 25 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 26 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 27 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 28 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 29 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 30 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 31 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 32 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 33 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 34 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 35 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 36 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 37 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 38 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 39 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 40 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 41 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 42 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 43 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 44 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 45 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 46 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 47 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 48 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n            mtfv_i = *mtfv.offset((gs + 49 as std::os::raw::c_int) as isize);\n            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,\n                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);\n        } else {\n            /*--- slow version which correctly handles all situations ---*/\n            i = gs;\n            while i <= ge {\n                bsW(s,\n                    (*s).len[(*s).selector[selCtr as usize] as\n                                 usize][*mtfv.offset(i as isize) as usize] as\n                        Int32,\n                    (*s).code[(*s).selector[selCtr as usize] as\n                                  usize][*mtfv.offset(i as isize) as usize] as\n                        UInt32);\n                i += 1\n            }\n        }\n        gs = ge + 1 as std::os::raw::c_int;\n        selCtr += 1\n    }\n    if !(selCtr == nSelectors) { BZ2_bz__AssertH__fail(3007 as std::os::raw::c_int); }\n    if (*s).verbosity >= 3 as std::os::raw::c_int {\n        fprintf(__stderrp,\n                b\"codes %d\\n\\x00\" as *const u8 as *const std::os::raw::c_char,\n                (*s).numZ - nBytes);\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2502:9: 2502:26 (#0)",
        "source": "sendMTFValues(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:21:1: 21:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:18:1: 18:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:20:1: 20:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:19:1: 19:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:17:1: 17:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:498 ~ c2rust_out[3c70]::compress::bsPutUInt32)",
    "span": "compress.rs:100:1: 112:2 (#0)",
    "pieces": [
      "compress.rs:100:1: 112:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn bsPutUInt32(mut s: *mut EState, mut u: UInt32) {\n    bsW(s, 8 as std::os::raw::c_int,\n        ((u >> 24 as std::os::raw::c_int) as std::os::raw::c_long & 0xff as std::os::raw::c_long) as\n            UInt32);\n    bsW(s, 8 as std::os::raw::c_int,\n        ((u >> 16 as std::os::raw::c_int) as std::os::raw::c_long & 0xff as std::os::raw::c_long) as\n            UInt32);\n    bsW(s, 8 as std::os::raw::c_int,\n        ((u >> 8 as std::os::raw::c_int) as std::os::raw::c_long & 0xff as std::os::raw::c_long) as\n            UInt32);\n    bsW(s, 8 as std::os::raw::c_int,\n        (u as std::os::raw::c_long & 0xff as std::os::raw::c_long) as UInt32);\n}",
    "calls": [
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2489:9: 2489:39 (#0)",
        "source": "bsPutUInt32(s, (*s).blockCRC);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2512:9: 2512:42 (#0)",
        "source": "bsPutUInt32(s, (*s).combinedCRC);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:21:1: 21:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:18:1: 18:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:20:1: 20:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:17:1: 17:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:19:1: 19:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:499 ~ c2rust_out[3c70]::compress::bsPutUChar)",
    "span": "compress.rs:114:1: 116:2 (#0)",
    "pieces": [
      "compress.rs:114:1: 116:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn bsPutUChar(mut s: *mut EState, mut c: UChar) {\n    bsW(s, 8 as std::os::raw::c_int, c as UInt32);\n}",
    "calls": [
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2479:9: 2479:84 (#0)",
        "source": "bsPutUChar(s, (0x30 as std::os::raw::c_int + (*s).blockSize100k) as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2507:9: 2507:61 (#0)",
        "source": "bsPutUChar(s, 0x72 as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2508:9: 2508:61 (#0)",
        "source": "bsPutUChar(s, 0x45 as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2511:9: 2511:61 (#0)",
        "source": "bsPutUChar(s, 0x90 as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2510:9: 2510:61 (#0)",
        "source": "bsPutUChar(s, 0x50 as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2487:9: 2487:61 (#0)",
        "source": "bsPutUChar(s, 0x59 as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2478:9: 2478:61 (#0)",
        "source": "bsPutUChar(s, 0x68 as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2477:9: 2477:61 (#0)",
        "source": "bsPutUChar(s, 0x5a as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2482:9: 2482:61 (#0)",
        "source": "bsPutUChar(s, 0x31 as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2486:9: 2486:61 (#0)",
        "source": "bsPutUChar(s, 0x53 as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2484:9: 2484:61 (#0)",
        "source": "bsPutUChar(s, 0x59 as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2476:9: 2476:61 (#0)",
        "source": "bsPutUChar(s, 0x42 as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2506:9: 2506:61 (#0)",
        "source": "bsPutUChar(s, 0x17 as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2485:9: 2485:61 (#0)",
        "source": "bsPutUChar(s, 0x26 as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2483:9: 2483:61 (#0)",
        "source": "bsPutUChar(s, 0x41 as std::os::raw::c_int as UChar);"
      },
      {
        "caller": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
        "span": "compress.rs:2509:9: 2509:61 (#0)",
        "source": "bsPutUChar(s, 0x38 as std::os::raw::c_int as UChar);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:17:1: 17:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:19:1: 19:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      },
      {
        "span": "compress.rs:18:1: 18:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:21:1: 21:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:20:1: 20:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:513 ~ c2rust_out[3c70]::compress::BZ2_compressBlock)",
    "span": "compress.rs:2453:1: 2520:2 (#0)",
    "pieces": [
      "compress.rs:2453:1: 2520:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 68,
    "source": "pub unsafe extern \"C\" fn BZ2_compressBlock(mut s: *mut EState,\n                                           mut is_last_block: Bool) {\n    if (*s).nblock > 0 as std::os::raw::c_int {\n        (*s).blockCRC = !(*s).blockCRC;\n        (*s).combinedCRC =\n            (*s).combinedCRC << 1 as std::os::raw::c_int |\n                (*s).combinedCRC >> 31 as std::os::raw::c_int;\n        (*s).combinedCRC ^= (*s).blockCRC;\n        if (*s).blockNo > 1 as std::os::raw::c_int { (*s).numZ = 0 as std::os::raw::c_int }\n        if (*s).verbosity >= 2 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"    block %d: crc = 0x%08x, combined CRC = 0x%08x, size = %d\\n\\x00\"\n                        as *const u8 as *const std::os::raw::c_char, (*s).blockNo,\n                    (*s).blockCRC, (*s).combinedCRC, (*s).nblock);\n        }\n        BZ2_blockSort(s);\n    }\n    (*s).zbits =\n        &mut *((*s).arr2 as *mut UChar).offset((*s).nblock as isize) as\n            *mut UChar;\n    /*-- If this is the first block, create the stream header. --*/\n    if (*s).blockNo == 1 as std::os::raw::c_int {\n        BZ2_bsInitWrite(s);\n        bsPutUChar(s, 0x42 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x5a as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x68 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, (0x30 as std::os::raw::c_int + (*s).blockSize100k) as UChar);\n    }\n    if (*s).nblock > 0 as std::os::raw::c_int {\n        bsPutUChar(s, 0x31 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x41 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x59 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x26 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x53 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x59 as std::os::raw::c_int as UChar);\n        /*-- Now the block's CRC, so it is in a known place. --*/\n        bsPutUInt32(s, (*s).blockCRC);\n        /*-- \n         Now a single bit indicating (non-)randomisation. \n         As of version 0.9.5, we use a better sorting algorithm\n         which makes randomisation unnecessary.  So always set\n         the randomised bit to 'no'.  Of course, the decoder\n         still needs to be able to handle randomised blocks\n         so as to maintain backwards compatibility with\n         older versions of bzip2.\n      --*/\n        bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);\n        bsW(s, 24 as std::os::raw::c_int, (*s).origPtr as UInt32);\n        generateMTFValues(s);\n        sendMTFValues(s);\n    }\n    /*-- If this is the last block, add the stream trailer. --*/\n    if is_last_block != 0 {\n        bsPutUChar(s, 0x17 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x72 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x45 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x38 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x50 as std::os::raw::c_int as UChar);\n        bsPutUChar(s, 0x90 as std::os::raw::c_int as UChar);\n        bsPutUInt32(s, (*s).combinedCRC);\n        if (*s).verbosity >= 2 as std::os::raw::c_int {\n            fprintf(__stderrp,\n                    b\"    final combined CRC = 0x%08x\\n   \\x00\" as *const u8\n                        as *const std::os::raw::c_char, (*s).combinedCRC);\n        }\n        bsFinishWrite(s);\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "compress.rs:21:1: 21:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "compress.rs:17:1: 17:41 (#0)",
        "source": "pub use crate::blocksort::BZ2_blockSort;"
      },
      {
        "span": "compress.rs:20:1: 20:47 (#0)",
        "source": "pub use crate::huffman::BZ2_hbMakeCodeLengths;"
      },
      {
        "span": "compress.rs:18:1: 18:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      },
      {
        "span": "compress.rs:19:1: 19:43 (#0)",
        "source": "pub use crate::huffman::BZ2_hbAssignCodes;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:569 ~ c2rust_out[3c70]::huffman::BZ2_hbCreateDecodeTables)",
    "span": "huffman.rs:218:1: 284:2 (#0)",
    "pieces": [
      "huffman.rs:218:1: 284:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 67,
    "source": "pub unsafe extern \"C\" fn BZ2_hbCreateDecodeTables(mut limit: *mut Int32,\n                                                  mut base: *mut Int32,\n                                                  mut perm: *mut Int32,\n                                                  mut length: *mut UChar,\n                                                  mut minLen: Int32,\n                                                  mut maxLen: Int32,\n                                                  mut alphaSize: Int32) {\n    let mut pp: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut vec: Int32 = 0;\n    pp = 0 as std::os::raw::c_int;\n    i = minLen;\n    while i <= maxLen {\n        j = 0 as std::os::raw::c_int;\n        while j < alphaSize {\n            if *length.offset(j as isize) as std::os::raw::c_int == i {\n                *perm.offset(pp as isize) = j;\n                pp += 1\n            }\n            j += 1\n        }\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 23 as std::os::raw::c_int {\n        *base.offset(i as isize) = 0 as std::os::raw::c_int;\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < alphaSize {\n        let ref mut fresh0 =\n            *base.offset((*length.offset(i as isize) as std::os::raw::c_int +\n                              1 as std::os::raw::c_int) as isize);\n        *fresh0 += 1;\n        i += 1\n    }\n    i = 1 as std::os::raw::c_int;\n    while i < 23 as std::os::raw::c_int {\n        let ref mut fresh1 = *base.offset(i as isize);\n        *fresh1 += *base.offset((i - 1 as std::os::raw::c_int) as isize);\n        i += 1\n    }\n    i = 0 as std::os::raw::c_int;\n    while i < 23 as std::os::raw::c_int {\n        *limit.offset(i as isize) = 0 as std::os::raw::c_int;\n        i += 1\n    }\n    vec = 0 as std::os::raw::c_int;\n    i = minLen;\n    while i <= maxLen {\n        vec +=\n            *base.offset((i + 1 as std::os::raw::c_int) as isize) -\n                *base.offset(i as isize);\n        *limit.offset(i as isize) = vec - 1 as std::os::raw::c_int;\n        vec <<= 1 as std::os::raw::c_int;\n        i += 1\n    }\n    i = minLen + 1 as std::os::raw::c_int;\n    while i <= maxLen {\n        *base.offset(i as isize) =\n            ((*limit.offset((i - 1 as std::os::raw::c_int) as isize) +\n                  1 as std::os::raw::c_int) << 1 as std::os::raw::c_int) -\n                *base.offset(i as isize);\n        i += 1\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "huffman.rs:6:1: 6:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:334 ~ c2rust_out[3c70]::bzip2recover::bsOpenWriteStream)",
    "span": "bzip2recover.rs:176:1: 190:2 (#0)",
    "pieces": [
      "bzip2recover.rs:176:1: 190:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn bsOpenWriteStream(mut stream: *mut FILE)\n -> *mut BitStream {\n    let mut bs: *mut BitStream =\n        malloc(::std::mem::size_of::<BitStream>() as std::os::raw::c_ulong) as\n            *mut BitStream;\n    if bs.is_null() {\n        mallocFail(::std::mem::size_of::<BitStream>() as std::os::raw::c_ulong as\n                       Int32);\n    }\n    (*bs).handle = stream;\n    (*bs).buffer = 0 as std::os::raw::c_int;\n    (*bs).buffLive = 0 as std::os::raw::c_int;\n    (*bs).mode = 'w' as i32 as Char;\n    return bs;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:423 ~ c2rust_out[3c70]::bzlib::add_pair_to_block)",
    "span": "bzlib.rs:421:1: 468:2 (#0)",
    "pieces": [
      "bzlib.rs:421:1: 468:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "unsafe extern \"C\" fn add_pair_to_block(mut s: *mut EState) {\n    let mut i: Int32 = 0;\n    let mut ch: UChar = (*s).state_in_ch as UChar;\n    i = 0 as std::os::raw::c_int;\n    while i < (*s).state_in_len {\n        (*s).blockCRC =\n            (*s).blockCRC << 8 as std::os::raw::c_int ^\n                BZ2_crc32Table[((*s).blockCRC >> 24 as std::os::raw::c_int ^\n                                    ch as std::os::raw::c_uint) as usize];\n        i += 1\n    }\n    (*s).inUse[(*s).state_in_ch as usize] = 1 as std::os::raw::c_int as Bool;\n    match (*s).state_in_len {\n        1 => {\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1\n        }\n        2 => {\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1\n        }\n        3 => {\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1\n        }\n        _ => {\n            (*s).inUse[((*s).state_in_len - 4 as std::os::raw::c_int) as usize] =\n                1 as std::os::raw::c_int as Bool;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) = ch;\n            (*s).nblock += 1;\n            *(*s).block.offset((*s).nblock as isize) =\n                ((*s).state_in_len - 4 as std::os::raw::c_int) as UChar;\n            (*s).nblock += 1\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:424 ~ c2rust_out[3c70]::bzlib::flush_RL)",
        "span": "bzlib.rs:472:9: 472:30 (#0)",
        "source": "add_pair_to_block(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:424 ~ c2rust_out[3c70]::bzlib::flush_RL)",
    "span": "bzlib.rs:470:1: 475:2 (#0)",
    "pieces": [
      "bzlib.rs:470:1: 475:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn flush_RL(mut s: *mut EState) {\n    if (*s).state_in_ch < 256 as std::os::raw::c_int as std::os::raw::c_uint {\n        add_pair_to_block(s);\n    }\n    init_RL(s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:282 ~ c2rust_out[3c70]::bzip2::main)",
    "span": "bzip2.rs:3129:1: 3140:2 (#0)",
    "pieces": [
      "bzip2.rs:3129:1: 3140:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub fn main() {\n    let mut args: Vec<*mut std::os::raw::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(::std::ffi::CString::new(arg).expect(\"Failed to convert argument into CString.\").into_raw());\n    };\n    args.push(::std::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(main_0((args.len() - 1) as IntNative,\n                                    args.as_mut_ptr() as *mut *mut Char) as\n                                 i32)\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:175 ~ c2rust_out[3c70]::bzip2::isascii)",
    "span": "bzip2.rs:291:2: 293:2 (#0)",
    "pieces": [
      "bzip2.rs:291:2: 293:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "extern \"C\" fn isascii(mut _c: std::os::raw::c_int) -> std::os::raw::c_int {\n    return (_c & !(0x7f as std::os::raw::c_int) == 0 as std::os::raw::c_int) as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:425 ~ c2rust_out[3c70]::bzlib::copy_input_until_stop)",
    "span": "bzlib.rs:480:1: 573:2 (#0)",
    "pieces": [
      "bzlib.rs:480:1: 573:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 94,
    "source": "unsafe extern \"C\" fn copy_input_until_stop(mut s: *mut EState) -> Bool {\n    let mut progress_in: Bool = 0 as std::os::raw::c_int as Bool;\n    if (*s).mode == 2 as std::os::raw::c_int {\n        /*-- fast track the common case --*/\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /*-- block full? --*/\n            if (*s).nblock >= (*s).nblockMAX { break ; }\n            /*-- no input? --*/\n            if (*(*s).strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n                break ;\n            }\n            progress_in = 1 as std::os::raw::c_int as Bool;\n            let mut zchh: UInt32 =\n                *((*(*s).strm).next_in as *mut UChar) as UInt32;\n            if zchh != (*s).state_in_ch &&\n                   (*s).state_in_len == 1 as std::os::raw::c_int {\n                let mut ch: UChar = (*s).state_in_ch as UChar;\n                (*s).blockCRC =\n                    (*s).blockCRC << 8 as std::os::raw::c_int ^\n                        BZ2_crc32Table[((*s).blockCRC >> 24 as std::os::raw::c_int ^\n                                            ch as std::os::raw::c_uint) as usize];\n                (*s).inUse[(*s).state_in_ch as usize] =\n                    1 as std::os::raw::c_int as Bool;\n                *(*s).block.offset((*s).nblock as isize) = ch;\n                (*s).nblock += 1;\n                (*s).state_in_ch = zchh\n            } else if zchh != (*s).state_in_ch ||\n                          (*s).state_in_len == 255 as std::os::raw::c_int {\n                if (*s).state_in_ch < 256 as std::os::raw::c_int as std::os::raw::c_uint {\n                    add_pair_to_block(s);\n                }\n                (*s).state_in_ch = zchh;\n                (*s).state_in_len = 1 as std::os::raw::c_int\n            } else { (*s).state_in_len += 1 }\n            (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n            (*(*s).strm).avail_in = (*(*s).strm).avail_in.wrapping_sub(1);\n            (*(*s).strm).total_in_lo32 =\n                (*(*s).strm).total_in_lo32.wrapping_add(1);\n            if (*(*s).strm).total_in_lo32 == 0 as std::os::raw::c_int as std::os::raw::c_uint\n               {\n                (*(*s).strm).total_in_hi32 =\n                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n            }\n        }\n    } else {\n        /*-- general, uncommon case --*/\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /*-- block full? --*/\n            if (*s).nblock >= (*s).nblockMAX { break ; }\n            /*-- no input? --*/\n            if (*(*s).strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n                break ;\n            }\n            /*-- flush/finish end? --*/\n            if (*s).avail_in_expect == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n                break ;\n            }\n            progress_in = 1 as std::os::raw::c_int as Bool;\n            let mut zchh_0: UInt32 =\n                *((*(*s).strm).next_in as *mut UChar) as UInt32;\n            if zchh_0 != (*s).state_in_ch &&\n                   (*s).state_in_len == 1 as std::os::raw::c_int {\n                let mut ch_0: UChar = (*s).state_in_ch as UChar;\n                (*s).blockCRC =\n                    (*s).blockCRC << 8 as std::os::raw::c_int ^\n                        BZ2_crc32Table[((*s).blockCRC >> 24 as std::os::raw::c_int ^\n                                            ch_0 as std::os::raw::c_uint) as usize];\n                (*s).inUse[(*s).state_in_ch as usize] =\n                    1 as std::os::raw::c_int as Bool;\n                *(*s).block.offset((*s).nblock as isize) = ch_0;\n                (*s).nblock += 1;\n                (*s).state_in_ch = zchh_0\n            } else if zchh_0 != (*s).state_in_ch ||\n                          (*s).state_in_len == 255 as std::os::raw::c_int {\n                if (*s).state_in_ch < 256 as std::os::raw::c_int as std::os::raw::c_uint {\n                    add_pair_to_block(s);\n                }\n                (*s).state_in_ch = zchh_0;\n                (*s).state_in_len = 1 as std::os::raw::c_int\n            } else { (*s).state_in_len += 1 }\n            (*(*s).strm).next_in = (*(*s).strm).next_in.offset(1);\n            (*(*s).strm).avail_in = (*(*s).strm).avail_in.wrapping_sub(1);\n            (*(*s).strm).total_in_lo32 =\n                (*(*s).strm).total_in_lo32.wrapping_add(1);\n            if (*(*s).strm).total_in_lo32 == 0 as std::os::raw::c_int as std::os::raw::c_uint\n               {\n                (*(*s).strm).total_in_hi32 =\n                    (*(*s).strm).total_in_hi32.wrapping_add(1)\n            }\n            (*s).avail_in_expect = (*s).avail_in_expect.wrapping_sub(1)\n        }\n    }\n    return progress_in;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:431 ~ c2rust_out[3c70]::bzlib::unRLE_obuf_to_output_FAST)",
    "span": "bzlib.rs:795:1: 1178:2 (#0)",
    "pieces": [
      "bzlib.rs:795:1: 1178:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 384,
    "source": "unsafe extern \"C\" fn unRLE_obuf_to_output_FAST(mut s: *mut DState) -> Bool {\n    let mut current_block: u64;\n    let mut k1: UChar = 0;\n    if (*s).blockRandomised != 0 {\n        while 1 as std::os::raw::c_int as Bool != 0 {\n            /* try to finish existing run */\n            while 1 as std::os::raw::c_int as Bool != 0 {\n                if (*(*s).strm).avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint\n                   {\n                    return 0 as std::os::raw::c_int as Bool\n                }\n                if (*s).state_out_len == 0 as std::os::raw::c_int { break ; }\n                *((*(*s).strm).next_out as *mut UChar) = (*s).state_out_ch;\n                (*s).calculatedBlockCRC =\n                    (*s).calculatedBlockCRC << 8 as std::os::raw::c_int ^\n                        BZ2_crc32Table[((*s).calculatedBlockCRC >>\n                                            24 as std::os::raw::c_int ^\n                                            (*s).state_out_ch as std::os::raw::c_uint)\n                                           as usize];\n                (*s).state_out_len -= 1;\n                (*(*s).strm).next_out = (*(*s).strm).next_out.offset(1);\n                (*(*s).strm).avail_out =\n                    (*(*s).strm).avail_out.wrapping_sub(1);\n                (*(*s).strm).total_out_lo32 =\n                    (*(*s).strm).total_out_lo32.wrapping_add(1);\n                if (*(*s).strm).total_out_lo32 ==\n                       0 as std::os::raw::c_int as std::os::raw::c_uint {\n                    (*(*s).strm).total_out_hi32 =\n                        (*(*s).strm).total_out_hi32.wrapping_add(1)\n                }\n            }\n            /* can a new run be started? */\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                return 0 as std::os::raw::c_int as Bool\n            }\n            /* Only caused by corrupt data stream? */\n            if (*s).nblock_used > (*s).save_nblock + 1 as std::os::raw::c_int {\n                return 1 as std::os::raw::c_int as Bool\n            }\n            (*s).state_out_len = 1 as std::os::raw::c_int;\n            (*s).state_out_ch = (*s).k0 as UChar;\n            if (*s).tPos >=\n                   (100000 as std::os::raw::c_int as\n                        UInt32).wrapping_mul((*s).blockSize100k as UInt32) {\n                return 1 as std::os::raw::c_int as Bool\n            }\n            (*s).tPos = *(*s).tt.offset((*s).tPos as isize);\n            k1 = ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as UChar;\n            (*s).tPos >>= 8 as std::os::raw::c_int;\n            if (*s).rNToGo == 0 as std::os::raw::c_int {\n                (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                (*s).rTPos += 1;\n                if (*s).rTPos == 512 as std::os::raw::c_int {\n                    (*s).rTPos = 0 as std::os::raw::c_int\n                }\n            }\n            (*s).rNToGo -= 1;\n            k1 =\n                (k1 as std::os::raw::c_int ^\n                     if (*s).rNToGo == 1 as std::os::raw::c_int {\n                         1 as std::os::raw::c_int\n                     } else { 0 as std::os::raw::c_int }) as UChar;\n            (*s).nblock_used += 1;\n            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                continue ;\n            }\n            if k1 as std::os::raw::c_int != (*s).k0 {\n                (*s).k0 = k1 as Int32\n            } else {\n                (*s).state_out_len = 2 as std::os::raw::c_int;\n                if (*s).tPos >=\n                       (100000 as std::os::raw::c_int as\n                            UInt32).wrapping_mul((*s).blockSize100k as UInt32)\n                   {\n                    return 1 as std::os::raw::c_int as Bool\n                }\n                (*s).tPos = *(*s).tt.offset((*s).tPos as isize);\n                k1 =\n                    ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n                        UChar;\n                (*s).tPos >>= 8 as std::os::raw::c_int;\n                if (*s).rNToGo == 0 as std::os::raw::c_int {\n                    (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                    (*s).rTPos += 1;\n                    if (*s).rTPos == 512 as std::os::raw::c_int {\n                        (*s).rTPos = 0 as std::os::raw::c_int\n                    }\n                }\n                (*s).rNToGo -= 1;\n                k1 =\n                    (k1 as std::os::raw::c_int ^\n                         if (*s).rNToGo == 1 as std::os::raw::c_int {\n                             1 as std::os::raw::c_int\n                         } else { 0 as std::os::raw::c_int }) as UChar;\n                (*s).nblock_used += 1;\n                if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {\n                    continue ;\n                }\n                if k1 as std::os::raw::c_int != (*s).k0 {\n                    (*s).k0 = k1 as Int32\n                } else {\n                    (*s).state_out_len = 3 as std::os::raw::c_int;\n                    if (*s).tPos >=\n                           (100000 as std::os::raw::c_int as\n                                UInt32).wrapping_mul((*s).blockSize100k as\n                                                         UInt32) {\n                        return 1 as std::os::raw::c_int as Bool\n                    }\n                    (*s).tPos = *(*s).tt.offset((*s).tPos as isize);\n                    k1 =\n                        ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n                            UChar;\n                    (*s).tPos >>= 8 as std::os::raw::c_int;\n                    if (*s).rNToGo == 0 as std::os::raw::c_int {\n                        (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                        (*s).rTPos += 1;\n                        if (*s).rTPos == 512 as std::os::raw::c_int {\n                            (*s).rTPos = 0 as std::os::raw::c_int\n                        }\n                    }\n                    (*s).rNToGo -= 1;\n                    k1 =\n                        (k1 as std::os::raw::c_int ^\n                             if (*s).rNToGo == 1 as std::os::raw::c_int {\n                                 1 as std::os::raw::c_int\n                             } else { 0 as std::os::raw::c_int }) as UChar;\n                    (*s).nblock_used += 1;\n                    if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int\n                       {\n                        continue ;\n                    }\n                    if k1 as std::os::raw::c_int != (*s).k0 {\n                        (*s).k0 = k1 as Int32\n                    } else {\n                        if (*s).tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul((*s).blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        (*s).tPos = *(*s).tt.offset((*s).tPos as isize);\n                        k1 =\n                            ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint)\n                                as UChar;\n                        (*s).tPos >>= 8 as std::os::raw::c_int;\n                        if (*s).rNToGo == 0 as std::os::raw::c_int {\n                            (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                            (*s).rTPos += 1;\n                            if (*s).rTPos == 512 as std::os::raw::c_int {\n                                (*s).rTPos = 0 as std::os::raw::c_int\n                            }\n                        }\n                        (*s).rNToGo -= 1;\n                        k1 =\n                            (k1 as std::os::raw::c_int ^\n                                 if (*s).rNToGo == 1 as std::os::raw::c_int {\n                                     1 as std::os::raw::c_int\n                                 } else { 0 as std::os::raw::c_int }) as UChar;\n                        (*s).nblock_used += 1;\n                        (*s).state_out_len = k1 as Int32 + 4 as std::os::raw::c_int;\n                        if (*s).tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul((*s).blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        (*s).tPos = *(*s).tt.offset((*s).tPos as isize);\n                        (*s).k0 =\n                            ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint)\n                                as UChar as Int32;\n                        (*s).tPos >>= 8 as std::os::raw::c_int;\n                        if (*s).rNToGo == 0 as std::os::raw::c_int {\n                            (*s).rNToGo = BZ2_rNums[(*s).rTPos as usize];\n                            (*s).rTPos += 1;\n                            if (*s).rTPos == 512 as std::os::raw::c_int {\n                                (*s).rTPos = 0 as std::os::raw::c_int\n                            }\n                        }\n                        (*s).rNToGo -= 1;\n                        (*s).k0 ^=\n                            if (*s).rNToGo == 1 as std::os::raw::c_int {\n                                1 as std::os::raw::c_int\n                            } else { 0 as std::os::raw::c_int };\n                        (*s).nblock_used += 1\n                    }\n                }\n            }\n        }\n    } else {\n        /* restore */\n        let mut c_calculatedBlockCRC: UInt32 = (*s).calculatedBlockCRC;\n        let mut c_state_out_ch: UChar = (*s).state_out_ch;\n        let mut c_state_out_len: Int32 = (*s).state_out_len;\n        let mut c_nblock_used: Int32 = (*s).nblock_used;\n        let mut c_k0: Int32 = (*s).k0;\n        let mut c_tt: *mut UInt32 = (*s).tt;\n        let mut c_tPos: UInt32 = (*s).tPos;\n        let mut cs_next_out: *mut std::os::raw::c_char = (*(*s).strm).next_out;\n        let mut cs_avail_out: std::os::raw::c_uint = (*(*s).strm).avail_out;\n        let mut ro_blockSize100k: Int32 = (*s).blockSize100k;\n        /* end restore */\n        let mut avail_out_INIT: UInt32 = cs_avail_out;\n        let mut s_save_nblockPP: Int32 = (*s).save_nblock + 1 as std::os::raw::c_int;\n        let mut total_out_lo32_old: std::os::raw::c_uint = 0;\n        's_569:\n            while 1 as std::os::raw::c_int as Bool != 0 {\n                /* try to finish existing run */\n                if c_state_out_len > 0 as std::os::raw::c_int {\n                    while 1 as std::os::raw::c_int as Bool != 0 {\n                        if cs_avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n                            break 's_569 ;\n                        }\n                        if c_state_out_len == 1 as std::os::raw::c_int { break ; }\n                        *(cs_next_out as *mut UChar) = c_state_out_ch;\n                        c_calculatedBlockCRC =\n                            c_calculatedBlockCRC << 8 as std::os::raw::c_int ^\n                                BZ2_crc32Table[(c_calculatedBlockCRC >>\n                                                    24 as std::os::raw::c_int ^\n                                                    c_state_out_ch as\n                                                        std::os::raw::c_uint) as\n                                                   usize];\n                        c_state_out_len -= 1;\n                        cs_next_out = cs_next_out.offset(1);\n                        cs_avail_out = cs_avail_out.wrapping_sub(1)\n                    }\n                    current_block = 16910810822589621899;\n                } else { current_block = 3024573345131975588; }\n                loop  {\n                    match current_block {\n                        16910810822589621899 => {\n                            if cs_avail_out ==\n                                   0 as std::os::raw::c_int as std::os::raw::c_uint {\n                                c_state_out_len = 1 as std::os::raw::c_int;\n                                break 's_569 ;\n                            } else {\n                                *(cs_next_out as *mut UChar) = c_state_out_ch;\n                                c_calculatedBlockCRC =\n                                    c_calculatedBlockCRC << 8 as std::os::raw::c_int ^\n                                        BZ2_crc32Table[(c_calculatedBlockCRC\n                                                            >>\n                                                            24 as std::os::raw::c_int\n                                                            ^\n                                                            c_state_out_ch as\n                                                                std::os::raw::c_uint)\n                                                           as usize];\n                                cs_next_out = cs_next_out.offset(1);\n                                cs_avail_out = cs_avail_out.wrapping_sub(1);\n                                current_block = 3024573345131975588;\n                            }\n                        }\n                        _ => {\n                            /* Only caused by corrupt data stream? */\n                            if c_nblock_used > s_save_nblockPP {\n                                return 1 as std::os::raw::c_int as Bool\n                            }\n                            /* can a new run be started? */\n                            if c_nblock_used == s_save_nblockPP {\n                                c_state_out_len = 0 as std::os::raw::c_int;\n                                break 's_569 ;\n                            } else {\n                                c_state_out_ch = c_k0 as UChar;\n                                if c_tPos >=\n                                       (100000 as std::os::raw::c_int as\n                                            UInt32).wrapping_mul(ro_blockSize100k\n                                                                     as\n                                                                     UInt32) {\n                                    return 1 as std::os::raw::c_int as Bool\n                                }\n                                c_tPos = *c_tt.offset(c_tPos as isize);\n                                k1 =\n                                    (c_tPos &\n                                         0xff as std::os::raw::c_int as std::os::raw::c_uint)\n                                        as UChar;\n                                c_tPos >>= 8 as std::os::raw::c_int;\n                                c_nblock_used += 1;\n                                if k1 as std::os::raw::c_int != c_k0 {\n                                    c_k0 = k1 as Int32;\n                                    current_block = 16910810822589621899;\n                                } else {\n                                    if c_nblock_used == s_save_nblockPP {\n                                        current_block = 16910810822589621899;\n                                        continue ;\n                                    }\n                                    c_state_out_len = 2 as std::os::raw::c_int;\n                                    if c_tPos >=\n                                           (100000 as std::os::raw::c_int as\n                                                UInt32).wrapping_mul(ro_blockSize100k\n                                                                         as\n                                                                         UInt32)\n                                       {\n                                        return 1 as std::os::raw::c_int as Bool\n                                    }\n                                    c_tPos = *c_tt.offset(c_tPos as isize);\n                                    k1 =\n                                        (c_tPos &\n                                             0xff as std::os::raw::c_int as\n                                                 std::os::raw::c_uint) as UChar;\n                                    c_tPos >>= 8 as std::os::raw::c_int;\n                                    c_nblock_used += 1;\n                                    if c_nblock_used == s_save_nblockPP {\n                                        continue 's_569 ;\n                                    }\n                                    if k1 as std::os::raw::c_int != c_k0 {\n                                        current_block = 18139099716546303047;\n                                        break ;\n                                    } else {\n                                        current_block = 919396821984190499;\n                                        break ;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                match current_block {\n                    18139099716546303047 => { c_k0 = k1 as Int32 }\n                    _ => {\n                        c_state_out_len = 3 as std::os::raw::c_int;\n                        if c_tPos >=\n                               (100000 as std::os::raw::c_int as\n                                    UInt32).wrapping_mul(ro_blockSize100k as\n                                                             UInt32) {\n                            return 1 as std::os::raw::c_int as Bool\n                        }\n                        c_tPos = *c_tt.offset(c_tPos as isize);\n                        k1 =\n                            (c_tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as\n                                UChar;\n                        c_tPos >>= 8 as std::os::raw::c_int;\n                        c_nblock_used += 1;\n                        if c_nblock_used == s_save_nblockPP { continue ; }\n                        if k1 as std::os::raw::c_int != c_k0 {\n                            c_k0 = k1 as Int32\n                        } else {\n                            if c_tPos >=\n                                   (100000 as std::os::raw::c_int as\n                                        UInt32).wrapping_mul(ro_blockSize100k\n                                                                 as UInt32) {\n                                return 1 as std::os::raw::c_int as Bool\n                            }\n                            c_tPos = *c_tt.offset(c_tPos as isize);\n                            k1 =\n                                (c_tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint)\n                                    as UChar;\n                            c_tPos >>= 8 as std::os::raw::c_int;\n                            c_nblock_used += 1;\n                            c_state_out_len = k1 as Int32 + 4 as std::os::raw::c_int;\n                            if c_tPos >=\n                                   (100000 as std::os::raw::c_int as\n                                        UInt32).wrapping_mul(ro_blockSize100k\n                                                                 as UInt32) {\n                                return 1 as std::os::raw::c_int as Bool\n                            }\n                            c_tPos = *c_tt.offset(c_tPos as isize);\n                            c_k0 =\n                                (c_tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint)\n                                    as UChar as Int32;\n                            c_tPos >>= 8 as std::os::raw::c_int;\n                            c_nblock_used += 1\n                        }\n                    }\n                }\n            }\n        total_out_lo32_old = (*(*s).strm).total_out_lo32;\n        (*(*s).strm).total_out_lo32 =\n            (*(*s).strm).total_out_lo32.wrapping_add(avail_out_INIT.wrapping_sub(cs_avail_out));\n        if (*(*s).strm).total_out_lo32 < total_out_lo32_old {\n            (*(*s).strm).total_out_hi32 =\n                (*(*s).strm).total_out_hi32.wrapping_add(1)\n        }\n        /* save */\n        (*s).calculatedBlockCRC = c_calculatedBlockCRC;\n        (*s).state_out_ch = c_state_out_ch;\n        (*s).state_out_len = c_state_out_len;\n        (*s).nblock_used = c_nblock_used;\n        (*s).k0 = c_k0;\n        (*s).tt = c_tt;\n        (*s).tPos = c_tPos;\n        (*(*s).strm).next_out = cs_next_out;\n        (*(*s).strm).avail_out = cs_avail_out\n        /* end save */\n    }\n    return 0 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:244 ~ c2rust_out[3c70]::bzip2::mySignalCatcher)",
    "span": "bzip2.rs:1738:1: 1743:2 (#0)",
    "pieces": [
      "bzip2.rs:1738:1: 1743:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn mySignalCatcher(mut n: IntNative) {\n    fprintf(__stderrp,\n            b\"\\n%s: Control-C or similar caught, quitting.\\n\\x00\" as *const u8\n                as *const std::os::raw::c_char, progName);\n    cleanUpAndFail(1 as std::os::raw::c_int);\n}",
    "calls": [],
    "globals": [
      {
        "span": "bzip2.rs:348:1: 348:68 (#0)",
        "source": "pub static mut progName: *mut Char = 0 as *const Char as *mut Char;"
      }
    ],
    "imports": [
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      },
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:266 ~ c2rust_out[3c70]::bzip2::hasSuffix)",
    "span": "bzip2.rs:2013:1: 2023:2 (#0)",
    "pieces": [
      "bzip2.rs:2013:1: 2023:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn hasSuffix(mut s: *mut Char, mut suffix: *const Char)\n -> Bool {\n    let mut ns: Int32 = strlen(s) as Int32;\n    let mut nx: Int32 = strlen(suffix) as Int32;\n    if ns < nx { return 0 as std::os::raw::c_int as Bool }\n    if strcmp(s.offset(ns as isize).offset(-(nx as isize)), suffix) ==\n           0 as std::os::raw::c_int {\n        return 1 as std::os::raw::c_int as Bool\n    }\n    return 0 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2.rs:120:1: 120:38 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadOpen;"
      },
      {
        "span": "bzip2.rs:118:1: 118:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadClose;"
      },
      {
        "span": "bzip2.rs:117:1: 117:34 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzRead;"
      },
      {
        "span": "bzip2.rs:125:1: 125:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzip2.rs:119:1: 119:43 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzReadGetUnused;"
      },
      {
        "span": "bzip2.rs:123:1: 123:39 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteOpen;"
      },
      {
        "span": "bzip2.rs:121:1: 121:35 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWrite;"
      },
      {
        "span": "bzip2.rs:122:1: 122:42 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzWriteClose64;"
      },
      {
        "span": "bzip2.rs:124:1: 124:40 (#0)",
        "source": "pub use crate::bzlib::BZ2_bzlibVersion;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:426 ~ c2rust_out[3c70]::bzlib::copy_output_until_stop)",
    "span": "bzlib.rs:575:1: 598:2 (#0)",
    "pieces": [
      "bzlib.rs:575:1: 598:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 24,
    "source": "unsafe extern \"C\" fn copy_output_until_stop(mut s: *mut EState) -> Bool {\n    let mut progress_out: Bool = 0 as std::os::raw::c_int as Bool;\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        /*-- no output space? --*/\n        if (*(*s).strm).avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            break ;\n        }\n        /*-- block done? --*/\n        if (*s).state_out_pos >= (*s).numZ { break ; }\n        progress_out = 1 as std::os::raw::c_int as Bool;\n        *(*(*s).strm).next_out =\n            *(*s).zbits.offset((*s).state_out_pos as isize) as std::os::raw::c_char;\n        (*s).state_out_pos += 1;\n        (*(*s).strm).avail_out = (*(*s).strm).avail_out.wrapping_sub(1);\n        (*(*s).strm).next_out = (*(*s).strm).next_out.offset(1);\n        (*(*s).strm).total_out_lo32 =\n            (*(*s).strm).total_out_lo32.wrapping_add(1);\n        if (*(*s).strm).total_out_lo32 == 0 as std::os::raw::c_int as std::os::raw::c_uint {\n            (*(*s).strm).total_out_hi32 =\n                (*(*s).strm).total_out_hi32.wrapping_add(1)\n        }\n    }\n    return progress_out;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:416 ~ c2rust_out[3c70]::bzlib::bz_config_ok)",
    "span": "bzlib.rs:237:2: 251:2 (#0)",
    "pieces": [
      "bzlib.rs:237:2: 251:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "extern \"C\" fn bz_config_ok() -> std::os::raw::c_int {\n    if ::std::mem::size_of::<std::os::raw::c_int>() as std::os::raw::c_ulong !=\n           4 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int\n    }\n    if ::std::mem::size_of::<std::os::raw::c_short>() as std::os::raw::c_ulong !=\n           2 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int\n    }\n    if ::std::mem::size_of::<std::os::raw::c_char>() as std::os::raw::c_ulong !=\n           1 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int\n    }\n    return 1 as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:36 ~ c2rust_out[3c70]::blocksort::mainQSort3)",
    "span": "blocksort.rs:894:1: 1114:2 (#0)",
    "pieces": [
      "blocksort.rs:894:1: 1114:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 221,
    "source": "unsafe extern \"C\" fn mainQSort3(mut ptr: *mut UInt32, mut block: *mut UChar,\n                                mut quadrant: *mut UInt16, mut nblock: Int32,\n                                mut loSt: Int32, mut hiSt: Int32,\n                                mut dSt: Int32, mut budget: *mut Int32) {\n    let mut unLo: Int32 = 0;\n    let mut unHi: Int32 = 0;\n    let mut ltLo: Int32 = 0;\n    let mut gtHi: Int32 = 0;\n    let mut n: Int32 = 0;\n    let mut m: Int32 = 0;\n    let mut med: Int32 = 0;\n    let mut sp: Int32 = 0;\n    let mut lo: Int32 = 0;\n    let mut hi: Int32 = 0;\n    let mut d: Int32 = 0;\n    let mut stackLo: [Int32; 100] = [0; 100];\n    let mut stackHi: [Int32; 100] = [0; 100];\n    let mut stackD: [Int32; 100] = [0; 100];\n    let mut nextLo: [Int32; 3] = [0; 3];\n    let mut nextHi: [Int32; 3] = [0; 3];\n    let mut nextD: [Int32; 3] = [0; 3];\n    sp = 0 as std::os::raw::c_int;\n    stackLo[sp as usize] = loSt;\n    stackHi[sp as usize] = hiSt;\n    stackD[sp as usize] = dSt;\n    sp += 1;\n    while sp > 0 as std::os::raw::c_int {\n        if !(sp < 100 as std::os::raw::c_int - 2 as std::os::raw::c_int) {\n            BZ2_bz__AssertH__fail(1001 as std::os::raw::c_int);\n        }\n        sp -= 1;\n        lo = stackLo[sp as usize];\n        hi = stackHi[sp as usize];\n        d = stackD[sp as usize];\n        if hi - lo < 20 as std::os::raw::c_int ||\n               d > 2 as std::os::raw::c_int + 12 as std::os::raw::c_int {\n            mainSimpleSort(ptr, block, quadrant, nblock, lo, hi, d, budget);\n            if *budget < 0 as std::os::raw::c_int { return }\n        } else {\n            med =\n                mmed3(*block.offset((*ptr.offset(lo as\n                                                     isize)).wrapping_add(d as\n                                                                              std::os::raw::c_uint)\n                                        as isize),\n                      *block.offset((*ptr.offset(hi as\n                                                     isize)).wrapping_add(d as\n                                                                              std::os::raw::c_uint)\n                                        as isize),\n                      *block.offset((*ptr.offset((lo + hi >> 1 as std::os::raw::c_int)\n                                                     as\n                                                     isize)).wrapping_add(d as\n                                                                              std::os::raw::c_uint)\n                                        as isize)) as Int32;\n            ltLo = lo;\n            unLo = ltLo;\n            gtHi = hi;\n            unHi = gtHi;\n            while 1 as std::os::raw::c_int as Bool != 0 {\n                while 1 as std::os::raw::c_int as Bool != 0 {\n                    if unLo > unHi { break ; }\n                    n =\n                        *block.offset((*ptr.offset(unLo as\n                                                       isize)).wrapping_add(d\n                                                                                as\n                                                                                std::os::raw::c_uint)\n                                          as isize) as Int32 - med;\n                    if n == 0 as std::os::raw::c_int {\n                        let mut zztmp: Int32 =\n                            *ptr.offset(unLo as isize) as Int32;\n                        *ptr.offset(unLo as isize) =\n                            *ptr.offset(ltLo as isize);\n                        *ptr.offset(ltLo as isize) = zztmp as UInt32;\n                        ltLo += 1;\n                        unLo += 1\n                    } else { if n > 0 as std::os::raw::c_int { break ; } unLo += 1 }\n                }\n                while 1 as std::os::raw::c_int as Bool != 0 {\n                    if unLo > unHi { break ; }\n                    n =\n                        *block.offset((*ptr.offset(unHi as\n                                                       isize)).wrapping_add(d\n                                                                                as\n                                                                                std::os::raw::c_uint)\n                                          as isize) as Int32 - med;\n                    if n == 0 as std::os::raw::c_int {\n                        let mut zztmp_0: Int32 =\n                            *ptr.offset(unHi as isize) as Int32;\n                        *ptr.offset(unHi as isize) =\n                            *ptr.offset(gtHi as isize);\n                        *ptr.offset(gtHi as isize) = zztmp_0 as UInt32;\n                        gtHi -= 1;\n                        unHi -= 1\n                    } else { if n < 0 as std::os::raw::c_int { break ; } unHi -= 1 }\n                }\n                if unLo > unHi { break ; }\n                let mut zztmp_1: Int32 = *ptr.offset(unLo as isize) as Int32;\n                *ptr.offset(unLo as isize) = *ptr.offset(unHi as isize);\n                *ptr.offset(unHi as isize) = zztmp_1 as UInt32;\n                unLo += 1;\n                unHi -= 1\n            }\n            if gtHi < ltLo {\n                stackLo[sp as usize] = lo;\n                stackHi[sp as usize] = hi;\n                stackD[sp as usize] = d + 1 as std::os::raw::c_int;\n                sp += 1\n            } else {\n                n =\n                    if ltLo - lo < unLo - ltLo {\n                        (ltLo) - lo\n                    } else { (unLo) - ltLo };\n                let mut yyp1: Int32 = lo;\n                let mut yyp2: Int32 = unLo - n;\n                let mut yyn: Int32 = n;\n                while yyn > 0 as std::os::raw::c_int {\n                    let mut zztmp_2: Int32 =\n                        *ptr.offset(yyp1 as isize) as Int32;\n                    *ptr.offset(yyp1 as isize) = *ptr.offset(yyp2 as isize);\n                    *ptr.offset(yyp2 as isize) = zztmp_2 as UInt32;\n                    yyp1 += 1;\n                    yyp2 += 1;\n                    yyn -= 1\n                }\n                m =\n                    if hi - gtHi < gtHi - unHi {\n                        (hi) - gtHi\n                    } else { (gtHi) - unHi };\n                let mut yyp1_0: Int32 = unLo;\n                let mut yyp2_0: Int32 = hi - m + 1 as std::os::raw::c_int;\n                let mut yyn_0: Int32 = m;\n                while yyn_0 > 0 as std::os::raw::c_int {\n                    let mut zztmp_3: Int32 =\n                        *ptr.offset(yyp1_0 as isize) as Int32;\n                    *ptr.offset(yyp1_0 as isize) =\n                        *ptr.offset(yyp2_0 as isize);\n                    *ptr.offset(yyp2_0 as isize) = zztmp_3 as UInt32;\n                    yyp1_0 += 1;\n                    yyp2_0 += 1;\n                    yyn_0 -= 1\n                }\n                n = lo + unLo - ltLo - 1 as std::os::raw::c_int;\n                m = hi - (gtHi - unHi) + 1 as std::os::raw::c_int;\n                nextLo[0 as std::os::raw::c_int as usize] = lo;\n                nextHi[0 as std::os::raw::c_int as usize] = n;\n                nextD[0 as std::os::raw::c_int as usize] = d;\n                nextLo[1 as std::os::raw::c_int as usize] = m;\n                nextHi[1 as std::os::raw::c_int as usize] = hi;\n                nextD[1 as std::os::raw::c_int as usize] = d;\n                nextLo[2 as std::os::raw::c_int as usize] = n + 1 as std::os::raw::c_int;\n                nextHi[2 as std::os::raw::c_int as usize] = m - 1 as std::os::raw::c_int;\n                nextD[2 as std::os::raw::c_int as usize] = d + 1 as std::os::raw::c_int;\n                if nextHi[0 as std::os::raw::c_int as usize] -\n                       nextLo[0 as std::os::raw::c_int as usize] <\n                       nextHi[1 as std::os::raw::c_int as usize] -\n                           nextLo[1 as std::os::raw::c_int as usize] {\n                    let mut tz: Int32 = 0;\n                    tz = nextLo[0 as std::os::raw::c_int as usize];\n                    nextLo[0 as std::os::raw::c_int as usize] =\n                        nextLo[1 as std::os::raw::c_int as usize];\n                    nextLo[1 as std::os::raw::c_int as usize] = tz;\n                    tz = nextHi[0 as std::os::raw::c_int as usize];\n                    nextHi[0 as std::os::raw::c_int as usize] =\n                        nextHi[1 as std::os::raw::c_int as usize];\n                    nextHi[1 as std::os::raw::c_int as usize] = tz;\n                    tz = nextD[0 as std::os::raw::c_int as usize];\n                    nextD[0 as std::os::raw::c_int as usize] =\n                        nextD[1 as std::os::raw::c_int as usize];\n                    nextD[1 as std::os::raw::c_int as usize] = tz\n                }\n                if nextHi[1 as std::os::raw::c_int as usize] -\n                       nextLo[1 as std::os::raw::c_int as usize] <\n                       nextHi[2 as std::os::raw::c_int as usize] -\n                           nextLo[2 as std::os::raw::c_int as usize] {\n                    let mut tz_0: Int32 = 0;\n                    tz_0 = nextLo[1 as std::os::raw::c_int as usize];\n                    nextLo[1 as std::os::raw::c_int as usize] =\n                        nextLo[2 as std::os::raw::c_int as usize];\n                    nextLo[2 as std::os::raw::c_int as usize] = tz_0;\n                    tz_0 = nextHi[1 as std::os::raw::c_int as usize];\n                    nextHi[1 as std::os::raw::c_int as usize] =\n                        nextHi[2 as std::os::raw::c_int as usize];\n                    nextHi[2 as std::os::raw::c_int as usize] = tz_0;\n                    tz_0 = nextD[1 as std::os::raw::c_int as usize];\n                    nextD[1 as std::os::raw::c_int as usize] =\n                        nextD[2 as std::os::raw::c_int as usize];\n                    nextD[2 as std::os::raw::c_int as usize] = tz_0\n                }\n                if nextHi[0 as std::os::raw::c_int as usize] -\n                       nextLo[0 as std::os::raw::c_int as usize] <\n                       nextHi[1 as std::os::raw::c_int as usize] -\n                           nextLo[1 as std::os::raw::c_int as usize] {\n                    let mut tz_1: Int32 = 0;\n                    tz_1 = nextLo[0 as std::os::raw::c_int as usize];\n                    nextLo[0 as std::os::raw::c_int as usize] =\n                        nextLo[1 as std::os::raw::c_int as usize];\n                    nextLo[1 as std::os::raw::c_int as usize] = tz_1;\n                    tz_1 = nextHi[0 as std::os::raw::c_int as usize];\n                    nextHi[0 as std::os::raw::c_int as usize] =\n                        nextHi[1 as std::os::raw::c_int as usize];\n                    nextHi[1 as std::os::raw::c_int as usize] = tz_1;\n                    tz_1 = nextD[0 as std::os::raw::c_int as usize];\n                    nextD[0 as std::os::raw::c_int as usize] =\n                        nextD[1 as std::os::raw::c_int as usize];\n                    nextD[1 as std::os::raw::c_int as usize] = tz_1\n                }\n                stackLo[sp as usize] = nextLo[0 as std::os::raw::c_int as usize];\n                stackHi[sp as usize] = nextHi[0 as std::os::raw::c_int as usize];\n                stackD[sp as usize] = nextD[0 as std::os::raw::c_int as usize];\n                sp += 1;\n                stackLo[sp as usize] = nextLo[1 as std::os::raw::c_int as usize];\n                stackHi[sp as usize] = nextHi[1 as std::os::raw::c_int as usize];\n                stackD[sp as usize] = nextD[1 as std::os::raw::c_int as usize];\n                sp += 1;\n                stackLo[sp as usize] = nextLo[2 as std::os::raw::c_int as usize];\n                stackHi[sp as usize] = nextHi[2 as std::os::raw::c_int as usize];\n                stackD[sp as usize] = nextD[2 as std::os::raw::c_int as usize];\n                sp += 1\n            }\n        }\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:11:1: 11:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:20 ~ c2rust_out[3c70]::blocksort::fallbackSimpleSort)",
    "span": "blocksort.rs:142:1: 181:2 (#0)",
    "pieces": [
      "blocksort.rs:142:1: 181:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 40,
    "source": "unsafe extern \"C\" fn fallbackSimpleSort(mut fmap: *mut UInt32,\n                                        mut eclass: *mut UInt32,\n                                        mut lo: Int32, mut hi: Int32) {\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut tmp: Int32 = 0;\n    let mut ec_tmp: UInt32 = 0;\n    if lo == hi { return }\n    if hi - lo > 3 as std::os::raw::c_int {\n        i = hi - 4 as std::os::raw::c_int;\n        while i >= lo {\n            tmp = *fmap.offset(i as isize) as Int32;\n            ec_tmp = *eclass.offset(tmp as isize);\n            j = i + 4 as std::os::raw::c_int;\n            while j <= hi &&\n                      ec_tmp >\n                          *eclass.offset(*fmap.offset(j as isize) as isize) {\n                *fmap.offset((j - 4 as std::os::raw::c_int) as isize) =\n                    *fmap.offset(j as isize);\n                j += 4 as std::os::raw::c_int\n            }\n            *fmap.offset((j - 4 as std::os::raw::c_int) as isize) = tmp as UInt32;\n            i -= 1\n        }\n    }\n    i = hi - 1 as std::os::raw::c_int;\n    while i >= lo {\n        tmp = *fmap.offset(i as isize) as Int32;\n        ec_tmp = *eclass.offset(tmp as isize);\n        j = i + 1 as std::os::raw::c_int;\n        while j <= hi &&\n                  ec_tmp > *eclass.offset(*fmap.offset(j as isize) as isize) {\n            *fmap.offset((j - 1 as std::os::raw::c_int) as isize) =\n                *fmap.offset(j as isize);\n            j += 1\n        }\n        *fmap.offset((j - 1 as std::os::raw::c_int) as isize) = tmp as UInt32;\n        i -= 1\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:11:1: 11:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:31 ~ c2rust_out[3c70]::blocksort::mainGtU)",
    "span": "blocksort.rs:552:1: 790:2 (#0)",
    "pieces": [
      "blocksort.rs:552:1: 790:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 239,
    "source": "unsafe extern \"C\" fn mainGtU(mut i1: UInt32, mut i2: UInt32,\n                             mut block: *mut UChar, mut quadrant: *mut UInt16,\n                             mut nblock: UInt32, mut budget: *mut Int32)\n -> Bool {\n    let mut k: Int32 = 0;\n    let mut c1: UChar = 0;\n    let mut c2: UChar = 0;\n    let mut s1: UInt16 = 0;\n    let mut s2: UInt16 = 0;\n    /* 1 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 2 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 3 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 4 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 5 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 6 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 7 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 8 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 9 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 10 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 11 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    /* 12 */\n    c1 = *block.offset(i1 as isize);\n    c2 = *block.offset(i2 as isize);\n    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool\n    }\n    i1 = i1.wrapping_add(1);\n    i2 = i2.wrapping_add(1);\n    k = nblock.wrapping_add(8 as std::os::raw::c_int as std::os::raw::c_uint) as Int32;\n    loop  {\n        /* 1 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 2 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 3 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 4 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 5 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 6 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 7 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        /* 8 */\n        c1 = *block.offset(i1 as isize);\n        c2 = *block.offset(i2 as isize);\n        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {\n            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        s1 = *quadrant.offset(i1 as isize);\n        s2 = *quadrant.offset(i2 as isize);\n        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {\n            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as\n                       Bool\n        }\n        i1 = i1.wrapping_add(1);\n        i2 = i2.wrapping_add(1);\n        if i1 >= nblock {\n            i1 = (i1 as std::os::raw::c_uint).wrapping_sub(nblock) as UInt32 as UInt32\n        }\n        if i2 >= nblock {\n            i2 = (i2 as std::os::raw::c_uint).wrapping_sub(nblock) as UInt32 as UInt32\n        }\n        k -= 8 as std::os::raw::c_int;\n        *budget -= 1;\n        if !(k >= 0 as std::os::raw::c_int) { break ; }\n    }\n    return 0 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "blocksort.rs:11:1: 11:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:354 ~ c2rust_out[3c70]::bzip2recover::main)",
    "span": "bzip2recover.rs:561:1: 572:2 (#0)",
    "pieces": [
      "bzip2recover.rs:561:1: 572:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub fn main() {\n    let mut args: Vec<*mut std::os::raw::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(::std::ffi::CString::new(arg).expect(\"Failed to convert argument into CString.\").into_raw());\n    };\n    args.push(::std::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(main_0((args.len() - 1) as Int32,\n                                    args.as_mut_ptr() as *mut *mut Char) as\n                                 i32)\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzip2recover.rs:45:1: 45:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:418 ~ c2rust_out[3c70]::bzlib::default_bzfree)",
    "span": "bzlib.rs:259:1: 262:2 (#0)",
    "pieces": [
      "bzlib.rs:259:1: 262:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn default_bzfree(mut opaque: *mut std::os::raw::c_void,\n                                    mut addr: *mut std::os::raw::c_void) {\n    if !addr.is_null() { free(addr); };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:561 ~ c2rust_out[3c70]::huffman::BZ2_hbMakeCodeLengths)",
    "span": "huffman.rs:12:1: 190:2 (#0)",
    "pieces": [
      "huffman.rs:12:1: 190:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 179,
    "source": "pub unsafe extern \"C\" fn BZ2_hbMakeCodeLengths(mut len: *mut UChar,\n                                               mut freq: *mut Int32,\n                                               mut alphaSize: Int32,\n                                               mut maxLen: Int32) {\n    /*--\n      Nodes and heap entries run from 1.  Entry 0\n      for both the heap and nodes is a sentinel.\n   --*/\n    let mut nNodes: Int32 = 0;\n    let mut nHeap: Int32 = 0;\n    let mut n1: Int32 = 0;\n    let mut n2: Int32 = 0;\n    let mut i: Int32 = 0;\n    let mut j: Int32 = 0;\n    let mut k: Int32 = 0;\n    let mut tooLong: Bool = 0;\n    let mut heap: [Int32; 260] = [0; 260];\n    let mut weight: [Int32; 516] = [0; 516];\n    let mut parent: [Int32; 516] = [0; 516];\n    i = 0 as std::os::raw::c_int;\n    while i < alphaSize {\n        weight[(i + 1 as std::os::raw::c_int) as usize] =\n            (if *freq.offset(i as isize) == 0 as std::os::raw::c_int {\n                 1 as std::os::raw::c_int\n             } else { *freq.offset(i as isize) }) << 8 as std::os::raw::c_int;\n        i += 1\n    }\n    while 1 as std::os::raw::c_int as Bool != 0 {\n        nNodes = alphaSize;\n        nHeap = 0 as std::os::raw::c_int;\n        heap[0 as std::os::raw::c_int as usize] = 0 as std::os::raw::c_int;\n        weight[0 as std::os::raw::c_int as usize] = 0 as std::os::raw::c_int;\n        parent[0 as std::os::raw::c_int as usize] = -(2 as std::os::raw::c_int);\n        i = 1 as std::os::raw::c_int;\n        while i <= alphaSize {\n            parent[i as usize] = -(1 as std::os::raw::c_int);\n            nHeap += 1;\n            heap[nHeap as usize] = i;\n            let mut zz: Int32 = 0;\n            let mut tmp: Int32 = 0;\n            zz = nHeap;\n            tmp = heap[zz as usize];\n            while weight[tmp as usize] <\n                      weight[heap[(zz >> 1 as std::os::raw::c_int) as usize] as usize]\n                  {\n                heap[zz as usize] = heap[(zz >> 1 as std::os::raw::c_int) as usize];\n                zz >>= 1 as std::os::raw::c_int\n            }\n            heap[zz as usize] = tmp;\n            i += 1\n        }\n        if !(nHeap < 258 as std::os::raw::c_int + 2 as std::os::raw::c_int) {\n            BZ2_bz__AssertH__fail(2001 as std::os::raw::c_int);\n        }\n        while nHeap > 1 as std::os::raw::c_int {\n            n1 = heap[1 as std::os::raw::c_int as usize];\n            heap[1 as std::os::raw::c_int as usize] = heap[nHeap as usize];\n            nHeap -= 1;\n            let mut zz_0: Int32 = 0;\n            let mut yy: Int32 = 0;\n            let mut tmp_0: Int32 = 0;\n            zz_0 = 1 as std::os::raw::c_int;\n            tmp_0 = heap[zz_0 as usize];\n            while 1 as std::os::raw::c_int as Bool != 0 {\n                yy = zz_0 << 1 as std::os::raw::c_int;\n                if yy > nHeap { break ; }\n                if yy < nHeap &&\n                       weight[heap[(yy + 1 as std::os::raw::c_int) as usize] as usize]\n                           < weight[heap[yy as usize] as usize] {\n                    yy += 1\n                }\n                if weight[tmp_0 as usize] < weight[heap[yy as usize] as usize]\n                   {\n                    break ;\n                }\n                heap[zz_0 as usize] = heap[yy as usize];\n                zz_0 = yy\n            }\n            heap[zz_0 as usize] = tmp_0;\n            n2 = heap[1 as std::os::raw::c_int as usize];\n            heap[1 as std::os::raw::c_int as usize] = heap[nHeap as usize];\n            nHeap -= 1;\n            let mut zz_1: Int32 = 0;\n            let mut yy_0: Int32 = 0;\n            let mut tmp_1: Int32 = 0;\n            zz_1 = 1 as std::os::raw::c_int;\n            tmp_1 = heap[zz_1 as usize];\n            while 1 as std::os::raw::c_int as Bool != 0 {\n                yy_0 = zz_1 << 1 as std::os::raw::c_int;\n                if yy_0 > nHeap { break ; }\n                if yy_0 < nHeap &&\n                       weight[heap[(yy_0 + 1 as std::os::raw::c_int) as usize] as\n                                  usize] <\n                           weight[heap[yy_0 as usize] as usize] {\n                    yy_0 += 1\n                }\n                if weight[tmp_1 as usize] <\n                       weight[heap[yy_0 as usize] as usize] {\n                    break ;\n                }\n                heap[zz_1 as usize] = heap[yy_0 as usize];\n                zz_1 = yy_0\n            }\n            heap[zz_1 as usize] = tmp_1;\n            nNodes += 1;\n            parent[n2 as usize] = nNodes;\n            parent[n1 as usize] = parent[n2 as usize];\n            weight[nNodes as usize] =\n                ((weight[n1 as usize] as std::os::raw::c_uint &\n                      0xffffff00 as\n                          std::os::raw::c_uint).wrapping_add(weight[n2 as usize] as\n                                                         std::os::raw::c_uint &\n                                                         0xffffff00 as\n                                                             std::os::raw::c_uint) |\n                     (1 as std::os::raw::c_int +\n                          (if weight[n1 as usize] & 0xff as std::os::raw::c_int >\n                                  weight[n2 as usize] & 0xff as std::os::raw::c_int {\n                               (weight[n1 as usize]) & 0xff as std::os::raw::c_int\n                           } else {\n                               (weight[n2 as usize]) & 0xff as std::os::raw::c_int\n                           })) as std::os::raw::c_uint) as Int32;\n            parent[nNodes as usize] = -(1 as std::os::raw::c_int);\n            nHeap += 1;\n            heap[nHeap as usize] = nNodes;\n            let mut zz_2: Int32 = 0;\n            let mut tmp_2: Int32 = 0;\n            zz_2 = nHeap;\n            tmp_2 = heap[zz_2 as usize];\n            while weight[tmp_2 as usize] <\n                      weight[heap[(zz_2 >> 1 as std::os::raw::c_int) as usize] as\n                                 usize] {\n                heap[zz_2 as usize] =\n                    heap[(zz_2 >> 1 as std::os::raw::c_int) as usize];\n                zz_2 >>= 1 as std::os::raw::c_int\n            }\n            heap[zz_2 as usize] = tmp_2\n        }\n        if !(nNodes < 258 as std::os::raw::c_int * 2 as std::os::raw::c_int) {\n            BZ2_bz__AssertH__fail(2002 as std::os::raw::c_int);\n        }\n        tooLong = 0 as std::os::raw::c_int as Bool;\n        i = 1 as std::os::raw::c_int;\n        while i <= alphaSize {\n            j = 0 as std::os::raw::c_int;\n            k = i;\n            while parent[k as usize] >= 0 as std::os::raw::c_int {\n                k = parent[k as usize];\n                j += 1\n            }\n            *len.offset((i - 1 as std::os::raw::c_int) as isize) = j as UChar;\n            if j > maxLen { tooLong = 1 as std::os::raw::c_int as Bool }\n            i += 1\n        }\n        if tooLong == 0 { break ; }\n        /* 17 Oct 04: keep-going condition for the following loop used\n         to be 'i < alphaSize', which missed the last element,\n         theoretically leading to the possibility of the compressor\n         looping.  However, this count-scaling step is only needed if\n         one of the generated Huffman code words is longer than\n         maxLen, which up to and including version 1.0.2 was 20 bits,\n         which is extremely unlikely.  In version 1.0.3 maxLen was\n         changed to 17 bits, which has minimal effect on compression\n         ratio, but does mean this scaling step is used from time to\n         time, enough to verify that it works.\n\n         This means that bzip2-1.0.3 and later will only produce\n         Huffman codes with a maximum length of 17 bits.  However, in\n         order to preserve backwards compatibility with bitstreams\n         produced by versions pre-1.0.3, the decompressor must still\n         handle lengths of up to 20. */\n        i = 1 as std::os::raw::c_int;\n        while i <= alphaSize {\n            j = weight[i as usize] >> 8 as std::os::raw::c_int;\n            j = 1 as std::os::raw::c_int + j / 2 as std::os::raw::c_int;\n            weight[i as usize] = j << 8 as std::os::raw::c_int;\n            i += 1\n        }\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "huffman.rs:6:1: 6:45 (#0)",
        "source": "pub use crate::bzlib::BZ2_bz__AssertH__fail;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:436 ~ c2rust_out[3c70]::bzlib::myfeof)",
    "span": "bzlib.rs:1672:1: 1677:2 (#0)",
    "pieces": [
      "bzlib.rs:1672:1: 1677:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn myfeof(mut f: *mut FILE) -> Bool {\n    let mut c: Int32 = fgetc(f);\n    if c == -(1 as std::os::raw::c_int) { return 1 as std::os::raw::c_int as Bool }\n    ungetc(c, f);\n    return 0 as std::os::raw::c_int as Bool;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:457 ~ c2rust_out[3c70]::bzlib::BZ2_bzwrite)",
    "span": "bzlib.rs:2342:1: 2350:2 (#0)",
    "pieces": [
      "bzlib.rs:2342:1: 2350:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn BZ2_bzwrite(mut b: *mut std::os::raw::c_void,\n                                     mut buf: *mut std::os::raw::c_void,\n                                     mut len: std::os::raw::c_int) -> std::os::raw::c_int {\n    let mut bzerr: std::os::raw::c_int = 0;\n    BZ2_bzWrite(&mut bzerr, b, buf, len);\n    if bzerr == 0 as std::os::raw::c_int {\n        return len\n    } else { return -(1 as std::os::raw::c_int) };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "bzlib.rs:54:1: 54:44 (#0)",
        "source": "pub use crate::compress::BZ2_compressBlock;"
      },
      {
        "span": "bzlib.rs:56:1: 56:36 (#0)",
        "source": "pub use crate::blocksort::__sFILEX;"
      },
      {
        "span": "bzlib.rs:55:1: 55:43 (#0)",
        "source": "pub use crate::decompress::BZ2_decompress;"
      }
    ],
    "chunks": []
  }
]