xzoom.rs:1055:1: 1058:2
pub unsafe extern "C" fn timeout_func(signum: i32) {
    set_title = 1;
    let _unused = signum; // Marking signum as unused
}
xzoom.rs:1061:1: 1085:2
pub unsafe extern "C" fn allocate_images() {
    let mut i: std::os::raw::c_int = 0;
    i = 0 as std::os::raw::c_int;
    while i < 2 as std::os::raw::c_int {
        let mut data: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
        data =
            malloc(((*(dpy as _XPrivDisplay)).bitmap_unit / 8 as std::os::raw::c_int *
                        width[i as usize] * height[i as usize]) as
                       std::os::raw::c_ulong) as *mut std::os::raw::c_char;
        ximage[i as usize] =
            XCreateImage(dpy, (*scr).root_visual,
                         (*scr).root_depth as std::os::raw::c_uint, 2 as std::os::raw::c_int,
                         0 as std::os::raw::c_int, data,
                         width[i as usize] as std::os::raw::c_uint,
                         height[i as usize] as std::os::raw::c_uint,
                         32 as std::os::raw::c_int, 0 as std::os::raw::c_int);
        if ximage[i as usize].is_null() {
            perror(b"XCreateImage\x00" as *const u8 as *const std::os::raw::c_char);
            exit(-(1 as std::os::raw::c_int));
        }
        i += 1
        /* XSHM */
    }
    created_images = 1 as std::os::raw::c_int;
}
xzoom.rs:1087:1: 1103:2
pub unsafe extern "C" fn destroy_images() {
    let mut i: std::os::raw::c_int = 0;
    if created_images == 0 { return }
    i = 0 as std::os::raw::c_int;
    while i < 2 as std::os::raw::c_int {
        free((*ximage[i as usize]).data as *mut std::os::raw::c_void);
        /* and destroy image */
        (*ximage[i as usize]).data =
            0 as *mut std::os::raw::c_char; /* remove refrence to that address */
        Some((**ximage.as_mut_ptr().offset(i as
                                               isize)).f.destroy_image.expect("non-null function pointer")).expect("non-null function pointer")(ximage[i
                                                                                                                                                           as
                                                                                                                                                           usize]);
        i += 1
    }
    created_images = 0 as std::os::raw::c_int;
}
xzoom.rs:1108:9: 1108:72
unsafe { std::ffi::CStr::from_ptr(progname).to_string_lossy() }
xzoom.rs:1119:5: 1154:6
unsafe {
        destroy_images(); // we can get rid of these
        // find new dimensions for source
        let (new_width, new_height) = if flipxy != 0 {
            (
                (new_height + magy - 1) / magy,
                (new_width + magx - 1) / magx,
            )
        } else {
            (
                (new_width + magx - 1) / magx,
                (new_height + magy - 1) / magy,
            )
        };

        let screen_width = (*scr).width;
        let screen_height = (*scr).height;

        width[0] = new_width.clamp(1, screen_width);
        height[0] = new_height.clamp(1, screen_height);

        // temporary, the dest image may be larger than the actual window
        if flipxy != 0 {
            width[1] = magx * height[0]; // allocate new images
            height[1] = magy * width[0];
        } else {
            width[1] = magx * width[0];
            height[1] = magy * height[0];
        }

        allocate_images();

        // remember actual window size
        width[1] = width[1].min(new_width);
        height[1] = height[1].min(new_height);
    }
xzoom.rs:1158:1: 1430:2
pub unsafe extern "C" fn scale8() {
    /* scale image from SRC to DST - parameterized by type T */
    /* scale image from SRC to DST - parameterized by type T */
    /* scale image from SRC to DST - parameterized by type T */
    /* get pixel address of point (x,y) in image t */
    /* get pixel address of point (x,y) in image t */
    /* get pixel address of point (x,y) in image t */
    let mut i: i32 = 0;
let mut j: i32 = 0;
let mut k: i32 = 0;

/* copy scaled lines from SRC to DST */
/* copy scaled lines from SRC to DST */
/* copy scaled lines from SRC to DST */
j = if flipxy != 0 {
    width[0] - 1
} else {
    height[0] - 1
};

loop {
     let mut p1: *mut std::os::raw::c_uchar = 0 as *mut std::os::raw::c_uchar;
        let mut p2: *mut std::os::raw::c_uchar = 0 as *mut std::os::raw::c_uchar;
        let mut p2step: std::os::raw::c_int = 0;
        let mut p1_save: *mut std::os::raw::c_uchar = 0 as *mut std::os::raw::c_uchar;
        /* p1 point to begining of scanline j*magy in DST */
        /* p1 point to begining of scanline j*magy in DST */
        /* p1 point to begining of scanline j*magy in DST */
        p1 =
            &mut *(**ximage.as_mut_ptr().offset(1 as std::os::raw::c_int as
                                                    isize)).data.offset((((**ximage.as_mut_ptr().offset(1
                                                                                                            as
                                                                                                            std::os::raw::c_int
                                                                                                            as
                                                                                                            isize)).xoffset
                                                                              +
                                                                              0
                                                                                  as
                                                                                  std::os::raw::c_int)
                                                                             as
                                                                             std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_uchar>()
                                                                                                             as
                                                                                                             std::os::raw::c_ulong).wrapping_add((j
                                                                                                                                              *
                                                                                                                                              magy
                                                                                                                                              *
                                                                                                                                              (**ximage.as_mut_ptr().offset(1
                                                                                                                                                                                as
                                                                                                                                                                                std::os::raw::c_int
                                                                                                                                                                                as
                                                                                                                                                                                isize)).bytes_per_line)
                                                                                                                                             as
                                                                                                                                             std::os::raw::c_ulong)
                                                                            as
                                                                            isize)
                as *mut std::os::raw::c_char as *mut std::os::raw::c_uchar;
        p1_save = p1;
        /* p2 point to begining of scanline j in SRC */
		/* if flipy then line height[SRC]-1-j */
        /* p2 point to begining of scanline j in SRC */
		/* if flipy then line height[SRC]-1-j */
        /* p2 point to begining of scanline j in SRC */
		/* if flipy then line height[SRC]-1-j */
        p2 =
            &mut *(**ximage.as_mut_ptr().offset(0 as std::os::raw::c_int as
                                                    isize)).data.offset((((**ximage.as_mut_ptr().offset(0
                                                                                                            as
                                                                                                            std::os::raw::c_int
                                                                                                            as
                                                                                                            isize)).xoffset
                                                                              +
                                                                              0
                                                                                  as
                                                                                  std::os::raw::c_int)
                                                                             as
                                                                             std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_uchar>()
                                                                                                             as
                                                                                                             std::os::raw::c_ulong).wrapping_add(((if flipy
                                                                                                                                                  !=
                                                                                                                                                  0
                                                                                                                                              {
                                                                                                                                               (*height.as_mut_ptr().offset(0
                                                                                                                                                                                as
                                                                                                                                                                                std::os::raw::c_int
                                                                                                                                                                                as
                                                                                                                                                                                isize)
                                                                                                                                                    -
                                                                                                                                                    1
                                                                                                                                                        as
                                                                                                                                                        std::os::raw::c_int)
                                                                                                                                                   -
                                                                                                                                                   j
                                                                                                                                           } else {
                                                                                                                                               j
                                                                                                                                           })
                                                                                                                                              *
                                                                                                                                              (**ximage.as_mut_ptr().offset(0
                                                                                                                                                                                as
                                                                                                                                                                                std::os::raw::c_int
                                                                                                                                                                                as
                                                                                                                                                                                isize)).bytes_per_line)
                                                                                                                                             as
                                                                                                                                             std::os::raw::c_ulong)
                                                                            as
                                                                            isize)
                as *mut std::os::raw::c_char as *mut std::os::raw::c_uchar;
       
     if flipxy != 0 {
            p2 =
                &mut *(**ximage.as_mut_ptr().offset(0 as std::os::raw::c_int as
                                                        isize)).data.offset((((**ximage.as_mut_ptr().offset(0
                                                                                                                as
                                                                                                                std::os::raw::c_int
                                                                                                                as
                                                                                                                isize)).xoffset
                                                                                  +
                                                                                  (if flipy
                                                                                          !=
                                                                                          0
                                                                                      {
                                                                                       j
                                                                                   } else {
                                                                                       (*width.as_mut_ptr().offset(0
                                                                                                                       as
                                                                                                                       std::os::raw::c_int
                                                                                                                       as
                                                                                                                       isize)
                                                                                            -
                                                                                            1
                                                                                                as
                                                                                                std::os::raw::c_int)
                                                                                           -
                                                                                           j
                                                                                   }))
                                                                                 as
                                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_uchar>()
                                                                                                                 as
                                                                                                                 std::os::raw::c_ulong).wrapping_add((0
                                                                                                                                                  as
                                                                                                                                                  std::os::raw::c_int
                                                                                                                                                  *
                                                                                                                                                  (**ximage.as_mut_ptr().offset(0
                                                                                                                                                                                    as
                                                                                                                                                                                    std::os::raw::c_int
                                                                                                                                                                                    as
                                                                                                                                                                                    isize)).bytes_per_line)
                                                                                                                                                 as
                                                                                                                                                 std::os::raw::c_ulong)
                                                                                as
                                                                                isize)
                    as *mut std::os::raw::c_char as *mut std::os::raw::c_uchar;
            p2step =
                ((*ximage[0 as std::os::raw::c_int as usize]).bytes_per_line as
                     std::os::raw::c_ulong).wrapping_div(::std::mem::size_of::<std::os::raw::c_uchar>()
                                                     as std::os::raw::c_ulong) as
                    std::os::raw::c_int;
            if flipx != 0 {
                p2 =
                    p2.offset((p2step *
                                   (height[0 as std::os::raw::c_int as usize] -
                                        1 as std::os::raw::c_int)) as isize);
                p2step = -p2step
            }
            i = height[0 as std::os::raw::c_int as usize];
            loop  {
                let mut c: std::os::raw::c_uchar = *p2;
                p2 = p2.offset(p2step as isize);
                k = magx;
                loop  {
                    let fresh0 = p1;
                    p1 = p1.offset(1);
                    *fresh0 = c;
                    k -= 1;
                    if !(k > 0 as std::os::raw::c_int) { break ; }
                }
                i -= 1;
                if !(i > 0 as std::os::raw::c_int) { break ; }
            }
        } else if flipx != 0 {
            p2 = p2.offset(width[0 as std::os::raw::c_int as usize] as isize);
            i = width[0 as std::os::raw::c_int as usize];
            loop  {
                p2 = p2.offset(-1);
                let mut c_0: std::os::raw::c_uchar = *p2;
                k = magx;
                loop  {
                    let fresh1 = p1;
                    p1 = p1.offset(1);
                    *fresh1 = c_0;
                    k -= 1;
                    if !(k > 0 as std::os::raw::c_int) { break ; }
                }
                i -= 1;
                if !(i > 0 as std::os::raw::c_int) { break ; }
            }
        } else {
            i = width[0 as std::os::raw::c_int as usize];
            loop  {
                let fresh2 = p2;
                p2 = p2.offset(1);
                let mut c_1: std::os::raw::c_uchar = *fresh2;
                k = magx;
                loop  {
                    let fresh3 = p1;
                    p1 = p1.offset(1);
                    *fresh3 = c_1;
                    k -= 1;
                    if !(k > 0 as std::os::raw::c_int) { break ; }
                }
                i -= 1;
                if !(i > 0 as std::os::raw::c_int) { break ; }
            }
        }
        /* draw vertical grid */
        /* draw vertical grid */
        /* draw vertical grid */
        if gridy != 0 && magx >= 2 as std::os::raw::c_int {
            p1 = p1_save.offset(-(1 as std::os::raw::c_int as isize));
            i = magx;
            k =
                if flipxy != 0 {
                    height[0 as std::os::raw::c_int as usize]
                } else { width[0 as std::os::raw::c_int as usize] };
            loop  {
                p1 = p1.offset(i as isize);
                *p1 =
                    (*p1 as std::os::raw::c_int ^
                         !(0 as std::os::raw::c_int as std::os::raw::c_uchar as std::os::raw::c_int))
                        as std::os::raw::c_uchar;
                k -= 1;
                if !(k > 0 as std::os::raw::c_int) { break ; }
            }
        }
        
    /* duplicate that line as needed */
    /* duplicate that line as needed */
    /* duplicate that line as needed */
     if magy > 1 {
    // p1 points to the beginning of scanline j * magy in DST
    p1 = p1_save;

    // p2 points to the beginning of the next line
    p2 = p1;
    p2step = ((*ximage[1]).bytes_per_line / std::mem::size_of::<u8>() as i32) as i32;
    i = (width[1] * std::mem::size_of::<u8>() as i32) as i32;
    k = magy - 1;

    while k > 0 {
        p2 = p2.add(p2step as usize);
        std::ptr::copy_nonoverlapping(p1, p2, i as usize);
        k -= 1;
    }

    // draw horizontal grid
    if gridx != 0 && magy >= 2 {
        k = width[1];
        while k > 0 {
            let fresh4 = p2;
            p2 = p2.add(1);
            *fresh4 ^= 0xFF; // Assuming the intention is to toggle the byte
            k -= 1;
        }
    }
}
j -= 1;
if j < 0 {
    break;
}

    
};

}
xzoom.rs:1432:1: 1671:2
pub unsafe extern "C" fn scale16() {
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    let mut k: std::os::raw::c_int = 0;
    j =
        if flipxy != 0 {
            (width[0 as std::os::raw::c_int as usize]) - 1 as std::os::raw::c_int
        } else { (height[0 as std::os::raw::c_int as usize]) - 1 as std::os::raw::c_int };
    loop  {
        let mut p1: *mut std::os::raw::c_ushort = 0 as *mut std::os::raw::c_ushort;
        let mut p2: *mut std::os::raw::c_ushort = 0 as *mut std::os::raw::c_ushort;
        let mut p2step: std::os::raw::c_int = 0;
        let mut p1_save: *mut std::os::raw::c_ushort = 0 as *mut std::os::raw::c_ushort;
        p1 =
            &mut *(**ximage.as_mut_ptr().offset(1 as std::os::raw::c_int as
                                                    isize)).data.offset((((**ximage.as_mut_ptr().offset(1
                                                                                                            as
                                                                                                            std::os::raw::c_int
                                                                                                            as
                                                                                                            isize)).xoffset
                                                                              +
                                                                              0
                                                                                  as
                                                                                  std::os::raw::c_int)
                                                                             as
                                                                             std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_ushort>()
                                                                                                             as
                                                                                                             std::os::raw::c_ulong).wrapping_add((j
                                                                                                                                              *
                                                                                                                                              magy
                                                                                                                                              *
                                                                                                                                              (**ximage.as_mut_ptr().offset(1
                                                                                                                                                                                as
                                                                                                                                                                                std::os::raw::c_int
                                                                                                                                                                                as
                                                                                                                                                                                isize)).bytes_per_line)
                                                                                                                                             as
                                                                                                                                             std::os::raw::c_ulong)
                                                                            as
                                                                            isize)
                as *mut std::os::raw::c_char as *mut std::os::raw::c_ushort;
        p1_save = p1;
        p2 =
            &mut *(**ximage.as_mut_ptr().offset(0 as std::os::raw::c_int as
                                                    isize)).data.offset((((**ximage.as_mut_ptr().offset(0
                                                                                                            as
                                                                                                            std::os::raw::c_int
                                                                                                            as
                                                                                                            isize)).xoffset
                                                                              +
                                                                              0
                                                                                  as
                                                                                  std::os::raw::c_int)
                                                                             as
                                                                             std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_ushort>()
                                                                                                             as
                                                                                                             std::os::raw::c_ulong).wrapping_add(((if flipy
                                                                                                                                                  !=
                                                                                                                                                  0
                                                                                                                                              {
                                                                                                                                               (*height.as_mut_ptr().offset(0
                                                                                                                                                                                as
                                                                                                                                                                                std::os::raw::c_int
                                                                                                                                                                                as
                                                                                                                                                                                isize)
                                                                                                                                                    -
                                                                                                                                                    1
                                                                                                                                                        as
                                                                                                                                                        std::os::raw::c_int)
                                                                                                                                                   -
                                                                                                                                                   j
                                                                                                                                           } else {
                                                                                                                                               j
                                                                                                                                           })
                                                                                                                                              *
                                                                                                                                              (**ximage.as_mut_ptr().offset(0
                                                                                                                                                                                as
                                                                                                                                                                                std::os::raw::c_int
                                                                                                                                                                                as
                                                                                                                                                                                isize)).bytes_per_line)
                                                                                                                                             as
                                                                                                                                             std::os::raw::c_ulong)
                                                                            as
                                                                            isize)
                as *mut std::os::raw::c_char as *mut std::os::raw::c_ushort;
        if flipxy != 0 {
            p2 =
                &mut *(**ximage.as_mut_ptr().offset(0 as std::os::raw::c_int as
                                                        isize)).data.offset((((**ximage.as_mut_ptr().offset(0
                                                                                                                as
                                                                                                                std::os::raw::c_int
                                                                                                                as
                                                                                                                isize)).xoffset
                                                                                  +
                                                                                  (if flipy
                                                                                          !=
                                                                                          0
                                                                                      {
                                                                                       j
                                                                                   } else {
                                                                                       (*width.as_mut_ptr().offset(0
                                                                                                                       as
                                                                                                                       std::os::raw::c_int
                                                                                                                       as
                                                                                                                       isize)
                                                                                            -
                                                                                            1
                                                                                                as
                                                                                                std::os::raw::c_int)
                                                                                           -
                                                                                           j
                                                                                   }))
                                                                                 as
                                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_ushort>()
                                                                                                                 as
                                                                                                                 std::os::raw::c_ulong).wrapping_add((0
                                                                                                                                                  as
                                                                                                                                                  std::os::raw::c_int
                                                                                                                                                  *
                                                                                                                                                  (**ximage.as_mut_ptr().offset(0
                                                                                                                                                                                    as
                                                                                                                                                                                    std::os::raw::c_int
                                                                                                                                                                                    as
                                                                                                                                                                                    isize)).bytes_per_line)
                                                                                                                                                 as
                                                                                                                                                 std::os::raw::c_ulong)
                                                                                as
                                                                                isize)
                    as *mut std::os::raw::c_char as *mut std::os::raw::c_ushort;
            p2step =
                ((*ximage[0 as std::os::raw::c_int as usize]).bytes_per_line as
                     std::os::raw::c_ulong).wrapping_div(::std::mem::size_of::<std::os::raw::c_ushort>()
                                                     as std::os::raw::c_ulong) as
                    std::os::raw::c_int;
            if flipx != 0 {
                p2 =
                    p2.offset((p2step *
                                   (height[0 as std::os::raw::c_int as usize] -
                                        1 as std::os::raw::c_int)) as isize);
                p2step = -p2step
            }
            i = height[0 as std::os::raw::c_int as usize];
            loop  {
                let mut c: std::os::raw::c_ushort = *p2;
                p2 = p2.offset(p2step as isize);
                k = magx;
                loop  {
                    let fresh5 = p1;
                    p1 = p1.offset(1);
                    *fresh5 = c;
                    k -= 1;
                    if !(k > 0 as std::os::raw::c_int) { break ; }
                }
                i -= 1;
                if !(i > 0 as std::os::raw::c_int) { break ; }
            }
        } else if flipx != 0 {
            p2 = p2.offset(width[0 as std::os::raw::c_int as usize] as isize);
            i = width[0 as std::os::raw::c_int as usize];
            loop  {
                p2 = p2.offset(-1);
                let mut c_0: std::os::raw::c_ushort = *p2;
                k = magx;
                loop  {
                    let fresh6 = p1;
                    p1 = p1.offset(1);
                    *fresh6 = c_0;
                    k -= 1;
                    if !(k > 0 as std::os::raw::c_int) { break ; }
                }
                i -= 1;
                if !(i > 0 as std::os::raw::c_int) { break ; }
            }
        } else {
            i = width[0 as std::os::raw::c_int as usize];
            loop  {
                let fresh7 = p2;
                p2 = p2.offset(1);
                let mut c_1: std::os::raw::c_ushort = *fresh7;
                k = magx;
                loop  {
                    let fresh8 = p1;
                    p1 = p1.offset(1);
                    *fresh8 = c_1;
                    k -= 1;
                    if !(k > 0 as std::os::raw::c_int) { break ; }
                }
                i -= 1;
                if !(i > 0 as std::os::raw::c_int) { break ; }
            }
        }
        if gridy != 0 && magx >= 2 as std::os::raw::c_int {
            p1 = p1_save.offset(-(1 as std::os::raw::c_int as isize));
            i = magx;
            k =
                if flipxy != 0 {
                    height[0 as std::os::raw::c_int as usize]
                } else { width[0 as std::os::raw::c_int as usize] };
            loop  {
                p1 = p1.offset(i as isize);
                *p1 =
                    (*p1 as std::os::raw::c_int ^
                         !(0 as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int))
                        as std::os::raw::c_ushort;
                k -= 1;
                if !(k > 0 as std::os::raw::c_int) { break ; }
            }
        }
        if magy > 1 {
    p1 = p1_save;
    p2 = p1;
    p2step = unsafe { (*ximage[1]).bytes_per_line as usize / std::mem::size_of::<u16>() } as i32;
    i = (width[1] as usize * std::mem::size_of::<u16>()) as i32;
    k = magy - 1;

    while k > 0 {
        p2 = p2.add(p2step as usize);
        unsafe {
            std::ptr::copy_nonoverlapping(p1, p2, i as usize);
        }
        k -= 1;
    }

    if gridx != 0 && magy >= 2 {
        k = width[1];
        while k > 0 {
            let fresh9 = p2;
            p2 = p2.add(1);
            unsafe {
                *fresh9 = (*fresh9 ^ !0) as u16;
            }
            k -= 1;
        }
    }
}
j -= 1;
if j < 0 { break; }

    };
}
xzoom.rs:1673:1: 1904:2
pub unsafe extern "C" fn scale32() {
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    let mut k: std::os::raw::c_int = 0;
    j =
        if flipxy != 0 {
            (width[0 as std::os::raw::c_int as usize]) - 1 as std::os::raw::c_int
        } else { (height[0 as std::os::raw::c_int as usize]) - 1 as std::os::raw::c_int };
    loop  {
        let mut p1: *mut std::os::raw::c_uint = 0 as *mut std::os::raw::c_uint;
        let mut p2: *mut std::os::raw::c_uint = 0 as *mut std::os::raw::c_uint;
        let mut p2step: std::os::raw::c_int = 0;
        let mut p1_save: *mut std::os::raw::c_uint = 0 as *mut std::os::raw::c_uint;
        p1 =
            &mut *(**ximage.as_mut_ptr().offset(1 as std::os::raw::c_int as
                                                    isize)).data.offset((((**ximage.as_mut_ptr().offset(1
                                                                                                            as
                                                                                                            std::os::raw::c_int
                                                                                                            as
                                                                                                            isize)).xoffset
                                                                              +
                                                                              0
                                                                                  as
                                                                                  std::os::raw::c_int)
                                                                             as
                                                                             std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_uint>()
                                                                                                             as
                                                                                                             std::os::raw::c_ulong).wrapping_add((j
                                                                                                                                              *
                                                                                                                                              magy
                                                                                                                                              *
                                                                                                                                              (**ximage.as_mut_ptr().offset(1
                                                                                                                                                                                as
                                                                                                                                                                                std::os::raw::c_int
                                                                                                                                                                                as
                                                                                                                                                                                isize)).bytes_per_line)
                                                                                                                                             as
                                                                                                                                             std::os::raw::c_ulong)
                                                                            as
                                                                            isize)
                as *mut std::os::raw::c_char as *mut std::os::raw::c_uint;
        p1_save = p1;
        p2 =
            &mut *(**ximage.as_mut_ptr().offset(0 as std::os::raw::c_int as
                                                    isize)).data.offset((((**ximage.as_mut_ptr().offset(0
                                                                                                            as
                                                                                                            std::os::raw::c_int
                                                                                                            as
                                                                                                            isize)).xoffset
                                                                              +
                                                                              0
                                                                                  as
                                                                                  std::os::raw::c_int)
                                                                             as
                                                                             std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_uint>()
                                                                                                             as
                                                                                                             std::os::raw::c_ulong).wrapping_add(((if flipy
                                                                                                                                                  !=
                                                                                                                                                  0
                                                                                                                                              {
                                                                                                                                               (*height.as_mut_ptr().offset(0
                                                                                                                                                                                as
                                                                                                                                                                                std::os::raw::c_int
                                                                                                                                                                                as
                                                                                                                                                                                isize)
                                                                                                                                                    -
                                                                                                                                                    1
                                                                                                                                                        as
                                                                                                                                                        std::os::raw::c_int)
                                                                                                                                                   -
                                                                                                                                                   j
                                                                                                                                           } else {
                                                                                                                                               j
                                                                                                                                           })
                                                                                                                                              *
                                                                                                                                              (**ximage.as_mut_ptr().offset(0
                                                                                                                                                                                as
                                                                                                                                                                                std::os::raw::c_int
                                                                                                                                                                                as
                                                                                                                                                                                isize)).bytes_per_line)
                                                                                                                                             as
                                                                                                                                             std::os::raw::c_ulong)
                                                                            as
                                                                            isize)
                as *mut std::os::raw::c_char as *mut std::os::raw::c_uint;
        if flipxy != 0 {
            p2 =
                &mut *(**ximage.as_mut_ptr().offset(0 as std::os::raw::c_int as
                                                        isize)).data.offset((((**ximage.as_mut_ptr().offset(0
                                                                                                                as
                                                                                                                std::os::raw::c_int
                                                                                                                as
                                                                                                                isize)).xoffset
                                                                                  +
                                                                                  (if flipy
                                                                                          !=
                                                                                          0
                                                                                      {
                                                                                       j
                                                                                   } else {
                                                                                       (*width.as_mut_ptr().offset(0
                                                                                                                       as
                                                                                                                       std::os::raw::c_int
                                                                                                                       as
                                                                                                                       isize)
                                                                                            -
                                                                                            1
                                                                                                as
                                                                                                std::os::raw::c_int)
                                                                                           -
                                                                                           j
                                                                                   }))
                                                                                 as
                                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_uint>()
                                                                                                                 as
                                                                                                                 std::os::raw::c_ulong).wrapping_add((0
                                                                                                                                                  as
                                                                                                                                                  std::os::raw::c_int
                                                                                                                                                  *
                                                                                                                                                  (**ximage.as_mut_ptr().offset(0
                                                                                                                                                                                    as
                                                                                                                                                                                    std::os::raw::c_int
                                                                                                                                                                                    as
                                                                                                                                                                                    isize)).bytes_per_line)
                                                                                                                                                 as
                                                                                                                                                 std::os::raw::c_ulong)
                                                                                as
                                                                                isize)
                    as *mut std::os::raw::c_char as *mut std::os::raw::c_uint;
            p2step =
                ((*ximage[0 as std::os::raw::c_int as usize]).bytes_per_line as
                     std::os::raw::c_ulong).wrapping_div(::std::mem::size_of::<std::os::raw::c_uint>()
                                                     as std::os::raw::c_ulong) as
                    std::os::raw::c_int;
            if flipx != 0 {
                p2 =
                    p2.offset((p2step *
                                   (height[0 as std::os::raw::c_int as usize] -
                                        1 as std::os::raw::c_int)) as isize);
                p2step = -p2step
            }
            i = height[0 as std::os::raw::c_int as usize];
            loop  {
                let mut c: std::os::raw::c_uint = *p2;
                p2 = p2.offset(p2step as isize);
                k = magx;
                loop  {
                    let fresh10 = p1;
                    p1 = p1.offset(1);
                    *fresh10 = c;
                    k -= 1;
                    if !(k > 0 as std::os::raw::c_int) { break ; }
                }
                i -= 1;
                if !(i > 0 as std::os::raw::c_int) { break ; }
            }
        } else if flipx != 0 {
            p2 = p2.offset(width[0 as std::os::raw::c_int as usize] as isize);
            i = width[0 as std::os::raw::c_int as usize];
            loop  {
                p2 = p2.offset(-1);
                let mut c_0: std::os::raw::c_uint = *p2;
                k = magx;
                loop  {
                    let fresh11 = p1;
                    p1 = p1.offset(1);
                    *fresh11 = c_0;
                    k -= 1;
                    if !(k > 0 as std::os::raw::c_int) { break ; }
                }
                i -= 1;
                if !(i > 0 as std::os::raw::c_int) { break ; }
            }
        } else {
            i = width[0 as std::os::raw::c_int as usize];
            loop  {
                let fresh12 = p2;
                p2 = p2.offset(1);
                let mut c_1: std::os::raw::c_uint = *fresh12;
                k = magx;
                loop  {
                    let fresh13 = p1;
                    p1 = p1.offset(1);
                    *fresh13 = c_1;
                    k -= 1;
                    if !(k > 0 as std::os::raw::c_int) { break ; }
                }
                i -= 1;
                if !(i > 0 as std::os::raw::c_int) { break ; }
            }
        }
        if gridy != 0 && magx >= 2 as std::os::raw::c_int {
            p1 = p1_save.offset(-(1 as std::os::raw::c_int as isize));
            i = magx;
            k =
                if flipxy != 0 {
                    height[0 as std::os::raw::c_int as usize]
                } else { width[0 as std::os::raw::c_int as usize] };
            loop  {
                p1 = p1.offset(i as isize);
                *p1 ^= !(0 as std::os::raw::c_int as std::os::raw::c_uint);
                k -= 1;
                if !(k > 0 as std::os::raw::c_int) { break ; }
            }
        }
        if magy > 1 {
    let p1_slice = unsafe { std::slice::from_raw_parts(p1_save, (width[1] * magy) as usize) };
    let p2_slice = unsafe { std::slice::from_raw_parts_mut(p1, (width[1] * magy) as usize) };

    let p2step = unsafe { (*ximage[1]).bytes_per_line / std::mem::size_of::<u32>() as i32 } as usize;
    let i = (width[1] * std::mem::size_of::<u32>() as i32) as usize;
    let mut k = magy - 1;

    for _ in 0..k {
        let p2_offset = &mut p2_slice[p2step..p2step + i];
        p2_offset.copy_from_slice(&p1_slice[0..i]);
    }

    if gridx != 0 && magy >= 2 {
        k = width[1];
        for _ in 0..k {
            for p in p2_slice.iter_mut() {
                *p ^= !0;
            }
        }
    }
}
j -= 1;
if j < 0 { break; }

    };
}
xzoom.rs:1914:5: 1918:6
unsafe {
        width_value = width[0] as u32;
        height_value = height[0] as u32;
        depth_value = depth as u32; // Assuming depth is also a mutable static
    }
xzoom.rs:1921:18: 1935:6
unsafe {
        XGetSubImage(
            dpy,
            (*scr).root,
            xgrab,
            ygrab,
            width_value,
            height_value,
            !(0 as i64) as u64,
            2,
            ximage[0],
            0,
            0,
        )
    }
xzoom.rs:1938:9: 1938:29
unsafe { scale8(); }
xzoom.rs:1940:9: 1940:30
unsafe { scale16(); }
xzoom.rs:1942:9: 1942:30
unsafe { scale32(); }
xzoom.rs:1945:5: 1958:6
unsafe {
        XPutImage(
            dpy,
            win,
            gc,
            ximage[1],
            0,
            0,
            0,
            0,
            width[1] as u32,
            height[1] as u32,
        );
    }
xzoom.rs:1960:8: 1960:33
unsafe { set_title != 0 }
xzoom.rs:1961:12: 1961:78
unsafe { magx == magy && flipx == 0 && flipy == 0 && flipxy == 0 }
xzoom.rs:1962:13: 1969:14
unsafe {
                sprintf(
                    title.as_mut_ptr(),
                    b"%s x%d\x00" as *const u8 as *const i8,
                    progname,
                    magx,
                );
            }
xzoom.rs:1971:13: 1994:14
unsafe {
                sprintf(
                    title.as_mut_ptr(),
                    b"%s X %s%d%s Y %s%d\x00" as *const u8 as *const i8,
                    progname,
                    if unsafe { flipx != 0 } {
                        b"-\x00" as *const u8 as *const i8
                    } else {
                        b"\x00" as *const u8 as *const i8
                    },
                    magx,
                    if unsafe { flipxy != 0 } {
                        b" <=>\x00" as *const u8 as *const i8
                    } else {
                        b";\x00" as *const u8 as *const i8
                    },
                    if unsafe { flipy != 0 } {
                        b"-\x00" as *const u8 as *const i8
                    } else {
                        b"\x00" as *const u8 as *const i8
                    },
                    magy,
                );
            }
xzoom.rs:1997:9: 2008:10
unsafe {
            XChangeProperty(
                dpy,
                win,
                39,
                31,
                8,
                0,
                title.as_mut_ptr() as *mut u8,
                strlen(title.as_mut_ptr()) as i32,
            );
        }
xzoom.rs:2009:9: 2009:34
unsafe { set_title = 0; }
xzoom.rs:2011:5: 2013:6
unsafe {
        XSync(dpy, 0);
    }
xzoom.rs:2016:1: 2549:2
unsafe fn main_0(mut argc: std::os::raw::c_int, mut argv: *mut *mut std::os::raw::c_char)
 -> std::os::raw::c_int {
    let mut xswa: XSetWindowAttributes =
        XSetWindowAttributes{background_pixmap: 0,
                             background_pixel: 0,
                             border_pixmap: 0,
                             border_pixel: 0,
                             bit_gravity: 0,
                             win_gravity: 0,
                             backing_store: 0,
                             backing_planes: 0,
                             backing_pixel: 0,
                             save_under: 0,
                             event_mask: 0,
                             do_not_propagate_mask: 0,
                             override_redirect: 0,
                             colormap: 0,
                             cursor: 0,};
    let mut event: XEvent = _XEvent{type_0: 0,};
    let mut str: XTextProperty =
        XTextProperty{value: 0 as *mut std::os::raw::c_uchar,
                      encoding: 0,
                      format: 0,
                      nitems: 0,};
    let mut sizeh: *mut XSizeHints = 0 as *mut XSizeHints;
    let mut ch: *mut XClassHint = 0 as *mut XClassHint;
    let mut buttonpressed: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut visible: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut scroll: std::os::raw::c_int = 1 as std::os::raw::c_int;
    let mut title: [std::os::raw::c_char; 80] = [0; 80];
    let mut gcv: XGCValues =
        XGCValues{function: 0,
                  plane_mask: 0,
                  foreground: 0,
                  background: 0,
                  line_width: 0,
                  line_style: 0,
                  cap_style: 0,
                  join_style: 0,
                  fill_style: 0,
                  fill_rule: 0,
                  arc_mode: 0,
                  tile: 0,
                  stipple: 0,
                  ts_x_origin: 0,
                  ts_y_origin: 0,
                  font: 0,
                  subwindow_mode: 0,
                  graphics_exposures: 0,
                  clip_x_origin: 0,
                  clip_y_origin: 0,
                  clip_mask: 0,
                  dash_offset: 0,
                  dashes: 0,};
    let mut dpyname: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut source_geom_mask: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut dest_geom_mask: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut copy_from_src_mask: std::os::raw::c_int = 0;
    let mut xpos: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ypos: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut isdock: std::os::raw::c_int = 0 as std::os::raw::c_int;
    atexit(Some(destroy_images as unsafe extern "C" fn() -> ()));
    progname = strrchr(*argv.offset(0 as std::os::raw::c_int as isize), '/' as i32);
    if !progname.is_null() {
        progname = progname.offset(1)
    } else { progname = *argv.offset(0 as std::os::raw::c_int as isize) }
    loop 
         /* parse command line options */
         {
        argc -= 1;
        if !(argc > 0 as std::os::raw::c_int) { break ; }
        argv = argv.offset(1);
        if *(*argv.offset(0 as std::os::raw::c_int as
                              isize)).offset(0 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '=' as i32 {
            dest_geom_mask =
                XParseGeometry(*argv.offset(0 as std::os::raw::c_int as isize),
                               &mut xpos, &mut ypos,
                               &mut *width.as_mut_ptr().offset(1 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                   as *mut std::os::raw::c_int as *mut std::os::raw::c_uint,
                               &mut *height.as_mut_ptr().offset(1 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                   as *mut std::os::raw::c_int as *mut std::os::raw::c_uint)
        } else if strcmp(*argv.offset(0 as std::os::raw::c_int as isize),
                         b"-mag\x00" as *const u8 as *const std::os::raw::c_char) == 0
         {
            argv = argv.offset(1);
            argc -= 1;
            magx =
                if argc > 0 as std::os::raw::c_int {
                    atoi(*argv.offset(0 as std::os::raw::c_int as isize))
                } else { -(1 as std::os::raw::c_int) };
            if magx <= 0 as std::os::raw::c_int { Usage(); }
            magy =
                if argc > 1 as std::os::raw::c_int {
                    atoi(*argv.offset(1 as std::os::raw::c_int as isize))
                } else { -(1 as std::os::raw::c_int) };
            if magy <= 0 as std::os::raw::c_int {
                magy = magx
            } else { argv = argv.offset(1); argc -= 1 }
        } else if strcmp(*argv.offset(0 as std::os::raw::c_int as isize),
                         b"-x\x00" as *const u8 as *const std::os::raw::c_char) == 0 {
            flipx = 1 as std::os::raw::c_int
        } else if strcmp(*argv.offset(0 as std::os::raw::c_int as isize),
                         b"-y\x00" as *const u8 as *const std::os::raw::c_char) == 0 {
            flipy = 1 as std::os::raw::c_int
        } else if strcmp(*argv.offset(0 as std::os::raw::c_int as isize),
                         b"-z\x00" as *const u8 as *const std::os::raw::c_char) == 0
                      ||
                      strcmp(*argv.offset(0 as std::os::raw::c_int as isize),
                             b"-xy\x00" as *const u8 as *const std::os::raw::c_char)
                          == 0 {
            flipxy = 1 as std::os::raw::c_int
        } else if strcmp(*argv.offset(0 as std::os::raw::c_int as isize),
                         b"-source\x00" as *const u8 as *const std::os::raw::c_char)
                      == 0 {
            argv = argv.offset(1);
            argc -= 1;
            if argc < 1 as std::os::raw::c_int { Usage(); }
            source_geom_mask =
                XParseGeometry(*argv.offset(0 as std::os::raw::c_int as isize),
                               &mut xgrab, &mut ygrab,
                               &mut *width.as_mut_ptr().offset(0 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                   as *mut std::os::raw::c_int as *mut std::os::raw::c_uint,
                               &mut *height.as_mut_ptr().offset(0 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                   as *mut std::os::raw::c_int as *mut std::os::raw::c_uint)
        } else if strcmp(*argv.offset(0 as std::os::raw::c_int as isize),
                         b"-dest\x00" as *const u8 as *const std::os::raw::c_char) ==
                      0 ||
                      strcmp(*argv.offset(0 as std::os::raw::c_int as isize),
                             b"-geometry\x00" as *const u8 as
                                 *const std::os::raw::c_char) == 0 {
            argv = argv.offset(1);
            argc -= 1;
            if argc < 1 as std::os::raw::c_int { Usage(); }
            dest_geom_mask =
                XParseGeometry(*argv.offset(0 as std::os::raw::c_int as isize),
                               &mut xpos, &mut ypos,
                               &mut *width.as_mut_ptr().offset(1 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                   as *mut std::os::raw::c_int as *mut std::os::raw::c_uint,
                               &mut *height.as_mut_ptr().offset(1 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                   as *mut std::os::raw::c_int as *mut std::os::raw::c_uint)
        } else if strcmp(*argv.offset(0 as std::os::raw::c_int as isize),
                         b"-d\x00" as *const u8 as *const std::os::raw::c_char) == 0
                      ||
                      strcmp(*argv.offset(0 as std::os::raw::c_int as isize),
                             b"-display\x00" as *const u8 as
                                 *const std::os::raw::c_char) == 0 {
            argv = argv.offset(1);
            argc -= 1;
            if argc < 1 as std::os::raw::c_int { Usage(); }
            dpyname = *argv.offset(0 as std::os::raw::c_int as isize)
        } else if strcmp(*argv.offset(0 as std::os::raw::c_int as isize),
                         b"-delay\x00" as *const u8 as *const std::os::raw::c_char) ==
                      0 {
            argv = argv.offset(1);
            argc -= 1;
            if argc < 1 as std::os::raw::c_int { Usage(); }
            if sscanf(*argv.offset(0 as std::os::raw::c_int as isize),
                      b"%u\x00" as *const u8 as *const std::os::raw::c_char,
                      &mut delay as *mut std::os::raw::c_int) != 1 as std::os::raw::c_int {
                Usage();
            }
            delay *= 1000 as std::os::raw::c_int
        } else if strcmp(*argv.offset(0 as std::os::raw::c_int as isize),
                         b"-dock\x00" as *const u8 as *const std::os::raw::c_char) ==
                      0 {
            isdock = 1 as std::os::raw::c_int
        } else { Usage(); }
    }
    dpy = XOpenDisplay(dpyname);
    if dpy.is_null() {
        perror(b"Cannot open display\x00" as *const u8 as
                   *const std::os::raw::c_char);
        exit(-(1 as std::os::raw::c_int));
    }
    /* Now, see if we have to calculate width[DST] and height[DST]
	   from the SRC parameters */
    copy_from_src_mask = 0 as std::os::raw::c_int; /* resize etc.. */
    if source_geom_mask & 0x4 as std::os::raw::c_int != 0 {
        if flipxy != 0 {
            height[1 as std::os::raw::c_int as usize] =
                magy * width[0 as std::os::raw::c_int as usize]; /* commands */
            copy_from_src_mask |= 0x8 as std::os::raw::c_int
        } else {
            width[1 as std::os::raw::c_int as usize] =
                magx * width[0 as std::os::raw::c_int as usize];
            copy_from_src_mask |= 0x4 as std::os::raw::c_int
        }
    }
    if source_geom_mask & 0x8 as std::os::raw::c_int != 0 {
        if flipxy != 0 {
            width[1 as std::os::raw::c_int as usize] =
                magx * height[0 as std::os::raw::c_int as usize];
            copy_from_src_mask |= 0x4 as std::os::raw::c_int
        } else {
            height[1 as std::os::raw::c_int as usize] =
                magy * height[0 as std::os::raw::c_int as usize];
            copy_from_src_mask |= 0x8 as std::os::raw::c_int
        }
    }
    if copy_from_src_mask & dest_geom_mask != 0 {
        fprintf(stderr,
                b"Conflicting dimensions between source and dest geometry\n\x00"
                    as *const u8 as *const std::os::raw::c_char);
        Usage();
    }
    scr =
        &mut *(*(dpy as
                     _XPrivDisplay)).screens.offset((*(dpy as
                                                           _XPrivDisplay)).default_screen
                                                        as isize) as
            *mut Screen;
    depth = (*scr).root_depth as std::os::raw::c_uint;
    if depth < 8 as std::os::raw::c_int as std::os::raw::c_uint {
        fprintf(stderr,
                b"%s: need at least 8 bits/pixel\n\x00" as *const u8 as
                    *const std::os::raw::c_char, progname);
        exit(1 as std::os::raw::c_int);
    }
    if source_geom_mask & 0x10 as std::os::raw::c_int != 0 { xgrab += (*scr).width }
    if source_geom_mask & 0x20 as std::os::raw::c_int != 0 { ygrab += (*scr).height }
    if dest_geom_mask & 0x10 as std::os::raw::c_int != 0 { xpos += (*scr).width }
    if dest_geom_mask & 0x20 as std::os::raw::c_int != 0 { ypos += (*scr).height }
    printf(b"=%dx%d+%d+%d\n\x00" as *const u8 as *const std::os::raw::c_char,
           width[1 as std::os::raw::c_int as usize],
           height[1 as std::os::raw::c_int as usize], xpos, ypos);
    xswa.event_mask =
        (1 as std::os::raw::c_long) << 2 as std::os::raw::c_int |
            (1 as std::os::raw::c_long) << 3 as std::os::raw::c_int |
            (1 as std::os::raw::c_long) << 13 as std::os::raw::c_int;
    xswa.event_mask |= (1 as std::os::raw::c_long) << 17 as std::os::raw::c_int;
    xswa.event_mask |=
        (1 as std::os::raw::c_long) << 0 as std::os::raw::c_int |
            (1 as std::os::raw::c_long) << 1 as std::os::raw::c_int;
    xswa.event_mask |= (1 as std::os::raw::c_long) << 16 as std::os::raw::c_int;
    xswa.background_pixel = (*scr).black_pixel;
    win =
        XCreateWindow(dpy, (*scr).root, xpos, ypos,
                      width[1 as std::os::raw::c_int as usize] as std::os::raw::c_uint,
                      height[1 as std::os::raw::c_int as usize] as std::os::raw::c_uint,
                      0 as std::os::raw::c_int as std::os::raw::c_uint, (*scr).root_depth,
                      1 as std::os::raw::c_int as std::os::raw::c_uint, (*scr).root_visual,
                      ((1 as std::os::raw::c_long) << 11 as std::os::raw::c_int |
                           (1 as std::os::raw::c_long) << 1 as std::os::raw::c_int) as
                          std::os::raw::c_ulong, &mut xswa);
    XChangeProperty(dpy, win, 37 as std::os::raw::c_int as Atom,
                    31 as std::os::raw::c_int as Atom, 8 as std::os::raw::c_int,
                    0 as std::os::raw::c_int, progname as *mut std::os::raw::c_uchar,
                    strlen(progname) as std::os::raw::c_int);
    if isdock == 0 {
        sizeh = XAllocSizeHints();
        (*sizeh).flags =
            (1 as std::os::raw::c_long) << 5 as std::os::raw::c_int |
                (1 as std::os::raw::c_long) << 4 as std::os::raw::c_int;
        (*sizeh).max_width = width[1 as std::os::raw::c_int as usize];
        (*sizeh).min_width = (*sizeh).max_width;
        (*sizeh).max_height = height[1 as std::os::raw::c_int as usize];
        (*sizeh).min_height = (*sizeh).max_height
    }
    XStringListToTextProperty(&mut progname, 1 as std::os::raw::c_int, &mut str);
    ch = XAllocClassHint();
    (*ch).res_class = progname;
    (*ch).res_name = progname;
    XSetWMProperties(dpy, win, &mut str, &mut str,
                     0 as *mut *mut std::os::raw::c_char, 0 as std::os::raw::c_int, sizeh,
                     0 as *mut XWMHints, ch);
    if isdock != 0 {
        wm_windowtype =
            XInternAtom(dpy,
                        b"_NET_WM_WINDOW_TYPE\x00" as *const u8 as
                            *const std::os::raw::c_char, 0 as std::os::raw::c_int);
        wm_dock =
            XInternAtom(dpy,
                        b"_NET_WM_WINDOW_TYPE_DOCK\x00" as *const u8 as
                            *const std::os::raw::c_char, 0 as std::os::raw::c_int);
        XChangeProperty(dpy, win, wm_windowtype, 4 as std::os::raw::c_int as Atom,
                        32 as std::os::raw::c_int, 0 as std::os::raw::c_int,
                        &mut wm_dock as *mut Atom as *mut std::os::raw::c_uchar,
                        1 as std::os::raw::c_int);
    }
    /*
	XChangeProperty(dpy, win, XA_WM_NAME, XA_STRING, 8,
			PropModeReplace,
			(unsigned char *)progname, strlen(progname));
	*/
    /* **	20020213
		code added by <tmancill@debian.org> to handle
		window manager "close" event
	***/
    wm_delete_window =
        XInternAtom(dpy,
                    b"WM_DELETE_WINDOW\x00" as *const u8 as
                        *const std::os::raw::c_char, 0 as std::os::raw::c_int);
    wm_protocols =
        XInternAtom(dpy,
                    b"WM_PROTOCOLS\x00" as *const u8 as *const std::os::raw::c_char,
                    0 as std::os::raw::c_int);
    status =
        XSetWMProtocols(dpy, win, &mut wm_delete_window, 1 as std::os::raw::c_int);
    set_title = 1 as std::os::raw::c_int;
    status = XMapWindow(dpy, win);
    gcv.plane_mask = !(0 as std::os::raw::c_long) as std::os::raw::c_ulong;
    gcv.subwindow_mode = 1 as std::os::raw::c_int;
    gcv.function = 0x3 as std::os::raw::c_int;
    gcv.foreground = (*scr).white_pixel;
    gcv.background = (*scr).black_pixel;
    gc =
        XCreateGC(dpy, (*scr).root,
                  ((1 as std::os::raw::c_long) << 0 as std::os::raw::c_int |
                       (1 as std::os::raw::c_long) << 1 as std::os::raw::c_int |
                       (1 as std::os::raw::c_long) << 15 as std::os::raw::c_int |
                       (1 as std::os::raw::c_long) << 2 as std::os::raw::c_int |
                       (1 as std::os::raw::c_long) << 3 as std::os::raw::c_int) as
                      std::os::raw::c_ulong, &mut gcv);
    let width_1 = width[1];
let height_1 = height[1];
resize(width_1, height_1);
    when_button = XCreateFontCursor(dpy, 144 as std::os::raw::c_int as std::os::raw::c_uint);
    crosshair = XCreateFontCursor(dpy, 34 as std::os::raw::c_int as std::os::raw::c_uint);
    XDefineCursor(dpy, win, crosshair);
    loop  {
        /* ****
		old event loop updated to support WM messages
		while(unmapped?
			(XWindowEvent(dpy, win, (long)-1, &event), 1):
			XCheckWindowEvent(dpy, win, (long)-1, &event)) {
		******/
        while XPending(dpy) != 0 {
                XNextEvent(dpy, &mut event);
    match event.type_0 {
        33 => {
            if event.xclient.message_type == wm_protocols &&
               event.xclient.data.l[0] as u64 == wm_delete_window {
                std::process::exit(0);
            }
        }
        22 => {
            if event.xconfigure.width != width[1] ||
               event.xconfigure.height != height[1] {
                resize(event.xconfigure.width, event.xconfigure.height);
            }
        }
        15 => {
            /* VisibilityUnobscured, VisibilityPartiallyObscured, or VisibilityFullyObscured */
            visible = (event.xvisibility.state != 2) as i32;
        }
        3 => {
            match XKeycodeToKeysym(dpy, event.xkey.keycode as KeyCode, 0) {
                65507 | 65508 => { scroll = 1; }
                _ => {}
            }
        }
        2 => {
             match XKeycodeToKeysym(dpy, event.xkey.keycode as KeyCode, 0) {
    65507 | 65508 => { scroll = 10 }
    43 | 61 | 65451 => {
        if yzoom_flag == 0 { magx += 1 }
        if xzoom_flag == 0 { magy += 1 }
        yzoom_flag = 0;
        xzoom_flag = yzoom_flag;
        resize(width[1], height[1]);
        set_title = 1;
    }
    45 | 65453 => {
        if yzoom_flag == 0 { magx -= 1 }
        if xzoom_flag == 0 { magy -= 1 }
        yzoom_flag = 0;
        xzoom_flag = yzoom_flag;
        if magx < 1 { magx = 1 }
        if magy < 1 { magy = 1 }
        resize(width[1], height[1]);
        set_title = 1;
    }
    65361 | 65430 => {
        if flipxy != 0 {
            if flipx != 0 {
                ygrab += scroll;
            } else {
                ygrab -= scroll;
            }
        } else if flipx != 0 {
            xgrab += scroll;
        } else {
            xgrab -= scroll;
        }
    }
    65363 | 65432 => {
        if flipxy != 0 {
            if flipx != 0 {
                ygrab -= scroll;
            } else {
                ygrab += scroll;
            }
        } else if flipx != 0 {
            xgrab -= scroll;
        } else {
            xgrab += scroll;
        }
    }
    65362 | 65431 => {
        if flipxy != 0 {
            if flipy != 0 {
                xgrab -= scroll;
            } else {
                xgrab += scroll;
            }
        } else if flipy != 0 {
            ygrab += scroll;
        } else {
            ygrab -= scroll;
        }
    }
    65364 | 65433 => {
        if flipxy != 0 {
            if flipy != 0 {
                xgrab += scroll;
            } else {
                xgrab -= scroll;
            }
        } else if flipy != 0 {
            ygrab -= scroll;
        } else {
            ygrab += scroll;
        }
    }
    120 => {
        flipx = (flipx == 0) as i32;
        set_title = 1;
    }
    121 => {
        flipy = (flipy == 0) as i32;
        set_title = 1;
    }
    122 => {
        if flipx ^ flipy ^ flipxy != 0 {
            flipx = (flipx == 0) as i32;
            flipy = (flipy == 0) as i32;
        }
        flipxy = (flipxy == 0) as i32;
        resize(width[1], height[1]);
        set_title = 1;
    }
    119 => {
        xzoom_flag = 1;
        yzoom_flag = 0;
    }
    104 => {
        yzoom_flag = 1;
        xzoom_flag = 0;
    }
    103 => {
        gridx = (gridx == 0) as i32;
        gridy = (gridy == 0) as i32;
    }
    100 => {
        delay_index += 1;
        if delay_index >= 5 { delay_index = 0 }
        delay = delays[delay_index as usize];
        let formatted_title = format!("delay = {} ms", delay / 1000);
        let bytes = formatted_title.as_bytes();
        let len = bytes.len().min(79); // Ensure we don't exceed the array size
        for i in 0..len {
            title[i] = bytes[i] as i8; // Convert u8 to i8
        }
        title[len] = 0; // Null-terminate the string
        XChangeProperty(dpy, win, 39, 31, 8, 0, title.as_ptr() as *mut u8, title.len() as i32);
        signal(14, Some(timeout_func));
        alarm(2);
    }
    113 => { std::process::exit(0); }
    _ => {}
}


        }
        4 => {
            xgrab = event.xbutton.x_root;
            ygrab = event.xbutton.y_root;
            XDefineCursor(dpy, win, when_button);
            buttonpressed = 1;
        }
        5 => {
            /*
            xgrab = event.xbutton.x_root - width[SRC]/2;
            ygrab = event.xbutton.y_root - height[SRC]/2;
            */
            XDefineCursor(dpy, win, crosshair);
            buttonpressed = 0;
        }
        6 => {
            if buttonpressed != 0 {
                xgrab = event.xmotion.x_root;
                ygrab = event.xmotion.y_root;
            }
        }
        21 | _ => {}
    }
    /* trying XShmGetImage when part of the rect is
       not on the screen will fail LOUDLY..
       we have to verify this after anything that may
       modified xgrab or ygrab or the size of
       the source ximage */
    if xgrab < 0 { xgrab = 0; }
    if xgrab > unsafe { (*scr).width } - width[0] {
        xgrab = unsafe { (*scr).width } - width[0];
    }
    if ygrab < 0 { ygrab = 0; }
    if ygrab > unsafe { (*scr).height } - height[0] {
        ygrab = unsafe { (*scr).height } - height[0];
    }
    /*
    The variables live at this point are:
    (mut event: _XEvent, mut buttonpressed: i32, mut visible: i32, mut scroll: i32, mut title: [i8; 80])
    */

        }
        if visible != 0 { xzoom(buttonpressed); }
        if buttonpressed == 0 && delay > 0 as std::os::raw::c_int {
            usleep(delay as __useconds_t);
        }
    };
}
xzoom.rs:2561:19: 2561:61
unsafe { main_0(argc, argv.as_mut_ptr()) }
