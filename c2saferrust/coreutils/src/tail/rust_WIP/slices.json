[
  {
    "func_defid": "DefId(0:1265 ~ rust[fc84]::src::xmalloc::_gl_alloc_nomem)",
    "span": "src/xmalloc.rs:101:1: 104:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:101:1: 104:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:1485 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:65:20: 65:48 (#0)",
        "source": "unsafe { _gl_alloc_nomem() }"
      },
      {
        "caller": "DefId(0:1485 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:71:20: 71:48 (#0)",
        "source": "unsafe { _gl_alloc_nomem() }"
      },
      {
        "caller": "DefId(0:1486 ~ rust[fc84]::src::xmalloc::ireallocarray)",
        "span": "src/xmalloc.rs:94:13: 94:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:1484 ~ rust[fc84]::src::xmalloc::irealloc)",
        "span": "src/xmalloc.rs:54:9: 54:37 (#0)",
        "source": "unsafe { _gl_alloc_nomem() }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1263 ~ rust[fc84]::src::xmalloc::icalloc)",
    "span": "src/xmalloc.rs:59:1: 79:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:59:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:1505 ~ rust[fc84]::src::xmalloc::xicalloc)",
        "span": "src/xmalloc.rs:984:5: 984:32 (#0)",
        "source": "let result = icalloc(n, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:359 ~ rust[fc84]::src::hash::hash_get_n_buckets_used)",
    "span": "src/hash.rs:138:1: 142:2 (#0)",
    "pieces": [
      "src/hash.rs:138:1: 142:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn hash_get_n_buckets_used(\n    mut table: *const Hash_table,\n) -> size_t {\n    return (*table).n_buckets_used;\n}",
    "calls": [
      {
        "caller": "DefId(0:480 ~ rust[fc84]::src::hash::hash_print_statistics)",
        "span": "src/hash.rs:210:33: 210:74 (#0)",
        "source": "unsafe { hash_get_n_buckets_used(table) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1053 ~ rust[fc84]::src::quotearg::gettext_quote)",
    "span": "src/quotearg.rs:293:1: 328:2 (#0)",
    "pieces": [
      "src/quotearg.rs:293:1: 328:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "unsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1219 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:376:21: 376:72 (#0)",
        "source": "let left_quote = gettext_quote(\"`\", quoting_style);"
      },
      {
        "caller": "DefId(0:1219 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:377:21: 377:73 (#0)",
        "source": "let right_quote = gettext_quote(\"'\", quoting_style);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1054 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
    "span": "src/quotearg.rs:330:1: 1161:2 (#0)",
    "pieces": [
      "src/quotearg.rs:330:1: 341:4 (#0)",
      "src/quotearg.rs:1161:1: 1161:2 (#0)"
    ],
    "sub_chunks": [
      11
    ],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n   <<chunk 11>>}",
    "calls": [
      {
        "caller": "DefId(0:1233 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1343:9: 1353:11 (#0)",
        "source": "quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );"
      },
      {
        "caller": "DefId(0:1223 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1214:5: 1225:58 (#0)",
        "source": "let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:1219 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1102:5: 1112:7 (#0)",
        "source": "return quotearg_buffer_restyled(\n        buffer,\n        orig_buffersize,\n        arg,\n        argsize,\n        c_quoting_style,\n        flags,\n        quote_these_too,\n        left_quote,\n        right_quote,\n    );"
      },
      {
        "caller": "DefId(0:1223 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1227:5: 1237:7 (#0)",
        "source": "quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:1221 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
        "span": "src/quotearg.rs:1170:13: 1182:6 (#0)",
        "source": "unsafe {\n        quotearg_buffer_restyled(\n            buffer.as_mut_ptr(),\n            buffer.len().try_into().unwrap(),\n            arg.as_ptr(),\n            arg.len().try_into().unwrap(),\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        )\n    }"
      },
      {
        "caller": "DefId(0:1219 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1131:13: 1141:15 (#0)",
        "source": "return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );"
      },
      {
        "caller": "DefId(0:1233 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1323:5: 1333:7 (#0)",
        "source": "let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:91:1: 91:52 (#0)",
        "source": "pub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;"
      },
      {
        "span": "src/quotearg.rs:84:1: 84:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/quotearg.rs:86:1: 86:57 (#0)",
        "source": "pub const shell_always_quoting_style: quoting_style = 2;"
      },
      {
        "span": "src/quotearg.rs:83:1: 83:46 (#0)",
        "source": "pub const c_quoting_style: quoting_style = 5;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/quotearg.rs:498:9: 542:2 (#0)",
        "pieces": [
          "src/quotearg.rs:498:9: 542:2 (#0)"
        ],
        "num_lines": 64,
        "source": "if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut escaping: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut escaping: bool"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/quotearg.rs:547:9: 677:22 (#0)",
        "pieces": [
          "src/quotearg.rs:547:9: 677:22 (#0)"
        ],
        "num_lines": 131,
        "source": "match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut elide_outer_quotes: bool",
          "mut c: u8"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut elide_outer_quotes: bool",
          "mut c: u8"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/quotearg.rs:709:9: 720:2 (#0)",
        "pieces": [
          "src/quotearg.rs:709:9: 720:2 (#0)"
        ],
        "num_lines": 17,
        "source": "esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut esc: u8"
        ],
        "live_out": [
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut esc: u8"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/quotearg.rs:725:9: 732:2 (#0)",
        "pieces": [
          "src/quotearg.rs:725:9: 732:2 (#0)"
        ],
        "num_lines": 11,
        "source": "if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut current_block: u64",
          "mut c: u8",
          "arg_slice: &[u8]"
        ],
        "live_out": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut current_block: u64",
          "mut c: u8",
          "arg_slice: &[u8]",
          "arg_slice: &[i8]",
          "is_null_terminated: bool"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/quotearg.rs:755:9: 789:2 (#0)",
        "pieces": [
          "src/quotearg.rs:755:9: 789:2 (#0)"
        ],
        "num_lines": 33,
        "source": "encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut c_and_shell_quote_compat: bool"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/quotearg.rs:803:9: 872:58 (#0)",
        "pieces": [
          "src/quotearg.rs:803:9: 872:58 (#0)"
        ],
        "num_lines": 70,
        "source": "let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;",
        "sub_chunks": [],
        "live_in": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut i: u64",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut i: u64",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut c_and_shell_quote_compat: bool",
          "mut m: u64",
          "mut printable: bool"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/quotearg.rs:874:9: 943:2 (#0)",
        "pieces": [
          "src/quotearg.rs:874:9: 943:2 (#0)"
        ],
        "num_lines": 96,
        "source": "if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut m: u64",
          "mut printable: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut m: u64",
          "mut printable: bool"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/quotearg.rs:468:13: 995:2 (#0)",
        "pieces": [
          "src/quotearg.rs:468:13: 498:8 (#0)",
          "src/quotearg.rs:544:1: 547:8 (#0)",
          "src/quotearg.rs:678:1: 709:8 (#0)",
          "src/quotearg.rs:722:1: 725:8 (#0)",
          "src/quotearg.rs:734:1: 755:8 (#0)",
          "src/quotearg.rs:791:1: 803:8 (#0)",
          "src/quotearg.rs:873:1: 874:8 (#0)",
          "src/quotearg.rs:945:1: 995:2 (#0)"
        ],
        "num_lines": 154,
        "source": "let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                   <<chunk 0>>                }\n                63 => {\n                   <<chunk 1>>                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                   <<chunk 2>>                }\n                123 | 125 => {\n                   <<chunk 3>>                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                   <<chunk 4>>                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                   <<chunk 5>>                   <<chunk 6>>                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }",
        "sub_chunks": [
          0,
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut c: u8",
          "mut esc: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut c_and_shell_quote_compat: bool",
          "arg_slice: &[u8]"
        ]
      },
      {
        "chunk_id": 8,
        "span": "src/quotearg.rs:997:13: 1083:8 (#0)",
        "pieces": [
          "src/quotearg.rs:997:13: 1083:8 (#0)"
        ],
        "num_lines": 113,
        "source": "match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut quote_these_too: *const u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut all_c_and_shell_quote_compat: bool",
          "mut c: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut quote_these_too: *const u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut all_c_and_shell_quote_compat: bool"
        ]
      },
      {
        "chunk_id": 9,
        "span": "src/quotearg.rs:356:9: 1100:10 (#0)",
        "pieces": [
          "src/quotearg.rs:356:9: 468:12 (#0)",
          "src/quotearg.rs:997:1: 997:12 (#0)",
          "src/quotearg.rs:1085:1: 1100:10 (#0)"
        ],
        "num_lines": 136,
        "source": "pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n           <<chunk 7>>           <<chunk 8>>        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }",
        "sub_chunks": [
          7,
          8
        ],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut all_c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut all_c_and_shell_quote_compat: bool",
          "mut current_block_48: u64"
        ]
      },
      {
        "chunk_id": 10,
        "span": "src/quotearg.rs:1101:9: 1120:2 (#0)",
        "pieces": [
          "src/quotearg.rs:1101:9: 1120:2 (#0)"
        ],
        "num_lines": 20,
        "source": "if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut all_c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut all_c_and_shell_quote_compat: bool"
        ]
      },
      {
        "chunk_id": 11,
        "span": "src/quotearg.rs:341:5: 1160:7 (#0)",
        "pieces": [
          "src/quotearg.rs:341:5: 356:8 (#0)",
          "src/quotearg.rs:1101:1: 1101:8 (#0)",
          "src/quotearg.rs:1122:1: 1160:7 (#0)"
        ],
        "num_lines": 56,
        "source": "let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n       <<chunk 9>>       <<chunk 10>>    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };",
        "sub_chunks": [
          9,
          10
        ],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut all_c_and_shell_quote_compat: bool"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:1055 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
    "span": "src/quotearg.rs:1163:1: 1185:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1163:1: 1185:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:177:1: 183:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:102 ~ rust[fc84]::src::c_ctype::c_isdigit)",
    "span": "src/c_ctype.rs:72:1: 74:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:72:1: 74:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1266 ~ rust[fc84]::src::xmalloc::imalloc)",
    "span": "src/xmalloc.rs:106:1: 118:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:106:1: 118:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1491 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:133:5: 133:59 (#0)",
        "source": "let allocated_memory = imalloc(s.try_into().unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1267 ~ rust[fc84]::src::xmalloc::check_nonnull)",
    "span": "src/xmalloc.rs:120:1: 125:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:120:1: 125:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:1504 ~ rust[fc84]::src::xmalloc::xcalloc)",
        "span": "src/xmalloc.rs:980:5: 980:40 (#0)",
        "source": "return check_nonnull(calloc(n, s));"
      },
      {
        "caller": "DefId(0:1505 ~ rust[fc84]::src::xmalloc::xicalloc)",
        "span": "src/xmalloc.rs:985:1: 985:41 (#0)",
        "source": "let nonnull_ptr = check_nonnull(result);"
      },
      {
        "caller": "DefId(0:1490 ~ rust[fc84]::src::xmalloc::xmalloc)",
        "span": "src/xmalloc.rs:129:5: 129:37 (#0)",
        "source": "return check_nonnull(malloc(s));"
      },
      {
        "caller": "DefId(0:1496 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:195:1: 195:31 (#0)",
        "source": "let p = check_nonnull(result);"
      },
      {
        "caller": "DefId(0:1491 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:132:70: 139:2 (#0)",
        "source": "{\n    let allocated_memory = imalloc(s.try_into().unwrap());\nif allocated_memory.is_null() {\n    // handle allocation failure\n    std::alloc::handle_alloc_error(std::alloc::Layout::from_size_align(s.try_into().unwrap(), 1).unwrap());\n}\ncheck_nonnull(allocated_memory)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1269 ~ rust[fc84]::src::xmalloc::ximalloc)",
    "span": "src/xmalloc.rs:132:1: 139:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:132:1: 139:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1286 ~ rust[fc84]::src::xmalloc::ximemdup0)",
    "span": "src/xmalloc.rs:1004:1: 1010:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1004:1: 1010:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:486 ~ rust[fc84]::src::isapipe::isapipe)",
    "span": "src/isapipe.rs:49:1: 93:2 (#0)",
    "pieces": [
      "src/isapipe.rs:49:1: 93:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 81,
    "source": "pub unsafe extern \"C\" fn isapipe(mut fd: libc::c_int) -> libc::c_int {\n    let mut pipe_link_count_max: nlink_t = 1 as libc::c_int as nlink_t;\n    let mut check_for_fifo: bool = 1 as libc::c_int == 1 as libc::c_int;\n    let mut st: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut fstat_result: libc::c_int = fstat(fd, &mut st);\n    if fstat_result != 0 as libc::c_int {\n        return fstat_result;\n    }\n    if !((1 as libc::c_int == 0 as libc::c_int || 1 as libc::c_int == 1 as libc::c_int)\n        && 1 as libc::c_int as libc::c_uint != -(1 as libc::c_int) as nlink_t)\n        && (st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o10000 as libc::c_int as libc::c_uint) as libc::c_int\n            | (st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o140000 as libc::c_int as libc::c_uint) as libc::c_int != 0\n    {\n        let mut fd_pair: [libc::c_int; 2] = [0; 2];\n        let mut pipe_result: libc::c_int = pipe(fd_pair.as_mut_ptr());\n        if pipe_result != 0 as libc::c_int {\n            return pipe_result\n        } else {\n            let mut pipe_st: stat = stat {\n                st_dev: 0,\n                st_ino: 0,\n                st_mode: 0,\n                st_nlink: 0,\n                st_uid: 0,\n                st_gid: 0,\n                st_rdev: 0,\n                __pad1: 0,\n                st_size: 0,\n                st_blksize: 0,\n                __pad2: 0,\n                st_blocks: 0,\n                st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n                st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n                st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n                __glibc_reserved: [0; 2],\n            };\n            let mut fstat_pipe_result: libc::c_int = fstat(\n                fd_pair[0 as libc::c_int as usize],\n                &mut pipe_st,\n            );\n            let mut fstat_pipe_errno: libc::c_int = *__errno_location();\n            close(fd_pair[0 as libc::c_int as usize]);\n            close(fd_pair[1 as libc::c_int as usize]);\n            if fstat_pipe_result != 0 as libc::c_int {\n                *__errno_location() = fstat_pipe_errno;\n                return fstat_pipe_result;\n            }\n            check_for_fifo = (pipe_st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o10000 as libc::c_int as libc::c_uint) as libc::c_int\n                != 0 as libc::c_int;\n            pipe_link_count_max = pipe_st.st_nlink;\n        }\n    }\n    return (st.st_nlink <= pipe_link_count_max\n        && (if check_for_fifo as libc::c_int != 0 {\n            (st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o10000 as libc::c_int as libc::c_uint) as libc::c_int\n        } else {\n            (st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o140000 as libc::c_int as libc::c_uint) as libc::c_int\n        }) != 0) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/isapipe.rs:1:1: 1:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/isapipe.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:372 ~ rust[fc84]::src::hash::next_prime)",
    "span": "src/hash.rs:391:1: 400:2 (#0)",
    "pieces": [
      "src/hash.rs:391:1: 400:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn next_prime(mut candidate: size_t) -> size_t {\n    if candidate < 10 as libc::c_int as libc::c_ulong {\n        candidate = 10 as libc::c_int as size_t;\n    }\n    candidate |= 1 as libc::c_int as libc::c_ulong;\n    while 18446744073709551615 as libc::c_ulong != candidate && !is_prime(candidate) {\n        candidate = (candidate as libc::c_ulong)\n            .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t as size_t;\n    }\n    return candidate;\n}",
    "calls": [
      {
        "caller": "DefId(0:494 ~ rust[fc84]::src::hash::compute_bucket_size)",
        "span": "src/hash.rs:457:13: 457:67 (#0)",
        "source": "candidate = next_prime(candidate.try_into().unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1067 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
    "span": "src/quotearg.rs:1279:1: 1357:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1279:1: 1357:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 79,
    "source": "unsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}",
    "calls": [
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
        "span": "src/quotearg.rs:1376:5: 1376:78 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);"
      },
      {
        "caller": "DefId(0:1234 ~ rust[fc84]::src::quotearg::quotearg_n)",
        "span": "src/quotearg.rs:1363:5: 1368:7 (#0)",
        "source": "return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );"
      },
      {
        "caller": "DefId(0:1247 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1494:5: 1499:7 (#0)",
        "source": "return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );"
      },
      {
        "caller": "DefId(0:1254 ~ rust[fc84]::src::quotearg::quote_n_mem)",
        "span": "src/quotearg.rs:1584:5: 1584:76 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);"
      },
      {
        "caller": "DefId(0:1238 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1402:5: 1402:82 (#0)",
        "source": "return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);"
      },
      {
        "caller": "DefId(0:1239 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1412:5: 1412:52 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &o);"
      },
      {
        "caller": "DefId(0:1242 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1450:5: 1450:77 (#0)",
        "source": "return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);"
      },
      {
        "caller": "DefId(0:1250 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1526:5: 1526:56 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut o);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1245:1: 1245:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      },
      {
        "span": "src/quotearg.rs:1246:1: 1254:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      },
      {
        "span": "src/quotearg.rs:1255:1: 1257:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:92:1: 92:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1283 ~ rust[fc84]::src::xmalloc::xicalloc)",
    "span": "src/xmalloc.rs:983:1: 987:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:983:1: 987:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1281 ~ rust[fc84]::src::xmalloc::xizalloc)",
    "span": "src/xmalloc.rs:974:1: 976:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:974:1: 976:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:377 ~ rust[fc84]::src::hash::compute_bucket_size)",
    "span": "src/hash.rs:438:1: 479:2 (#0)",
    "pieces": [
      "src/hash.rs:438:1: 479:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 42,
    "source": "unsafe extern \"C\" fn compute_bucket_size(\n    mut candidate: size_t,\n    mut tuning: *const Hash_tuning,\n) -> size_t {\n    let mut current_block: u64;\n    if !(*tuning).is_n_buckets {\n        let mut new_candidate: libc::c_float = candidate as libc::c_float\n            / (*tuning).growth_threshold;\n        if 18446744073709551615 as libc::c_ulong as libc::c_float <= new_candidate {\n            current_block = 8933918830699217881;\n        } else {\n            candidate = new_candidate as size_t;\n            current_block = 12675440807659640239;\n        }\n    } else {\n        current_block = 12675440807659640239;\n    }\n    match current_block {\n        12675440807659640239 => {\n            candidate = next_prime(candidate);\n            if !(::core::mem::size_of::<*mut hash_entry>() as libc::c_ulong\n                != 0 as libc::c_int as libc::c_ulong\n                && (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n                    < 18446744073709551615 as libc::c_ulong\n                {\n                    9223372036854775807 as libc::c_long as libc::c_ulong\n                } else {\n                    (18446744073709551615 as libc::c_ulong)\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                })\n                    .wrapping_div(\n                        ::core::mem::size_of::<*mut hash_entry>() as libc::c_ulong,\n                    ) < candidate)\n            {\n                return candidate;\n            }\n        }\n        _ => {}\n    }\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as libc::c_int as size_t;\n}",
    "calls": [
      {
        "caller": "DefId(0:503 ~ rust[fc84]::src::hash::hash_rehash)",
        "span": "src/hash.rs:740:5: 740:80 (#0)",
        "source": "let mut new_size: size_t = compute_bucket_size(candidate, (*table).tuning);"
      },
      {
        "caller": "DefId(0:495 ~ rust[fc84]::src::hash::hash_initialize)",
        "span": "src/hash.rs:505:23: 505:98 (#0)",
        "source": "unsafe { compute_bucket_size(candidate.try_into().unwrap(), table.tuning) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:378 ~ rust[fc84]::src::hash::hash_initialize)",
    "span": "src/hash.rs:481:1: 522:2 (#0)",
    "pieces": [
      "src/hash.rs:481:1: 522:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 55,
    "source": "pub unsafe extern \"C\" fn hash_initialize(\n    mut candidate: size_t,\n    mut tuning: *const Hash_tuning,\n    mut hasher: Hash_hasher,\n    mut comparator: Hash_comparator,\n    mut data_freer: Hash_data_freer,\n) -> *mut Hash_table {\n    let mut table: *mut Hash_table = 0 as *mut Hash_table;\n    if hasher.is_none() {\n        hasher = Some(\n            raw_hasher as unsafe extern \"C\" fn(*const libc::c_void, size_t) -> size_t,\n        );\n    }\n    if comparator.is_none() {\n        comparator = Some(\n            raw_comparator\n                as unsafe extern \"C\" fn(*const libc::c_void, *const libc::c_void) -> bool,\n        );\n    }\n    table = malloc(::core::mem::size_of::<Hash_table>() as libc::c_ulong)\n        as *mut Hash_table;\n    if table.is_null() {\n        return 0 as *mut Hash_table;\n    }\n    if tuning.is_null() {\n        tuning = &default_tuning;\n    }\n    (*table).tuning = tuning;\n    if !check_tuning(table) {\n        *__errno_location() = 22 as libc::c_int;\n    } else {\n        (*table).n_buckets = compute_bucket_size(candidate, tuning);\n        if !((*table).n_buckets == 0) {\n            (*table)\n                .bucket = calloc(\n                (*table).n_buckets,\n                ::core::mem::size_of::<hash_entry>() as libc::c_ulong,\n            ) as *mut hash_entry;\n            if !((*table).bucket).is_null() {\n                (*table)\n                    .bucket_limit = ((*table).bucket)\n                    .offset((*table).n_buckets as isize);\n                (*table).n_buckets_used = 0 as libc::c_int as size_t;\n                (*table).n_entries = 0 as libc::c_int as size_t;\n                (*table).hasher = hasher;\n                (*table).comparator = comparator;\n                (*table).data_freer = data_freer;\n                (*table).free_entry_list = 0 as *mut hash_entry;\n                return table;\n            }\n        }\n    }\n    free(table as *mut libc::c_void);\n    return 0 as *mut Hash_table;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/hash.rs:122:1: 131:3 (#0)",
        "source": "static mut default_tuning: Hash_tuning = {\n    let mut init = hash_tuning {\n        shrink_threshold: 0.0f32,\n        shrink_factor: 1.0f32,\n        growth_threshold: 0.8f32,\n        growth_factor: 1.414f32,\n        is_n_buckets: 0 as libc::c_int != 0,\n    };\n    init\n};"
      }
    ],
    "imports": [
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:455 ~ rust[fc84]::src::iopoll::iopoll_input_ok)",
    "span": "src/iopoll.rs:184:1: 212:2 (#0)",
    "pieces": [
      "src/iopoll.rs:184:1: 212:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 26,
    "source": "pub unsafe extern \"C\" fn iopoll_input_ok(mut fdin: libc::c_int) -> bool {\n    let mut st: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut always_ready: bool = fstat(fdin, &mut st) == 0 as libc::c_int\n        && (st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o100000 as libc::c_int as libc::c_uint\n            || st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o60000 as libc::c_int as libc::c_uint);\n    return !always_ready;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/iopoll.rs:8:1: 8:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/iopoll.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/iopoll.rs:6:1: 6:30 (#0)",
        "source": "use std::os::unix::io::RawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:921 ~ rust[fc84]::src::nanosleep::rpl_nanosleep)",
    "span": "src/nanosleep.rs:21:1: 50:2 (#0)",
    "pieces": [
      "src/nanosleep.rs:21:1: 50:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 30,
    "source": "pub unsafe extern \"C\" fn rpl_nanosleep(\n    mut requested_delay: *const timespec,\n    mut remaining_delay: *mut timespec,\n) -> libc::c_int {\n    if (*requested_delay).tv_nsec < 0 as libc::c_int as libc::c_long\n        || BILLION as libc::c_int as libc::c_long <= (*requested_delay).tv_nsec\n    {\n        *__errno_location() = 22 as libc::c_int;\n        return -(1 as libc::c_int);\n    }\n    let limit: time_t = (24 as libc::c_int * 24 as libc::c_int * 60 as libc::c_int\n        * 60 as libc::c_int) as time_t;\n    let mut seconds: time_t = (*requested_delay).tv_sec;\n    let mut intermediate: timespec = *requested_delay;\n    while limit < seconds {\n        let mut result: libc::c_int = 0;\n        intermediate.tv_sec = limit;\n        result = nanosleep(&mut intermediate, remaining_delay);\n        seconds -= limit;\n        if result != 0 {\n            if !remaining_delay.is_null() {\n                (*remaining_delay).tv_sec += seconds;\n            }\n            return result;\n        }\n        intermediate.tv_nsec = 0 as libc::c_int as __syscall_slong_t;\n    }\n    intermediate.tv_sec = seconds;\n    return nanosleep(&mut intermediate, remaining_delay);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/nanosleep.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1069 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
    "span": "src/quotearg.rs:1371:1: 1377:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1371:1: 1377:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:1237 ~ rust[fc84]::src::quotearg::quotearg_mem)",
        "span": "src/quotearg.rs:1390:9: 1390:68 (#0)",
        "source": "result_ptr = quotearg_n_mem(0, c_string.as_ptr(), argsize);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:177:1: 183:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:98 ~ rust[fc84]::src::c_ctype::c_isalpha)",
    "span": "src/c_ctype.rs:33:1: 35:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:33:1: 35:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1050 ~ rust[fc84]::src::quotearg::set_quoting_flags)",
    "span": "src/quotearg.rs:240:1: 258:2 (#0)",
    "pieces": [
      "src/quotearg.rs:240:1: 258:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:177:1: 183:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:83 ~ rust[fc84]::src::bitrotate::rotl8)",
    "span": "src/bitrotate.rs:35:1: 38:2 (#0)",
    "pieces": [
      "src/bitrotate.rs:35:1: 38:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn rotl8(mut x: uint8_t, mut n: libc::c_int) -> uint8_t {\n    return (((x as libc::c_uint) << n | x as libc::c_uint >> 8 as libc::c_int - n)\n        & 255 as libc::c_int as libc::c_uint) as uint8_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/bitrotate.rs:8:1: 8:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/bitrotate.rs:12:1: 12:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/bitrotate.rs:10:1: 10:24 (#0)",
        "source": "use std::num::Wrapping;"
      },
      {
        "span": "src/bitrotate.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/bitrotate.rs:10:5: 10:23 (#0)",
        "source": "std::num::Wrapping"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:370 ~ rust[fc84]::src::hash::hash_string)",
    "span": "src/hash.rs:359:1: 368:2 (#0)",
    "pieces": [
      "src/hash.rs:359:1: 368:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn hash_string(\n    mut string: *const libc::c_char,\n    mut n_buckets: size_t,\n) -> size_t {\n    let mut value: size_t = 0 as libc::c_int as size_t;\n    let mut ch: libc::c_uchar = 0;\n    loop {\n        ch = *string as libc::c_uchar;\n        if !(ch != 0) {\n            break;\n        }\n        value = value\n            .wrapping_mul(31 as libc::c_int as libc::c_ulong)\n            .wrapping_add(ch as libc::c_ulong)\n            .wrapping_rem(n_buckets);\n        string = string.offset(1);\n        string;\n    }\n    return value;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:68 ~ rust[fc84]::src::binary_io::__gl_setmode)",
    "span": "src/binary_io.rs:15:1: 17:2 (#0)",
    "pieces": [
      "src/binary_io.rs:15:1: 17:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:82 ~ rust[fc84]::src::binary_io::set_binary_mode)",
        "span": "src/binary_io.rs:8:51: 10:2 (#0)",
        "source": "{\n    __gl_setmode(fd, mode)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/binary_io.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/binary_io.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:67 ~ rust[fc84]::src::binary_io::set_binary_mode)",
    "span": "src/binary_io.rs:8:1: 10:2 (#0)",
    "pieces": [
      "src/binary_io.rs:8:1: 10:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/binary_io.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/binary_io.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:105 ~ rust[fc84]::src::c_ctype::c_isprint)",
    "span": "src/c_ctype.rs:97:1: 108:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:97:1: 108:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:364 ~ rust[fc84]::src::hash::safe_hasher)",
    "span": "src/hash.rs:219:1: 229:2 (#0)",
    "pieces": [
      "src/hash.rs:219:1: 229:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn safe_hasher(\n    mut table: *const Hash_table,\n    mut key: *const libc::c_void,\n) -> *mut hash_entry {\n    let mut n: size_t = ((*table).hasher)\n        .expect(\"non-null function pointer\")(key, (*table).n_buckets);\n    if !(n < (*table).n_buckets) {\n        abort();\n    }\n    return ((*table).bucket).offset(n as isize);\n}",
    "calls": [
      {
        "caller": "DefId(0:484 ~ rust[fc84]::src::hash::hash_get_next)",
        "span": "src/hash.rs:277:5: 277:67 (#0)",
        "source": "let mut bucket: *const hash_entry = safe_hasher(table, entry);"
      },
      {
        "caller": "DefId(0:482 ~ rust[fc84]::src::hash::hash_lookup)",
        "span": "src/hash.rs:235:5: 235:67 (#0)",
        "source": "let mut bucket: *const hash_entry = safe_hasher(table, entry);"
      },
      {
        "caller": "DefId(0:501 ~ rust[fc84]::src::hash::hash_find_entry)",
        "span": "src/hash.rs:624:5: 624:65 (#0)",
        "source": "let mut bucket: *mut hash_entry = safe_hasher(table, entry);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:365 ~ rust[fc84]::src::hash::hash_lookup)",
    "span": "src/hash.rs:231:1: 252:2 (#0)",
    "pieces": [
      "src/hash.rs:231:1: 252:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 22,
    "source": "pub unsafe extern \"C\" fn hash_lookup(\n    mut table: *const Hash_table,\n    mut entry: *const libc::c_void,\n) -> *mut libc::c_void {\n    let mut bucket: *const hash_entry = safe_hasher(table, entry);\n    let mut cursor: *const hash_entry = 0 as *const hash_entry;\n    if ((*bucket).data).is_null() {\n        return 0 as *mut libc::c_void;\n    }\n    cursor = bucket;\n    while !cursor.is_null() {\n        if entry == (*cursor).data as *const libc::c_void\n            || ((*table).comparator)\n                .expect(\"non-null function pointer\")(entry, (*cursor).data)\n                as libc::c_int != 0\n        {\n            return (*cursor).data;\n        }\n        cursor = (*cursor).next;\n    }\n    return 0 as *mut libc::c_void;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1271 ~ rust[fc84]::src::xmalloc::xrealloc)",
    "span": "src/xmalloc.rs:156:1: 165:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:156:1: 165:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:1501 ~ rust[fc84]::src::xmalloc::xpalloc)",
        "span": "src/xmalloc.rs:963:5: 963:41 (#0)",
        "source": "pa = xrealloc(pa, nbytes as size_t);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1279 ~ rust[fc84]::src::xmalloc::xpalloc)",
    "span": "src/xmalloc.rs:261:1: 966:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:261:1: 268:4 (#0)",
      "src/xmalloc.rs:966:1: 966:2 (#0)"
    ],
    "sub_chunks": [
      7
    ],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n   <<chunk 7>>}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:45:1: 45:51 (#0)",
        "source": "pub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/xmalloc.rs:287:17: 366:18 (#0)",
        "pieces": [
          "src/xmalloc.rs:287:17: 366:18 (#0)"
        ],
        "num_lines": 80,
        "source": "if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/xmalloc.rs:368:17: 473:18 (#0)",
        "pieces": [
          "src/xmalloc.rs:368:17: 473:18 (#0)"
        ],
        "num_lines": 106,
        "source": "if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/xmalloc.rs:476:13: 589:14 (#0)",
        "pieces": [
          "src/xmalloc.rs:476:13: 589:14 (#0)"
        ],
        "num_lines": 114,
        "source": "if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/xmalloc.rs:643:29: 724:30 (#0)",
        "pieces": [
          "src/xmalloc.rs:643:29: 724:30 (#0)"
        ],
        "num_lines": 82,
        "source": "if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/xmalloc.rs:726:29: 832:30 (#0)",
        "pieces": [
          "src/xmalloc.rs:726:29: 832:30 (#0)"
        ],
        "num_lines": 107,
        "source": "if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/xmalloc.rs:835:25: 948:26 (#0)",
        "pieces": [
          "src/xmalloc.rs:835:25: 948:26 (#0)"
        ],
        "num_lines": 114,
        "source": "if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/xmalloc.rs:624:13: 958:24 (#0)",
        "pieces": [
          "src/xmalloc.rs:624:13: 643:28 (#0)",
          "src/xmalloc.rs:725:1: 726:28 (#0)",
          "src/xmalloc.rs:833:1: 835:24 (#0)",
          "src/xmalloc.rs:949:1: 958:24 (#0)"
        ],
        "num_lines": 35,
        "source": "let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                           <<chunk 3>>                        } else {\n                           <<chunk 4>>                        }\n                    } else {\n                       <<chunk 5>>                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0",
        "sub_chunks": [
          3,
          4,
          5
        ],
        "live_in": [
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64",
          "mut n0: i64",
          "mut n: i64",
          "mut nbytes: i64"
        ],
        "live_out": [
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64",
          "mut n0: i64",
          "mut n: i64",
          "mut nbytes: i64",
          "fresh12: i64",
          "fresh13: bool"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/xmalloc.rs:268:5: 965:15 (#0)",
        "pieces": [
          "src/xmalloc.rs:268:5: 287:16 (#0)",
          "src/xmalloc.rs:367:1: 368:16 (#0)",
          "src/xmalloc.rs:474:1: 476:12 (#0)",
          "src/xmalloc.rs:590:1: 624:12 (#0)",
          "src/xmalloc.rs:959:1: 965:15 (#0)"
        ],
        "num_lines": 67,
        "source": "let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n               <<chunk 0>>            } else {\n               <<chunk 1>>            }\n        } else {\n           <<chunk 2>>        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n           <<chunk 6>>        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;",
        "sub_chunks": [
          0,
          1,
          2,
          6
        ],
        "live_in": [
          "mut pa: *mut libc::c_void",
          "mut pn: *mut i64",
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64"
        ],
        "live_out": [
          "mut pa: *mut libc::c_void",
          "mut pn: *mut i64",
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:116 ~ rust[fc84]::src::c_strcasecmp::c_tolower)",
    "span": "src/c_strcasecmp.rs:6:1: 11:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:6:1: 11:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:153 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:15:5: 15:60 (#0)",
        "source": "let c1 = s1.chars().map(|c| c_tolower(c as i32) as u8);"
      },
      {
        "caller": "DefId(0:153 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:16:5: 16:60 (#0)",
        "source": "let c2 = s2.chars().map(|c| c_tolower(c as i32) as u8);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:407 ~ rust[fc84]::src::ialloc::_gl_alloc_nomem)",
    "span": "src/ialloc.rs:96:1: 99:2 (#0)",
    "pieces": [
      "src/ialloc.rs:96:1: 99:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:530 ~ rust[fc84]::src::ialloc::ireallocarray)",
        "span": "src/ialloc.rs:42:12: 44:6 (#0)",
        "source": "{\n        return _gl_alloc_nomem()\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:5:1: 5:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:1:1: 1:24 (#0)",
        "source": "use std::alloc::Layout;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:3:1: 3:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:403 ~ rust[fc84]::src::ialloc::ireallocarray)",
    "span": "src/ialloc.rs:25:1: 45:2 (#0)",
    "pieces": [
      "src/ialloc.rs:25:1: 45:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:1:1: 1:24 (#0)",
        "source": "use std::alloc::Layout;"
      },
      {
        "span": "src/ialloc.rs:5:1: 5:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:3:1: 3:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1052 ~ rust[fc84]::src::quotearg::quoting_options_from_style)",
    "span": "src/quotearg.rs:276:1: 291:2 (#0)",
    "pieces": [
      "src/quotearg.rs:276:1: 291:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}",
    "calls": [
      {
        "caller": "DefId(0:1247 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1492:5: 1492:45 (#0)",
        "source": "options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:1238 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1401:5: 1401:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:1239 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1411:5: 1411:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:88:1: 88:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1072 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
    "span": "src/quotearg.rs:1396:1: 1403:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1396:1: 1403:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:1240 ~ rust[fc84]::src::quotearg::quotearg_style)",
        "span": "src/quotearg.rs:1420:9: 1420:63 (#0)",
        "source": "let result_ptr = quotearg_n_style(0, s, arg.as_ptr());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1074 ~ rust[fc84]::src::quotearg::quotearg_style)",
    "span": "src/quotearg.rs:1415:1: 1423:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1415:1: 1423:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1049 ~ rust[fc84]::src::quotearg::set_char_quoting)",
    "span": "src/quotearg.rs:219:1: 237:2 (#0)",
    "pieces": [
      "src/quotearg.rs:219:1: 237:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 30,
    "source": "pub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:1247 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1493:5: 1493:64 (#0)",
        "source": "set_char_quoting(Some(&mut options), ':' as u8 as char, 1);"
      },
      {
        "caller": "DefId(0:1242 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1449:5: 1449:63 (#0)",
        "source": "set_char_quoting(Some(&mut options), ch as u8 as char, 1);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:177:1: 183:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1076 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
    "span": "src/quotearg.rs:1436:1: 1451:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1436:1: 1451:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}",
    "calls": [
      {
        "caller": "DefId(0:1244 ~ rust[fc84]::src::quotearg::quotearg_char)",
        "span": "src/quotearg.rs:1457:5: 1457:78 (#0)",
        "source": "return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);"
      },
      {
        "caller": "DefId(0:1246 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
        "span": "src/quotearg.rs:1475:41: 1475:114 (#0)",
        "source": "unsafe { quotearg_char_mem(arg.as_ptr(), argsize, ':' as i32 as c_char) }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:88:1: 88:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      },
      {
        "span": "src/quotearg.rs:177:1: 183:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1148 ~ rust[fc84]::src::stat_time::get_stat_ctime_ns)",
    "span": "src/stat_time.rs:119:1: 121:2 (#0)",
    "pieces": [
      "src/stat_time.rs:119:1: 121:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn get_stat_ctime_ns(mut st: *const stat) -> libc::c_long {\n    return (*st).st_ctim.tv_nsec;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stat_time.rs:9:1: 9:18 (#0)",
        "source": "use libc::time_t;"
      },
      {
        "span": "src/stat_time.rs:12:1: 12:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/stat_time.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stat_time.rs:7:1: 7:23 (#0)",
        "source": "use std::fs::Metadata;"
      },
      {
        "span": "src/stat_time.rs:10:1: 10:18 (#0)",
        "source": "use libc::c_long;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:183 ~ rust[fc84]::src::closeout::close_stdout_set_file_name)",
    "span": "src/closeout.rs:66:1: 71:2 (#0)",
    "pieces": [
      "src/closeout.rs:66:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:64:1: 64:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1273 ~ rust[fc84]::src::xmalloc::xreallocarray)",
    "span": "src/xmalloc.rs:183:1: 186:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:183:1: 186:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:1497 ~ rust[fc84]::src::xmalloc::xnmalloc)",
        "span": "src/xmalloc.rs:201:1: 201:49 (#0)",
        "source": "xreallocarray(&mut vec, n as usize, s as usize);"
      },
      {
        "caller": "DefId(0:1500 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
        "span": "src/xmalloc.rs:255:1: 255:49 (#0)",
        "source": "xreallocarray(&mut vec, n as usize, s as usize);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1275 ~ rust[fc84]::src::xmalloc::xnmalloc)",
    "span": "src/xmalloc.rs:199:1: 203:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:199:1: 203:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [
      {
        "caller": "DefId(0:1492 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:149:13: 149:112 (#0)",
        "source": "let ptr = xnmalloc(n.try_into().unwrap(), std::mem::size_of::<libc::c_char>().try_into().unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:207 ~ rust[fc84]::src::dtotimespec::make_timespec)",
    "span": "src/dtotimespec.rs:14:1: 19:2 (#0)",
    "pieces": [
      "src/dtotimespec.rs:14:1: 19:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn make_timespec(mut s: time_t, mut ns: libc::c_long) -> timespec {\n    return {\n        let mut init = timespec { tv_sec: s, tv_nsec: ns };\n        init\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:271 ~ rust[fc84]::src::dtotimespec::dtotimespec)",
        "span": "src/dtotimespec.rs:32:5: 46:6 (#0)",
        "source": "{\n        return make_timespec(\n            !if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n                -(1 as libc::c_int) as time_t\n            } else {\n                (((1 as libc::c_int as time_t)\n                    << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            },\n            0 as libc::c_int as libc::c_long,\n        )\n    }"
      },
      {
        "caller": "DefId(0:271 ~ rust[fc84]::src::dtotimespec::dtotimespec)",
        "span": "src/dtotimespec.rs:58:5: 72:6 (#0)",
        "source": "{\n        return make_timespec(\n            if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n                -(1 as libc::c_int) as time_t\n            } else {\n                (((1 as libc::c_int as time_t)\n                    << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            },\n            (TIMESPEC_HZ as libc::c_int - 1 as libc::c_int) as libc::c_long,\n        )\n    }"
      },
      {
        "caller": "DefId(0:271 ~ rust[fc84]::src::dtotimespec::dtotimespec)",
        "span": "src/dtotimespec.rs:85:9: 85:37 (#0)",
        "source": "return make_timespec(s, ns);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/dtotimespec.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:460 ~ rust[fc84]::src::iopoll::fwrite_wait)",
    "span": "src/iopoll.rs:246:1: 293:2 (#0)",
    "pieces": [
      "src/iopoll.rs:246:1: 293:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "pub unsafe extern \"C\" fn fwrite_wait(\n    mut buf: *const libc::c_char,\n    mut size: ssize_t,\n    mut f: *mut FILE,\n) -> bool {\n    loop {\n        let written: size_t = fwrite_unlocked(\n            buf as *const libc::c_void,\n            1 as libc::c_int as size_t,\n            size as size_t,\n            f,\n        );\n        size = (size as libc::c_ulong).wrapping_sub(written) as ssize_t as ssize_t;\n        if size >= 0 as libc::c_int as libc::c_long {} else {\n            __assert_fail(\n                b\"size >= 0\\0\" as *const u8 as *const libc::c_char,\n                b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n                230 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 49],\n                    &[libc::c_char; 49],\n                >(b\"_Bool fwrite_wait(const char *, ssize_t, FILE *)\\0\"))\n                    .as_ptr(),\n            );\n        }\n        'c_7276: {\n            if size >= 0 as libc::c_int as libc::c_long {} else {\n                __assert_fail(\n                    b\"size >= 0\\0\" as *const u8 as *const libc::c_char,\n                    b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n                    230 as libc::c_int as libc::c_uint,\n                    (*::core::mem::transmute::<\n                        &[u8; 49],\n                        &[libc::c_char; 49],\n                    >(b\"_Bool fwrite_wait(const char *, ssize_t, FILE *)\\0\"))\n                        .as_ptr(),\n                );\n            }\n        };\n        if size <= 0 as libc::c_int as libc::c_long {\n            return 1 as libc::c_int != 0;\n        }\n        if !fwait_for_nonblocking_write(f) {\n            return 0 as libc::c_int != 0;\n        }\n        buf = buf.offset(written as isize);\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/iopoll.rs:6:1: 6:30 (#0)",
        "source": "use std::os::unix::io::RawFd;"
      },
      {
        "span": "src/iopoll.rs:8:1: 8:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/iopoll.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1081 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
    "span": "src/quotearg.rs:1480:1: 1500:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1480:1: 1500:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:88:1: 88:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1142 ~ rust[fc84]::src::stat_time::get_stat_birthtime)",
    "span": "src/stat_time.rs:62:1: 67:2 (#0)",
    "pieces": [
      "src/stat_time.rs:62:1: 67:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn get_stat_birthtime(mut _st: *const stat) -> timespec {\n    let mut t: timespec = timespec { tv_sec: 0, tv_nsec: 0 };\n    t = {\n        let mut init = timespec {\n            tv_sec: -(1 as libc::c_int) as __time_t,\n            tv_nsec: -(1 as libc::c_int) as __syscall_slong_t,\n        };\n        init\n    };\n    return t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stat_time.rs:10:1: 10:18 (#0)",
        "source": "use libc::c_long;"
      },
      {
        "span": "src/stat_time.rs:9:1: 9:18 (#0)",
        "source": "use libc::time_t;"
      },
      {
        "span": "src/stat_time.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stat_time.rs:12:1: 12:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/stat_time.rs:7:1: 7:23 (#0)",
        "source": "use std::fs::Metadata;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1159 ~ rust[fc84]::src::timespec::timespec_sign)",
    "span": "src/timespec.rs:48:1: 60:2 (#0)",
    "pieces": [
      "src/timespec.rs:48:1: 60:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn timespec_sign(mut a: timespec) -> libc::c_int {\n    return (a.tv_sec > 0 as libc::c_int as libc::c_long) as libc::c_int\n        - (a.tv_sec < 0 as libc::c_int as libc::c_long) as libc::c_int\n        + ((a.tv_sec == 0) as libc::c_int & (a.tv_nsec != 0) as libc::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/timespec.rs:6:1: 6:15 (#0)",
        "source": "use std::time;"
      },
      {
        "span": "src/timespec.rs:8:1: 8:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/timespec.rs:3:1: 3:25 (#0)",
        "source": "use std::time::Duration;"
      },
      {
        "span": "src/timespec.rs:4:1: 4:27 (#0)",
        "source": "use std::time::SystemTime;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1282 ~ rust[fc84]::src::xmalloc::xcalloc)",
    "span": "src/xmalloc.rs:979:1: 981:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:979:1: 981:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1280 ~ rust[fc84]::src::xmalloc::xzalloc)",
    "span": "src/xmalloc.rs:968:1: 971:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:968:1: 971:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1141 ~ rust[fc84]::src::stat_time::stat_time_normalize)",
    "span": "src/stat_time.rs:55:1: 57:2 (#0)",
    "pieces": [
      "src/stat_time.rs:55:1: 57:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn stat_time_normalize(\n    mut result: libc::c_int,\n    mut _st: *mut stat,\n) -> libc::c_int {\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stat_time.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stat_time.rs:9:1: 9:18 (#0)",
        "source": "use libc::time_t;"
      },
      {
        "span": "src/stat_time.rs:7:1: 7:23 (#0)",
        "source": "use std::fs::Metadata;"
      },
      {
        "span": "src/stat_time.rs:10:1: 10:18 (#0)",
        "source": "use libc::c_long;"
      },
      {
        "span": "src/stat_time.rs:12:1: 12:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1088 ~ rust[fc84]::src::quotearg::quote_n_mem)",
    "span": "src/quotearg.rs:1579:1: 1585:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1579:1: 1585:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:1256 ~ rust[fc84]::src::quotearg::quote_n)",
        "span": "src/quotearg.rs:1598:5: 1598:71 (#0)",
        "source": "return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:1255 ~ rust[fc84]::src::quotearg::quote_mem)",
        "span": "src/quotearg.rs:1589:18: 1589:86 (#0)",
        "source": "unsafe { quote_n_mem(0, arg.as_ptr(), argsize.try_into().unwrap()) }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1568:1: 1577:3 (#0)",
        "source": "pub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1090 ~ rust[fc84]::src::quotearg::quote_n)",
    "span": "src/quotearg.rs:1594:1: 1599:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1594:1: 1599:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:1257 ~ rust[fc84]::src::quotearg::quote)",
        "span": "src/quotearg.rs:1602:5: 1602:40 (#0)",
        "source": "unsafe { quote_n(0, arg.as_ptr()) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:458 ~ rust[fc84]::src::iopoll::fwait_for_nonblocking_write)",
    "span": "src/iopoll.rs:219:1: 234:2 (#0)",
    "pieces": [
      "src/iopoll.rs:219:1: 234:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 22,
    "source": "unsafe extern \"C\" fn fwait_for_nonblocking_write(mut f: *mut FILE) -> bool {\n    if !(*__errno_location() == 11 as libc::c_int\n        || *__errno_location() == 11 as libc::c_int)\n    {\n        return 0 as libc::c_int != 0;\n    }\n    let mut fd: libc::c_int = fileno(f);\n    if !(fd == -(1 as libc::c_int)) {\n        if !(iopoll_internal(\n            -(1 as libc::c_int),\n            fd,\n            1 as libc::c_int != 0,\n            0 as libc::c_int != 0,\n        ) != 0 as libc::c_int)\n        {\n            clearerr_unlocked(f);\n            return 1 as libc::c_int != 0;\n        }\n    }\n    *__errno_location() = 11 as libc::c_int;\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/iopoll.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/iopoll.rs:6:1: 6:30 (#0)",
        "source": "use std::os::unix::io::RawFd;"
      },
      {
        "span": "src/iopoll.rs:8:1: 8:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:185 ~ rust[fc84]::src::closeout::close_stdout_set_ignore_EPIPE)",
    "span": "src/closeout.rs:75:1: 79:2 (#0)",
    "pieces": [
      "src/closeout.rs:75:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:73:1: 73:39 (#0)",
        "source": "static mut ignore_EPIPE: bool = false;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:362 ~ rust[fc84]::src::hash::hash_table_ok)",
    "span": "src/hash.rs:174:1: 202:2 (#0)",
    "pieces": [
      "src/hash.rs:174:1: 202:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 29,
    "source": "pub unsafe extern \"C\" fn hash_table_ok(mut table: *const Hash_table) -> bool {\n    let mut bucket: *const hash_entry = 0 as *const hash_entry;\n    let mut n_buckets_used: size_t = 0 as libc::c_int as size_t;\n    let mut n_entries: size_t = 0 as libc::c_int as size_t;\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit {\n        if !((*bucket).data).is_null() {\n            let mut cursor: *const hash_entry = bucket;\n            n_buckets_used = n_buckets_used.wrapping_add(1);\n            n_buckets_used;\n            n_entries = n_entries.wrapping_add(1);\n            n_entries;\n            loop {\n                cursor = (*cursor).next;\n                if cursor.is_null() {\n                    break;\n                }\n                n_entries = n_entries.wrapping_add(1);\n                n_entries;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    if n_buckets_used == (*table).n_buckets_used && n_entries == (*table).n_entries {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1113 ~ rust[fc84]::src::setlocale_null::setlocale_null_r)",
    "span": "src/setlocale_null.rs:16:1: 24:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:16:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null.rs:3:1: 3:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/setlocale_null.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1190 ~ rust[fc84]::src::version_etc::version_etc_arn)",
    "span": "src/version_etc.rs:69:1: 247:2 (#0)",
    "pieces": [
      "src/version_etc.rs:69:1: 77:4 (#0)",
      "src/version_etc.rs:109:1: 109:4 (#0)",
      "src/version_etc.rs:247:1: 247:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:1395 ~ rust[fc84]::src::version_etc::version_etc_va)",
        "span": "src/version_etc.rs:284:5: 291:7 (#0)",
        "source": "version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );"
      },
      {
        "caller": "DefId(0:1394 ~ rust[fc84]::src::version_etc::version_etc_ar)",
        "span": "src/version_etc.rs:262:5: 262:81 (#0)",
        "source": "version_etc_arn(stream, command_name, package, version, authors, n_authors);"
      }
    ],
    "globals": [
      {
        "span": "src/version_etc.rs:66:1: 66:48 (#0)",
        "source": "pub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;"
      }
    ],
    "imports": [
      {
        "span": "src/version_etc.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:3:1: 3:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/version_etc.rs:77:5: 108:73 (#0)",
        "pieces": [
          "src/version_etc.rs:77:5: 108:73 (#0)"
        ],
        "num_lines": 32,
        "source": "if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);",
        "sub_chunks": [],
        "live_in": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut command_name: *const i8",
          "mut package: *const i8",
          "mut version: *const i8"
        ],
        "live_out": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut command_name: *const i8",
          "mut package: *const i8",
          "mut version: *const i8"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/version_etc.rs:109:5: 245:3 (#0)",
        "pieces": [
          "src/version_etc.rs:109:5: 245:3 (#0)"
        ],
        "num_lines": 142,
        "source": "match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };",
        "sub_chunks": [],
        "live_in": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut authors: *const *const i8",
          "mut n_authors: u64"
        ],
        "live_out": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut authors: *const *const i8",
          "mut n_authors: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:1191 ~ rust[fc84]::src::version_etc::version_etc_ar)",
    "span": "src/version_etc.rs:249:1: 263:2 (#0)",
    "pieces": [
      "src/version_etc.rs:249:1: 263:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:3:1: 3:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/version_etc.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:89 ~ rust[fc84]::src::bitrotate::rotl32)",
    "span": "src/bitrotate.rs:84:1: 87:2 (#0)",
    "pieces": [
      "src/bitrotate.rs:84:1: 87:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn rotl32(mut x: uint32_t, mut n: libc::c_int) -> uint32_t {\n    return (x << n | x >> 32 as libc::c_int - n) & 4294967295 as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/bitrotate.rs:10:1: 10:24 (#0)",
        "source": "use std::num::Wrapping;"
      },
      {
        "span": "src/bitrotate.rs:12:1: 12:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/bitrotate.rs:8:1: 8:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/bitrotate.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/bitrotate.rs:10:5: 10:23 (#0)",
        "source": "std::num::Wrapping"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:99 ~ rust[fc84]::src::c_ctype::c_isascii)",
    "span": "src/c_ctype.rs:40:1: 53:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:40:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:361 ~ rust[fc84]::src::hash::hash_get_max_bucket_length)",
    "span": "src/hash.rs:149:1: 171:2 (#0)",
    "pieces": [
      "src/hash.rs:149:1: 171:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn hash_get_max_bucket_length(\n    mut table: *const Hash_table,\n) -> size_t {\n    let mut bucket: *const hash_entry = 0 as *const hash_entry;\n    let mut max_bucket_length: size_t = 0 as libc::c_int as size_t;\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit {\n        if !((*bucket).data).is_null() {\n            let mut cursor: *const hash_entry = bucket;\n            let mut bucket_length: size_t = 1 as libc::c_int as size_t;\n            loop {\n                cursor = (*cursor).next;\n                if cursor.is_null() {\n                    break;\n                }\n                bucket_length = bucket_length.wrapping_add(1);\n                bucket_length;\n            }\n            if bucket_length > max_bucket_length {\n                max_bucket_length = bucket_length;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    return max_bucket_length;\n}",
    "calls": [
      {
        "caller": "DefId(0:480 ~ rust[fc84]::src::hash::hash_print_statistics)",
        "span": "src/hash.rs:211:36: 211:80 (#0)",
        "source": "unsafe { hash_get_max_bucket_length(table) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:369 ~ rust[fc84]::src::hash::hash_do_for_each)",
    "span": "src/hash.rs:330:1: 357:2 (#0)",
    "pieces": [
      "src/hash.rs:330:1: 357:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "pub unsafe extern \"C\" fn hash_do_for_each(\n    mut table: *const Hash_table,\n    mut processor: Hash_processor,\n    mut processor_data: *mut libc::c_void,\n) -> size_t {\n    let mut counter: size_t = 0 as libc::c_int as size_t;\n    let mut bucket: *const hash_entry = 0 as *const hash_entry;\n    let mut cursor: *const hash_entry = 0 as *const hash_entry;\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit {\n        if !((*bucket).data).is_null() {\n            cursor = bucket;\n            while !cursor.is_null() {\n                if !processor\n                    .expect(\"non-null function pointer\")((*cursor).data, processor_data)\n                {\n                    return counter;\n                }\n                counter = counter.wrapping_add(1);\n                counter;\n                cursor = (*cursor).next;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    return counter;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1241 ~ rust[fc84]::src::xdectoumax::xnumtoumax)",
    "span": "src/xdectoumax.rs:49:1: 92:2 (#0)",
    "pieces": [
      "src/xdectoumax.rs:49:1: 92:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 96,
    "source": "pub unsafe extern \"C\" fn xnumtoumax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: uintmax_t = 0;\n    s_err = xstrtoumax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_ulong {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}",
    "calls": [
      {
        "caller": "DefId(0:1449 ~ rust[fc84]::src::xdectoumax::xdectoumax)",
        "span": "src/xdectoumax.rs:37:5: 45:3 (#0)",
        "source": "let result = xnumtoumax(\n    std::ffi::CStr::from_ptr(n_str).to_str().unwrap(),\n    10,\n    min,\n    max,\n    if suffixes.is_null() { None } else { Some(std::ffi::CStr::from_ptr(suffixes).to_str().unwrap()) },\n    std::ffi::CStr::from_ptr(err).to_str().unwrap(),\n    err_exit,\n);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xdectoumax.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1262 ~ rust[fc84]::src::xmalloc::irealloc)",
    "span": "src/xmalloc.rs:48:1: 56:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:48:1: 56:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1268 ~ rust[fc84]::src::xmalloc::xmalloc)",
    "span": "src/xmalloc.rs:128:1: 130:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:128:1: 130:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}",
    "calls": [
      {
        "caller": "DefId(0:1492 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:144:13: 144:54 (#0)",
        "source": "let ptr = xmalloc(n.try_into().unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1270 ~ rust[fc84]::src::xmalloc::xcharalloc)",
    "span": "src/xmalloc.rs:141:1: 153:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:141:1: 153:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1284 ~ rust[fc84]::src::xmalloc::xmemdup)",
    "span": "src/xmalloc.rs:989:1: 993:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:989:1: 993:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1048 ~ rust[fc84]::src::quotearg::set_quoting_style)",
    "span": "src/quotearg.rs:204:1: 216:2 (#0)",
    "pieces": [
      "src/quotearg.rs:204:1: 216:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:177:1: 183:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1287 ~ rust[fc84]::src::xmalloc::xstrdup)",
    "span": "src/xmalloc.rs:1013:1: 1015:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1013:1: 1015:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1065 ~ rust[fc84]::src::quotearg::quotearg_free)",
    "span": "src/quotearg.rs:1259:1: 1278:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1259:1: 1278:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:1255:1: 1257:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1244:1: 1244:50 (#0)",
        "source": "static mut slot0: [libc::c_char; 256] = [0; 256];"
      },
      {
        "span": "src/quotearg.rs:1246:1: 1254:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      },
      {
        "span": "src/quotearg.rs:1245:1: 1245:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:86 ~ rust[fc84]::src::bitrotate::rotr_sz)",
    "span": "src/bitrotate.rs:59:1: 63:2 (#0)",
    "pieces": [
      "src/bitrotate.rs:59:1: 63:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn rotr_sz(mut x: size_t, mut n: libc::c_int) -> size_t {\n    return (x >> n\n        | x\n            << (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<size_t>() as libc::c_ulong)\n                .wrapping_sub(n as libc::c_ulong))\n        & 18446744073709551615 as libc::c_ulong;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/bitrotate.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/bitrotate.rs:8:1: 8:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/bitrotate.rs:12:1: 12:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/bitrotate.rs:10:1: 10:24 (#0)",
        "source": "use std::num::Wrapping;"
      },
      {
        "span": "src/bitrotate.rs:10:5: 10:23 (#0)",
        "source": "std::num::Wrapping"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:82 ~ rust[fc84]::src::bitrotate::rotr8)",
    "span": "src/bitrotate.rs:27:1: 30:2 (#0)",
    "pieces": [
      "src/bitrotate.rs:27:1: 30:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn rotr8(mut x: uint8_t, mut n: libc::c_int) -> uint8_t {\n    return ((x as libc::c_uint >> n | (x as libc::c_uint) << 8 as libc::c_int - n)\n        & 255 as libc::c_int as libc::c_uint) as uint8_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/bitrotate.rs:8:1: 8:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/bitrotate.rs:10:1: 10:24 (#0)",
        "source": "use std::num::Wrapping;"
      },
      {
        "span": "src/bitrotate.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/bitrotate.rs:12:1: 12:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/bitrotate.rs:10:5: 10:23 (#0)",
        "source": "std::num::Wrapping"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:444 ~ rust[fc84]::src::iopoll::iopoll_internal)",
    "span": "src/iopoll.rs:118:1: 172:2 (#0)",
    "pieces": [
      "src/iopoll.rs:118:1: 172:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 114,
    "source": "unsafe extern \"C\" fn iopoll_internal(\n    mut fdin: libc::c_int,\n    mut fdout: libc::c_int,\n    mut block: bool,\n    mut broken_output: bool,\n) -> libc::c_int {\n    if fdin != -(1 as libc::c_int) || fdout != -(1 as libc::c_int) {} else {\n        __assert_fail(\n            b\"fdin != -1 || fdout != -1\\0\" as *const u8 as *const libc::c_char,\n            b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n            63 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 44],\n                &[libc::c_char; 44],\n            >(b\"int iopoll_internal(int, int, _Bool, _Bool)\\0\"))\n                .as_ptr(),\n        );\n    }\n    'c_6989: {\n        if fdin != -(1 as libc::c_int) || fdout != -(1 as libc::c_int) {} else {\n            __assert_fail(\n                b\"fdin != -1 || fdout != -1\\0\" as *const u8 as *const libc::c_char,\n                b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n                63 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 44],\n                    &[libc::c_char; 44],\n                >(b\"int iopoll_internal(int, int, _Bool, _Bool)\\0\"))\n                    .as_ptr(),\n            );\n        }\n    };\n    let mut pfds: [pollfd; 2] = [\n        {\n            let mut init = pollfd {\n                fd: fdin,\n                events: (0x1 as libc::c_int | 0x80 as libc::c_int) as libc::c_short,\n                revents: 0 as libc::c_int as libc::c_short,\n            };\n            init\n        },\n        {\n            let mut init = pollfd {\n                fd: fdout,\n                events: 0x80 as libc::c_int as libc::c_short,\n                revents: 0 as libc::c_int as libc::c_short,\n            };\n            init\n        },\n    ];\n    let mut check_out_events: libc::c_int = 0x8 as libc::c_int | 0x10 as libc::c_int\n        | 0x20 as libc::c_int;\n    let mut ret: libc::c_int = 0 as libc::c_int;\n    if !broken_output {\n        pfds[1 as libc::c_int as usize].events = 0x4 as libc::c_int as libc::c_short;\n        pfds[0 as libc::c_int as usize].events = pfds[1 as libc::c_int as usize].events;\n        check_out_events = 0x4 as libc::c_int;\n    }\n    while 0 as libc::c_int <= ret || *__errno_location() == 4 as libc::c_int {\n        ret = poll(\n            pfds.as_mut_ptr(),\n            2 as libc::c_int as nfds_t,\n            if block as libc::c_int != 0 {\n                -(1 as libc::c_int)\n            } else {\n                0 as libc::c_int\n            },\n        );\n        if ret < 0 as libc::c_int {\n            continue;\n        }\n        if ret == 0 as libc::c_int && !block {\n            return 0 as libc::c_int;\n        }\n        if (0 as libc::c_int) < ret {} else {\n            __assert_fail(\n                b\"0 < ret\\0\" as *const u8 as *const libc::c_char,\n                b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n                87 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 44],\n                    &[libc::c_char; 44],\n                >(b\"int iopoll_internal(int, int, _Bool, _Bool)\\0\"))\n                    .as_ptr(),\n            );\n        }\n        'c_6877: {\n            if (0 as libc::c_int) < ret {} else {\n                __assert_fail(\n                    b\"0 < ret\\0\" as *const u8 as *const libc::c_char,\n                    b\"iopoll.c\\0\" as *const u8 as *const libc::c_char,\n                    87 as libc::c_int as libc::c_uint,\n                    (*::core::mem::transmute::<\n                        &[u8; 44],\n                        &[libc::c_char; 44],\n                    >(b\"int iopoll_internal(int, int, _Bool, _Bool)\\0\"))\n                        .as_ptr(),\n                );\n            }\n        };\n        if pfds[0 as libc::c_int as usize].revents != 0 {\n            return 0 as libc::c_int;\n        }\n        if pfds[1 as libc::c_int as usize].revents as libc::c_int & check_out_events != 0\n        {\n            return if broken_output as libc::c_int != 0 {\n                -(2 as libc::c_int)\n            } else {\n                0 as libc::c_int\n            };\n        }\n    }\n    return -(3 as libc::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:580 ~ rust[fc84]::src::iopoll::iopoll)",
        "span": "src/iopoll.rs:179:10: 181:2 (#0)",
        "source": "{\n    iopoll_internal(fdin, fdout, block, true)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/iopoll.rs:8:1: 8:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/iopoll.rs:6:1: 6:30 (#0)",
        "source": "use std::os::unix::io::RawFd;"
      },
      {
        "span": "src/iopoll.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:948 ~ rust[fc84]::src::posixver::posix2_version)",
    "span": "src/posixver.rs:13:1: 27:2 (#0)",
    "pieces": [
      "src/posixver.rs:13:1: 27:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn posix2_version() -> libc::c_int {\n    let mut v: libc::c_long = 200809 as libc::c_long;\n    let mut s: *const libc::c_char = getenv(\n        b\"_POSIX2_VERSION\\0\" as *const u8 as *const libc::c_char,\n    );\n    if !s.is_null() && *s as libc::c_int != 0 {\n        let mut e: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut i: libc::c_long = strtol(s, &mut e, 10 as libc::c_int);\n        if *e == 0 {\n            v = i;\n        }\n    }\n    return (if v < (-(2147483647 as libc::c_int) - 1 as libc::c_int) as libc::c_long {\n        (-(2147483647 as libc::c_int) - 1 as libc::c_int) as libc::c_long\n    } else if v < 2147483647 as libc::c_int as libc::c_long {\n        v\n    } else {\n        2147483647 as libc::c_int as libc::c_long\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/posixver.rs:1:1: 1:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "src/posixver.rs:1:5: 1:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "src/posixver.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1078 ~ rust[fc84]::src::quotearg::quotearg_char)",
    "span": "src/quotearg.rs:1453:1: 1458:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1453:1: 1458:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}",
    "calls": [
      {
        "caller": "DefId(0:1245 ~ rust[fc84]::src::quotearg::quotearg_colon)",
        "span": "src/quotearg.rs:1465:9: 1465:63 (#0)",
        "source": "let result_ptr = quotearg_char(c_string.as_ptr(), ch);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1079 ~ rust[fc84]::src::quotearg::quotearg_colon)",
    "span": "src/quotearg.rs:1460:1: 1470:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1460:1: 1470:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:88 ~ rust[fc84]::src::bitrotate::rotr32)",
    "span": "src/bitrotate.rs:76:1: 79:2 (#0)",
    "pieces": [
      "src/bitrotate.rs:76:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn rotr32(mut x: uint32_t, mut n: libc::c_int) -> uint32_t {\n    return (x >> n | x << 32 as libc::c_int - n) & 4294967295 as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/bitrotate.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/bitrotate.rs:10:5: 10:23 (#0)",
        "source": "std::num::Wrapping"
      },
      {
        "span": "src/bitrotate.rs:12:1: 12:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/bitrotate.rs:10:1: 10:24 (#0)",
        "source": "use std::num::Wrapping;"
      },
      {
        "span": "src/bitrotate.rs:8:1: 8:16 (#0)",
        "source": "use std::usize;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:255 ~ rust[fc84]::src::fcntl::run_static_initializers)",
    "span": "src/fcntl.rs:104:1: 110:2 (#0)",
    "pieces": [
      "src/fcntl.rs:104:1: 110:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn run_static_initializers() {\n    have_dupfd_cloexec = if 0 as libc::c_int != 0 {\n        -(1 as libc::c_int)\n    } else {\n        0 as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/fcntl.rs:71:1: 71:48 (#0)",
        "source": "static mut have_dupfd_cloexec: libc::c_int = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/fcntl.rs:4:1: 4:22 (#0)",
        "source": "use std::ffi::VaList;"
      },
      {
        "span": "src/fcntl.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:49 ~ rust[fc84]::src::argmatch::argmatch_exact)",
    "span": "src/argmatch.rs:142:1: 152:2 (#0)",
    "pieces": [
      "src/argmatch.rs:142:1: 152:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn argmatch_exact(\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n) -> ptrdiff_t {\n    let mut i: size_t = 0;\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if strcmp(*arglist.offset(i as isize), arg) == 0 {\n            return i as ptrdiff_t;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return -(1 as libc::c_int) as ptrdiff_t;\n}",
    "calls": [
      {
        "caller": "DefId(0:61 ~ rust[fc84]::src::argmatch::__xargmatch_internal)",
        "span": "src/argmatch.rs:265:1: 265:52 (#0)",
        "source": "let res = argmatch_exact(arg_cstr, &arglist_slice);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/argmatch.rs:4:1: 4:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/argmatch.rs:3:1: 3:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/argmatch.rs:5:1: 5:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:53 ~ rust[fc84]::src::argmatch::argmatch_to_argument)",
    "span": "src/argmatch.rs:279:1: 301:2 (#0)",
    "pieces": [
      "src/argmatch.rs:279:1: 301:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn argmatch_to_argument(\n    mut value: *const libc::c_void,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) -> *const libc::c_char {\n    let mut i: size_t = 0;\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if memcmp(\n            value,\n            (vallist as *const libc::c_char).offset(valsize.wrapping_mul(i) as isize)\n                as *const libc::c_void,\n            valsize,\n        ) == 0\n        {\n            return *arglist.offset(i as isize);\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as *const libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/argmatch.rs:4:1: 4:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/argmatch.rs:3:1: 3:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/argmatch.rs:5:1: 5:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:97 ~ rust[fc84]::src::c_ctype::c_isalnum)",
    "span": "src/c_ctype.rs:23:1: 28:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:23:1: 28:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:457 ~ rust[fc84]::src::iopoll::iopoll_output_ok)",
    "span": "src/iopoll.rs:215:1: 217:2 (#0)",
    "pieces": [
      "src/iopoll.rs:215:1: 217:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn iopoll_output_ok(mut fdout: libc::c_int) -> bool {\n    return isapipe(fdout) > 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/iopoll.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/iopoll.rs:6:1: 6:30 (#0)",
        "source": "use std::os::unix::io::RawFd;"
      },
      {
        "span": "src/iopoll.rs:8:1: 8:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:196 ~ rust[fc84]::src::dirname_lgpl::dir_len)",
    "span": "src/dirname_lgpl.rs:15:1: 53:2 (#0)",
    "pieces": [
      "src/dirname_lgpl.rs:15:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 39,
    "source": "pub unsafe extern \"C\" fn dir_len(mut file: *const libc::c_char) -> size_t {\n    let mut prefix_length: size_t = 0 as libc::c_int as size_t;\n    let mut length: size_t = 0;\n    prefix_length = (prefix_length as libc::c_ulong)\n        .wrapping_add(\n            (if prefix_length != 0 as libc::c_int as libc::c_ulong {\n                (0 as libc::c_int != 0\n                    && *file.offset(prefix_length as isize) as libc::c_int == '/' as i32)\n                    as libc::c_int\n            } else if *file.offset(0 as libc::c_int as isize) as libc::c_int\n                == '/' as i32\n            {\n                if 0 as libc::c_int != 0\n                    && *file.offset(1 as libc::c_int as isize) as libc::c_int\n                        == '/' as i32\n                    && !(*file.offset(2 as libc::c_int as isize) as libc::c_int\n                        == '/' as i32)\n                {\n                    2 as libc::c_int\n                } else {\n                    1 as libc::c_int\n                }\n            } else {\n                0 as libc::c_int\n            }) as libc::c_ulong,\n        ) as size_t as size_t;\n    length = (last_component(file)).offset_from(file) as libc::c_long as size_t;\n    while prefix_length < length {\n        if !(*file\n            .offset(length.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_int == '/' as i32)\n        {\n            break;\n        }\n        length = length.wrapping_sub(1);\n        length;\n    }\n    return length;\n}",
    "calls": [
      {
        "caller": "DefId(0:260 ~ rust[fc84]::src::dirname_lgpl::mdir_name)",
        "span": "src/dirname_lgpl.rs:57:9: 57:45 (#0)",
        "source": "let length = dir_len(file) as usize;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/dirname_lgpl.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/dirname_lgpl.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:318 ~ rust[fc84]::src::fseeko::rpl_fseeko)",
    "span": "src/fseeko.rs:52:1: 74:2 (#0)",
    "pieces": [
      "src/fseeko.rs:52:1: 74:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fseeko.rs:1:1: 1:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/fseeko.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:908 ~ rust[fc84]::src::mbszero::mbszero)",
    "span": "src/mbszero.rs:25:1: 31:2 (#0)",
    "pieces": [
      "src/mbszero.rs:25:1: 31:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/mbszero.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:46 ~ rust[fc84]::src::argmatch::__argmatch_die)",
    "span": "src/argmatch.rs:96:1: 98:2 (#0)",
    "pieces": [
      "src/argmatch.rs:96:1: 98:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn __argmatch_die() {\n    usage(1 as libc::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/argmatch.rs:5:1: 5:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/argmatch.rs:3:1: 3:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/argmatch.rs:4:1: 4:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:51 ~ rust[fc84]::src::argmatch::argmatch_valid)",
    "span": "src/argmatch.rs:186:1: 225:2 (#0)",
    "pieces": [
      "src/argmatch.rs:186:1: 225:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 40,
    "source": "pub unsafe extern \"C\" fn argmatch_valid(\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) {\n    let mut i: size_t = 0;\n    let mut last_val: *const libc::c_char = 0 as *const libc::c_char;\n    fputs_unlocked(\n        gettext(b\"Valid arguments are:\\0\" as *const u8 as *const libc::c_char),\n        stderr,\n    );\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if i == 0 as libc::c_int as libc::c_ulong\n            || memcmp(\n                last_val as *const libc::c_void,\n                (vallist as *const libc::c_char).offset(valsize.wrapping_mul(i) as isize)\n                    as *const libc::c_void,\n                valsize,\n            ) != 0\n        {\n            fprintf(\n                stderr,\n                b\"\\n  - %s\\0\" as *const u8 as *const libc::c_char,\n                quote(*arglist.offset(i as isize)),\n            );\n            last_val = (vallist as *const libc::c_char)\n                .offset(valsize.wrapping_mul(i) as isize);\n        } else {\n            fprintf(\n                stderr,\n                b\", %s\\0\" as *const u8 as *const libc::c_char,\n                quote(*arglist.offset(i as isize)),\n            );\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    putc_unlocked('\\n' as i32, stderr);\n}",
    "calls": [
      {
        "caller": "DefId(0:61 ~ rust[fc84]::src::argmatch::__xargmatch_internal)",
        "span": "src/argmatch.rs:273:5: 273:47 (#0)",
        "source": "argmatch_valid(arglist, vallist, valsize);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/argmatch.rs:5:1: 5:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/argmatch.rs:3:1: 3:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/argmatch.rs:4:1: 4:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:50 ~ rust[fc84]::src::argmatch::argmatch_invalid)",
    "span": "src/argmatch.rs:155:1: 183:2 (#0)",
    "pieces": [
      "src/argmatch.rs:155:1: 183:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 54,
    "source": "pub unsafe extern \"C\" fn argmatch_invalid(\n    mut context: *const libc::c_char,\n    mut value: *const libc::c_char,\n    mut problem: ptrdiff_t,\n) {\n    let mut format: *const libc::c_char = if problem\n        == -(1 as libc::c_int) as libc::c_long\n    {\n        gettext(b\"invalid argument %s for %s\\0\" as *const u8 as *const libc::c_char)\n    } else {\n        gettext(b\"ambiguous argument %s for %s\\0\" as *const u8 as *const libc::c_char)\n    };\n    if 0 != 0 {\n        error(\n            0 as libc::c_int,\n            0 as libc::c_int,\n            format,\n            quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n            quote_n(1 as libc::c_int, context),\n        );\n        if 0 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 0 as libc::c_int;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                format,\n                quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n                quote_n(1 as libc::c_int, context),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 0 as libc::c_int;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                format,\n                quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n                quote_n(1 as libc::c_int, context),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:61 ~ rust[fc84]::src::argmatch::__xargmatch_internal)",
        "span": "src/argmatch.rs:272:1: 272:67 (#0)",
        "source": "argmatch_invalid(&context_str, &arg_str, res.try_into().unwrap());"
      }
    ],
    "globals": [
      {
        "span": "src/argmatch.rs:87:1: 87:51 (#0)",
        "source": "pub const locale_quoting_style: quoting_style = 8;"
      }
    ],
    "imports": [
      {
        "span": "src/argmatch.rs:3:1: 3:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/argmatch.rs:5:1: 5:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/argmatch.rs:4:1: 4:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:48 ~ rust[fc84]::src::argmatch::argmatch)",
    "span": "src/argmatch.rs:104:1: 139:2 (#0)",
    "pieces": [
      "src/argmatch.rs:104:1: 139:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn argmatch(\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) -> ptrdiff_t {\n    let mut i: size_t = 0;\n    let mut arglen: size_t = 0;\n    let mut matchind: ptrdiff_t = -(1 as libc::c_int) as ptrdiff_t;\n    let mut ambiguous: bool = 0 as libc::c_int != 0;\n    arglen = strlen(arg);\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if strncmp(*arglist.offset(i as isize), arg, arglen) == 0 {\n            if strlen(*arglist.offset(i as isize)) == arglen {\n                return i as ptrdiff_t\n            } else if matchind == -(1 as libc::c_int) as libc::c_long {\n                matchind = i as ptrdiff_t;\n            } else if vallist.is_null()\n                || memcmp(\n                    (vallist as *const libc::c_char)\n                        .offset(valsize.wrapping_mul(matchind as libc::c_ulong) as isize)\n                        as *const libc::c_void,\n                    (vallist as *const libc::c_char)\n                        .offset(valsize.wrapping_mul(i) as isize) as *const libc::c_void,\n                    valsize,\n                ) != 0\n            {\n                ambiguous = 1 as libc::c_int != 0;\n            }\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    if ambiguous { return -(2 as libc::c_int) as ptrdiff_t } else { return matchind };\n}",
    "calls": [
      {
        "caller": "DefId(0:61 ~ rust[fc84]::src::argmatch::__xargmatch_internal)",
        "span": "src/argmatch.rs:248:1: 253:3 (#0)",
        "source": "let res = argmatch(\n    &arg_str,\n    &arglist_slice,\n    if vallist.is_null() { None } else { Some(std::slice::from_raw_parts(vallist as *const u8, valsize as usize)) },\n    valsize as usize\n);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/argmatch.rs:5:1: 5:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/argmatch.rs:4:1: 4:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/argmatch.rs:3:1: 3:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:52 ~ rust[fc84]::src::argmatch::__xargmatch_internal)",
    "span": "src/argmatch.rs:227:1: 277:2 (#0)",
    "pieces": [
      "src/argmatch.rs:227:1: 277:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 24,
    "source": "pub unsafe extern \"C\" fn __xargmatch_internal(\n    mut context: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n    mut exit_fn: argmatch_exit_fn,\n    mut allow_abbreviation: bool,\n) -> ptrdiff_t {\n    let mut res: ptrdiff_t = 0;\n    if allow_abbreviation {\n        res = argmatch(arg, arglist, vallist, valsize);\n    } else {\n        res = argmatch_exact(arg, arglist);\n    }\n    if res >= 0 as libc::c_int as libc::c_long {\n        return res;\n    }\n    argmatch_invalid(context, arg, res);\n    argmatch_valid(arglist, vallist, valsize);\n    (Some(exit_fn.expect(\"non-null function pointer\")))\n        .expect(\"non-null function pointer\")();\n    return -(1 as libc::c_int) as ptrdiff_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/argmatch.rs:4:1: 4:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/argmatch.rs:5:1: 5:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/argmatch.rs:3:1: 3:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:107 ~ rust[fc84]::src::c_ctype::c_isspace)",
    "span": "src/c_ctype.rs:125:1: 130:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:125:1: 130:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:197 ~ rust[fc84]::src::dirname_lgpl::mdir_name)",
    "span": "src/dirname_lgpl.rs:55:1: 71:2 (#0)",
    "pieces": [
      "src/dirname_lgpl.rs:55:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn mdir_name(mut file: *const libc::c_char) -> *mut libc::c_char {\n    let mut length: size_t = dir_len(file);\n    let mut append_dot: bool = length == 0 as libc::c_int as libc::c_ulong\n        || 0 as libc::c_int != 0 && length == 0 as libc::c_int as libc::c_ulong\n            && *file.offset(2 as libc::c_int as isize) as libc::c_int != '\\0' as i32\n            && !(*file.offset(2 as libc::c_int as isize) as libc::c_int == '/' as i32);\n    let mut dir: *mut libc::c_char = malloc(\n        length\n            .wrapping_add(append_dot as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n    if dir.is_null() {\n        return 0 as *mut libc::c_char;\n    }\n    memcpy(dir as *mut libc::c_void, file as *const libc::c_void, length);\n    if append_dot {\n        let fresh0 = length;\n        length = length.wrapping_add(1);\n        *dir.offset(fresh0 as isize) = '.' as i32 as libc::c_char;\n    }\n    *dir.offset(length as isize) = '\\0' as i32 as libc::c_char;\n    return dir;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/dirname_lgpl.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/dirname_lgpl.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:61 ~ rust[fc84]::src::basename_lgpl::last_component)",
    "span": "src/basename_lgpl.rs:10:1: 24:2 (#0)",
    "pieces": [
      "src/basename_lgpl.rs:10:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn last_component(\n    mut name: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut base: *const libc::c_char = name.offset(0 as libc::c_int as isize);\n    let mut p: *const libc::c_char = 0 as *const libc::c_char;\n    let mut last_was_slash: bool = 0 as libc::c_int != 0;\n    while *base as libc::c_int == '/' as i32 {\n        base = base.offset(1);\n        base;\n    }\n    p = base;\n    while *p != 0 {\n        if *p as libc::c_int == '/' as i32 {\n            last_was_slash = 1 as libc::c_int != 0;\n        } else if last_was_slash {\n            base = p;\n            last_was_slash = 0 as libc::c_int != 0;\n        }\n        p = p.offset(1);\n        p;\n    }\n    return base as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/basename_lgpl.rs:2:1: 2:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/basename_lgpl.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:366 ~ rust[fc84]::src::hash::hash_get_first)",
    "span": "src/hash.rs:254:1: 270:2 (#0)",
    "pieces": [
      "src/hash.rs:254:1: 270:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn hash_get_first(\n    mut table: *const Hash_table,\n) -> *mut libc::c_void {\n    let mut bucket: *const hash_entry = 0 as *const hash_entry;\n    if (*table).n_entries == 0 as libc::c_int as libc::c_ulong {\n        return 0 as *mut libc::c_void;\n    }\n    bucket = (*table).bucket;\n    loop {\n        if !(bucket < (*table).bucket_limit) {\n            abort();\n        } else if !((*bucket).data).is_null() {\n            return (*bucket).data\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:379 ~ rust[fc84]::src::hash::hash_clear)",
    "span": "src/hash.rs:525:1: 558:2 (#0)",
    "pieces": [
      "src/hash.rs:525:1: 558:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 32,
    "source": "pub unsafe extern \"C\" fn hash_clear(mut table: *mut Hash_table) {\n    let mut bucket: *mut hash_entry = 0 as *mut hash_entry;\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit as *mut hash_entry {\n        if !((*bucket).data).is_null() {\n            let mut cursor: *mut hash_entry = 0 as *mut hash_entry;\n            let mut next: *mut hash_entry = 0 as *mut hash_entry;\n            cursor = (*bucket).next;\n            while !cursor.is_null() {\n                if ((*table).data_freer).is_some() {\n                    ((*table).data_freer)\n                        .expect(\"non-null function pointer\")((*cursor).data);\n                }\n                (*cursor).data = 0 as *mut libc::c_void;\n                next = (*cursor).next;\n                (*cursor).next = (*table).free_entry_list;\n                (*table).free_entry_list = cursor;\n                cursor = next;\n            }\n            if ((*table).data_freer).is_some() {\n                ((*table).data_freer)\n                    .expect(\"non-null function pointer\")((*bucket).data);\n            }\n            (*bucket).data = 0 as *mut libc::c_void;\n            (*bucket).next = 0 as *mut hash_entry;\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    (*table).n_buckets_used = 0 as libc::c_int as size_t;\n    (*table).n_entries = 0 as libc::c_int as size_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:382 ~ rust[fc84]::src::hash::free_entry)",
    "span": "src/hash.rs:613:1: 617:2 (#0)",
    "pieces": [
      "src/hash.rs:613:1: 617:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn free_entry(mut table: *mut Hash_table, mut entry: *mut hash_entry) {\n    (*entry).data = 0 as *mut libc::c_void;\n    (*entry).next = (*table).free_entry_list;\n    (*table).free_entry_list = entry;\n}",
    "calls": [
      {
        "caller": "DefId(0:501 ~ rust[fc84]::src::hash::hash_find_entry)",
        "span": "src/hash.rs:640:17: 640:41 (#0)",
        "source": "free_entry(table, next);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:383 ~ rust[fc84]::src::hash::hash_find_entry)",
    "span": "src/hash.rs:618:1: 665:2 (#0)",
    "pieces": [
      "src/hash.rs:618:1: 665:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "unsafe extern \"C\" fn hash_find_entry(\n    mut table: *mut Hash_table,\n    mut entry: *const libc::c_void,\n    mut bucket_head: *mut *mut hash_entry,\n    mut delete: bool,\n) -> *mut libc::c_void {\n    let mut bucket: *mut hash_entry = safe_hasher(table, entry);\n    let mut cursor: *mut hash_entry = 0 as *mut hash_entry;\n    *bucket_head = bucket;\n    if ((*bucket).data).is_null() {\n        return 0 as *mut libc::c_void;\n    }\n    if entry == (*bucket).data as *const libc::c_void\n        || ((*table).comparator)\n            .expect(\"non-null function pointer\")(entry, (*bucket).data) as libc::c_int\n            != 0\n    {\n        let mut data: *mut libc::c_void = (*bucket).data;\n        if delete {\n            if !((*bucket).next).is_null() {\n                let mut next: *mut hash_entry = (*bucket).next;\n                *bucket = *next;\n                free_entry(table, next);\n            } else {\n                (*bucket).data = 0 as *mut libc::c_void;\n            }\n        }\n        return data;\n    }\n    cursor = bucket;\n    while !((*cursor).next).is_null() {\n        if entry == (*(*cursor).next).data as *const libc::c_void\n            || ((*table).comparator)\n                .expect(\"non-null function pointer\")(entry, (*(*cursor).next).data)\n                as libc::c_int != 0\n        {\n            let mut data_0: *mut libc::c_void = (*(*cursor).next).data;\n            if delete {\n                let mut next_0: *mut hash_entry = (*cursor).next;\n                (*cursor).next = (*next_0).next;\n                free_entry(table, next_0);\n            }\n            return data_0;\n        }\n        cursor = (*cursor).next;\n    }\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:504 ~ rust[fc84]::src::hash::hash_insert_if_absent)",
        "span": "src/hash.rs:794:5: 794:78 (#0)",
        "source": "data = hash_find_entry(table, entry, &mut bucket, 0 as libc::c_int != 0);"
      },
      {
        "caller": "DefId(0:506 ~ rust[fc84]::src::hash::hash_remove)",
        "span": "src/hash.rs:877:9: 877:65 (#0)",
        "source": "data = hash_find_entry(table, entry, &mut bucket, true);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:108 ~ rust[fc84]::src::c_ctype::c_isupper)",
    "span": "src/c_ctype.rs:135:1: 137:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:135:1: 137:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:376 ~ rust[fc84]::src::hash::check_tuning)",
    "span": "src/hash.rs:418:1: 437:2 (#0)",
    "pieces": [
      "src/hash.rs:418:1: 437:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "unsafe extern \"C\" fn check_tuning(mut table: *mut Hash_table) -> bool {\n    let mut tuning: *const Hash_tuning = (*table).tuning;\n    let mut epsilon: libc::c_float = 0.;\n    if tuning == &default_tuning as *const Hash_tuning {\n        return 1 as libc::c_int != 0;\n    }\n    epsilon = 0.1f32;\n    if epsilon < (*tuning).growth_threshold\n        && (*tuning).growth_threshold < 1 as libc::c_int as libc::c_float - epsilon\n        && 1 as libc::c_int as libc::c_float + epsilon < (*tuning).growth_factor\n        && 0 as libc::c_int as libc::c_float <= (*tuning).shrink_threshold\n        && (*tuning).shrink_threshold + epsilon < (*tuning).shrink_factor\n        && (*tuning).shrink_factor <= 1 as libc::c_int as libc::c_float\n        && (*tuning).shrink_threshold + epsilon < (*tuning).growth_threshold\n    {\n        return 1 as libc::c_int != 0;\n    }\n    (*table).tuning = &default_tuning;\n    return 0 as libc::c_int != 0;\n}",
    "calls": [
      {
        "caller": "DefId(0:506 ~ rust[fc84]::src::hash::hash_remove)",
        "span": "src/hash.rs:888:17: 888:37 (#0)",
        "source": "check_tuning(table);"
      },
      {
        "caller": "DefId(0:504 ~ rust[fc84]::src::hash::hash_insert_if_absent)",
        "span": "src/hash.rs:804:9: 804:29 (#0)",
        "source": "check_tuning(table);"
      }
    ],
    "globals": [
      {
        "span": "src/hash.rs:122:1: 131:3 (#0)",
        "source": "static mut default_tuning: Hash_tuning = {\n    let mut init = hash_tuning {\n        shrink_threshold: 0.0f32,\n        shrink_factor: 1.0f32,\n        growth_threshold: 0.8f32,\n        growth_factor: 1.414f32,\n        is_n_buckets: 0 as libc::c_int != 0,\n    };\n    init\n};"
      }
    ],
    "imports": [
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:388 ~ rust[fc84]::src::hash::hash_remove)",
    "span": "src/hash.rs:869:1: 911:2 (#0)",
    "pieces": [
      "src/hash.rs:869:1: 911:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 47,
    "source": "pub unsafe extern \"C\" fn hash_remove(\n    mut table: *mut Hash_table,\n    mut entry: *const libc::c_void,\n) -> *mut libc::c_void {\n    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;\n    let mut bucket: *mut hash_entry = 0 as *mut hash_entry;\n    data = hash_find_entry(table, entry, &mut bucket, 1 as libc::c_int != 0);\n    if data.is_null() {\n        return 0 as *mut libc::c_void;\n    }\n    (*table).n_entries = ((*table).n_entries).wrapping_sub(1);\n    (*table).n_entries;\n    if ((*bucket).data).is_null() {\n        (*table).n_buckets_used = ((*table).n_buckets_used).wrapping_sub(1);\n        (*table).n_buckets_used;\n        if ((*table).n_buckets_used as libc::c_float)\n            < (*(*table).tuning).shrink_threshold * (*table).n_buckets as libc::c_float\n        {\n            check_tuning(table);\n            if ((*table).n_buckets_used as libc::c_float)\n                < (*(*table).tuning).shrink_threshold\n                    * (*table).n_buckets as libc::c_float\n            {\n                let mut tuning: *const Hash_tuning = (*table).tuning;\n                let mut candidate: size_t = (if (*tuning).is_n_buckets as libc::c_int\n                    != 0\n                {\n                    (*table).n_buckets as libc::c_float * (*tuning).shrink_factor\n                } else {\n                    (*table).n_buckets as libc::c_float * (*tuning).shrink_factor\n                        * (*tuning).growth_threshold\n                }) as size_t;\n                if !hash_rehash(table, candidate) {\n                    let mut cursor: *mut hash_entry = (*table).free_entry_list;\n                    let mut next: *mut hash_entry = 0 as *mut hash_entry;\n                    while !cursor.is_null() {\n                        next = (*cursor).next;\n                        free(cursor as *mut libc::c_void);\n                        cursor = next;\n                    }\n                    (*table).free_entry_list = 0 as *mut hash_entry;\n                }\n            }\n        }\n    }\n    return data;\n}",
    "calls": [
      {
        "caller": "DefId(0:507 ~ rust[fc84]::src::hash::hash_delete)",
        "span": "src/hash.rs:917:24: 919:2 (#0)",
        "source": "{\n    hash_remove(table, entry)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:389 ~ rust[fc84]::src::hash::hash_delete)",
    "span": "src/hash.rs:914:1: 919:2 (#0)",
    "pieces": [
      "src/hash.rs:914:1: 919:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn hash_delete(\n    mut table: *mut Hash_table,\n    mut entry: *const libc::c_void,\n) -> *mut libc::c_void {\n    return hash_remove(table, entry);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1047 ~ rust[fc84]::src::quotearg::get_quoting_style)",
    "span": "src/quotearg.rs:195:1: 201:2 (#0)",
    "pieces": [
      "src/quotearg.rs:195:1: 201:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:177:1: 183:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1057 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
    "span": "src/quotearg.rs:1196:1: 1243:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1196:1: 1243:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}",
    "calls": [
      {
        "caller": "DefId(0:1222 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
        "span": "src/quotearg.rs:1193:5: 1193:66 (#0)",
        "source": "return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:92:1: 92:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      },
      {
        "span": "src/quotearg.rs:177:1: 183:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1056 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
    "span": "src/quotearg.rs:1188:1: 1194:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1188:1: 1194:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1073 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
    "span": "src/quotearg.rs:1405:1: 1413:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1405:1: 1413:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:1241 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
        "span": "src/quotearg.rs:1431:22: 1431:82 (#0)",
        "source": "unsafe { quotearg_n_style_mem(0, s, arg.as_ptr(), argsize) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1075 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
    "span": "src/quotearg.rs:1426:1: 1433:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1426:1: 1433:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1104 ~ rust[fc84]::src::safe_read::safe_read)",
    "span": "src/safe_read.rs:12:1: 34:2 (#0)",
    "pieces": [
      "src/safe_read.rs:12:1: 34:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn safe_read(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = read(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/safe_read.rs:9:1: 9:55 (#0)",
        "source": "pub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;"
      }
    ],
    "imports": [
      {
        "span": "src/safe_read.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:406 ~ rust[fc84]::src::ialloc::imalloc)",
    "span": "src/ialloc.rs:83:1: 90:2 (#0)",
    "pieces": [
      "src/ialloc.rs:83:1: 90:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:1:1: 1:24 (#0)",
        "source": "use std::alloc::Layout;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:3:1: 3:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:5:1: 5:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:327 ~ rust[fc84]::src::hard_locale::hard_locale)",
    "span": "src/hard_locale.rs:14:1: 32:2 (#0)",
    "pieces": [
      "src/hard_locale.rs:14:1: 32:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hard_locale.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/hard_locale.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:368 ~ rust[fc84]::src::hash::hash_get_entries)",
    "span": "src/hash.rs:301:1: 328:2 (#0)",
    "pieces": [
      "src/hash.rs:301:1: 328:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "pub unsafe extern \"C\" fn hash_get_entries(\n    mut table: *const Hash_table,\n    mut buffer: *mut *mut libc::c_void,\n    mut buffer_size: size_t,\n) -> size_t {\n    let mut counter: size_t = 0 as libc::c_int as size_t;\n    let mut bucket: *const hash_entry = 0 as *const hash_entry;\n    let mut cursor: *const hash_entry = 0 as *const hash_entry;\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit {\n        if !((*bucket).data).is_null() {\n            cursor = bucket;\n            while !cursor.is_null() {\n                if counter >= buffer_size {\n                    return counter;\n                }\n                let fresh0 = counter;\n                counter = counter.wrapping_add(1);\n                let ref mut fresh1 = *buffer.offset(fresh0 as isize);\n                *fresh1 = (*cursor).data;\n                cursor = (*cursor).next;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    return counter;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:454 ~ rust[fc84]::src::iopoll::iopoll)",
    "span": "src/iopoll.rs:175:1: 181:2 (#0)",
    "pieces": [
      "src/iopoll.rs:175:1: 181:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn iopoll(\n    mut fdin: libc::c_int,\n    mut fdout: libc::c_int,\n    mut block: bool,\n) -> libc::c_int {\n    return iopoll_internal(fdin, fdout, block, 1 as libc::c_int != 0);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/iopoll.rs:8:1: 8:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/iopoll.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/iopoll.rs:6:1: 6:30 (#0)",
        "source": "use std::os::unix::io::RawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1091 ~ rust[fc84]::src::quotearg::quote)",
    "span": "src/quotearg.rs:1601:1: 1603:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1601:1: 1603:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1147 ~ rust[fc84]::src::stat_time::get_stat_mtime_ns)",
    "span": "src/stat_time.rs:112:1: 114:2 (#0)",
    "pieces": [
      "src/stat_time.rs:112:1: 114:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn get_stat_mtime_ns(mut st: *const stat) -> libc::c_long {\n    return (*st).st_mtim.tv_nsec;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stat_time.rs:10:1: 10:18 (#0)",
        "source": "use libc::c_long;"
      },
      {
        "span": "src/stat_time.rs:9:1: 9:18 (#0)",
        "source": "use libc::time_t;"
      },
      {
        "span": "src/stat_time.rs:7:1: 7:23 (#0)",
        "source": "use std::fs::Metadata;"
      },
      {
        "span": "src/stat_time.rs:12:1: 12:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/stat_time.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1158 ~ rust[fc84]::src::timespec::timespec_cmp)",
    "span": "src/timespec.rs:29:1: 43:2 (#0)",
    "pieces": [
      "src/timespec.rs:29:1: 43:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn timespec_cmp(mut a: timespec, mut b: timespec) -> libc::c_int {\n    return 2 as libc::c_int\n        * ((a.tv_sec > b.tv_sec) as libc::c_int - (a.tv_sec < b.tv_sec) as libc::c_int)\n        + ((a.tv_nsec > b.tv_nsec) as libc::c_int\n            - (a.tv_nsec < b.tv_nsec) as libc::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/timespec.rs:8:1: 8:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/timespec.rs:4:1: 4:27 (#0)",
        "source": "use std::time::SystemTime;"
      },
      {
        "span": "src/timespec.rs:3:1: 3:25 (#0)",
        "source": "use std::time::Duration;"
      },
      {
        "span": "src/timespec.rs:6:1: 6:15 (#0)",
        "source": "use std::time;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:404 ~ rust[fc84]::src::ialloc::icalloc)",
    "span": "src/ialloc.rs:49:1: 64:2 (#0)",
    "pieces": [
      "src/ialloc.rs:49:1: 64:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:3:1: 3:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:5:1: 5:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:1:1: 1:24 (#0)",
        "source": "use std::alloc::Layout;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:928 ~ rust[fc84]::src::offtostr::offtostr)",
    "span": "src/offtostr.rs:7:1: 35:2 (#0)",
    "pieces": [
      "src/offtostr.rs:7:1: 35:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 46,
    "source": "pub unsafe extern \"C\" fn offtostr(\n    mut i: off_t,\n    mut buf: *mut libc::c_char,\n) -> *mut libc::c_char {\n    let mut p: *mut libc::c_char = buf\n        .offset(\n            (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                .wrapping_sub(\n                    !((0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t)\n                        as libc::c_int as libc::c_ulong,\n                )\n                .wrapping_mul(146 as libc::c_int as libc::c_ulong)\n                .wrapping_add(484 as libc::c_int as libc::c_ulong)\n                .wrapping_div(485 as libc::c_int as libc::c_ulong)\n                .wrapping_add(\n                    !((0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t)\n                        as libc::c_int as libc::c_ulong,\n                ) as isize,\n        );\n    *p = 0 as libc::c_int as libc::c_char;\n    if i < 0 as libc::c_int as libc::c_long {\n        loop {\n            p = p.offset(-1);\n            *p = ('0' as i32 as libc::c_long - i % 10 as libc::c_int as libc::c_long)\n                as libc::c_char;\n            i /= 10 as libc::c_int as libc::c_long;\n            if !(i != 0 as libc::c_int as libc::c_long) {\n                break;\n            }\n        }\n        p = p.offset(-1);\n        *p = '-' as i32 as libc::c_char;\n    } else {\n        loop {\n            p = p.offset(-1);\n            *p = ('0' as i32 as libc::c_long + i % 10 as libc::c_int as libc::c_long)\n                as libc::c_char;\n            i /= 10 as libc::c_int as libc::c_long;\n            if !(i != 0 as libc::c_int as libc::c_long) {\n                break;\n            }\n        }\n    }\n    return p;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/offtostr.rs:1:1: 1:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/offtostr.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1192 ~ rust[fc84]::src::version_etc::version_etc_va)",
    "span": "src/version_etc.rs:265:1: 292:2 (#0)",
    "pieces": [
      "src/version_etc.rs:265:1: 292:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "pub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:1398 ~ rust[fc84]::src::version_etc::version_etc)",
        "span": "src/version_etc.rs:303:5: 303:82 (#0)",
        "source": "version_etc_va(stream, command_name, package, version, authors.as_va_list());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:3:1: 3:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/version_etc.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1195 ~ rust[fc84]::src::version_etc::version_etc)",
    "span": "src/version_etc.rs:294:1: 304:2 (#0)",
    "pieces": [
      "src/version_etc.rs:294:1: 304:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:3:1: 3:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/version_etc.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1196 ~ rust[fc84]::src::version_etc::emit_bug_reporting_address)",
    "span": "src/version_etc.rs:306:1: 321:2 (#0)",
    "pieces": [
      "src/version_etc.rs:306:1: 321:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:3:1: 3:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/version_etc.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:371 ~ rust[fc84]::src::hash::is_prime)",
    "span": "src/hash.rs:370:1: 389:2 (#0)",
    "pieces": [
      "src/hash.rs:370:1: 389:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "unsafe extern \"C\" fn is_prime(mut candidate: size_t) -> bool {\n    let mut divisor: size_t = 3 as libc::c_int as size_t;\n    let mut square: size_t = divisor.wrapping_mul(divisor);\n    while square < candidate && candidate.wrapping_rem(divisor) != 0 {\n        divisor = divisor.wrapping_add(1);\n        divisor;\n        square = (square as libc::c_ulong)\n            .wrapping_add((4 as libc::c_int as libc::c_ulong).wrapping_mul(divisor))\n            as size_t as size_t;\n        divisor = divisor.wrapping_add(1);\n        divisor;\n    }\n    return if candidate.wrapping_rem(divisor) != 0 {\n        1 as libc::c_int\n    } else {\n        0 as libc::c_int\n    } != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:381 ~ rust[fc84]::src::hash::allocate_entry)",
    "span": "src/hash.rs:602:1: 612:2 (#0)",
    "pieces": [
      "src/hash.rs:602:1: 612:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn allocate_entry(mut table: *mut Hash_table) -> *mut hash_entry {\n    let mut new: *mut hash_entry = 0 as *mut hash_entry;\n    if !((*table).free_entry_list).is_null() {\n        new = (*table).free_entry_list;\n        (*table).free_entry_list = (*new).next;\n    } else {\n        new = malloc(::core::mem::size_of::<hash_entry>() as libc::c_ulong)\n            as *mut hash_entry;\n    }\n    return new;\n}",
    "calls": [
      {
        "caller": "DefId(0:504 ~ rust[fc84]::src::hash::hash_insert_if_absent)",
        "span": "src/hash.rs:832:9: 832:68 (#0)",
        "source": "let mut new_entry: *mut hash_entry = allocate_entry(table);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:386 ~ rust[fc84]::src::hash::hash_insert_if_absent)",
    "span": "src/hash.rs:784:1: 849:2 (#0)",
    "pieces": [
      "src/hash.rs:784:1: 849:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 66,
    "source": "pub unsafe extern \"C\" fn hash_insert_if_absent(\n    mut table: *mut Hash_table,\n    mut entry: *const libc::c_void,\n    mut matched_ent: *mut *const libc::c_void,\n) -> libc::c_int {\n    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;\n    let mut bucket: *mut hash_entry = 0 as *mut hash_entry;\n    if entry.is_null() {\n        abort();\n    }\n    data = hash_find_entry(table, entry, &mut bucket, 0 as libc::c_int != 0);\n    if !data.is_null() {\n        if !matched_ent.is_null() {\n            *matched_ent = data;\n        }\n        return 0 as libc::c_int;\n    }\n    if (*table).n_buckets_used as libc::c_float\n        > (*(*table).tuning).growth_threshold * (*table).n_buckets as libc::c_float\n    {\n        check_tuning(table);\n        if (*table).n_buckets_used as libc::c_float\n            > (*(*table).tuning).growth_threshold * (*table).n_buckets as libc::c_float\n        {\n            let mut tuning: *const Hash_tuning = (*table).tuning;\n            let mut candidate: libc::c_float = if (*tuning).is_n_buckets as libc::c_int\n                != 0\n            {\n                (*table).n_buckets as libc::c_float * (*tuning).growth_factor\n            } else {\n                (*table).n_buckets as libc::c_float * (*tuning).growth_factor\n                    * (*tuning).growth_threshold\n            };\n            if 18446744073709551615 as libc::c_ulong as libc::c_float <= candidate {\n                *__errno_location() = 12 as libc::c_int;\n                return -(1 as libc::c_int);\n            }\n            if !hash_rehash(table, candidate as size_t) {\n                return -(1 as libc::c_int);\n            }\n            if !(hash_find_entry(table, entry, &mut bucket, 0 as libc::c_int != 0))\n                .is_null()\n            {\n                abort();\n            }\n        }\n    }\n    if !((*bucket).data).is_null() {\n        let mut new_entry: *mut hash_entry = allocate_entry(table);\n        if new_entry.is_null() {\n            return -(1 as libc::c_int);\n        }\n        (*new_entry).data = entry as *mut libc::c_void;\n        (*new_entry).next = (*bucket).next;\n        (*bucket).next = new_entry;\n        (*table).n_entries = ((*table).n_entries).wrapping_add(1);\n        (*table).n_entries;\n        return 1 as libc::c_int;\n    }\n    (*bucket).data = entry as *mut libc::c_void;\n    (*table).n_entries = ((*table).n_entries).wrapping_add(1);\n    (*table).n_entries;\n    (*table).n_buckets_used = ((*table).n_buckets_used).wrapping_add(1);\n    (*table).n_buckets_used;\n    return 1 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:505 ~ rust[fc84]::src::hash::hash_insert)",
        "span": "src/hash.rs:858:9: 858:73 (#0)",
        "source": "let err = hash_insert_if_absent(table, entry, &mut matched_ent);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:387 ~ rust[fc84]::src::hash::hash_insert)",
    "span": "src/hash.rs:851:1: 866:2 (#0)",
    "pieces": [
      "src/hash.rs:851:1: 866:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn hash_insert(\n    mut table: *mut Hash_table,\n    mut entry: *const libc::c_void,\n) -> *mut libc::c_void {\n    let mut matched_ent: *const libc::c_void = 0 as *const libc::c_void;\n    let mut err: libc::c_int = hash_insert_if_absent(table, entry, &mut matched_ent);\n    return if err == -(1 as libc::c_int) {\n        0 as *mut libc::c_void\n    } else {\n        (if err == 0 as libc::c_int { matched_ent } else { entry }) as *mut libc::c_void\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1272 ~ rust[fc84]::src::xmalloc::xirealloc)",
    "span": "src/xmalloc.rs:167:1: 180:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:167:1: 180:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1264 ~ rust[fc84]::src::xmalloc::ireallocarray)",
    "span": "src/xmalloc.rs:82:1: 97:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:82:1: 97:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1496 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:194:5: 194:38 (#0)",
        "source": "let result = ireallocarray(n, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1274 ~ rust[fc84]::src::xmalloc::xireallocarray)",
    "span": "src/xmalloc.rs:189:1: 197:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:189:1: 197:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1039 ~ rust[fc84]::src::quotearg::mbszero)",
    "span": "src/quotearg.rs:143:1: 149:2 (#0)",
    "pieces": [
      "src/quotearg.rs:143:1: 149:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1051 ~ rust[fc84]::src::quotearg::set_custom_quoting)",
    "span": "src/quotearg.rs:261:1: 275:2 (#0)",
    "pieces": [
      "src/quotearg.rs:261:1: 275:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}",
    "calls": [
      {
        "caller": "DefId(0:1250 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1525:5: 1525:57 (#0)",
        "source": "set_custom_quoting(&mut o, left_quote, right_quote);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:177:1: 183:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:78:1: 78:52 (#0)",
        "source": "pub const custom_quoting_style: quoting_style = 10;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1084 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
    "span": "src/quotearg.rs:1517:1: 1527:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1517:1: 1527:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}",
    "calls": [
      {
        "caller": "DefId(0:1252 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
        "span": "src/quotearg.rs:1555:41: 1563:6 (#0)",
        "source": "unsafe {\n        quotearg_n_custom_mem(\n            0,\n            left_quote.as_ptr(),\n            right_quote.as_ptr(),\n            arg.as_ptr(),\n            argsize,\n        )\n    }"
      },
      {
        "caller": "DefId(0:1249 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
        "span": "src/quotearg.rs:1508:5: 1514:7 (#0)",
        "source": "return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:177:1: 183:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1083 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
    "span": "src/quotearg.rs:1502:1: 1515:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1502:1: 1515:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:1251 ~ rust[fc84]::src::quotearg::quotearg_custom)",
        "span": "src/quotearg.rs:1540:9: 1540:106 (#0)",
        "source": "result_ptr = quotearg_n_custom(0, left_quote_c.as_ptr(), right_quote_c.as_ptr(), arg_c.as_ptr());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1089 ~ rust[fc84]::src::quotearg::quote_mem)",
    "span": "src/quotearg.rs:1587:1: 1591:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1587:1: 1591:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:157 ~ rust[fc84]::src::close_stream::close_stream)",
    "span": "src/close_stream.rs:50:1: 65:2 (#0)",
    "pieces": [
      "src/close_stream.rs:50:1: 65:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/close_stream.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1086 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
    "span": "src/quotearg.rs:1549:1: 1565:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1549:1: 1565:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1143 ~ rust[fc84]::src::stat_time::get_stat_mtime)",
    "span": "src/stat_time.rs:72:1: 78:2 (#0)",
    "pieces": [
      "src/stat_time.rs:72:1: 78:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn get_stat_mtime(mut st: *const stat) -> timespec {\n    return (*st).st_mtim;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stat_time.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stat_time.rs:10:1: 10:18 (#0)",
        "source": "use libc::c_long;"
      },
      {
        "span": "src/stat_time.rs:12:1: 12:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/stat_time.rs:7:1: 7:23 (#0)",
        "source": "use std::fs::Metadata;"
      },
      {
        "span": "src/stat_time.rs:9:1: 9:18 (#0)",
        "source": "use libc::time_t;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1339 ~ rust[fc84]::src::xstrtoumax::bkm_scale)",
    "span": "src/xstrtoumax.rs:42:1: 329:2 (#0)",
    "pieces": [
      "src/xstrtoumax.rs:42:1: 46:4 (#0)",
      "src/xstrtoumax.rs:329:1: 329:2 (#0)"
    ],
    "sub_chunks": [
      4
    ],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn bkm_scale(\n    mut x: *mut uintmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n   <<chunk 4>>}",
    "calls": [
      {
        "caller": "DefId(0:1566 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:490:13: 490:47 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 2);"
      },
      {
        "caller": "DefId(0:1566 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:460:13: 460:50 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 1024);"
      },
      {
        "caller": "DefId(0:1566 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:457:13: 457:49 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 512);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoumax.rs:27:1: 27:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xstrtoumax.rs:28:1: 28:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoumax.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/xstrtoumax.rs:55:17: 136:18 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:55:17: 136:18 (#0)"
        ],
        "num_lines": 82,
        "source": "if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        -(1 as libc::c_int) as uintmax_t\n                    })\n                        .wrapping_add(scale_factor as libc::c_ulong)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    (*x\n                        < (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(scale_factor as libc::c_ulong)) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(-(1 as libc::c_int) as uintmax_t)\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(-scale_factor as libc::c_ulong)\n                    }) <= (-(1 as libc::c_int) as libc::c_ulong).wrapping_sub(*x))\n                        as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut u64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut u64",
          "mut scale_factor: i32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/xstrtoumax.rs:138:17: 264:18 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:138:17: 264:18 (#0)"
        ],
        "num_lines": 127,
        "source": "if (if (if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    !((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                }) < 0 as libc::c_int as libc::c_ulong\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                        < (if (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_ulong)\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            < 0 as libc::c_int as libc::c_ulong\n                        {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                << (::core::mem::size_of::<libc::c_ulong>()\n                                    as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        })\n                            .wrapping_neg()) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_ulong)\n                        < ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        *x\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (*x).wrapping_add(0 as libc::c_int as uintmax_t))\n                            as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong) < *x\n                            && (-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (*x).wrapping_sub(1 as libc::c_int as libc::c_ulong))\n                            as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut u64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut u64",
          "mut scale_factor: i32"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/xstrtoumax.rs:267:13: 289:2 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:267:13: 289:2 (#0)"
        ],
        "num_lines": 133,
        "source": "if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_ulong {\n                    if (if (if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        !((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                    }) < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                            < (if (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    *x\n                                })\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                < 0 as libc::c_int as libc::c_ulong\n                            {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                    << (::core::mem::size_of::<libc::c_ulong>()\n                                        as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            })\n                                .wrapping_neg()) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_ulong\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_ulong)\n                                < (scale_factor as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_ulong)\n                                as libc::c_int\n                        }\n                    } else {\n                        ((0 as libc::c_int as uintmax_t).wrapping_div(*x)\n                            < scale_factor as libc::c_ulong) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut u64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut u64",
          "mut scale_factor: i32"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/xstrtoumax.rs:302:9: 325:33 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:302:9: 325:33 (#0)"
        ],
        "num_lines": 24,
        "source": "*x = if *x < 0 as libc::c_int as libc::c_ulong {\n            !if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n                -(1 as libc::c_int) as uintmax_t\n            } else {\n                ((1 as libc::c_int as uintmax_t)\n                    << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            }\n        } else if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n            -(1 as libc::c_int) as uintmax_t\n        } else {\n            ((1 as libc::c_int as uintmax_t)\n                << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        };\n        return LONGINT_OVERFLOW;",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut u64"
        ],
        "live_out": [
          "mut x: *mut u64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/xstrtoumax.rs:46:5: 328:23 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:46:5: 55:16 (#0)",
          "src/xstrtoumax.rs:137:1: 138:16 (#0)",
          "src/xstrtoumax.rs:265:1: 267:12 (#0)",
          "src/xstrtoumax.rs:291:1: 302:8 (#0)",
          "src/xstrtoumax.rs:326:1: 328:23 (#0)"
        ],
        "num_lines": 30,
        "source": "let mut scaled: uintmax_t = 0;\n    if if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t\n        && (if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_ulong } else { *x })\n            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n            < 0 as libc::c_int as libc::c_ulong\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_ulong {\n               <<chunk 0>>            } else {\n               <<chunk 1>>            }\n        } else {\n           <<chunk 2>>        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n       <<chunk 3>>    }\n    *x = scaled;\n    return LONGINT_OK;",
        "sub_chunks": [
          0,
          1,
          2,
          3
        ],
        "live_in": [
          "mut x: *mut u64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut u64",
          "mut scale_factor: i32",
          "mut scaled: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:1340 ~ rust[fc84]::src::xstrtoumax::bkm_scale_by_power)",
    "span": "src/xstrtoumax.rs:330:1: 342:2 (#0)",
    "pieces": [
      "src/xstrtoumax.rs:330:1: 342:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn bkm_scale_by_power(\n    mut x: *mut uintmax_t,\n    mut base: libc::c_int,\n    mut power: libc::c_int,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    loop {\n        let fresh8 = power;\n        power = power - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);\n    }\n    return err;\n}",
    "calls": [
      {
        "caller": "DefId(0:1566 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:478:13: 478:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 5);"
      },
      {
        "caller": "DefId(0:1566 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:481:13: 481:63 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 10);"
      },
      {
        "caller": "DefId(0:1566 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:466:13: 466:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 6);"
      },
      {
        "caller": "DefId(0:1566 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:487:13: 487:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 4);"
      },
      {
        "caller": "DefId(0:1566 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:493:13: 493:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 8);"
      },
      {
        "caller": "DefId(0:1566 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:496:13: 496:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 7);"
      },
      {
        "caller": "DefId(0:1566 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:472:13: 472:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 1);"
      },
      {
        "caller": "DefId(0:1566 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:484:13: 484:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 9);"
      },
      {
        "caller": "DefId(0:1566 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:469:13: 469:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 3);"
      },
      {
        "caller": "DefId(0:1566 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:475:13: 475:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 2);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoumax.rs:28:1: 28:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoumax.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1222 ~ rust[fc84]::src::xbinary_io::__gl_setmode)",
    "span": "src/xbinary_io.rs:31:1: 33:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:31:1: 33:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:1430 ~ rust[fc84]::src::xbinary_io::set_binary_mode)",
        "span": "src/xbinary_io.rs:26:47: 28:2 (#0)",
        "source": "{\n    __gl_setmode(fd, mode)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1085 ~ rust[fc84]::src::quotearg::quotearg_custom)",
    "span": "src/quotearg.rs:1529:1: 1546:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1529:1: 1546:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:109 ~ rust[fc84]::src::c_ctype::c_isxdigit)",
    "span": "src/c_ctype.rs:142:1: 144:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:142:1: 144:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:208 ~ rust[fc84]::src::dtotimespec::dtotimespec)",
    "span": "src/dtotimespec.rs:21:1: 87:2 (#0)",
    "pieces": [
      "src/dtotimespec.rs:21:1: 87:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 67,
    "source": "pub unsafe extern \"C\" fn dtotimespec(mut sec: libc::c_double) -> timespec {\n    if !((!(if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n        -(1 as libc::c_int) as time_t\n    } else {\n        (((1 as libc::c_int as time_t)\n            << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n            - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n            + 1 as libc::c_int as libc::c_long\n    }) as libc::c_double) < sec)\n    {\n        return make_timespec(\n            !if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n                -(1 as libc::c_int) as time_t\n            } else {\n                (((1 as libc::c_int as time_t)\n                    << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            },\n            0 as libc::c_int as libc::c_long,\n        )\n    } else if !(sec\n        < 1.0f64\n            + (if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n                -(1 as libc::c_int) as time_t\n            } else {\n                (((1 as libc::c_int as time_t)\n                    << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            }) as libc::c_double)\n    {\n        return make_timespec(\n            if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n                -(1 as libc::c_int) as time_t\n            } else {\n                (((1 as libc::c_int as time_t)\n                    << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            },\n            (TIMESPEC_HZ as libc::c_int - 1 as libc::c_int) as libc::c_long,\n        )\n    } else {\n        let mut s: time_t = sec as time_t;\n        let mut frac: libc::c_double = TIMESPEC_HZ as libc::c_int as libc::c_double\n            * (sec - s as libc::c_double);\n        let mut ns: libc::c_long = frac as libc::c_long;\n        ns += ((ns as libc::c_double) < frac) as libc::c_int as libc::c_long;\n        s += ns / TIMESPEC_HZ as libc::c_int as libc::c_long;\n        ns %= TIMESPEC_HZ as libc::c_int as libc::c_long;\n        if ns < 0 as libc::c_int as libc::c_long {\n            s -= 1;\n            s;\n            ns += TIMESPEC_HZ as libc::c_int as libc::c_long;\n        }\n        return make_timespec(s, ns);\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/dtotimespec.rs:12:1: 12:51 (#0)",
        "source": "pub const TIMESPEC_HZ: C2RustUnnamed = 1000000000;"
      }
    ],
    "imports": [
      {
        "span": "src/dtotimespec.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:882 ~ rust[fc84]::src::localcharset::locale_charset)",
    "span": "src/localcharset.rs:393:1: 402:2 (#0)",
    "pieces": [
      "src/localcharset.rs:393:1: 402:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/localcharset.rs:7:1: 7:39 (#0)",
        "source": "pub const CODESET: C2RustUnnamed = 14;"
      }
    ],
    "imports": [
      {
        "span": "src/localcharset.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/localcharset.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:101 ~ rust[fc84]::src::c_ctype::c_iscntrl)",
    "span": "src/c_ctype.rs:65:1: 67:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:65:1: 67:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1276 ~ rust[fc84]::src::xmalloc::xinmalloc)",
    "span": "src/xmalloc.rs:205:1: 209:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:205:1: 209:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:367 ~ rust[fc84]::src::hash::hash_get_next)",
    "span": "src/hash.rs:273:1: 299:2 (#0)",
    "pieces": [
      "src/hash.rs:273:1: 299:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn hash_get_next(\n    mut table: *const Hash_table,\n    mut entry: *const libc::c_void,\n) -> *mut libc::c_void {\n    let mut bucket: *const hash_entry = safe_hasher(table, entry);\n    let mut cursor: *const hash_entry = 0 as *const hash_entry;\n    cursor = bucket;\n    loop {\n        if (*cursor).data == entry as *mut libc::c_void && !((*cursor).next).is_null() {\n            return (*(*cursor).next).data;\n        }\n        cursor = (*cursor).next;\n        if cursor.is_null() {\n            break;\n        }\n    }\n    loop {\n        bucket = bucket.offset(1);\n        if !(bucket < (*table).bucket_limit) {\n            break;\n        }\n        if !((*bucket).data).is_null() {\n            return (*bucket).data;\n        }\n    }\n    return 0 as *mut libc::c_void;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:970 ~ rust[fc84]::src::progname::set_program_name)",
    "span": "src/progname.rs:62:1: 90:2 (#0)",
    "pieces": [
      "src/progname.rs:62:1: 90:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "pub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/progname.rs:60:1: 60:77 (#0)",
        "source": "pub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/progname.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/progname.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/progname.rs:2:1: 2:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:252 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD)",
    "span": "src/fcntl.rs:65:1: 69:2 (#0)",
    "pieces": [
      "src/fcntl.rs:65:1: 69:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn rpl_fcntl_DUPFD(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    result = fcntl(fd, 0 as libc::c_int, target);\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:326 ~ rust[fc84]::src::fcntl::rpl_fcntl)",
        "span": "src/fcntl.rs:34:13: 34:50 (#0)",
        "source": "result = rpl_fcntl_DUPFD(fd, target);"
      },
      {
        "caller": "DefId(0:329 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD_CLOEXEC)",
        "span": "src/fcntl.rs:88:13: 88:50 (#0)",
        "source": "result = rpl_fcntl_DUPFD(fd, target);"
      },
      {
        "caller": "DefId(0:329 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD_CLOEXEC)",
        "span": "src/fcntl.rs:82:17: 82:54 (#0)",
        "source": "result = rpl_fcntl_DUPFD(fd, target);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fcntl.rs:4:1: 4:22 (#0)",
        "source": "use std::ffi::VaList;"
      },
      {
        "span": "src/fcntl.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1146 ~ rust[fc84]::src::stat_time::get_stat_birthtime_ns)",
    "span": "src/stat_time.rs:105:1: 107:2 (#0)",
    "pieces": [
      "src/stat_time.rs:105:1: 107:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn get_stat_birthtime_ns(mut _st: *const stat) -> libc::c_long {\n    return 0 as libc::c_int as libc::c_long;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stat_time.rs:7:1: 7:23 (#0)",
        "source": "use std::fs::Metadata;"
      },
      {
        "span": "src/stat_time.rs:10:1: 10:18 (#0)",
        "source": "use libc::c_long;"
      },
      {
        "span": "src/stat_time.rs:12:1: 12:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/stat_time.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stat_time.rs:9:1: 9:18 (#0)",
        "source": "use libc::time_t;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1068 ~ rust[fc84]::src::quotearg::quotearg_n)",
    "span": "src/quotearg.rs:1359:1: 1369:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1359:1: 1369:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:1236 ~ rust[fc84]::src::quotearg::quotearg)",
        "span": "src/quotearg.rs:1380:22: 1380:60 (#0)",
        "source": "unsafe { quotearg_n(0, arg.as_ptr()) }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:177:1: 183:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1070 ~ rust[fc84]::src::quotearg::quotearg)",
    "span": "src/quotearg.rs:1379:1: 1382:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1379:1: 1382:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1278 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
    "span": "src/xmalloc.rs:231:1: 259:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:231:1: 259:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:43:1: 43:47 (#0)",
        "source": "pub const DEFAULT_MXFAST: C2RustUnnamed = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:940 ~ rust[fc84]::src::open_safer::open_safer)",
    "span": "src/open_safer.rs:20:1: 32:2 (#0)",
    "pieces": [
      "src/open_safer.rs:20:1: 32:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "pub unsafe extern \"C\" fn open_safer(\n    mut file: *const libc::c_char,\n    mut flags: libc::c_int,\n    mut args: ...\n) -> libc::c_int {\n    let mut mode: mode_t = 0 as libc::c_int as mode_t;\n    if flags & 0o100 as libc::c_int != 0 {\n        let mut ap: ::core::ffi::VaListImpl;\n        ap = args.clone();\n        mode = ap.arg::<mode_t>();\n    }\n    return fd_safer(open(file, flags, mode));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/open_safer.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:360 ~ rust[fc84]::src::hash::hash_get_n_entries)",
    "span": "src/hash.rs:145:1: 147:2 (#0)",
    "pieces": [
      "src/hash.rs:145:1: 147:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn hash_get_n_entries(mut table: *const Hash_table) -> size_t {\n    return (*table).n_entries;\n}",
    "calls": [
      {
        "caller": "DefId(0:480 ~ rust[fc84]::src::hash::hash_print_statistics)",
        "span": "src/hash.rs:208:28: 208:64 (#0)",
        "source": "unsafe { hash_get_n_entries(table) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:380 ~ rust[fc84]::src::hash::hash_free)",
    "span": "src/hash.rs:561:1: 601:2 (#0)",
    "pieces": [
      "src/hash.rs:561:1: 601:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "pub unsafe extern \"C\" fn hash_free(mut table: *mut Hash_table) {\n    let mut bucket: *mut hash_entry = 0 as *mut hash_entry;\n    let mut cursor: *mut hash_entry = 0 as *mut hash_entry;\n    let mut next: *mut hash_entry = 0 as *mut hash_entry;\n    let mut err: libc::c_int = *__errno_location();\n    if ((*table).data_freer).is_some() && (*table).n_entries != 0 {\n        bucket = (*table).bucket;\n        while bucket < (*table).bucket_limit as *mut hash_entry {\n            if !((*bucket).data).is_null() {\n                cursor = bucket;\n                while !cursor.is_null() {\n                    ((*table).data_freer)\n                        .expect(\"non-null function pointer\")((*cursor).data);\n                    cursor = (*cursor).next;\n                }\n            }\n            bucket = bucket.offset(1);\n            bucket;\n        }\n    }\n    bucket = (*table).bucket;\n    while bucket < (*table).bucket_limit as *mut hash_entry {\n        cursor = (*bucket).next;\n        while !cursor.is_null() {\n            next = (*cursor).next;\n            free(cursor as *mut libc::c_void);\n            cursor = next;\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    cursor = (*table).free_entry_list;\n    while !cursor.is_null() {\n        next = (*cursor).next;\n        free(cursor as *mut libc::c_void);\n        cursor = next;\n    }\n    free((*table).bucket as *mut libc::c_void);\n    free(table as *mut libc::c_void);\n    *__errno_location() = err;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1038 ~ rust[fc84]::src::quotearg::c32isprint)",
    "span": "src/quotearg.rs:138:1: 140:2 (#0)",
    "pieces": [
      "src/quotearg.rs:138:1: 140:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:358 ~ rust[fc84]::src::hash::hash_get_n_buckets)",
    "span": "src/hash.rs:133:1: 135:2 (#0)",
    "pieces": [
      "src/hash.rs:133:1: 135:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn hash_get_n_buckets(mut table: *const Hash_table) -> size_t {\n    return (*table).n_buckets;\n}",
    "calls": [
      {
        "caller": "DefId(0:480 ~ rust[fc84]::src::hash::hash_print_statistics)",
        "span": "src/hash.rs:209:28: 209:64 (#0)",
        "source": "unsafe { hash_get_n_buckets(table) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:363 ~ rust[fc84]::src::hash::hash_print_statistics)",
    "span": "src/hash.rs:204:1: 217:2 (#0)",
    "pieces": [
      "src/hash.rs:204:1: 217:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 30,
    "source": "pub unsafe extern \"C\" fn hash_print_statistics(\n    mut table: *const Hash_table,\n    mut stream: *mut FILE,\n) {\n    let mut n_entries: size_t = hash_get_n_entries(table);\n    let mut n_buckets: size_t = hash_get_n_buckets(table);\n    let mut n_buckets_used: size_t = hash_get_n_buckets_used(table);\n    let mut max_bucket_length: size_t = hash_get_max_bucket_length(table);\n    fprintf(\n        stream,\n        b\"# entries:         %lu\\n\\0\" as *const u8 as *const libc::c_char,\n        n_entries,\n    );\n    fprintf(\n        stream,\n        b\"# buckets:         %lu\\n\\0\" as *const u8 as *const libc::c_char,\n        n_buckets,\n    );\n    fprintf(\n        stream,\n        b\"# buckets used:    %lu (%.2f%%)\\n\\0\" as *const u8 as *const libc::c_char,\n        n_buckets_used,\n        100.0f64 * n_buckets_used as libc::c_double / n_buckets as libc::c_double,\n    );\n    fprintf(\n        stream,\n        b\"max bucket length: %lu\\n\\0\" as *const u8 as *const libc::c_char,\n        max_bucket_length,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1124 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:18:1: 23:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:18:1: 23:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:1301 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
        "span": "src/setlocale_null_unlocked.rs:31:9: 31:52 (#0)",
        "source": "result = setlocale_null_unlocked(category);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1125 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:25:1: 55:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:25:1: 55:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:91 ~ rust[fc84]::src::bitrotate::rotl64)",
    "span": "src/bitrotate.rs:100:1: 103:2 (#0)",
    "pieces": [
      "src/bitrotate.rs:100:1: 103:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn rotl64(mut x: uint64_t, mut n: libc::c_int) -> uint64_t {\n    return (x << n | x >> 64 as libc::c_int - n) & 18446744073709551615 as libc::c_ulong;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/bitrotate.rs:8:1: 8:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/bitrotate.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/bitrotate.rs:12:1: 12:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/bitrotate.rs:10:1: 10:24 (#0)",
        "source": "use std::num::Wrapping;"
      },
      {
        "span": "src/bitrotate.rs:10:5: 10:23 (#0)",
        "source": "std::num::Wrapping"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1114 ~ rust[fc84]::src::setlocale_null::setlocale_null)",
    "span": "src/setlocale_null.rs:27:1: 38:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:27:1: 38:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/setlocale_null.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null.rs:3:1: 3:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:104 ~ rust[fc84]::src::c_ctype::c_islower)",
    "span": "src/c_ctype.rs:90:1: 92:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:90:1: 92:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:85 ~ rust[fc84]::src::bitrotate::rotl16)",
    "span": "src/bitrotate.rs:51:1: 54:2 (#0)",
    "pieces": [
      "src/bitrotate.rs:51:1: 54:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn rotl16(mut x: uint16_t, mut n: libc::c_int) -> uint16_t {\n    return (((x as libc::c_uint) << n | x as libc::c_uint >> 16 as libc::c_int - n)\n        & 65535 as libc::c_int as libc::c_uint) as uint16_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/bitrotate.rs:8:1: 8:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/bitrotate.rs:10:5: 10:23 (#0)",
        "source": "std::num::Wrapping"
      },
      {
        "span": "src/bitrotate.rs:12:1: 12:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/bitrotate.rs:10:1: 10:24 (#0)",
        "source": "use std::num::Wrapping;"
      },
      {
        "span": "src/bitrotate.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:300 ~ rust[fc84]::src::fpurge::fpurge)",
    "span": "src/fpurge.rs:48:1: 53:2 (#0)",
    "pieces": [
      "src/fpurge.rs:48:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn fpurge(mut fp: *mut FILE) -> libc::c_int {\n    __fpurge(fp);\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fpurge.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1277 ~ rust[fc84]::src::xmalloc::x2realloc)",
    "span": "src/xmalloc.rs:212:1: 228:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:212:1: 228:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:284 ~ rust[fc84]::src::fflush::clear_ungetc_buffer_preserving_position)",
    "span": "src/fflush.rs:53:1: 59:2 (#0)",
    "pieces": [
      "src/fflush.rs:53:1: 59:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:370 ~ rust[fc84]::src::fflush::rpl_fflush)",
        "span": "src/fflush.rs:65:13: 65:66 (#0)",
        "source": "unsafe { clear_ungetc_buffer_preserving_position(s) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:3:1: 3:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/fflush.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/fflush.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:285 ~ rust[fc84]::src::fflush::rpl_fflush)",
    "span": "src/fflush.rs:62:1: 70:2 (#0)",
    "pieces": [
      "src/fflush.rs:62:1: 70:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fflush.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/fflush.rs:3:1: 3:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:254 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD_CLOEXEC)",
    "span": "src/fcntl.rs:72:1: 102:2 (#0)",
    "pieces": [
      "src/fcntl.rs:72:1: 102:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 32,
    "source": "unsafe extern \"C\" fn rpl_fcntl_DUPFD_CLOEXEC(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    if 0 as libc::c_int <= have_dupfd_cloexec {\n        result = fcntl(fd, 1030 as libc::c_int, target);\n        if 0 as libc::c_int <= result || *__errno_location() != 22 as libc::c_int {\n            have_dupfd_cloexec = 1 as libc::c_int;\n        } else {\n            result = rpl_fcntl_DUPFD(fd, target);\n            if result >= 0 as libc::c_int {\n                have_dupfd_cloexec = -(1 as libc::c_int);\n            }\n        }\n    } else {\n        result = rpl_fcntl_DUPFD(fd, target);\n    }\n    if 0 as libc::c_int <= result && have_dupfd_cloexec == -(1 as libc::c_int) {\n        let mut flags: libc::c_int = fcntl(result, 1 as libc::c_int);\n        if flags < 0 as libc::c_int\n            || fcntl(result, 2 as libc::c_int, flags | 1 as libc::c_int)\n                == -(1 as libc::c_int)\n        {\n            let mut saved_errno: libc::c_int = *__errno_location();\n            close(result);\n            *__errno_location() = saved_errno;\n            result = -(1 as libc::c_int);\n        }\n    }\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:326 ~ rust[fc84]::src::fcntl::rpl_fcntl)",
        "span": "src/fcntl.rs:38:13: 38:58 (#0)",
        "source": "result = rpl_fcntl_DUPFD_CLOEXEC(fd, target);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fcntl.rs:4:1: 4:22 (#0)",
        "source": "use std::ffi::VaList;"
      },
      {
        "span": "src/fcntl.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:139 ~ rust[fc84]::src::cl_strtod::cl_strtod)",
    "span": "src/cl_strtod.rs:11:1: 32:2 (#0)",
    "pieces": [
      "src/cl_strtod.rs:11:1: 32:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 22,
    "source": "pub unsafe extern \"C\" fn cl_strtod(\n    mut nptr: *const libc::c_char,\n    mut endptr: *mut *mut libc::c_char,\n) -> libc::c_double {\n    let mut end: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut d: libc::c_double = strtod(nptr, &mut end);\n    if *end != 0 {\n        let mut strtod_errno: libc::c_int = *__errno_location();\n        let mut c_end: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut c: libc::c_double = c_strtod(nptr, &mut c_end);\n        if end < c_end {\n            d = c;\n            end = c_end;\n        } else {\n            *__errno_location() = strtod_errno;\n        }\n    }\n    if !endptr.is_null() {\n        *endptr = end;\n    }\n    return d;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/cl_strtod.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:100 ~ rust[fc84]::src::c_ctype::c_isblank)",
    "span": "src/c_ctype.rs:58:1: 60:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:58:1: 60:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:266 ~ rust[fc84]::src::fd_safer::fd_safer)",
    "span": "src/fd_safer.rs:10:1: 17:2 (#0)",
    "pieces": [
      "src/fd_safer.rs:10:1: 17:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn fd_safer(mut fd: libc::c_int) -> libc::c_int {\n    if 0 as libc::c_int <= fd && fd <= 2 as libc::c_int {\n        let mut f: libc::c_int = dup_safer(fd);\n        let mut e: libc::c_int = *__errno_location();\n        close(fd);\n        *__errno_location() = e;\n        fd = f;\n    }\n    return fd;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fd_safer.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fd_safer.rs:1:1: 1:17 (#0)",
        "source": "use libc::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:385 ~ rust[fc84]::src::hash::hash_rehash)",
    "span": "src/hash.rs:723:1: 782:2 (#0)",
    "pieces": [
      "src/hash.rs:723:1: 782:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 60,
    "source": "pub unsafe extern \"C\" fn hash_rehash(\n    mut table: *mut Hash_table,\n    mut candidate: size_t,\n) -> bool {\n    let mut storage: Hash_table = Hash_table {\n        bucket: 0 as *mut hash_entry,\n        bucket_limit: 0 as *const hash_entry,\n        n_buckets: 0,\n        n_buckets_used: 0,\n        n_entries: 0,\n        tuning: 0 as *const Hash_tuning,\n        hasher: None,\n        comparator: None,\n        data_freer: None,\n        free_entry_list: 0 as *mut hash_entry,\n    };\n    let mut new_table: *mut Hash_table = 0 as *mut Hash_table;\n    let mut new_size: size_t = compute_bucket_size(candidate, (*table).tuning);\n    if new_size == 0 {\n        return 0 as libc::c_int != 0;\n    }\n    if new_size == (*table).n_buckets {\n        return 1 as libc::c_int != 0;\n    }\n    new_table = &mut storage;\n    (*new_table)\n        .bucket = calloc(new_size, ::core::mem::size_of::<hash_entry>() as libc::c_ulong)\n        as *mut hash_entry;\n    if ((*new_table).bucket).is_null() {\n        return 0 as libc::c_int != 0;\n    }\n    (*new_table).n_buckets = new_size;\n    (*new_table).bucket_limit = ((*new_table).bucket).offset(new_size as isize);\n    (*new_table).n_buckets_used = 0 as libc::c_int as size_t;\n    (*new_table).n_entries = 0 as libc::c_int as size_t;\n    (*new_table).tuning = (*table).tuning;\n    (*new_table).hasher = (*table).hasher;\n    (*new_table).comparator = (*table).comparator;\n    (*new_table).data_freer = (*table).data_freer;\n    (*new_table).free_entry_list = (*table).free_entry_list;\n    if transfer_entries(new_table, table, 0 as libc::c_int != 0) {\n        free((*table).bucket as *mut libc::c_void);\n        (*table).bucket = (*new_table).bucket;\n        (*table).bucket_limit = (*new_table).bucket_limit;\n        (*table).n_buckets = (*new_table).n_buckets;\n        (*table).n_buckets_used = (*new_table).n_buckets_used;\n        (*table).free_entry_list = (*new_table).free_entry_list;\n        return 1 as libc::c_int != 0;\n    }\n    let mut err: libc::c_int = *__errno_location();\n    (*table).free_entry_list = (*new_table).free_entry_list;\n    if !(transfer_entries(table, new_table, 1 as libc::c_int != 0) as libc::c_int != 0\n        && transfer_entries(table, new_table, 0 as libc::c_int != 0) as libc::c_int != 0)\n    {\n        abort();\n    }\n    free((*new_table).bucket as *mut libc::c_void);\n    *__errno_location() = err;\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1145 ~ rust[fc84]::src::stat_time::get_stat_atime)",
    "span": "src/stat_time.rs:94:1: 100:2 (#0)",
    "pieces": [
      "src/stat_time.rs:94:1: 100:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn get_stat_atime(mut st: *const stat) -> timespec {\n    return (*st).st_atim;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stat_time.rs:9:1: 9:18 (#0)",
        "source": "use libc::time_t;"
      },
      {
        "span": "src/stat_time.rs:10:1: 10:18 (#0)",
        "source": "use libc::c_long;"
      },
      {
        "span": "src/stat_time.rs:12:1: 12:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/stat_time.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stat_time.rs:7:1: 7:23 (#0)",
        "source": "use std::fs::Metadata;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1214 ~ rust[fc84]::src::xalloc_die::xalloc_die)",
    "span": "src/xalloc_die.rs:16:1: 57:2 (#0)",
    "pieces": [
      "src/xalloc_die.rs:16:1: 57:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "pub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalloc_die.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xalloc_die.rs:1:1: 1:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:84 ~ rust[fc84]::src::bitrotate::rotr16)",
    "span": "src/bitrotate.rs:43:1: 46:2 (#0)",
    "pieces": [
      "src/bitrotate.rs:43:1: 46:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn rotr16(mut x: uint16_t, mut n: libc::c_int) -> uint16_t {\n    return ((x as libc::c_uint >> n | (x as libc::c_uint) << 16 as libc::c_int - n)\n        & 65535 as libc::c_int as libc::c_uint) as uint16_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/bitrotate.rs:8:1: 8:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/bitrotate.rs:10:5: 10:23 (#0)",
        "source": "std::num::Wrapping"
      },
      {
        "span": "src/bitrotate.rs:10:1: 10:24 (#0)",
        "source": "use std::num::Wrapping;"
      },
      {
        "span": "src/bitrotate.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/bitrotate.rs:12:1: 12:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:103 ~ rust[fc84]::src::c_ctype::c_isgraph)",
    "span": "src/c_ctype.rs:79:1: 85:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:79:1: 85:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:111 ~ rust[fc84]::src::c_ctype::c_toupper)",
    "span": "src/c_ctype.rs:159:1: 166:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:159:1: 166:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:106 ~ rust[fc84]::src::c_ctype::c_ispunct)",
    "span": "src/c_ctype.rs:113:1: 120:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:113:1: 120:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:373 ~ rust[fc84]::src::hash::hash_reset_tuning)",
    "span": "src/hash.rs:403:1: 405:2 (#0)",
    "pieces": [
      "src/hash.rs:403:1: 405:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn hash_reset_tuning(mut tuning: *mut Hash_tuning) {\n    *tuning = default_tuning;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/hash.rs:122:1: 131:3 (#0)",
        "source": "static mut default_tuning: Hash_tuning = {\n    let mut init = hash_tuning {\n        shrink_threshold: 0.0f32,\n        shrink_factor: 1.0f32,\n        growth_threshold: 0.8f32,\n        growth_factor: 1.414f32,\n        is_n_buckets: 0 as libc::c_int != 0,\n    };\n    init\n};"
      }
    ],
    "imports": [
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:375 ~ rust[fc84]::src::hash::raw_comparator)",
    "span": "src/hash.rs:411:1: 416:2 (#0)",
    "pieces": [
      "src/hash.rs:411:1: 416:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn raw_comparator(\n    mut a: *const libc::c_void,\n    mut b: *const libc::c_void,\n) -> bool {\n    return a == b;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1071 ~ rust[fc84]::src::quotearg::quotearg_mem)",
    "span": "src/quotearg.rs:1385:1: 1393:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1385:1: 1393:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1144 ~ rust[fc84]::src::stat_time::get_stat_ctime)",
    "span": "src/stat_time.rs:83:1: 89:2 (#0)",
    "pieces": [
      "src/stat_time.rs:83:1: 89:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn get_stat_ctime(mut st: *const stat) -> timespec {\n    return (*st).st_ctim;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stat_time.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stat_time.rs:9:1: 9:18 (#0)",
        "source": "use libc::time_t;"
      },
      {
        "span": "src/stat_time.rs:12:1: 12:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/stat_time.rs:10:1: 10:18 (#0)",
        "source": "use libc::c_long;"
      },
      {
        "span": "src/stat_time.rs:7:1: 7:23 (#0)",
        "source": "use std::fs::Metadata;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:129 ~ rust[fc84]::src::c_strtod::c_locale)",
    "span": "src/c_strtod.rs:31:1: 51:2 (#0)",
    "pieces": [
      "src/c_strtod.rs:31:1: 51:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 24,
    "source": "unsafe extern \"C\" fn c_locale() -> locale_t {\n    if c_locale_cache.is_null() {\n        ::core::ptr::write_volatile(\n            &mut c_locale_cache as *mut locale_t,\n            newlocale(\n                (1 as libc::c_int) << 0 as libc::c_int\n                    | (1 as libc::c_int) << 1 as libc::c_int\n                    | (1 as libc::c_int) << 2 as libc::c_int\n                    | (1 as libc::c_int) << 3 as libc::c_int\n                    | (1 as libc::c_int) << 4 as libc::c_int\n                    | (1 as libc::c_int) << 5 as libc::c_int\n                    | (1 as libc::c_int) << 7 as libc::c_int\n                    | (1 as libc::c_int) << 8 as libc::c_int\n                    | (1 as libc::c_int) << 9 as libc::c_int\n                    | (1 as libc::c_int) << 10 as libc::c_int\n                    | (1 as libc::c_int) << 11 as libc::c_int\n                    | (1 as libc::c_int) << 12 as libc::c_int,\n                b\"C\\0\" as *const u8 as *const libc::c_char,\n                0 as locale_t,\n            ),\n        );\n    }\n    return c_locale_cache;\n}",
    "calls": [
      {
        "caller": "DefId(0:186 ~ rust[fc84]::src::c_strtod::c_strtod)",
        "span": "src/c_strtod.rs:58:5: 58:29 (#0)",
        "source": "let locale = c_locale();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strtod.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_strtod.rs:2:25: 2:29 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/c_strtod.rs:32:27: 32:32 (#0)",
        "source": "Mutex"
      },
      {
        "span": "src/c_strtod.rs:32:21: 32:25 (#0)",
        "source": "Once"
      },
      {
        "span": "src/c_strtod.rs:32:5: 32:34 (#0)",
        "source": "use std::sync::{Once, Mutex};"
      },
      {
        "span": "src/c_strtod.rs:2:1: 2:31 (#0)",
        "source": "use std::ffi::{CString, CStr};"
      },
      {
        "span": "src/c_strtod.rs:2:16: 2:23 (#0)",
        "source": "CString"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:130 ~ rust[fc84]::src::c_strtod::c_strtod)",
    "span": "src/c_strtod.rs:54:1: 73:2 (#0)",
    "pieces": [
      "src/c_strtod.rs:54:1: 73:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn c_strtod(\n    mut nptr: *const libc::c_char,\n    mut endptr: *mut *mut libc::c_char,\n) -> libc::c_double {\n    let mut r: libc::c_double = 0.;\n    let mut locale: locale_t = c_locale();\n    if locale.is_null() {\n        if !endptr.is_null() {\n            *endptr = nptr as *mut libc::c_char;\n        }\n        return 0 as libc::c_int as libc::c_double;\n    }\n    r = strtod_l(nptr, endptr, locale);\n    return r;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strtod.rs:32:5: 32:34 (#0)",
        "source": "use std::sync::{Once, Mutex};"
      },
      {
        "span": "src/c_strtod.rs:2:16: 2:23 (#0)",
        "source": "CString"
      },
      {
        "span": "src/c_strtod.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_strtod.rs:2:1: 2:31 (#0)",
        "source": "use std::ffi::{CString, CStr};"
      },
      {
        "span": "src/c_strtod.rs:2:25: 2:29 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/c_strtod.rs:32:21: 32:25 (#0)",
        "source": "Once"
      },
      {
        "span": "src/c_strtod.rs:32:27: 32:32 (#0)",
        "source": "Mutex"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:117 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
    "span": "src/c_strcasecmp.rs:14:1: 30:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:14:1: 30:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "pub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_strcasecmp.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:459 ~ rust[fc84]::src::iopoll::fclose_wait)",
    "span": "src/iopoll.rs:237:1: 244:2 (#0)",
    "pieces": [
      "src/iopoll.rs:237:1: 244:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn fclose_wait(mut f: *mut FILE) -> bool {\n    while !(fflush_unlocked(f) == 0 as libc::c_int) {\n        if !fwait_for_nonblocking_write(f) {\n            break;\n        }\n    }\n    return rpl_fclose(f) == 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/iopoll.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/iopoll.rs:6:1: 6:30 (#0)",
        "source": "use std::os::unix::io::RawFd;"
      },
      {
        "span": "src/iopoll.rs:8:1: 8:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:240 ~ rust[fc84]::src::fclose::rpl_fclose)",
    "span": "src/fclose.rs:53:1: 78:2 (#0)",
    "pieces": [
      "src/fclose.rs:53:1: 78:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fclose.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1149 ~ rust[fc84]::src::stat_time::get_stat_atime_ns)",
    "span": "src/stat_time.rs:126:1: 128:2 (#0)",
    "pieces": [
      "src/stat_time.rs:126:1: 128:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn get_stat_atime_ns(mut st: *const stat) -> libc::c_long {\n    return (*st).st_atim.tv_nsec;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stat_time.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stat_time.rs:10:1: 10:18 (#0)",
        "source": "use libc::c_long;"
      },
      {
        "span": "src/stat_time.rs:7:1: 7:23 (#0)",
        "source": "use std::fs::Metadata;"
      },
      {
        "span": "src/stat_time.rs:12:1: 12:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/stat_time.rs:9:1: 9:18 (#0)",
        "source": "use libc::time_t;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1046 ~ rust[fc84]::src::quotearg::clone_quoting_options)",
    "span": "src/quotearg.rs:185:1: 192:2 (#0)",
    "pieces": [
      "src/quotearg.rs:185:1: 192:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:177:1: 183:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:356 ~ rust[fc84]::src::hash::rotr_sz)",
    "span": "src/hash.rs:116:1: 120:2 (#0)",
    "pieces": [
      "src/hash.rs:116:1: 120:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn rotr_sz(mut x: size_t, mut n: libc::c_int) -> size_t {\n    return (x >> n\n        | x\n            << (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<size_t>() as libc::c_ulong)\n                .wrapping_sub(n as libc::c_ulong))\n        & 18446744073709551615 as libc::c_ulong;\n}",
    "calls": [
      {
        "caller": "DefId(0:491 ~ rust[fc84]::src::hash::raw_hasher)",
        "span": "src/hash.rs:408:5: 408:44 (#0)",
        "source": "let val: u64 = rotr_sz(data as u64, 3);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:898 ~ rust[fc84]::src::mbrtoc32::mbszero)",
    "span": "src/mbrtoc32.rs:37:1: 41:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:37:1: 41:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:1030 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
        "span": "src/mbrtoc32.rs:64:9: 64:27 (#0)",
        "source": "mbszero(&mut *ps);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1080 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
    "span": "src/quotearg.rs:1473:1: 1477:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1473:1: 1477:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:35:1: 35:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:22:5: 22:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:90 ~ rust[fc84]::src::bitrotate::rotr64)",
    "span": "src/bitrotate.rs:92:1: 95:2 (#0)",
    "pieces": [
      "src/bitrotate.rs:92:1: 95:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn rotr64(mut x: uint64_t, mut n: libc::c_int) -> uint64_t {\n    return (x >> n | x << 64 as libc::c_int - n) & 18446744073709551615 as libc::c_ulong;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/bitrotate.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/bitrotate.rs:8:1: 8:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/bitrotate.rs:12:1: 12:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/bitrotate.rs:10:5: 10:23 (#0)",
        "source": "std::num::Wrapping"
      },
      {
        "span": "src/bitrotate.rs:10:1: 10:24 (#0)",
        "source": "use std::num::Wrapping;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1160 ~ rust[fc84]::src::timespec::timespectod)",
    "span": "src/timespec.rs:65:1: 68:2 (#0)",
    "pieces": [
      "src/timespec.rs:65:1: 68:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn timespectod(mut a: timespec) -> libc::c_double {\n    return a.tv_sec as libc::c_double + a.tv_nsec as libc::c_double / 1e9f64;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/timespec.rs:8:1: 8:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/timespec.rs:3:1: 3:25 (#0)",
        "source": "use std::time::Duration;"
      },
      {
        "span": "src/timespec.rs:4:1: 4:27 (#0)",
        "source": "use std::time::SystemTime;"
      },
      {
        "span": "src/timespec.rs:6:1: 6:15 (#0)",
        "source": "use std::time;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1220 ~ rust[fc84]::src::xbinary_io::xset_binary_mode_error)",
    "span": "src/xbinary_io.rs:19:1: 23:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:19:1: 23:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 1,
    "source": "pub unsafe extern \"C\" fn xset_binary_mode_error() {}",
    "calls": [
      {
        "caller": "DefId(0:1428 ~ rust[fc84]::src::xbinary_io::xset_binary_mode)",
        "span": "src/xbinary_io.rs:12:9: 12:34 (#0)",
        "source": "xset_binary_mode_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:110 ~ rust[fc84]::src::c_ctype::c_tolower)",
    "span": "src/c_ctype.rs:149:1: 154:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:149:1: 154:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:19:1: 19:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1221 ~ rust[fc84]::src::xbinary_io::set_binary_mode)",
    "span": "src/xbinary_io.rs:26:1: 28:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:26:1: 28:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1285 ~ rust[fc84]::src::xmalloc::ximemdup)",
    "span": "src/xmalloc.rs:996:1: 1001:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:996:1: 1001:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:384 ~ rust[fc84]::src::hash::transfer_entries)",
    "span": "src/hash.rs:666:1: 721:2 (#0)",
    "pieces": [
      "src/hash.rs:666:1: 721:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 56,
    "source": "unsafe extern \"C\" fn transfer_entries(\n    mut dst: *mut Hash_table,\n    mut src: *mut Hash_table,\n    mut safe: bool,\n) -> bool {\n    let mut bucket: *mut hash_entry = 0 as *mut hash_entry;\n    let mut cursor: *mut hash_entry = 0 as *mut hash_entry;\n    let mut next: *mut hash_entry = 0 as *mut hash_entry;\n    bucket = (*src).bucket;\n    while bucket < (*src).bucket_limit as *mut hash_entry {\n        if !((*bucket).data).is_null() {\n            let mut data: *mut libc::c_void = 0 as *mut libc::c_void;\n            let mut new_bucket: *mut hash_entry = 0 as *mut hash_entry;\n            cursor = (*bucket).next;\n            while !cursor.is_null() {\n                data = (*cursor).data;\n                new_bucket = safe_hasher(dst, data);\n                next = (*cursor).next;\n                if !((*new_bucket).data).is_null() {\n                    (*cursor).next = (*new_bucket).next;\n                    (*new_bucket).next = cursor;\n                } else {\n                    (*new_bucket).data = data;\n                    (*dst).n_buckets_used = ((*dst).n_buckets_used).wrapping_add(1);\n                    (*dst).n_buckets_used;\n                    free_entry(dst, cursor);\n                }\n                cursor = next;\n            }\n            data = (*bucket).data;\n            (*bucket).next = 0 as *mut hash_entry;\n            if !safe {\n                new_bucket = safe_hasher(dst, data);\n                if !((*new_bucket).data).is_null() {\n                    let mut new_entry: *mut hash_entry = allocate_entry(dst);\n                    if new_entry.is_null() {\n                        return 0 as libc::c_int != 0;\n                    }\n                    (*new_entry).data = data;\n                    (*new_entry).next = (*new_bucket).next;\n                    (*new_bucket).next = new_entry;\n                } else {\n                    (*new_bucket).data = data;\n                    (*dst).n_buckets_used = ((*dst).n_buckets_used).wrapping_add(1);\n                    (*dst).n_buckets_used;\n                }\n                (*bucket).data = 0 as *mut libc::c_void;\n                (*src).n_buckets_used = ((*src).n_buckets_used).wrapping_sub(1);\n                (*src).n_buckets_used;\n            }\n        }\n        bucket = bucket.offset(1);\n        bucket;\n    }\n    return 1 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:62 ~ rust[fc84]::src::basename_lgpl::base_len)",
    "span": "src/basename_lgpl.rs:27:1: 43:2 (#0)",
    "pieces": [
      "src/basename_lgpl.rs:27:1: 43:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 25,
    "source": "pub unsafe extern \"C\" fn base_len(mut name: *const libc::c_char) -> size_t {\n    let mut len: size_t = 0;\n    let mut prefix_len: size_t = 0 as libc::c_int as size_t;\n    len = strlen(name);\n    while (1 as libc::c_int as libc::c_ulong) < len\n        && *name.offset(len.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_int == '/' as i32\n    {\n        len = len.wrapping_sub(1);\n        len;\n    }\n    if 0 as libc::c_int != 0 && len == 1 as libc::c_int as libc::c_ulong\n        && *name.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32\n        && *name.offset(1 as libc::c_int as isize) as libc::c_int == '/' as i32\n        && *name.offset(2 as libc::c_int as isize) == 0\n    {\n        return 2 as libc::c_int as size_t;\n    }\n    if 0 as libc::c_int != 0 && prefix_len != 0 && len == prefix_len\n        && *name.offset(prefix_len as isize) as libc::c_int == '/' as i32\n    {\n        return prefix_len.wrapping_add(1 as libc::c_int as libc::c_ulong);\n    }\n    return len;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/basename_lgpl.rs:2:1: 2:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/basename_lgpl.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:251 ~ rust[fc84]::src::fcntl::rpl_fcntl)",
    "span": "src/fcntl.rs:24:1: 63:2 (#0)",
    "pieces": [
      "src/fcntl.rs:24:1: 63:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 136,
    "source": "pub unsafe extern \"C\" fn rpl_fcntl(\n    mut fd: libc::c_int,\n    mut action: libc::c_int,\n    mut args: ...\n) -> libc::c_int {\n    let mut arg: ::core::ffi::VaListImpl;\n    let mut result: libc::c_int = -(1 as libc::c_int);\n    arg = args.clone();\n    match action {\n        0 => {\n            let mut target: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD(fd, target);\n        }\n        1030 => {\n            let mut target_0: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD_CLOEXEC(fd, target_0);\n        }\n        _ => {\n            let mut current_block_7: u64;\n            match action {\n                1 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                3 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                1025 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                9 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                1032 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                1034 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                11 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                1033 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                0 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                1030 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                1026 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                2 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                4 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                8 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1031 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1024 | 10 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {\n                    let mut p: *mut libc::c_void = arg.arg::<*mut libc::c_void>();\n                    result = fcntl(fd, action, p);\n                    current_block_7 = 7175849428784450219;\n                }\n            }\n            match current_block_7 {\n                4046302689674688614 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                8871774344836507656 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                12013198723313890981 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6453289516101043606 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                5351856672558463576 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                13722137258147953758 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                9332010126091029806 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                12766345184754617216 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                17966572639739034653 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6940526744265269810 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                15280576717888187136 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                7022052692272556539 => {\n                    result = fcntl(fd, action);\n                }\n                14034191772621753005 => {\n                    let mut x: libc::c_int = arg.arg::<libc::c_int>();\n                    result = fcntl(fd, action, x);\n                }\n                _ => {}\n            }\n        }\n    }\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fcntl.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fcntl.rs:4:1: 4:22 (#0)",
        "source": "use std::ffi::VaList;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:900 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
    "span": "src/mbrtoc32.rs:48:1: 78:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:48:1: 78:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 31,
    "source": "pub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/mbrtoc32.rs:43:1: 46:3 (#0)",
        "source": "static mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};"
      }
    ],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:87 ~ rust[fc84]::src::bitrotate::rotl_sz)",
    "span": "src/bitrotate.rs:68:1: 71:2 (#0)",
    "pieces": [
      "src/bitrotate.rs:68:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn rotl_sz(mut x: size_t, mut n: libc::c_int) -> size_t {\n    return (x << n\n        | x\n            >> (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<size_t>() as libc::c_ulong)\n                .wrapping_sub(n as libc::c_ulong))\n        & 18446744073709551615 as libc::c_ulong;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/bitrotate.rs:10:5: 10:23 (#0)",
        "source": "std::num::Wrapping"
      },
      {
        "span": "src/bitrotate.rs:8:1: 8:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/bitrotate.rs:14:1: 14:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/bitrotate.rs:12:1: 12:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/bitrotate.rs:10:1: 10:24 (#0)",
        "source": "use std::num::Wrapping;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1157 ~ rust[fc84]::src::timespec::make_timespec)",
    "span": "src/timespec.rs:21:1: 24:2 (#0)",
    "pieces": [
      "src/timespec.rs:21:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn make_timespec(mut s: time_t, mut ns: libc::c_long) -> timespec {\n    return {\n        let mut init = timespec { tv_sec: s, tv_nsec: ns };\n        init\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/timespec.rs:4:1: 4:27 (#0)",
        "source": "use std::time::SystemTime;"
      },
      {
        "span": "src/timespec.rs:6:1: 6:15 (#0)",
        "source": "use std::time;"
      },
      {
        "span": "src/timespec.rs:3:1: 3:25 (#0)",
        "source": "use std::time::Duration;"
      },
      {
        "span": "src/timespec.rs:8:1: 8:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:186 ~ rust[fc84]::src::closeout::close_stdout)",
    "span": "src/closeout.rs:82:1: 177:2 (#0)",
    "pieces": [
      "src/closeout.rs:82:1: 177:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 96,
    "source": "pub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:64:1: 64:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/closeout.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:979 ~ rust[fc84]::src::propername_lite::proper_name_lite)",
    "span": "src/propername_lite.rs:8:1: 24:2 (#0)",
    "pieces": [
      "src/propername_lite.rs:8:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "pub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/propername_lite.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1307 ~ rust[fc84]::src::xstrtod::xstrtod)",
    "span": "src/xstrtod.rs:6:1: 36:2 (#0)",
    "pieces": [
      "src/xstrtod.rs:6:1: 36:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 31,
    "source": "pub unsafe extern \"C\" fn xstrtod(\n    mut str: *const libc::c_char,\n    mut ptr: *mut *const libc::c_char,\n    mut result: *mut libc::c_double,\n    mut convert: Option::<\n        unsafe extern \"C\" fn(\n            *const libc::c_char,\n            *mut *mut libc::c_char,\n        ) -> libc::c_double,\n    >,\n) -> bool {\n    let mut val: libc::c_double = 0.;\n    let mut terminator: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    *__errno_location() = 0 as libc::c_int;\n    val = convert.expect(\"non-null function pointer\")(str, &mut terminator);\n    if terminator == str as *mut libc::c_char\n        || ptr.is_null() && *terminator as libc::c_int != '\\0' as i32\n    {\n        ok = 0 as libc::c_int != 0;\n    } else if val != 0 as libc::c_int as libc::c_double\n        && *__errno_location() == 34 as libc::c_int\n    {\n        ok = 0 as libc::c_int != 0;\n    }\n    if !ptr.is_null() {\n        *ptr = terminator;\n    }\n    *result = val;\n    return ok;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xstrtod.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:215 ~ rust[fc84]::src::dup_safer::dup_safer)",
    "span": "src/dup_safer.rs:8:1: 16:2 (#0)",
    "pieces": [
      "src/dup_safer.rs:8:1: 16:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn dup_safer(mut fd: libc::c_int) -> libc::c_int {\n    return rpl_fcntl(fd, 0 as libc::c_int, 2 as libc::c_int + 1 as libc::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/dup_safer.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/dup_safer.rs:10:5: 10:40 (#0)",
        "source": "use std::os::unix::net::UnixStream;"
      },
      {
        "span": "src/dup_safer.rs:9:5: 9:36 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/dup_safer.rs:1:1: 1:34 (#0)",
        "source": "use std::os::unix::io::FromRawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:405 ~ rust[fc84]::src::ialloc::irealloc)",
    "span": "src/ialloc.rs:69:1: 78:2 (#0)",
    "pieces": [
      "src/ialloc.rs:69:1: 78:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:5:1: 5:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:1:1: 1:24 (#0)",
        "source": "use std::alloc::Layout;"
      },
      {
        "span": "src/ialloc.rs:3:1: 3:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1219 ~ rust[fc84]::src::xbinary_io::xset_binary_mode)",
    "span": "src/xbinary_io.rs:10:1: 14:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:10:1: 14:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1341 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
    "span": "src/xstrtoumax.rs:345:1: 513:2 (#0)",
    "pieces": [
      "src/xstrtoumax.rs:345:1: 352:4 (#0)",
      "src/xstrtoumax.rs:422:1: 422:4 (#0)",
      "src/xstrtoumax.rs:513:1: 513:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xstrtoumax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut uintmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [],
    "globals": [
      {
        "span": "src/xstrtoumax.rs:28:1: 28:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      },
      {
        "span": "src/xstrtoumax.rs:24:1: 24:45 (#0)",
        "source": "pub const LONGINT_INVALID: strtol_error = 4;"
      },
      {
        "span": "src/xstrtoumax.rs:27:1: 27:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xstrtoumax.rs:26:1: 26:57 (#0)",
        "source": "pub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoumax.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/xstrtoumax.rs:352:5: 421:6 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:352:5: 421:6 (#0)"
        ],
        "num_lines": 70,
        "source": "let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: uintmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 79],\n                &[libc::c_char; 79],\n            >(\n                b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2256: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 79],\n                    &[libc::c_char; 79],\n                >(\n                    b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoumax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as uintmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *const i8",
          "mut ptr: *mut *mut i8",
          "mut strtol_base: i32",
          "mut val: *mut u64",
          "mut valid_suffixes: *const i8"
        ],
        "live_out": [
          "mut s: *const i8",
          "mut ptr: *mut *mut i8",
          "mut strtol_base: i32",
          "mut val: *mut u64",
          "mut valid_suffixes: *const i8",
          "mut t_ptr: *mut i8",
          "mut p: *mut *mut i8",
          "mut tmp: u64",
          "mut err: u32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/xstrtoumax.rs:422:5: 511:12 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:422:5: 511:12 (#0)"
        ],
        "num_lines": 102,
        "source": "if **p as libc::c_int != '\\0' as i32 {\n        let mut base: libc::c_int = 1024 as libc::c_int;\n        let mut suffixes: libc::c_int = 1 as libc::c_int;\n        let mut overflow: strtol_error = LONGINT_OK;\n        if (strchr(valid_suffixes, **p as libc::c_int)).is_null() {\n            *val = tmp;\n            return (err as libc::c_uint\n                | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                as strtol_error;\n        }\n        match **p as libc::c_int {\n            69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n                if !(strchr(valid_suffixes, '0' as i32)).is_null() {\n                    match *(*p.offset(0 as libc::c_int as isize))\n                        .offset(1 as libc::c_int as isize) as libc::c_int\n                    {\n                        105 => {\n                            if *(*p.offset(0 as libc::c_int as isize))\n                                .offset(2 as libc::c_int as isize) as libc::c_int\n                                == 'B' as i32\n                            {\n                                suffixes += 2 as libc::c_int;\n                            }\n                        }\n                        66 | 68 => {\n                            base = 1000 as libc::c_int;\n                            suffixes += 1;\n                            suffixes;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n            _ => {}\n        }\n        match **p as libc::c_int {\n            98 => {\n                overflow = bkm_scale(&mut tmp, 512 as libc::c_int);\n            }\n            66 => {\n                overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);\n            }\n            99 => {\n                overflow = LONGINT_OK;\n            }\n            69 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);\n            }\n            71 | 103 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);\n            }\n            107 | 75 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);\n            }\n            77 | 109 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);\n            }\n            80 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);\n            }\n            81 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);\n            }\n            82 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);\n            }\n            84 | 116 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);\n            }\n            119 => {\n                overflow = bkm_scale(&mut tmp, 2 as libc::c_int);\n            }\n            89 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);\n            }\n            90 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);\n            }\n            _ => {\n                *val = tmp;\n                return (err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                    as strtol_error;\n            }\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | overflow as libc::c_uint);\n        *p = (*p).offset(suffixes as isize);\n        if **p != 0 {\n            err = ::core::mem::transmute::<\n                libc::c_uint,\n                strtol_error,\n            >(\n                err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint,\n            );\n        }\n    }\n    *val = tmp;\n    return err;",
        "sub_chunks": [],
        "live_in": [
          "mut val: *mut u64",
          "mut valid_suffixes: *const i8",
          "mut p: *mut *mut i8",
          "mut tmp: u64",
          "mut err: u32"
        ],
        "live_out": [
          "mut val: *mut u64",
          "mut valid_suffixes: *const i8",
          "mut p: *mut *mut i8",
          "mut tmp: u64",
          "mut err: u32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:374 ~ rust[fc84]::src::hash::raw_hasher)",
    "span": "src/hash.rs:407:1: 410:2 (#0)",
    "pieces": [
      "src/hash.rs:407:1: 410:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn raw_hasher(mut data: *const libc::c_void, mut n: size_t) -> size_t {\n    let mut val: size_t = rotr_sz(data as size_t, 3 as libc::c_int);\n    return val.wrapping_rem(n);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hash.rs:21:1: 21:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/hash.rs:22:1: 22:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/hash.rs:17:1: 17:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/hash.rs:24:1: 24:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hash.rs:15:1: 15:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/hash.rs:13:36: 13:44 (#0)",
        "source": "Ordering"
      },
      {
        "span": "src/hash.rs:13:25: 13:34 (#0)",
        "source": "AtomicPtr"
      },
      {
        "span": "src/hash.rs:138:1: 138:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/hash.rs:13:1: 13:46 (#0)",
        "source": "use std::sync::atomic::{AtomicPtr, Ordering};"
      },
      {
        "span": "src/hash.rs:19:1: 19:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/hash.rs:20:1: 20:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1300 ~ rust[fc84]::src::xnanosleep::xnanosleep)",
    "span": "src/xnanosleep.rs:20:1: 48:2 (#0)",
    "pieces": [
      "src/xnanosleep.rs:20:1: 48:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "pub unsafe extern \"C\" fn xnanosleep(mut seconds: libc::c_double) -> libc::c_int {\n    if 1.0f64\n        + (if (0 as libc::c_int as time_t) < -(1 as libc::c_int) as time_t {\n            -(1 as libc::c_int) as time_t\n        } else {\n            (((1 as libc::c_int as time_t)\n                << (::core::mem::size_of::<time_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        }) as libc::c_double <= seconds\n    {\n        loop {\n            pause();\n            if !(*__errno_location() == 4 as libc::c_int) {\n                break;\n            }\n        }\n    }\n    let mut ts_sleep: timespec = dtotimespec(seconds);\n    loop {\n        *__errno_location() = 0 as libc::c_int;\n        if rpl_nanosleep(&mut ts_sleep, &mut ts_sleep) == 0 as libc::c_int {\n            break;\n        }\n        if *__errno_location() != 4 as libc::c_int\n            && *__errno_location() != 0 as libc::c_int\n        {\n            return -(1 as libc::c_int);\n        }\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xnanosleep.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xnanosleep.rs:1:1: 1:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1240 ~ rust[fc84]::src::xdectoumax::xdectoumax)",
    "span": "src/xdectoumax.rs:29:1: 47:2 (#0)",
    "pieces": [
      "src/xdectoumax.rs:29:1: 47:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xdectoumax(\n    mut n_str: *const libc::c_char,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    return xnumtoumax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xdectoumax.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:200 ~ tail[5173]::die_pipe)",
    "span": "src/tail.rs:1064:1: 1066:2 (#0)",
    "pieces": [
      "src/tail.rs:1064:1: 1066:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn die_pipe() {\n    raise(13 as libc::c_int);\n    exit(1 as libc::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:239 ~ tail[5173]::check_output_alive)",
        "span": "src/tail.rs:1074:9: 1074:20 (#0)",
        "source": "die_pipe();"
      },
      {
        "caller": "DefId(0:290 ~ tail[5173]::tail_forever_inotify)",
        "span": "src/tail.rs:3622:17: 3622:28 (#0)",
        "source": "die_pipe();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:201 ~ tail[5173]::check_output_alive)",
    "span": "src/tail.rs:1068:1: 1076:2 (#0)",
    "pieces": [
      "src/tail.rs:1068:1: 1076:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "unsafe extern \"C\" fn check_output_alive() {\n    if !monitor_output {\n        return;\n    }\n    if iopoll(-(1 as libc::c_int), 1 as libc::c_int, 0 as libc::c_int != 0)\n        == -(2 as libc::c_int)\n    {\n        die_pipe();\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:279 ~ tail[5173]::tail_forever)",
        "span": "src/tail.rs:3021:5: 3021:26 (#0)",
        "source": "check_output_alive();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:202 ~ tail[5173]::valid_file_spec)",
    "span": "src/tail.rs:1078:1: 1081:2 (#0)",
    "pieces": [
      "src/tail.rs:1078:1: 1081:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn valid_file_spec(mut f: *const File_spec) -> bool {\n    return ((*f).fd == -(1 as libc::c_int)) as libc::c_int\n        ^ ((*f).errnum == 0 as libc::c_int) as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:208 ~ tail[5173]::xwrite_stdout)",
    "span": "src/tail.rs:1167:1: 1228:2 (#0)",
    "pieces": [
      "src/tail.rs:1167:1: 1228:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 62,
    "source": "unsafe extern \"C\" fn xwrite_stdout(\n    mut buffer: *const libc::c_char,\n    mut n_bytes: size_t,\n) {\n    if n_bytes > 0 as libc::c_int as libc::c_ulong\n        && fwrite_unlocked(\n            buffer as *const libc::c_void,\n            1 as libc::c_int as size_t,\n            n_bytes,\n            stdout,\n        ) < n_bytes\n    {\n        clearerr_unlocked(stdout);\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:258 ~ tail[5173]::pipe_lines)",
        "span": "src/tail.rs:1852:13: 1852:89 (#0)",
        "source": "xwrite_stdout(beg, buffer_end_0.offset_from(beg) as libc::c_long as size_t);"
      },
      {
        "caller": "DefId(0:247 ~ tail[5173]::dump_remainder)",
        "span": "src/tail.rs:1315:13: 1315:60 (#0)",
        "source": "xwrite_stdout(buffer.as_mut_ptr(), bytes_read);"
      },
      {
        "caller": "DefId(0:259 ~ tail[5173]::pipe_bytes)",
        "span": "src/tail.rs:1984:9: 1987:11 (#0)",
        "source": "xwrite_stdout(\n            &mut *((*tmp).buffer).as_mut_ptr().offset(i as isize),\n            ((*tmp).nbytes).wrapping_sub(i),\n        );"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:206 ~ tail[5173]::write_header)",
    "span": "src/tail.rs:1154:1: 1166:2 (#0)",
    "pieces": [
      "src/tail.rs:1154:1: 1166:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn write_header(mut pretty_filename: *const libc::c_char) {\n    static mut first_file: bool = 1 as libc::c_int != 0;\n    printf(\n        b\"%s==> %s <==\\n\\0\" as *const u8 as *const libc::c_char,\n        if first_file as libc::c_int != 0 {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\n\\0\" as *const u8 as *const libc::c_char\n        },\n        pretty_filename,\n    );\n    first_file = 0 as libc::c_int != 0;\n}",
    "calls": [
      {
        "caller": "DefId(0:247 ~ tail[5173]::dump_remainder)",
        "span": "src/tail.rs:1312:17: 1312:47 (#0)",
        "source": "write_header(pretty_filename);"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4216:9: 4216:38 (#0)",
        "source": "write_header(pretty_name(f));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:209 ~ tail[5173]::dump_remainder)",
    "span": "src/tail.rs:1229:1: 1333:2 (#0)",
    "pieces": [
      "src/tail.rs:1229:1: 1333:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 105,
    "source": "unsafe extern \"C\" fn dump_remainder(\n    mut want_header: bool,\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n) -> uintmax_t {\n    let mut n_written: uintmax_t = 0;\n    let mut n_remaining: uintmax_t = n_bytes;\n    n_written = 0 as libc::c_int as uintmax_t;\n    loop {\n        let mut buffer: [libc::c_char; 8192] = [0; 8192];\n        let mut n: size_t = if n_remaining < 8192 as libc::c_int as libc::c_ulong {\n            n_remaining\n        } else {\n            8192 as libc::c_int as libc::c_ulong\n        };\n        let mut bytes_read: size_t = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            n,\n        );\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if *__errno_location() != 11 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_filename,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_filename,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            break;\n        } else {\n            if bytes_read == 0 as libc::c_int as libc::c_ulong {\n                break;\n            }\n            if want_header {\n                write_header(pretty_filename);\n                want_header = 0 as libc::c_int != 0;\n            }\n            xwrite_stdout(buffer.as_mut_ptr(), bytes_read);\n            n_written = (n_written as libc::c_ulong).wrapping_add(bytes_read)\n                as uintmax_t as uintmax_t;\n            if !(n_bytes != 18446744073709551615 as libc::c_ulong) {\n                continue;\n            }\n            n_remaining = (n_remaining as libc::c_ulong).wrapping_sub(bytes_read)\n                as uintmax_t as uintmax_t;\n            if n_remaining == 0 as libc::c_int as libc::c_ulong\n                || n_bytes\n                    == (18446744073709551615 as libc::c_ulong)\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n            {\n                break;\n            }\n        }\n    }\n    return n_written;\n}",
    "calls": [
      {
        "caller": "DefId(0:253 ~ tail[5173]::file_lines)",
        "span": "src/tail.rs:1604:17: 1612:23 (#0)",
        "source": "*read_pos = (start_pos as libc::c_ulong)\n                    .wrapping_add(\n                        dump_remainder(\n                            0 as libc::c_int != 0,\n                            pretty_filename,\n                            fd,\n                            end_pos as uintmax_t,\n                        ),\n                    );"
      },
      {
        "caller": "DefId(0:288 ~ tail[5173]::check_fspec)",
        "span": "src/tail.rs:3252:5: 3257:7 (#0)",
        "source": "let mut bytes_read: uintmax_t = dump_remainder(\n        want_header,\n        name,\n        (*fspec).fd,\n        18446744073709551615 as libc::c_ulong,\n    );"
      },
      {
        "caller": "DefId(0:304 ~ tail[5173]::tail_lines)",
        "span": "src/tail.rs:4092:9: 4100:41 (#0)",
        "source": "*read_pos = (*read_pos as libc::c_ulong)\n            .wrapping_add(\n                dump_remainder(\n                    0 as libc::c_int != 0,\n                    pretty_filename,\n                    fd,\n                    18446744073709551615 as libc::c_ulong,\n                ),\n            ) as uintmax_t as uintmax_t;"
      },
      {
        "caller": "DefId(0:294 ~ tail[5173]::tail_bytes)",
        "span": "src/tail.rs:4016:5: 4019:37 (#0)",
        "source": "*read_pos = (*read_pos as libc::c_ulong)\n        .wrapping_add(\n            dump_remainder(0 as libc::c_int != 0, pretty_filename, fd, n_bytes),\n        ) as uintmax_t as uintmax_t;"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:212 ~ tail[5173]::xlseek)",
    "span": "src/tail.rs:1334:1: 1452:2 (#0)",
    "pieces": [
      "src/tail.rs:1334:1: 1349:12 (#0)",
      "src/tail.rs:1380:1: 1382:12 (#0)",
      "src/tail.rs:1413:1: 1415:12 (#0)",
      "src/tail.rs:1446:1: 1452:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1,
      2
    ],
    "num_lines": 29,
    "source": "unsafe extern \"C\" fn xlseek(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n    mut filename: *const libc::c_char,\n) -> off_t {\n    let mut new_offset: off_t = lseek(fd, offset, whence);\n    let mut buf: [libc::c_char; 21] = [0; 21];\n    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;\n    if 0 as libc::c_int as libc::c_long <= new_offset {\n        return new_offset;\n    }\n    s = offtostr(offset, buf.as_mut_ptr());\n    match whence {\n        0 => {\n           <<chunk 0>>        }\n        1 => {\n           <<chunk 1>>        }\n        2 => {\n           <<chunk 2>>        }\n        _ => {\n            unreachable!();\n        }\n    }\n    panic!(\"Reached end of non-void function without returning\");\n}",
    "calls": [
      {
        "caller": "DefId(0:294 ~ tail[5173]::tail_bytes)",
        "span": "src/tail.rs:4011:17: 4011:76 (#0)",
        "source": "xlseek(fd, current_pos, 0 as libc::c_int, pretty_filename);"
      },
      {
        "caller": "DefId(0:253 ~ tail[5173]::file_lines)",
        "span": "src/tail.rs:1603:17: 1603:74 (#0)",
        "source": "xlseek(fd, start_pos, 0 as libc::c_int, pretty_filename);"
      },
      {
        "caller": "DefId(0:253 ~ tail[5173]::file_lines)",
        "span": "src/tail.rs:1519:5: 1519:56 (#0)",
        "source": "xlseek(fd, pos, 0 as libc::c_int, pretty_filename);"
      },
      {
        "caller": "DefId(0:304 ~ tail[5173]::tail_lines)",
        "span": "src/tail.rs:4132:17: 4132:74 (#0)",
        "source": "xlseek(fd, start_pos, 0 as libc::c_int, pretty_filename);"
      },
      {
        "caller": "DefId(0:288 ~ tail[5173]::check_fspec)",
        "span": "src/tail.rs:3242:9: 3242:80 (#0)",
        "source": "xlseek((*fspec).fd, 0 as libc::c_int as off_t, 0 as libc::c_int, name);"
      },
      {
        "caller": "DefId(0:253 ~ tail[5173]::file_lines)",
        "span": "src/tail.rs:1616:17: 1616:68 (#0)",
        "source": "xlseek(fd, pos, 0 as libc::c_int, pretty_filename);"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2687:13: 2687:85 (#0)",
        "source": "xlseek(fd, 0 as libc::c_int as off_t, 0 as libc::c_int, pretty_name(f));"
      },
      {
        "caller": "DefId(0:294 ~ tail[5173]::tail_bytes)",
        "span": "src/tail.rs:4000:13: 4005:15 (#0)",
        "source": "current_pos = xlseek(\n                fd,\n                0 as libc::c_int as off_t,\n                1 as libc::c_int,\n                pretty_filename,\n            );"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:391:1: 391:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/tail.rs:1349:13: 1378:2 (#0)",
        "pieces": [
          "src/tail.rs:1349:13: 1378:2 (#0)"
        ],
        "num_lines": 62,
        "source": "if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: cannot seek to offset %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                    s,\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot seek to offset %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                        s,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot seek to offset %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                        s,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };",
        "sub_chunks": [],
        "live_in": [
          "mut offset: i64",
          "mut filename: *const i8",
          "mut s: *mut i8",
          "__errstatus: i32",
          "__errstatus: i32"
        ],
        "live_out": [
          "mut offset: i64",
          "mut filename: *const i8",
          "mut s: *mut i8",
          "__errstatus: i32",
          "__errstatus: i32",
          "__errstatus: i32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/tail.rs:1382:13: 1411:2 (#0)",
        "pieces": [
          "src/tail.rs:1382:13: 1411:2 (#0)"
        ],
        "num_lines": 62,
        "source": "if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                    s,\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                        s,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                        s,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };",
        "sub_chunks": [],
        "live_in": [
          "mut offset: i64",
          "mut filename: *const i8",
          "mut s: *mut i8",
          "__errstatus: i32",
          "__errstatus: i32"
        ],
        "live_out": [
          "mut offset: i64",
          "mut filename: *const i8",
          "mut s: *mut i8",
          "__errstatus: i32",
          "__errstatus: i32",
          "__errstatus: i32"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/tail.rs:1415:13: 1444:2 (#0)",
        "pieces": [
          "src/tail.rs:1415:13: 1444:2 (#0)"
        ],
        "num_lines": 62,
        "source": "if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: cannot seek to end-relative offset %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                    s,\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot seek to end-relative offset %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                        s,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot seek to end-relative offset %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                        s,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };",
        "sub_chunks": [],
        "live_in": [
          "mut offset: i64",
          "mut filename: *const i8",
          "mut s: *mut i8",
          "errstatus: i32"
        ],
        "live_out": [
          "mut offset: i64",
          "mut filename: *const i8",
          "mut s: *mut i8",
          "errstatus: i32",
          "errstatus: i32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:221 ~ tail[5173]::pipe_bytes)",
    "span": "src/tail.rs:1870:1: 2000:2 (#0)",
    "pieces": [
      "src/tail.rs:1870:1: 2000:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 131,
    "source": "unsafe extern \"C\" fn pipe_bytes(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    let mut first: *mut CBUFFER = 0 as *mut CBUFFER;\n    let mut last: *mut CBUFFER = 0 as *mut CBUFFER;\n    let mut tmp: *mut CBUFFER = 0 as *mut CBUFFER;\n    let mut i: size_t = 0;\n    let mut total_bytes: size_t = 0 as libc::c_int as size_t;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut n_read: size_t = 0;\n    last = xmalloc(::core::mem::size_of::<CBUFFER>() as libc::c_ulong) as *mut CBUFFER;\n    first = last;\n    (*first).nbytes = 0 as libc::c_int as size_t;\n    (*first).next = 0 as *mut charbuffer;\n    tmp = xmalloc(::core::mem::size_of::<CBUFFER>() as libc::c_ulong) as *mut CBUFFER;\n    loop {\n        n_read = safe_read(\n            fd,\n            ((*tmp).buffer).as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if n_read == 0 as libc::c_int as libc::c_ulong\n            || n_read == -(1 as libc::c_int) as size_t\n        {\n            break;\n        }\n        *read_pos = (*read_pos as libc::c_ulong).wrapping_add(n_read) as uintmax_t\n            as uintmax_t;\n        (*tmp).nbytes = n_read;\n        (*tmp).next = 0 as *mut charbuffer;\n        total_bytes = (total_bytes as libc::c_ulong).wrapping_add((*tmp).nbytes)\n            as size_t as size_t;\n        if ((*tmp).nbytes).wrapping_add((*last).nbytes)\n            < 8192 as libc::c_int as libc::c_ulong\n        {\n            memcpy(\n                &mut *((*last).buffer).as_mut_ptr().offset((*last).nbytes as isize)\n                    as *mut libc::c_char as *mut libc::c_void,\n                ((*tmp).buffer).as_mut_ptr() as *const libc::c_void,\n                (*tmp).nbytes,\n            );\n            (*last)\n                .nbytes = ((*last).nbytes as libc::c_ulong).wrapping_add((*tmp).nbytes)\n                as size_t as size_t;\n        } else {\n            (*last).next = tmp;\n            last = (*last).next;\n            if total_bytes.wrapping_sub((*first).nbytes) > n_bytes {\n                tmp = first;\n                total_bytes = (total_bytes as libc::c_ulong)\n                    .wrapping_sub((*first).nbytes) as size_t as size_t;\n                first = (*first).next;\n            } else {\n                tmp = xmalloc(::core::mem::size_of::<CBUFFER>() as libc::c_ulong)\n                    as *mut CBUFFER;\n            }\n        }\n    }\n    free(tmp as *mut libc::c_void);\n    if n_read == -(1 as libc::c_int) as size_t {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        ok = 0 as libc::c_int != 0;\n    } else {\n        tmp = first;\n        while total_bytes.wrapping_sub((*tmp).nbytes) > n_bytes {\n            total_bytes = (total_bytes as libc::c_ulong).wrapping_sub((*tmp).nbytes)\n                as size_t as size_t;\n            tmp = (*tmp).next;\n        }\n        if total_bytes > n_bytes {\n            i = total_bytes.wrapping_sub(n_bytes);\n        } else {\n            i = 0 as libc::c_int as size_t;\n        }\n        xwrite_stdout(\n            &mut *((*tmp).buffer).as_mut_ptr().offset(i as isize),\n            ((*tmp).nbytes).wrapping_sub(i),\n        );\n        tmp = (*tmp).next;\n        while !tmp.is_null() {\n            xwrite_stdout(((*tmp).buffer).as_mut_ptr(), (*tmp).nbytes);\n            tmp = (*tmp).next;\n        }\n    }\n    while !first.is_null() {\n        tmp = (*first).next;\n        free(first as *mut libc::c_void);\n        first = tmp;\n    }\n    return ok;\n}",
    "calls": [
      {
        "caller": "DefId(0:294 ~ tail[5173]::tail_bytes)",
        "span": "src/tail.rs:3997:13: 3997:71 (#0)",
        "source": "return pipe_bytes(pretty_filename, fd, n_bytes, read_pos);"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:222 ~ tail[5173]::start_bytes)",
    "span": "src/tail.rs:2001:1: 2083:2 (#0)",
    "pieces": [
      "src/tail.rs:2001:1: 2083:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 83,
    "source": "unsafe extern \"C\" fn start_bytes(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> libc::c_int {\n    let mut buffer: [libc::c_char; 8192] = [0; 8192];\n    while (0 as libc::c_int as libc::c_ulong) < n_bytes {\n        let mut bytes_read: size_t = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if bytes_read == 0 as libc::c_int as libc::c_ulong {\n            return -(1 as libc::c_int);\n        }\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 1 as libc::c_int;\n        }\n        *read_pos = (*read_pos as libc::c_ulong).wrapping_add(bytes_read) as uintmax_t\n            as uintmax_t;\n        if bytes_read <= n_bytes {\n            n_bytes = (n_bytes as libc::c_ulong).wrapping_sub(bytes_read) as uintmax_t\n                as uintmax_t;\n        } else {\n            let mut n_remaining: size_t = bytes_read.wrapping_sub(n_bytes);\n            xwrite_stdout(\n                &mut *buffer.as_mut_ptr().offset(n_bytes as isize),\n                n_remaining,\n            );\n            break;\n        }\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:294 ~ tail[5173]::tail_bytes)",
        "span": "src/tail.rs:3945:13: 3945:90 (#0)",
        "source": "let mut t: libc::c_int = start_bytes(pretty_filename, fd, n_bytes, read_pos);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:263 ~ tail[5173]::tail_bytes)",
    "span": "src/tail.rs:3893:1: 4021:2 (#0)",
    "pieces": [
      "src/tail.rs:3893:1: 3899:4 (#0)",
      "src/tail.rs:3921:1: 3921:4 (#0)",
      "src/tail.rs:4021:1: 4021:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn tail_bytes(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:306 ~ tail[5173]::tail)",
        "span": "src/tail.rs:4149:12: 4151:6 (#0)",
        "source": "{\n        return tail_bytes(filename, fd, n_units, read_pos)\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/tail.rs:3899:5: 3919:3 (#0)",
        "pieces": [
          "src/tail.rs:3899:5: 3919:3 (#0)"
        ],
        "num_lines": 59,
        "source": "let mut stats: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    if fstat(fd, &mut stats) != 0 {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut pretty_filename: *const i8",
          "mut fd: i32"
        ],
        "live_out": [
          "mut pretty_filename: *const i8",
          "mut fd: i32",
          "mut stats: stat"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/tail.rs:3921:5: 4020:34 (#0)",
        "pieces": [
          "src/tail.rs:3921:5: 4020:34 (#0)"
        ],
        "num_lines": 100,
        "source": "if from_start {\n        if !presume_input_pipe\n            && n_bytes\n                <= (if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                    -(1 as libc::c_int) as off_t\n                } else {\n                    (((1 as libc::c_int as off_t)\n                        << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long\n                }) as libc::c_ulong\n            && (stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint\n                && xlseek(fd, n_bytes as off_t, 1 as libc::c_int, pretty_filename)\n                    >= 0 as libc::c_int as libc::c_long\n                || lseek(fd, n_bytes as __off_t, 1 as libc::c_int)\n                    != -(1 as libc::c_int) as libc::c_long)\n        {\n            *read_pos = (*read_pos as libc::c_ulong).wrapping_add(n_bytes) as uintmax_t\n                as uintmax_t;\n        } else {\n            let mut t: libc::c_int = start_bytes(pretty_filename, fd, n_bytes, read_pos);\n            if t != 0 {\n                return t < 0 as libc::c_int;\n            }\n        }\n        n_bytes = 18446744073709551615 as libc::c_ulong;\n    } else {\n        let mut end_pos: off_t = -(1 as libc::c_int) as off_t;\n        let mut current_pos: off_t = -(1 as libc::c_int) as off_t;\n        let mut copy_from_current_pos: bool = 0 as libc::c_int != 0;\n        if !presume_input_pipe\n            && n_bytes\n                <= (if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                    -(1 as libc::c_int) as off_t\n                } else {\n                    (((1 as libc::c_int as off_t)\n                        << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long\n                }) as libc::c_ulong\n        {\n            if usable_st_size(&mut stats) {\n                end_pos = stats.st_size;\n                let mut smallish_size: off_t = (if (0 as libc::c_int) < stats.st_blksize\n                    && stats.st_blksize as libc::c_ulong\n                        <= (-(1 as libc::c_int) as size_t)\n                            .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                {\n                    stats.st_blksize\n                } else {\n                    512 as libc::c_int\n                }) as off_t;\n                copy_from_current_pos = smallish_size < end_pos;\n            } else {\n                current_pos = lseek(\n                    fd,\n                    n_bytes.wrapping_neg() as __off_t,\n                    2 as libc::c_int,\n                );\n                copy_from_current_pos = current_pos\n                    != -(1 as libc::c_int) as libc::c_long;\n                if copy_from_current_pos {\n                    end_pos = (current_pos as libc::c_ulong).wrapping_add(n_bytes)\n                        as off_t;\n                }\n            }\n        }\n        if !copy_from_current_pos {\n            return pipe_bytes(pretty_filename, fd, n_bytes, read_pos);\n        }\n        if current_pos == -(1 as libc::c_int) as libc::c_long {\n            current_pos = xlseek(\n                fd,\n                0 as libc::c_int as off_t,\n                1 as libc::c_int,\n                pretty_filename,\n            );\n        }\n        if current_pos < end_pos {\n            let mut bytes_remaining: off_t = end_pos - current_pos;\n            if n_bytes < bytes_remaining as libc::c_ulong {\n                current_pos = (end_pos as libc::c_ulong).wrapping_sub(n_bytes) as off_t;\n                xlseek(fd, current_pos, 0 as libc::c_int, pretty_filename);\n            }\n        }\n        *read_pos = current_pos as uintmax_t;\n    }\n    *read_pos = (*read_pos as libc::c_ulong)\n        .wrapping_add(\n            dump_remainder(0 as libc::c_int != 0, pretty_filename, fd, n_bytes),\n        ) as uintmax_t as uintmax_t;\n    return 1 as libc::c_int != 0;",
        "sub_chunks": [],
        "live_in": [
          "mut pretty_filename: *const i8",
          "mut fd: i32",
          "mut n_bytes: u64",
          "mut read_pos: *mut u64",
          "mut stats: stat"
        ],
        "live_out": [
          "mut pretty_filename: *const i8",
          "mut fd: i32",
          "mut n_bytes: u64",
          "mut read_pos: *mut u64",
          "mut stats: stat"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:256 ~ tail[5173]::wd_comparator)",
    "span": "src/tail.rs:3147:1: 3154:2 (#0)",
    "pieces": [
      "src/tail.rs:3147:1: 3154:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn wd_comparator(\n    mut e1: *const libc::c_void,\n    mut e2: *const libc::c_void,\n) -> bool {\n    let mut spec1: *const File_spec = e1 as *const File_spec;\n    let mut spec2: *const File_spec = e2 as *const File_spec;\n    return (*spec1).wd == (*spec2).wd;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:171 ~ tail[5173]::get_stat_mtime)",
    "span": "src/tail.rs:647:1: 649:2 (#0)",
    "pieces": [
      "src/tail.rs:647:1: 649:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn get_stat_mtime(mut st: *const stat) -> timespec {\n    return (*st).st_mtim;\n}",
    "calls": [
      {
        "caller": "DefId(0:242 ~ tail[5173]::record_open_fd)",
        "span": "src/tail.rs:1100:5: 1100:34 (#0)",
        "source": "f.mtime = get_stat_mtime(st);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:204 ~ tail[5173]::record_open_fd)",
    "span": "src/tail.rs:1091:1: 1107:2 (#0)",
    "pieces": [
      "src/tail.rs:1091:1: 1107:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "unsafe extern \"C\" fn record_open_fd(\n    mut f: *mut File_spec,\n    mut fd: libc::c_int,\n    mut size: off_t,\n    mut st: *const stat,\n    mut blocking: libc::c_int,\n) {\n    (*f).fd = fd;\n    (*f).size = size;\n    (*f).mtime = get_stat_mtime(st);\n    (*f).dev = (*st).st_dev;\n    (*f).ino = (*st).st_ino;\n    (*f).mode = (*st).st_mode;\n    (*f).blocking = blocking;\n    (*f).n_unchanged_stats = 0 as libc::c_int as uintmax_t;\n    (*f).ignore = 0 as libc::c_int != 0;\n}",
    "calls": [
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4400:5: 4406:7 (#0)",
        "source": "record_open_fd(\n        &mut *f,\n        fd,\n        read_pos as i64,\n        &mut stats,\n        if is_stdin { -1 } else { 1 },\n    );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2677:1: 2683:3 (#0)",
        "source": "record_open_fd(\n    &mut *f,\n    fd,\n    0,\n    &new_stats,\n    blocking_value,\n);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:205 ~ tail[5173]::close_fd)",
    "span": "src/tail.rs:1109:1: 1153:2 (#0)",
    "pieces": [
      "src/tail.rs:1109:1: 1153:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 45,
    "source": "unsafe extern \"C\" fn close_fd(mut fd: libc::c_int, mut filename: *const libc::c_char) {\n    if fd != -(1 as libc::c_int) && fd != 0 as libc::c_int && close(fd) != 0 {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"closing %s (fd=%d)\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, filename),\n                fd,\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"closing %s (fd=%d)\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                    fd,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"closing %s (fd=%d)\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                    fd,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2669:9: 2669:38 (#0)",
        "source": "close_fd(fd, pretty_name(f));"
      },
      {
        "caller": "DefId(0:288 ~ tail[5173]::check_fspec)",
        "span": "src/tail.rs:3185:9: 3185:37 (#0)",
        "source": "close_fd((*fspec).fd, name);"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4397:5: 4397:34 (#0)",
        "source": "close_fd(fd, pretty_name(f));"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2666:1: 2666:46 (#0)",
        "source": "close_fd(unsafe { (*f).fd }, pretty_name(f));"
      },
      {
        "caller": "DefId(0:290 ~ tail[5173]::tail_forever_inotify)",
        "span": "src/tail.rs:3833:13: 3833:53 (#0)",
        "source": "close_fd((*prev).fd, pretty_name(prev));"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2520:9: 2520:43 (#0)",
        "source": "close_fd((*f).fd, pretty_name(f));"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2519:9: 2519:38 (#0)",
        "source": "close_fd(fd, pretty_name(f));"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:176 ~ tail[5173]::is_local_fs_type)",
    "span": "src/tail.rs:688:1: 826:2 (#0)",
    "pieces": [
      "src/tail.rs:688:1: 826:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 139,
    "source": "unsafe extern \"C\" fn is_local_fs_type(mut magic: libc::c_ulong) -> libc::c_int {\n    match magic {\n        1513908720 => return 1 as libc::c_int,\n        1633904243 => return 0 as libc::c_int,\n        44533 => return 1 as libc::c_int,\n        44543 => return 1 as libc::c_int,\n        1397113167 => return 0 as libc::c_int,\n        151263540 => return 1 as libc::c_int,\n        1635083891 => return 0 as libc::c_int,\n        391 => return 1 as libc::c_int,\n        325456742 => return 1 as libc::c_int,\n        3393526350 => return 1 as libc::c_int,\n        1111905073 => return 1 as libc::c_int,\n        1650746742 => return 1 as libc::c_int,\n        464386766 => return 1 as libc::c_int,\n        1819242352 => return 1 as libc::c_int,\n        3405662737 => return 1 as libc::c_int,\n        1112100429 => return 1 as libc::c_int,\n        2435016766 => return 1 as libc::c_int,\n        1936880249 => return 1 as libc::c_int,\n        12805120 => return 0 as libc::c_int,\n        2613483 => return 1 as libc::c_int,\n        1667723888 => return 1 as libc::c_int,\n        4283649346 => return 0 as libc::c_int,\n        1937076805 => return 0 as libc::c_int,\n        19920823 => return 1 as libc::c_int,\n        1650812272 => return 1 as libc::c_int,\n        684539205 => return 1 as libc::c_int,\n        1161678120 => return 1 as libc::c_int,\n        1684300152 => return 1 as libc::c_int,\n        1684170528 => return 1 as libc::c_int,\n        4979 => return 1 as libc::c_int,\n        1162691661 => return 1 as libc::c_int,\n        7377 => return 1 as libc::c_int,\n        1145913666 => return 1 as libc::c_int,\n        61791 => return 1 as libc::c_int,\n        3730735588 => return 1 as libc::c_int,\n        4278867 => return 1 as libc::c_int,\n        3774210530 => return 1 as libc::c_int,\n        538032816 => return 1 as libc::c_int,\n        1163413075 => return 1 as libc::c_int,\n        24053 => return 1 as libc::c_int,\n        4989 => return 1 as libc::c_int,\n        61267 => return 1 as libc::c_int,\n        61265 => return 1 as libc::c_int,\n        4076150800 => return 1 as libc::c_int,\n        16390 => return 1 as libc::c_int,\n        428016422 => return 0 as libc::c_int,\n        1702057286 => return 0 as libc::c_int,\n        1702057283 => return 0 as libc::c_int,\n        195894762 => return 1 as libc::c_int,\n        18225520 => return 0 as libc::c_int,\n        1196443219 => return 0 as libc::c_int,\n        16964 => return 1 as libc::c_int,\n        18475 => return 1 as libc::c_int,\n        18520 => return 1 as libc::c_int,\n        12648430 => return 1 as libc::c_int,\n        4187351113 => return 1 as libc::c_int,\n        2508478710 => return 1 as libc::c_int,\n        288389204 => return 1 as libc::c_int,\n        19993000 => return 0 as libc::c_int,\n        732765674 => return 1 as libc::c_int,\n        38496 => return 1 as libc::c_int,\n        16388 => return 1 as libc::c_int,\n        16384 => return 1 as libc::c_int,\n        1984 => return 1 as libc::c_int,\n        29366 => return 1 as libc::c_int,\n        827541066 => return 1 as libc::c_int,\n        1799439955 => return 0 as libc::c_int,\n        3380511080 => return 1 as libc::c_int,\n        198183888 => return 0 as libc::c_int,\n        1397109069 => return 1 as libc::c_int,\n        4991 => return 1 as libc::c_int,\n        5007 => return 1 as libc::c_int,\n        9320 => return 1 as libc::c_int,\n        9336 => return 1 as libc::c_int,\n        19802 => return 1 as libc::c_int,\n        427819522 => return 1 as libc::c_int,\n        19780 => return 1 as libc::c_int,\n        22092 => return 0 as libc::c_int,\n        26985 => return 0 as libc::c_int,\n        1852207972 => return 0 as libc::c_int,\n        13364 => return 1 as libc::c_int,\n        1853056627 => return 1 as libc::c_int,\n        1397118030 => return 1 as libc::c_int,\n        40865 => return 1 as libc::c_int,\n        1952539503 => return 0 as libc::c_int,\n        2035054128 => return 0 as libc::c_int,\n        2866260714 => return 0 as libc::c_int,\n        1346978886 => return 1 as libc::c_int,\n        1346981957 => return 0 as libc::c_int,\n        3344373136 => return 1 as libc::c_int,\n        2088527475 => return 0 as libc::c_int,\n        40864 => return 1 as libc::c_int,\n        1634035564 => return 1 as libc::c_int,\n        47 => return 1 as libc::c_int,\n        1746473250 => return 1 as libc::c_int,\n        2240043254 => return 1 as libc::c_int,\n        124082209 => return 1 as libc::c_int,\n        1382369651 => return 1 as libc::c_int,\n        29301 => return 1 as libc::c_int,\n        1733912937 => return 1 as libc::c_int,\n        1573531125 => return 1 as libc::c_int,\n        1397048141 => return 1 as libc::c_int,\n        1935894131 => return 1 as libc::c_int,\n        4185718668 => return 1 as libc::c_int,\n        1128357203 => return 1 as libc::c_int,\n        20859 => return 0 as libc::c_int,\n        4266872130 => return 0 as libc::c_int,\n        3203391149 => return 0 as libc::c_int,\n        1397703499 => return 1 as libc::c_int,\n        1936814952 => return 1 as libc::c_int,\n        1650812274 => return 1 as libc::c_int,\n        19920822 => return 1 as libc::c_int,\n        19920821 => return 1 as libc::c_int,\n        16914836 => return 1 as libc::c_int,\n        1953653091 => return 1 as libc::c_int,\n        604313861 => return 1 as libc::c_int,\n        352400198 => return 1 as libc::c_int,\n        72020 => return 1 as libc::c_int,\n        1410924800 => return 1 as libc::c_int,\n        40866 => return 1 as libc::c_int,\n        16914839 => return 1 as libc::c_int,\n        2020557398 => return 0 as libc::c_int,\n        3133910204 => return 0 as libc::c_int,\n        2768370933 => return 0 as libc::c_int,\n        1448756819 => return 1 as libc::c_int,\n        1397114950 => return 1 as libc::c_int,\n        2881100148 => return 1 as libc::c_int,\n        19920820 => return 1 as libc::c_int,\n        1481003842 => return 1 as libc::c_int,\n        19911021 => return 1 as libc::c_int,\n        51 => return 1 as libc::c_int,\n        801189825 => return 1 as libc::c_int,\n        1515144787 => return 1 as libc::c_int,\n        1479104553 => return 1 as libc::c_int,\n        _ => return -(1 as libc::c_int),\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:264 ~ tail[5173]::fremote)",
        "span": "src/tail.rs:2211:9: 2211:63 (#0)",
        "source": "let remote = is_local_fs_type(buf.f_type as u64) <= 0;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:228 ~ tail[5173]::fremote)",
    "span": "src/tail.rs:2140:1: 2214:2 (#0)",
    "pieces": [
      "src/tail.rs:2140:1: 2214:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 75,
    "source": "unsafe extern \"C\" fn fremote(\n    mut fd: libc::c_int,\n    mut name: *const libc::c_char,\n) -> bool {\n    let mut remote: bool = 1 as libc::c_int != 0;\n    let mut buf: statfs = statfs {\n        f_type: 0,\n        f_bsize: 0,\n        f_blocks: 0,\n        f_bfree: 0,\n        f_bavail: 0,\n        f_files: 0,\n        f_ffree: 0,\n        f_fsid: __fsid_t { __val: [0; 2] },\n        f_namelen: 0,\n        f_frsize: 0,\n        f_flags: 0,\n        f_spare: [0; 4],\n    };\n    let mut err: libc::c_int = fstatfs(fd, &mut buf);\n    if err != 0 as libc::c_int {\n        if *__errno_location() != 38 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot determine location of %s. reverting to polling\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, name),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot determine location of %s. reverting to polling\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot determine location of %s. reverting to polling\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    } else {\n        remote = is_local_fs_type(buf.f_type as libc::c_ulong) <= 0 as libc::c_int;\n    }\n    return remote;\n}",
    "calls": [
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4407:5: 4407:47 (#0)",
        "source": "(*f).remote = fremote(fd, pretty_name(f));"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2495:9: 2495:50 (#0)",
        "source": "let remote = fremote(fd, pretty_name(f));"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:203 ~ tail[5173]::pretty_name)",
    "span": "src/tail.rs:1082:1: 1090:2 (#0)",
    "pieces": [
      "src/tail.rs:1082:1: 1090:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn pretty_name(mut f: *const File_spec) -> *const libc::c_char {\n    return if strcmp((*f).name, b\"-\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        gettext(b\"standard input\\0\" as *const u8 as *const libc::c_char)\n    } else {\n        (*f).name\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4424:5: 4429:7 (#0)",
        "source": "error(\n        __errstatus,\n        *__errno_location(),\n        gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:288 ~ tail[5173]::check_fspec)",
        "span": "src/tail.rs:3182:5: 3182:31 (#0)",
        "source": "name = pretty_name(fspec);"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2467:21: 2486:23 (#0)",
        "source": "error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has been replaced with an untailable file%s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_name(f),\n                        ),\n                        if (*f).ignore as libc::c_int != 0 {\n                            gettext(\n                                b\"; giving up on this name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ) as *const libc::c_char\n                        } else {\n                            b\"\\0\" as *const u8 as *const libc::c_char\n                        },\n                    );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2551:13: 2558:15 (#0)",
        "source": "error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s has become accessible\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2669:9: 2669:38 (#0)",
        "source": "close_fd(fd, pretty_name(f));"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4397:5: 4397:34 (#0)",
        "source": "close_fd(fd, pretty_name(f));"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2565:17: 2572:19 (#0)",
        "source": "error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has become accessible\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4338:25: 4358:27 (#0)",
        "source": "error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s: cannot follow end of this type of file%s\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                pretty_name(f),\n                            ),\n                            if (*f).ignore as libc::c_int != 0 {\n                                gettext(\n                                    b\"; giving up on this name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ) as *const libc::c_char\n                            } else {\n                                b\"\\0\" as *const u8 as *const libc::c_char\n                            },\n                        );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2367:9: 2372:11 (#0)",
        "source": "error(\n            0,\n            errnum,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            quotearg_n_style_colon(0, shell_escape_quoting_style, pretty_name(f)),\n        );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2313:5: 2318:7 (#0)",
        "source": "error(\n        __errstatus,\n        0,\n        gettext(b\"%s has been replaced with an untailable symbolic link\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2633:5: 2638:7 (#0)",
        "source": "error(\n        0,\n        0,\n        gettext(b\"%s has been replaced; following new file\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4435:5: 4440:7 (#0)",
        "source": "error(\n        __errstatus,\n        *__errno_location(),\n        gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2580:17: 2587:19 (#0)",
        "source": "error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has become accessible\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2293:5: 2298:7 (#0)",
        "source": "error(\n        0,\n        0,\n        gettext(b\"%s has been replaced with an untailable symbolic link\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2666:1: 2666:46 (#0)",
        "source": "close_fd(unsafe { (*f).fd }, pretty_name(f));"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2655:5: 2660:7 (#0)",
        "source": "error(\n        errstatus,\n        0,\n        gettext(b\"%s has been replaced; following new file\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2520:9: 2520:43 (#0)",
        "source": "close_fd((*f).fd, pretty_name(f));"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4248:21: 4255:23 (#0)",
        "source": "error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4413:5: 4418:7 (#0)",
        "source": "error(\n        0,\n        *__errno_location(),\n        gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2499:5: 2506:7 (#0)",
        "source": "error(\n        0,\n        0,\n        gettext(\n            b\"%s has been replaced with an untailable remote file\\0\" as *const u8 as *const libc::c_char,\n        ),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2519:9: 2519:38 (#0)",
        "source": "close_fd(fd, pretty_name(f));"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4188:5: 4193:7 (#0)",
        "source": "error(\n        __errstatus,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        gettext(b\"cannot open %s for reading\\0\".as_ptr() as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2618:5: 2623:7 (#0)",
        "source": "error(\n        errstatus,\n        0,\n        gettext(b\"%s has appeared;  following new file\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2607:5: 2612:7 (#0)",
        "source": "error(\n        errstatus,\n        0,\n        gettext(b\"%s has appeared;  following new file\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2376:9: 2381:11 (#0)",
        "source": "error(\n            __errstatus,\n            errnum,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            quotearg_n_style_colon(0, shell_escape_quoting_style, pretty_name(f)),\n        );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2343:13: 2348:15 (#0)",
        "source": "error(\n                __errstatus,\n                f_ref.errnum,\n                gettext(b\"%s has become inaccessible\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2598:5: 2603:7 (#0)",
        "source": "error(\n        0,\n        0,\n        gettext(b\"%s has appeared;  following new file\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2354:13: 2359:15 (#0)",
        "source": "error(\n                __errstatus,\n                f_ref.errnum,\n                gettext(b\"%s has become inaccessible\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2417:17: 2433:19 (#0)",
        "source": "error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced with an untailable file%s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    if (*f).ignore as libc::c_int != 0 {\n                        gettext(\n                            b\"; giving up on this name\\0\" as *const u8\n                                as *const libc::c_char,\n                        ) as *const libc::c_char\n                    } else {\n                        b\"\\0\" as *const u8 as *const libc::c_char\n                    },\n                );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2644:5: 2649:7 (#0)",
        "source": "error(\n        errstatus,\n        0,\n        gettext(b\"%s has been replaced; following new file\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2334:13: 2339:15 (#0)",
        "source": "error(\n                0,\n                f_ref.errnum,\n                gettext(b\"%s has become inaccessible\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2495:9: 2495:50 (#0)",
        "source": "let remote = fremote(fd, pretty_name(f));"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4216:9: 4216:38 (#0)",
        "source": "write_header(pretty_name(f));"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2387:9: 2392:11 (#0)",
        "source": "error(\n            __errstatus,\n            errnum,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            quotearg_n_style_colon(0, shell_escape_quoting_style, pretty_name(f)),\n        );"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4366:25: 4386:27 (#0)",
        "source": "error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s: cannot follow end of this type of file%s\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                pretty_name(f),\n                            ),\n                            if (*f).ignore as libc::c_int != 0 {\n                                gettext(\n                                    b\"; giving up on this name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ) as *const libc::c_char\n                            } else {\n                                b\"\\0\" as *const u8 as *const libc::c_char\n                            },\n                        );"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4262:25: 4272:27 (#0)",
        "source": "error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(f),\n                            ),\n                        );"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2440:21: 2459:23 (#0)",
        "source": "error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has been replaced with an untailable file%s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_name(f),\n                        ),\n                        if (*f).ignore as libc::c_int != 0 {\n                            gettext(\n                                b\"; giving up on this name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ) as *const libc::c_char\n                        } else {\n                            b\"\\0\" as *const u8 as *const libc::c_char\n                        },\n                    );"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4280:25: 4290:27 (#0)",
        "source": "error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(f),\n                            ),\n                        );"
      },
      {
        "caller": "DefId(0:290 ~ tail[5173]::tail_forever_inotify)",
        "span": "src/tail.rs:3833:13: 3833:53 (#0)",
        "source": "close_fd((*prev).fd, pretty_name(prev));"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2302:5: 2307:7 (#0)",
        "source": "error(\n        __errstatus,\n        0,\n        gettext(b\"%s has been replaced with an untailable symbolic link\\0\" as *const u8 as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4177:5: 4182:7 (#0)",
        "source": "error(\n        0,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        gettext(b\"cannot open %s for reading\\0\".as_ptr() as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4218:5: 4218:59 (#0)",
        "source": "ok = tail(pretty_name(f), fd, n_units, &mut read_pos);"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4407:5: 4407:47 (#0)",
        "source": "(*f).remote = fremote(fd, pretty_name(f));"
      },
      {
        "caller": "DefId(0:267 ~ tail[5173]::recheck)",
        "span": "src/tail.rs:2687:13: 2687:85 (#0)",
        "source": "xlseek(fd, 0 as libc::c_int as off_t, 0 as libc::c_int, pretty_name(f));"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4311:21: 4331:23 (#0)",
        "source": "error(\n                        0 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s: cannot follow end of this type of file%s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            pretty_name(f),\n                        ),\n                        if (*f).ignore as libc::c_int != 0 {\n                            gettext(\n                                b\"; giving up on this name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ) as *const libc::c_char\n                        } else {\n                            b\"\\0\" as *const u8 as *const libc::c_char\n                        },\n                    );"
      },
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4199:5: 4204:7 (#0)",
        "source": "error(\n        __errstatus,\n        std::io::Error::last_os_error().raw_os_error().unwrap_or(0),\n        gettext(b\"cannot open %s for reading\\0\".as_ptr() as *const libc::c_char),\n        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n    );"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:231 ~ tail[5173]::recheck)",
    "span": "src/tail.rs:2215:1: 2690:2 (#0)",
    "pieces": [
      "src/tail.rs:2215:1: 2216:4 (#0)",
      "src/tail.rs:2690:1: 2690:2 (#0)"
    ],
    "sub_chunks": [
      7
    ],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn recheck(mut f: *mut File_spec, mut blocking: bool) {\n   <<chunk 7>>}",
    "calls": [
      {
        "caller": "DefId(0:290 ~ tail[5173]::tail_forever_inotify)",
        "span": "src/tail.rs:3829:13: 3829:34 (#0)",
        "source": "recheck(prev, false);"
      },
      {
        "caller": "DefId(0:290 ~ tail[5173]::tail_forever_inotify)",
        "span": "src/tail.rs:3881:5: 3881:27 (#0)",
        "source": "recheck(fspec, false);"
      },
      {
        "caller": "DefId(0:290 ~ tail[5173]::tail_forever_inotify)",
        "span": "src/tail.rs:3841:5: 3841:27 (#0)",
        "source": "recheck(fspec, false);"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:834:1: 834:52 (#0)",
        "source": "static mut reopen_inaccessible_files: bool = false;"
      },
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/tail.rs:391:1: 391:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/tail.rs:836:1: 836:57 (#0)",
        "source": "static mut follow_mode: Follow_mode = Follow_descriptor;"
      },
      {
        "span": "src/tail.rs:455:1: 455:40 (#0)",
        "source": "pub const Follow_name: Follow_mode = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/tail.rs:2288:9: 2322:2 (#0)",
        "pieces": [
          "src/tail.rs:2288:9: 2322:2 (#0)"
        ],
        "num_lines": 50,
        "source": "ok = 0 as libc::c_int != 0;\n        (*f).errnum = -(1 as libc::c_int);\n        (*f).ignore = 1 as libc::c_int != 0;\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s has been replaced with an untailable symbolic link\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced with an untailable symbolic link\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced with an untailable symbolic link\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut ok: bool"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut ok: bool"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/tail.rs:2325:9: 2397:2 (#0)",
        "pieces": [
          "src/tail.rs:2325:9: 2397:2 (#0)"
        ],
        "num_lines": 110,
        "source": "ok = 0 as libc::c_int != 0;\n        (*f).errnum = *__errno_location();\n        if !(*f).tailable {\n            if was_tailable {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        (*f).errnum,\n                        gettext(\n                            b\"%s has become inaccessible\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            (*f).errnum,\n                            gettext(\n                                b\"%s has become inaccessible\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(f),\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            (*f).errnum,\n                            gettext(\n                                b\"%s has become inaccessible\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(f),\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        } else if prev_errnum != *__errno_location() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        pretty_name(f),\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            pretty_name(f),\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            pretty_name(f),\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut ok: bool",
          "mut was_tailable: bool",
          "mut prev_errnum: i32"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut ok: bool",
          "mut was_tailable: bool",
          "mut prev_errnum: i32",
          "ok: bool",
          "errnum: i32",
          "f_ref: &mut File_spec"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/tail.rs:2408:9: 2493:10 (#0)",
        "pieces": [
          "src/tail.rs:2408:9: 2493:10 (#0)"
        ],
        "num_lines": 86,
        "source": "ok = 0 as libc::c_int != 0;\n        (*f).errnum = -(1 as libc::c_int);\n        (*f).tailable = 0 as libc::c_int != 0;\n        (*f)\n            .ignore = !(reopen_inaccessible_files as libc::c_int != 0\n            && follow_mode as libc::c_uint\n                == Follow_name as libc::c_int as libc::c_uint);\n        if was_tailable as libc::c_int != 0 || prev_errnum != (*f).errnum {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced with an untailable file%s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    if (*f).ignore as libc::c_int != 0 {\n                        gettext(\n                            b\"; giving up on this name\\0\" as *const u8\n                                as *const libc::c_char,\n                        ) as *const libc::c_char\n                    } else {\n                        b\"\\0\" as *const u8 as *const libc::c_char\n                    },\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has been replaced with an untailable file%s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_name(f),\n                        ),\n                        if (*f).ignore as libc::c_int != 0 {\n                            gettext(\n                                b\"; giving up on this name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ) as *const libc::c_char\n                        } else {\n                            b\"\\0\" as *const u8 as *const libc::c_char\n                        },\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has been replaced with an untailable file%s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_name(f),\n                        ),\n                        if (*f).ignore as libc::c_int != 0 {\n                            gettext(\n                                b\"; giving up on this name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ) as *const libc::c_char\n                        } else {\n                            b\"\\0\" as *const u8 as *const libc::c_char\n                        },\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut ok: bool",
          "mut was_tailable: bool",
          "mut prev_errnum: i32"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut ok: bool",
          "mut was_tailable: bool",
          "mut prev_errnum: i32"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/tail.rs:2495:9: 2514:2 (#0)",
        "pieces": [
          "src/tail.rs:2495:9: 2514:2 (#0)"
        ],
        "num_lines": 56,
        "source": "(*f).remote = fremote(fd, pretty_name(f));\n        if (*f).remote as libc::c_int != 0 && !disable_inotify {\n            ok = 0 as libc::c_int != 0;\n            (*f).errnum = -(1 as libc::c_int);\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced with an untailable remote file\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has been replaced with an untailable remote file\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has been replaced with an untailable remote file\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            (*f).ignore = 1 as libc::c_int != 0;\n            (*f).remote = 1 as libc::c_int != 0;\n        } else {\n            (*f).errnum = 0 as libc::c_int;\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut ok: bool",
          "mut fd: i32"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut ok: bool",
          "mut fd: i32",
          "remote: bool"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/tail.rs:2523:9: 2593:11 (#0)",
        "pieces": [
          "src/tail.rs:2523:9: 2593:11 (#0)"
        ],
        "num_lines": 71,
        "source": "new_file = 1 as libc::c_int != 0;\n        if (*f).fd == -(1 as libc::c_int) {} else {\n            __assert_fail(\n                b\"f->fd == -1\\0\" as *const u8 as *const libc::c_char,\n                b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                1064 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 40],\n                    &[libc::c_char; 40],\n                >(b\"void recheck(struct File_spec *, _Bool)\\0\"))\n                    .as_ptr(),\n            );\n        }\n        'c_12481: {\n            if (*f).fd == -(1 as libc::c_int) {} else {\n                __assert_fail(\n                    b\"f->fd == -1\\0\" as *const u8 as *const libc::c_char,\n                    b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                    1064 as libc::c_int as libc::c_uint,\n                    (*::core::mem::transmute::<\n                        &[u8; 40],\n                        &[libc::c_char; 40],\n                    >(b\"void recheck(struct File_spec *, _Bool)\\0\"))\n                        .as_ptr(),\n                );\n            }\n        };\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s has become accessible\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has become accessible\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has become accessible\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut new_file: bool",
          "mut fd: i32"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut new_file: bool",
          "mut fd: i32"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/tail.rs:2595:9: 2627:2 (#0)",
        "pieces": [
          "src/tail.rs:2595:9: 2627:2 (#0)"
        ],
        "num_lines": 48,
        "source": "new_file = 1 as libc::c_int != 0;\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s has appeared;  following new file\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has appeared;  following new file\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has appeared;  following new file\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut new_file: bool"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut new_file: bool"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/tail.rs:2630:9: 2666:46 (#0)",
        "pieces": [
          "src/tail.rs:2630:9: 2666:46 (#0)"
        ],
        "num_lines": 49,
        "source": "new_file = 1 as libc::c_int != 0;\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s has been replaced;  following new file\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced;  following new file\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s has been replaced;  following new file\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        close_fd((*f).fd, pretty_name(f));",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut new_file: bool",
          "mut fd: i32"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut new_file: bool",
          "mut fd: i32"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/tail.rs:2216:5: 2689:6 (#0)",
        "pieces": [
          "src/tail.rs:2216:5: 2288:8 (#0)",
          "src/tail.rs:2324:1: 2325:8 (#0)",
          "src/tail.rs:2399:1: 2408:8 (#0)",
          "src/tail.rs:2494:1: 2495:8 (#0)",
          "src/tail.rs:2516:1: 2523:8 (#0)",
          "src/tail.rs:2594:1: 2595:8 (#0)",
          "src/tail.rs:2629:1: 2630:8 (#0)",
          "src/tail.rs:2668:1: 2689:6 (#0)"
        ],
        "num_lines": 120,
        "source": "let mut new_stats: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut is_stdin: bool = strcmp(\n        (*f).name,\n        b\"-\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int;\n    let mut was_tailable: bool = (*f).tailable;\n    let mut prev_errnum: libc::c_int = (*f).errnum;\n    let mut new_file: bool = false;\n    let mut fd: libc::c_int = if is_stdin as libc::c_int != 0 {\n        0 as libc::c_int\n    } else {\n        open_safer(\n            (*f).name,\n            0 as libc::c_int\n                | (if blocking as libc::c_int != 0 {\n                    0 as libc::c_int\n                } else {\n                    0o4000 as libc::c_int\n                }),\n        )\n    };\n    if valid_file_spec(f) {} else {\n        __assert_fail(\n            b\"valid_file_spec (f)\\0\" as *const u8 as *const libc::c_char,\n            b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n            987 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 40],\n                &[libc::c_char; 40],\n            >(b\"void recheck(struct File_spec *, _Bool)\\0\"))\n                .as_ptr(),\n        );\n    }\n    'c_13353: {\n        if valid_file_spec(f) {} else {\n            __assert_fail(\n                b\"valid_file_spec (f)\\0\" as *const u8 as *const libc::c_char,\n                b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                987 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 40],\n                    &[libc::c_char; 40],\n                >(b\"void recheck(struct File_spec *, _Bool)\\0\"))\n                    .as_ptr(),\n            );\n        }\n    };\n    (*f)\n        .tailable = !(reopen_inaccessible_files as libc::c_int != 0\n        && fd == -(1 as libc::c_int));\n    if !disable_inotify && lstat((*f).name, &mut new_stats) == 0\n        && new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o120000 as libc::c_int as libc::c_uint\n    {\n       <<chunk 0>>    } else if fd == -(1 as libc::c_int) || fstat(fd, &mut new_stats) < 0 as libc::c_int {\n       <<chunk 1>>    } else if !(new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        || new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o10000 as libc::c_int as libc::c_uint\n        || new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o140000 as libc::c_int as libc::c_uint\n        || new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o20000 as libc::c_int as libc::c_uint)\n    {\n       <<chunk 2>>    } else {\n       <<chunk 3>>    }\n    new_file = 0 as libc::c_int != 0;\n    if !ok {\n        close_fd(fd, pretty_name(f));\n        close_fd((*f).fd, pretty_name(f));\n        (*f).fd = -(1 as libc::c_int);\n    } else if prev_errnum != 0 && prev_errnum != 2 as libc::c_int {\n       <<chunk 4>>    } else if (*f).fd == -(1 as libc::c_int) {\n       <<chunk 5>>    } else if (*f).ino != new_stats.st_ino || (*f).dev != new_stats.st_dev {\n       <<chunk 6>>    } else {\n        close_fd(fd, pretty_name(f));\n    }\n    if new_file {\n        record_open_fd(\n            f,\n            fd,\n            0 as libc::c_int as off_t,\n            &mut new_stats,\n            if is_stdin as libc::c_int != 0 {\n                -(1 as libc::c_int)\n            } else {\n                blocking as libc::c_int\n            },\n        );\n        if new_stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o100000 as libc::c_int as libc::c_uint\n        {\n            xlseek(fd, 0 as libc::c_int as off_t, 0 as libc::c_int, pretty_name(f));\n        }\n    }",
        "sub_chunks": [
          0,
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "live_in": [
          "mut f: *mut File_spec",
          "mut blocking: bool"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut blocking: bool",
          "mut new_stats: stat",
          "mut ok: bool",
          "mut is_stdin: bool",
          "mut was_tailable: bool",
          "mut prev_errnum: i32",
          "mut new_file: bool",
          "mut fd: i32",
          "blocking_value: i32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:174 ~ tail[5173]::__gl_setmode)",
    "span": "src/tail.rs:678:1: 680:2 (#0)",
    "pieces": [
      "src/tail.rs:678:1: 680:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:213 ~ tail[5173]::set_binary_mode)",
        "span": "src/tail.rs:683:71: 685:2 (#0)",
        "source": "{\n    __gl_setmode(fd, mode)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:175 ~ tail[5173]::set_binary_mode)",
    "span": "src/tail.rs:683:1: 685:2 (#0)",
    "pieces": [
      "src/tail.rs:683:1: 685:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:166 ~ tail[5173]::emit_ancillary_info)",
    "span": "src/tail.rs:539:1: 590:2 (#0)",
    "pieces": [
      "src/tail.rs:539:1: 590:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 115,
    "source": "unsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:237 ~ tail[5173]::usage)",
        "span": "src/tail.rs:1059:9: 1059:37 (#0)",
        "source": "emit_ancillary_info(\"tail\");"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:165 ~ tail[5173]::emit_mandatory_arg_note)",
    "span": "src/tail.rs:531:1: 536:2 (#0)",
    "pieces": [
      "src/tail.rs:531:1: 536:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_mandatory_arg_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nMandatory arguments to long options are mandatory for short options too.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:237 ~ tail[5173]::usage)",
        "span": "src/tail.rs:1014:9: 1014:35 (#0)",
        "source": "emit_mandatory_arg_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:164 ~ tail[5173]::emit_stdin_note)",
    "span": "src/tail.rs:523:1: 528:2 (#0)",
    "pieces": [
      "src/tail.rs:523:1: 528:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_stdin_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nWith no FILE, or when FILE is -, read standard input.\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:237 ~ tail[5173]::usage)",
        "span": "src/tail.rs:1013:9: 1013:27 (#0)",
        "source": "emit_stdin_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:199 ~ tail[5173]::usage)",
    "span": "src/tail.rs:998:1: 1062:2 (#0)",
    "pieces": [
      "src/tail.rs:998:1: 1062:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 108,
    "source": "pub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [FILE]...\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        printf(\n            gettext(\n                b\"Print the last %d lines of each FILE to standard output.\\nWith more than one FILE, precede each with a header giving the file name.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            10 as libc::c_int,\n        );\n        emit_stdin_note();\n        emit_mandatory_arg_note();\n        fputs_unlocked(\n            gettext(\n                b\"  -c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\\n                             output starting with byte NUM of each file\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -f, --follow[={name|descriptor}]\\n                           output appended data as the file grows;\\n                             an absent option argument means 'descriptor'\\n  -F                       same as --follow=name --retry\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        printf(\n            gettext(\n                b\"  -n, --lines=[+]NUM       output the last NUM lines, instead of the last %d;\\n                             or use -n +NUM to skip NUM-1 lines at the start\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            10 as libc::c_int,\n        );\n        printf(\n            gettext(\n                b\"      --max-unchanged-stats=N\\n                           with --follow=name, reopen a FILE which has not\\n                             changed size after N (default %d) iterations\\n                             to see if it has been unlinked or renamed\\n                             (this is the usual case of rotated log files);\\n                             with inotify, this option is rarely useful\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            5 as libc::c_int,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --pid=PID            with -f, terminate after process ID, PID dies;\\n                             can be repeated to watch multiple processes\\n  -q, --quiet, --silent    never output headers giving file names\\n      --retry              keep trying to open a file if it is inaccessible\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\\n                             (default 1.0) between iterations;\\n                             with inotify and --pid=P, check process P at\\n                             least once every N seconds\\n  -v, --verbose            always output headers giving file names\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -z, --zero-terminated    line delimiter is NUL, not newline\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"\\nNUM may have a multiplier suffix:\\nb 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\\nGB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"With --follow (-f), tail defaults to following the file descriptor, which\\nmeans that even if a tail'ed file is renamed, tail will continue to track\\nits end.  This default behavior is not desirable when you really want to\\ntrack the actual name of the file, not the file descriptor (e.g., log\\nrotation).  Use --follow=name in that case.  That causes tail to track the\\nnamed file in a way that accommodates renaming, removal and creation.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_ancillary_info(b\"tail\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}",
    "calls": [
      {
        "caller": "DefId(0:310 ~ tail[5173]::parse_options)",
        "span": "src/tail.rs:4931:9: 4931:18 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:310 ~ tail[5173]::parse_options)",
        "span": "src/tail.rs:4842:9: 4842:18 (#0)",
        "source": "usage(0);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:251 ~ tail[5173]::any_symlinks)",
    "span": "src/tail.rs:3075:1: 3106:2 (#0)",
    "pieces": [
      "src/tail.rs:3075:1: 3106:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 32,
    "source": "unsafe extern \"C\" fn any_symlinks(mut f: *const File_spec, mut n_files: size_t) -> bool {\n    let mut st: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if lstat((*f.offset(i as isize)).name, &mut st) == 0 as libc::c_int\n            && st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o120000 as libc::c_int as libc::c_uint\n        {\n            return 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:271 ~ tail[5173]::parse_options)",
    "span": "src/tail.rs:4611:1: 5090:2 (#0)",
    "pieces": [
      "src/tail.rs:4611:1: 4618:4 (#0)",
      "src/tail.rs:5024:1: 5024:4 (#0)",
      "src/tail.rs:5090:1: 5090:2 (#0)"
    ],
    "sub_chunks": [
      8,
      9
    ],
    "num_lines": 10,
    "source": "unsafe extern \"C\" fn parse_options(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n    mut n_units: *mut uintmax_t,\n    mut header_mode: *mut header_mode,\n    mut sleep_interval: *mut libc::c_double,\n) {\n   <<chunk 8>>   <<chunk 9>>}",
    "calls": [
      {
        "caller": "DefId(0:318 ~ tail[5173]::main_0)",
        "span": "src/tail.rs:5150:5: 5150:84 (#0)",
        "source": "parse_options(argc, argv, &mut n_units, &mut header_mode, &mut sleep_interval);"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:846:1: 846:34 (#0)",
        "source": "static mut pids_alloc: idx_t = 0;"
      },
      {
        "span": "src/tail.rs:455:1: 455:40 (#0)",
        "source": "pub const Follow_name: Follow_mode = 1;"
      },
      {
        "span": "src/tail.rs:828:1: 832:3 (#0)",
        "source": "static mut follow_mode_string: [*const libc::c_char; 3] = [\n    b\"descriptor\\0\" as *const u8 as *const libc::c_char,\n    b\"name\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];"
      },
      {
        "span": "src/tail.rs:842:1: 843:18 (#0)",
        "source": "static mut max_n_unchanged_stats_between_opens: uintmax_t = 5 as libc::c_int\n    as uintmax_t;"
      },
      {
        "span": "src/tail.rs:837:1: 837:34 (#0)",
        "source": "static mut forever: bool = false;"
      },
      {
        "span": "src/tail.rs:850:1: 850:42 (#0)",
        "source": "static mut disable_inotify: bool = false;"
      },
      {
        "span": "src/tail.rs:845:1: 845:63 (#0)",
        "source": "static mut pids: *mut pid_t = 0 as *const pid_t as *mut pid_t;"
      },
      {
        "span": "src/tail.rs:844:1: 844:51 (#0)",
        "source": "static mut nbpids: libc::c_int = 0 as libc::c_int;"
      },
      {
        "span": "src/tail.rs:477:1: 477:34 (#0)",
        "source": "pub const never: header_mode = 2;"
      },
      {
        "span": "src/tail.rs:841:1: 841:39 (#0)",
        "source": "static mut line_end: libc::c_char = 0;"
      },
      {
        "span": "src/tail.rs:849:1: 849:45 (#0)",
        "source": "static mut presume_input_pipe: bool = false;"
      },
      {
        "span": "src/tail.rs:454:1: 454:46 (#0)",
        "source": "pub const Follow_descriptor: Follow_mode = 2;"
      },
      {
        "span": "src/tail.rs:851:1: 996:3 (#0)",
        "source": "static mut long_options: [option; 16] = [\n    {\n        let mut init = option {\n            name: b\"bytes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'c' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"follow\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 2 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: LONG_FOLLOW_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"lines\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'n' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"max-unchanged-stats\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: MAX_UNCHANGED_STATS_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"-disable-inotify\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: DISABLE_INOTIFY_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"pid\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: PID_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"-presume-input-pipe\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: PRESUME_INPUT_PIPE_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"quiet\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'q' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"retry\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: RETRY_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"silent\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'q' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"sleep-interval\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 's' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"verbose\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'v' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"zero-terminated\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'z' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];"
      },
      {
        "span": "src/tail.rs:836:1: 836:57 (#0)",
        "source": "static mut follow_mode: Follow_mode = Follow_descriptor;"
      },
      {
        "span": "src/tail.rs:834:1: 834:52 (#0)",
        "source": "static mut reopen_inaccessible_files: bool = false;"
      },
      {
        "span": "src/tail.rs:478:1: 478:35 (#0)",
        "source": "pub const always: header_mode = 1;"
      },
      {
        "span": "src/tail.rs:833:1: 833:81 (#0)",
        "source": "static mut follow_mode_map: [Follow_mode; 2] = [Follow_descriptor, Follow_name];"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/tail.rs:4650:9: 4674:40 (#0)",
        "pieces": [
          "src/tail.rs:4650:9: 4674:40 (#0)"
        ],
        "num_lines": 26,
        "source": "count_lines = c == 'n' as i32;\n                if *optarg as libc::c_int == '+' as i32 {\n                    from_start = 1 as libc::c_int != 0;\n                } else if *optarg as libc::c_int == '-' as i32 {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                *n_units = xdectoumax(\n                    optarg,\n                    0 as libc::c_int as uintmax_t,\n                    18446744073709551615 as libc::c_ulong,\n                    b\"bkKmMGTPEZYRQ0\\0\" as *const u8 as *const libc::c_char,\n                    if count_lines as libc::c_int != 0 {\n                        gettext(\n                            b\"invalid number of lines\\0\" as *const u8\n                                as *const libc::c_char,\n                        )\n                    } else {\n                        gettext(\n                            b\"invalid number of bytes\\0\" as *const u8\n                                as *const libc::c_char,\n                        )\n                    },\n                    0 as libc::c_int,\n                );\n                current_block_33 = 4567019141635105728;",
        "sub_chunks": [],
        "live_in": [
          "mut n_units: *mut u64",
          "mut c: i32",
          "mut c: i32",
          "mut current_block_33: u64"
        ],
        "live_out": [
          "mut n_units: *mut u64",
          "mut c: i32",
          "mut c: i32",
          "mut current_block_33: u64",
          "is_count_lines: bool",
          "optarg_str: std::borrow::Cow<str>"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/tail.rs:4679:9: 4693:40 (#0)",
        "pieces": [
          "src/tail.rs:4679:9: 4693:40 (#0)"
        ],
        "num_lines": 15,
        "source": "forever = 1 as libc::c_int != 0;\n                if optarg.is_null() {\n                    follow_mode = Follow_descriptor;\n                } else {\n                    follow_mode = follow_mode_map[__xargmatch_internal(\n                        b\"--follow\\0\" as *const u8 as *const libc::c_char,\n                        optarg,\n                        follow_mode_string.as_ptr(),\n                        follow_mode_map.as_ptr() as *const libc::c_void,\n                        ::core::mem::size_of::<Follow_mode>() as libc::c_ulong,\n                        argmatch_die,\n                        1 as libc::c_int != 0,\n                    ) as usize];\n                }\n                current_block_33 = 4567019141635105728;",
        "sub_chunks": [],
        "live_in": [
          "mut current_block_33: u64"
        ],
        "live_out": [
          "mut current_block_33: u64"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/tail.rs:4702:9: 4710:40 (#0)",
        "pieces": [
          "src/tail.rs:4702:9: 4710:40 (#0)"
        ],
        "num_lines": 12,
        "source": "max_n_unchanged_stats_between_opens = xdectoumax(\n                    optarg,\n                    0 as libc::c_int as uintmax_t,\n                    18446744073709551615 as libc::c_ulong,\n                    b\"\\0\" as *const u8 as *const libc::c_char,\n                    gettext(\n                        b\"invalid maximum number of unchanged stats between opens\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    0 as libc::c_int,\n                );\n                current_block_33 = 4567019141635105728;",
        "sub_chunks": [],
        "live_in": [
          "mut current_block_33: u64"
        ],
        "live_out": [
          "mut current_block_33: u64"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/tail.rs:4719:9: 4755:56 (#0)",
        "pieces": [
          "src/tail.rs:4719:9: 4755:56 (#0)"
        ],
        "num_lines": 37,
        "source": "if nbpids as libc::c_long == pids_alloc {\n                    pids = xpalloc(\n                        pids as *mut libc::c_void,\n                        &mut pids_alloc,\n                        1 as libc::c_int as idx_t,\n                        if (2147483647 as libc::c_int as libc::c_long)\n                            < 9223372036854775807 as libc::c_long\n                        {\n                            2147483647 as libc::c_int as libc::c_long\n                        } else {\n                            9223372036854775807 as libc::c_long\n                        },\n                        ::core::mem::size_of::<pid_t>() as libc::c_ulong as idx_t,\n                    ) as *mut pid_t;\n                }\n                let fresh6 = nbpids;\n                nbpids = nbpids + 1;\n                *pids\n                    .offset(\n                        fresh6 as isize,\n                    ) = xdectoumax(\n                    optarg,\n                    0 as libc::c_int as uintmax_t,\n                    (if (0 as libc::c_int) < -(1 as libc::c_int) {\n                        -(1 as libc::c_int)\n                    } else {\n                        (((1 as libc::c_int)\n                            << (::core::mem::size_of::<pid_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                    }) as uintmax_t,\n                    b\"\\0\" as *const u8 as *const libc::c_char,\n                    gettext(b\"invalid PID\\0\" as *const u8 as *const libc::c_char),\n                    0 as libc::c_int,\n                ) as pid_t;\n                current_block_33 = 4567019141635105728;",
        "sub_chunks": [],
        "live_in": [
          "mut current_block_33: u64"
        ],
        "live_out": [
          "mut current_block_33: u64",
          "fresh6: i32"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/tail.rs:4767:9: 4830:56 (#0)",
        "pieces": [
          "src/tail.rs:4767:9: 4830:56 (#0)"
        ],
        "num_lines": 64,
        "source": "let mut s: libc::c_double = 0.;\n                if !(xstrtod(\n                    optarg,\n                    0 as *mut *const libc::c_char,\n                    &mut s,\n                    Some(\n                        cl_strtod\n                            as unsafe extern \"C\" fn(\n                                *const libc::c_char,\n                                *mut *mut libc::c_char,\n                            ) -> libc::c_double,\n                    ),\n                ) as libc::c_int != 0 && 0 as libc::c_int as libc::c_double <= s)\n                {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"invalid number of seconds: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quote(optarg),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid number of seconds: %s\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid number of seconds: %s\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                *sleep_interval = s;\n                current_block_33 = 4567019141635105728;",
        "sub_chunks": [],
        "live_in": [
          "mut sleep_interval: *mut f64",
          "mut current_block_33: u64"
        ],
        "live_out": [
          "mut sleep_interval: *mut f64",
          "mut current_block_33: u64",
          "mut s: f64"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/tail.rs:4846:9: 4869:23 (#0)",
        "pieces": [
          "src/tail.rs:4846:9: 4869:23 (#0)"
        ],
        "num_lines": 24,
        "source": "version_etc(\n                    stdout,\n                    b\"tail\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Paul Rubin\\0\" as *const u8 as *const libc::c_char,\n                        b\"Paul Rubin\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                        b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"Ian Lance Taylor\\0\" as *const u8 as *const libc::c_char,\n                        b\"Ian Lance Taylor\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);",
        "sub_chunks": [],
        "live_in": [],
        "live_out": []
      },
      {
        "chunk_id": 6,
        "span": "src/tail.rs:4874:9: 4921:57 (#0)",
        "pieces": [
          "src/tail.rs:4874:9: 4921:57 (#0)"
        ],
        "num_lines": 48,
        "source": "if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"option used in invalid context -- %c\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        c,\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"option used in invalid context -- %c\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            c,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"option used in invalid context -- %c\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            c,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                current_block_33 = 17156019370052222107;",
        "sub_chunks": [],
        "live_in": [
          "mut c: i32",
          "mut c: i32",
          "mut current_block_33: u64"
        ],
        "live_out": [
          "mut c: i32",
          "mut c: i32",
          "mut current_block_33: u64"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/tail.rs:4624:5: 4939:3 (#0)",
        "pieces": [
          "src/tail.rs:4624:5: 4650:8 (#0)",
          "src/tail.rs:4676:1: 4679:8 (#0)",
          "src/tail.rs:4695:1: 4702:8 (#0)",
          "src/tail.rs:4712:1: 4719:8 (#0)",
          "src/tail.rs:4756:1: 4767:8 (#0)",
          "src/tail.rs:4831:1: 4846:8 (#0)",
          "src/tail.rs:4871:1: 4874:8 (#0)",
          "src/tail.rs:4922:1: 4939:3 (#0)"
        ],
        "num_lines": 77,
        "source": "c = getopt_long(\n            argc,\n            argv,\n            b\"c:n:fFqs:vz0123456789\\0\" as *const u8 as *const libc::c_char,\n            long_options.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if !(c != -(1 as libc::c_int)) {\n            break;\n        }\n        let mut current_block_33: u64;\n        match c {\n            70 => {\n                forever = 1 as libc::c_int != 0;\n                follow_mode = Follow_name;\n                reopen_inaccessible_files = 1 as libc::c_int != 0;\n                current_block_33 = 4567019141635105728;\n            }\n            99 | 110 => {\n               <<chunk 0>>            }\n            102 | 260 => {\n               <<chunk 1>>            }\n            256 => {\n                reopen_inaccessible_files = 1 as libc::c_int != 0;\n                current_block_33 = 4567019141635105728;\n            }\n            257 => {\n               <<chunk 2>>            }\n            261 => {\n                disable_inotify = 1 as libc::c_int != 0;\n                current_block_33 = 4567019141635105728;\n            }\n            258 => {\n               <<chunk 3>>            }\n            259 => {\n                presume_input_pipe = 1 as libc::c_int != 0;\n                current_block_33 = 4567019141635105728;\n            }\n            113 => {\n                *header_mode = never;\n                current_block_33 = 4567019141635105728;\n            }\n            115 => {\n               <<chunk 4>>            }\n            118 => {\n                *header_mode = always;\n                current_block_33 = 4567019141635105728;\n            }\n            122 => {\n                line_end = '\\0' as i32 as libc::c_char;\n                current_block_33 = 4567019141635105728;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n                current_block_33 = 4567019141635105728;\n            }\n            -3 => {\n               <<chunk 5>>            }\n            48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => {\n               <<chunk 6>>            }\n            _ => {\n                current_block_33 = 17156019370052222107;\n            }\n        }\n        match current_block_33 {\n            17156019370052222107 => {\n                usage(1 as libc::c_int);\n            }\n            _ => {}\n        }",
        "sub_chunks": [
          0,
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "live_in": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut n_units: *mut u64",
          "mut header_mode: *mut u32",
          "mut sleep_interval: *mut f64",
          "mut c: i32"
        ],
        "live_out": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut n_units: *mut u64",
          "mut header_mode: *mut u32",
          "mut sleep_interval: *mut f64",
          "mut c: i32",
          "mut c: i32",
          "mut current_block_33: u64"
        ]
      },
      {
        "chunk_id": 8,
        "span": "src/tail.rs:4618:5: 5022:3 (#0)",
        "pieces": [
          "src/tail.rs:4618:5: 4624:4 (#0)",
          "src/tail.rs:4941:1: 5022:3 (#0)"
        ],
        "num_lines": 100,
        "source": "let mut c: libc::c_int = 0;\n    loop {\n       <<chunk 7>>    }\n    if reopen_inaccessible_files {\n        if !forever {\n            reopen_inaccessible_files = 0 as libc::c_int != 0;\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: --retry ignored; --retry is useful only when following\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: --retry ignored; --retry is useful only when following\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: --retry ignored; --retry is useful only when following\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else if follow_mode as libc::c_uint\n            == Follow_descriptor as libc::c_int as libc::c_uint\n        {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: --retry only effective for the initial open\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: --retry only effective for the initial open\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: --retry only effective for the initial open\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    }",
        "sub_chunks": [
          7
        ],
        "live_in": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut n_units: *mut u64",
          "mut header_mode: *mut u32",
          "mut sleep_interval: *mut f64"
        ],
        "live_out": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut n_units: *mut u64",
          "mut header_mode: *mut u32",
          "mut sleep_interval: *mut f64",
          "mut c: i32"
        ]
      },
      {
        "chunk_id": 9,
        "span": "src/tail.rs:5024:5: 5088:2 (#0)",
        "pieces": [
          "src/tail.rs:5024:5: 5088:2 (#0)"
        ],
        "num_lines": 96,
        "source": "if nbpids != 0 && !forever {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"warning: PID ignored; --pid=PID is useful only when following\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: PID ignored; --pid=PID is useful only when following\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: PID ignored; --pid=PID is useful only when following\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    } else if nbpids != 0\n        && kill(*pids.offset(0 as libc::c_int as isize), 0 as libc::c_int)\n            != 0 as libc::c_int && *__errno_location() == 38 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"warning: --pid=PID is not supported on this system\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: --pid=PID is not supported on this system\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: --pid=PID is not supported on this system\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        nbpids = 0 as libc::c_int;\n        free(pids as *mut libc::c_void);\n    }",
        "sub_chunks": [],
        "live_in": [],
        "live_out": []
      }
    ]
  },
  {
    "func_defid": "DefId(0:170 ~ tail[5173]::write_error)",
    "span": "src/tail.rs:601:1: 644:2 (#0)",
    "pieces": [
      "src/tail.rs:601:1: 644:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "unsafe extern \"C\" fn write_error() {\n    let mut saved_errno: libc::c_int = *__errno_location();\n    fflush_unlocked(stdout);\n    fpurge(stdout);\n    clearerr_unlocked(stdout);\n    if 0 != 0 {\n        error(\n            1 as libc::c_int,\n            saved_errno,\n            gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n        );\n        if 1 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:279 ~ tail[5173]::tail_forever)",
        "span": "src/tail.rs:3019:9: 3019:23 (#0)",
        "source": "write_error();"
      },
      {
        "caller": "DefId(0:318 ~ tail[5173]::main_0)",
        "span": "src/tail.rs:5411:21: 5411:35 (#0)",
        "source": "write_error();"
      },
      {
        "caller": "DefId(0:288 ~ tail[5173]::check_fspec)",
        "span": "src/tail.rs:3264:13: 3264:27 (#0)",
        "source": "write_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:220 ~ tail[5173]::pipe_lines)",
    "span": "src/tail.rs:1690:1: 1868:2 (#0)",
    "pieces": [
      "src/tail.rs:1690:1: 1700:8 (#0)",
      "src/tail.rs:1778:1: 1779:8 (#0)",
      "src/tail.rs:1866:1: 1868:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn pipe_lines(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_lines: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:304 ~ tail[5173]::tail_lines)",
        "span": "src/tail.rs:4134:13: 4134:77 (#0)",
        "source": "let result = pipe_lines(pretty_filename, fd, n_lines, read_pos);"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/tail.rs:841:1: 841:39 (#0)",
        "source": "static mut line_end: libc::c_char = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/tail.rs:1700:9: 1777:36 (#0)",
        "pieces": [
          "src/tail.rs:1700:9: 1777:36 (#0)"
        ],
        "num_lines": 78,
        "source": "let mut first: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut last: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut tmp: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut total_lines: size_t = 0 as libc::c_int as size_t;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut n_read: size_t = 0;\n    last = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong) as *mut LBUFFER;\n    first = last;\n    (*first).nlines = 0 as libc::c_int as size_t;\n    (*first).nbytes = (*first).nlines;\n    (*first).next = 0 as *mut linebuffer;\n    tmp = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong) as *mut LBUFFER;\n    loop {\n        n_read = safe_read(\n            fd,\n            ((*tmp).buffer).as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if n_read == 0 as libc::c_int as libc::c_ulong\n            || n_read == -(1 as libc::c_int) as size_t\n        {\n            break;\n        }\n        (*tmp).nbytes = n_read;\n        *read_pos = (*read_pos as libc::c_ulong).wrapping_add(n_read) as uintmax_t\n            as uintmax_t;\n        (*tmp).nlines = 0 as libc::c_int as size_t;\n        (*tmp).next = 0 as *mut linebuffer;\n        let mut buffer_end: *const libc::c_char = ((*tmp).buffer)\n            .as_mut_ptr()\n            .offset(n_read as isize);\n        let mut p: *const libc::c_char = ((*tmp).buffer).as_mut_ptr();\n        loop {\n            p = memchr(\n                p as *const libc::c_void,\n                line_end as libc::c_int,\n                buffer_end.offset_from(p) as libc::c_long as libc::c_ulong,\n            ) as *const libc::c_char;\n            if p.is_null() {\n                break;\n            }\n            p = p.offset(1);\n            p;\n            (*tmp).nlines = ((*tmp).nlines).wrapping_add(1);\n            (*tmp).nlines;\n        }\n        total_lines = (total_lines as libc::c_ulong).wrapping_add((*tmp).nlines)\n            as size_t as size_t;\n        if ((*tmp).nbytes).wrapping_add((*last).nbytes)\n            < 8192 as libc::c_int as libc::c_ulong\n        {\n            memcpy(\n                &mut *((*last).buffer).as_mut_ptr().offset((*last).nbytes as isize)\n                    as *mut libc::c_char as *mut libc::c_void,\n                ((*tmp).buffer).as_mut_ptr() as *const libc::c_void,\n                (*tmp).nbytes,\n            );\n            (*last)\n                .nbytes = ((*last).nbytes as libc::c_ulong).wrapping_add((*tmp).nbytes)\n                as size_t as size_t;\n            (*last)\n                .nlines = ((*last).nlines as libc::c_ulong).wrapping_add((*tmp).nlines)\n                as size_t as size_t;\n        } else {\n            (*last).next = tmp;\n            last = (*last).next;\n            if total_lines.wrapping_sub((*first).nlines) > n_lines {\n                tmp = first;\n                total_lines = (total_lines as libc::c_ulong)\n                    .wrapping_sub((*first).nlines) as size_t as size_t;\n                first = (*first).next;\n            } else {\n                tmp = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong)\n                    as *mut LBUFFER;\n            }\n        }\n    }\n    free(tmp as *mut libc::c_void);",
        "sub_chunks": [],
        "live_in": [
          "fd: i32",
          "n_lines: u64",
          "read_pos: *mut u64"
        ],
        "live_out": [
          "fd: i32",
          "n_lines: u64",
          "read_pos: *mut u64",
          "mut first: *mut linebuffer",
          "mut last: *mut linebuffer",
          "mut tmp: *mut linebuffer",
          "mut total_lines: u64",
          "mut ok: bool",
          "mut n_read: u64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/tail.rs:1779:9: 1865:15 (#0)",
        "pieces": [
          "src/tail.rs:1779:9: 1865:15 (#0)"
        ],
        "num_lines": 87,
        "source": "if n_read == -(1 as libc::c_int) as size_t {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        ok = 0 as libc::c_int != 0;\n    } else if !((*last).nbytes == 0 as libc::c_int as libc::c_ulong) {\n        if !(n_lines == 0 as libc::c_int as libc::c_ulong) {\n            if (*last)\n                .buffer[((*last).nbytes).wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                as usize] as libc::c_int != line_end as libc::c_int\n            {\n                (*last).nlines = ((*last).nlines).wrapping_add(1);\n                (*last).nlines;\n                total_lines = total_lines.wrapping_add(1);\n                total_lines;\n            }\n            tmp = first;\n            while total_lines.wrapping_sub((*tmp).nlines) > n_lines {\n                total_lines = (total_lines as libc::c_ulong).wrapping_sub((*tmp).nlines)\n                    as size_t as size_t;\n                tmp = (*tmp).next;\n            }\n            let mut beg: *const libc::c_char = ((*tmp).buffer).as_mut_ptr();\n            let mut buffer_end_0: *const libc::c_char = ((*tmp).buffer)\n                .as_mut_ptr()\n                .offset((*tmp).nbytes as isize);\n            if total_lines > n_lines {\n                let mut j: size_t = 0;\n                j = total_lines.wrapping_sub(n_lines);\n                while j != 0 {\n                    beg = rawmemchr(beg as *const libc::c_void, line_end as libc::c_int)\n                        as *const libc::c_char;\n                    beg = beg.offset(1);\n                    beg;\n                    j = j.wrapping_sub(1);\n                    j;\n                }\n            }\n            xwrite_stdout(beg, buffer_end_0.offset_from(beg) as libc::c_long as size_t);\n            tmp = (*tmp).next;\n            while !tmp.is_null() {\n                xwrite_stdout(((*tmp).buffer).as_mut_ptr(), (*tmp).nbytes);\n                tmp = (*tmp).next;\n            }\n        }\n    }\n    while !first.is_null() {\n        tmp = (*first).next;\n        free(first as *mut libc::c_void);\n        first = tmp;\n    }\n    return ok;",
        "sub_chunks": [],
        "live_in": [
          "pretty_filename: *const i8",
          "n_lines: u64",
          "mut first: *mut linebuffer",
          "mut last: *mut linebuffer",
          "mut tmp: *mut linebuffer",
          "mut total_lines: u64",
          "mut ok: bool",
          "mut n_read: u64"
        ],
        "live_out": [
          "pretty_filename: *const i8",
          "n_lines: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:225 ~ tail[5173]::start_lines)",
    "span": "src/tail.rs:2084:1: 2138:2 (#0)",
    "pieces": [
      "src/tail.rs:2084:1: 2138:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 100,
    "source": "unsafe extern \"C\" fn start_lines(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_lines: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> libc::c_int {\n    if n_lines == 0 as libc::c_int as libc::c_ulong {\n        return 0 as libc::c_int;\n    }\n    loop {\n        let mut buffer: [libc::c_char; 8192] = [0; 8192];\n        let mut bytes_read: size_t = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if bytes_read == 0 as libc::c_int as libc::c_ulong {\n            return -(1 as libc::c_int);\n        }\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 1 as libc::c_int;\n        }\n        let mut buffer_end: *mut libc::c_char = buffer\n            .as_mut_ptr()\n            .offset(bytes_read as isize);\n        *read_pos = (*read_pos as libc::c_ulong).wrapping_add(bytes_read) as uintmax_t\n            as uintmax_t;\n        let mut p: *mut libc::c_char = buffer.as_mut_ptr();\n        loop {\n            p = memchr(\n                p as *const libc::c_void,\n                line_end as libc::c_int,\n                buffer_end.offset_from(p) as libc::c_long as libc::c_ulong,\n            ) as *mut libc::c_char;\n            if p.is_null() {\n                break;\n            }\n            p = p.offset(1);\n            p;\n            n_lines = n_lines.wrapping_sub(1);\n            if n_lines == 0 as libc::c_int as libc::c_ulong {\n                if p < buffer_end {\n                    xwrite_stdout(\n                        p,\n                        buffer_end.offset_from(p) as libc::c_long as size_t,\n                    );\n                }\n                return 0 as libc::c_int;\n            }\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:304 ~ tail[5173]::tail_lines)",
        "span": "src/tail.rs:4088:9: 4088:106 (#0)",
        "source": "let mut t: libc::c_int = start_lines(pretty_filename, fd, n_lines.try_into().unwrap(), read_pos);"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:265 ~ tail[5173]::tail_lines)",
    "span": "src/tail.rs:4022:1: 4139:2 (#0)",
    "pieces": [
      "src/tail.rs:4022:1: 4139:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 117,
    "source": "unsafe extern \"C\" fn tail_lines(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_lines: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    let mut stats: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    if fstat(fd, &mut stats) != 0 {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    if from_start {\n        let mut t: libc::c_int = start_lines(pretty_filename, fd, n_lines, read_pos);\n        if t != 0 {\n            return t < 0 as libc::c_int;\n        }\n        *read_pos = (*read_pos as libc::c_ulong)\n            .wrapping_add(\n                dump_remainder(\n                    0 as libc::c_int != 0,\n                    pretty_filename,\n                    fd,\n                    18446744073709551615 as libc::c_ulong,\n                ),\n            ) as uintmax_t as uintmax_t;\n    } else {\n        let mut start_pos: off_t = -(1 as libc::c_int) as off_t;\n        let mut end_pos: off_t = 0;\n        if !presume_input_pipe\n            && stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint\n            && {\n                start_pos = lseek(fd, 0 as libc::c_int as __off_t, 1 as libc::c_int);\n                start_pos != -(1 as libc::c_int) as libc::c_long\n            }\n            && {\n                end_pos = lseek(fd, 0 as libc::c_int as __off_t, 2 as libc::c_int);\n                start_pos < end_pos\n            }\n        {\n            *read_pos = end_pos as uintmax_t;\n            if end_pos != 0 as libc::c_int as libc::c_long\n                && !file_lines(\n                    pretty_filename,\n                    fd,\n                    &mut stats,\n                    n_lines,\n                    start_pos,\n                    end_pos,\n                    read_pos,\n                )\n            {\n                return 0 as libc::c_int != 0;\n            }\n        } else {\n            if start_pos != -(1 as libc::c_int) as libc::c_long {\n                xlseek(fd, start_pos, 0 as libc::c_int, pretty_filename);\n            }\n            return pipe_lines(pretty_filename, fd, n_lines, read_pos);\n        }\n    }\n    return 1 as libc::c_int != 0;\n}",
    "calls": [
      {
        "caller": "DefId(0:306 ~ tail[5173]::tail)",
        "span": "src/tail.rs:4147:20: 4149:6 (#0)",
        "source": "{\n        return tail_lines(filename, fd, n_units, read_pos)\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:267 ~ tail[5173]::tail)",
    "span": "src/tail.rs:4140:1: 4152:2 (#0)",
    "pieces": [
      "src/tail.rs:4140:1: 4152:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn tail(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_units: uintmax_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n    *read_pos = 0 as libc::c_int as uintmax_t;\n    if count_lines {\n        return tail_lines(filename, fd, n_units, read_pos)\n    } else {\n        return tail_bytes(filename, fd, n_units, read_pos)\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4218:5: 4218:59 (#0)",
        "source": "ok = tail(pretty_name(f), fd, n_units, &mut read_pos);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:172 ~ tail[5173]::xset_binary_mode_error)",
    "span": "src/tail.rs:652:1: 666:2 (#0)",
    "pieces": [
      "src/tail.rs:652:1: 666:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 1,
    "source": "unsafe extern \"C\" fn xset_binary_mode_error() {}",
    "calls": [
      {
        "caller": "DefId(0:211 ~ tail[5173]::xset_binary_mode)",
        "span": "src/tail.rs:672:13: 672:38 (#0)",
        "source": "xset_binary_mode_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:173 ~ tail[5173]::xset_binary_mode)",
    "span": "src/tail.rs:669:1: 675:2 (#0)",
    "pieces": [
      "src/tail.rs:669:1: 675:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:307 ~ tail[5173]::tail_file)",
        "span": "src/tail.rs:4160:5: 4160:28 (#0)",
        "source": "xset_binary_mode(0, 0);"
      },
      {
        "caller": "DefId(0:318 ~ tail[5173]::main_0)",
        "span": "src/tail.rs:5328:1: 5328:30 (#0)",
        "source": "xset_binary_mode(fd1, mode1);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:268 ~ tail[5173]::tail_file)",
    "span": "src/tail.rs:4153:1: 4452:2 (#0)",
    "pieces": [
      "src/tail.rs:4153:1: 4154:4 (#0)",
      "src/tail.rs:4452:1: 4452:2 (#0)"
    ],
    "sub_chunks": [
      5
    ],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn tail_file(mut f: *mut File_spec, mut n_units: uintmax_t) -> bool {\n   <<chunk 5>>}",
    "calls": [],
    "globals": [
      {
        "span": "src/tail.rs:848:1: 848:42 (#0)",
        "source": "static mut have_read_stdin: bool = false;"
      },
      {
        "span": "src/tail.rs:834:1: 834:52 (#0)",
        "source": "static mut reopen_inaccessible_files: bool = false;"
      },
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/tail.rs:391:1: 391:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/tail.rs:4166:5: 4210:12 (#0)",
        "pieces": [
          "src/tail.rs:4166:5: 4210:12 (#0)"
        ],
        "num_lines": 54,
        "source": "if forever {\n            (*f).fd = -(1 as libc::c_int);\n            (*f).errnum = *__errno_location();\n            (*f).ignore = !reopen_inaccessible_files;\n            (*f).ino = 0 as libc::c_int as ino_t;\n            (*f).dev = 0 as libc::c_int as dev_t;\n        }\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"cannot open %s for reading\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open %s for reading\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open %s for reading\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        ok = 0 as libc::c_int != 0;",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut fd: i32",
          "mut ok: bool"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut fd: i32",
          "mut ok: bool"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/tail.rs:4220:9: 4241:2 (#0)",
        "pieces": [
          "src/tail.rs:4220:9: 4241:2 (#0)"
        ],
        "num_lines": 19,
        "source": "let mut stats: stat = stat {\n                st_dev: 0,\n                st_ino: 0,\n                st_mode: 0,\n                st_nlink: 0,\n                st_uid: 0,\n                st_gid: 0,\n                st_rdev: 0,\n                __pad1: 0,\n                st_size: 0,\n                st_blksize: 0,\n                __pad2: 0,\n                st_blocks: 0,\n                st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n                st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n                st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n                __glibc_reserved: [0; 2],\n            };\n            (*f).errnum = ok as libc::c_int - 1 as libc::c_int;",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut ok: bool"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut ok: bool",
          "mut stats: stat"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/tail.rs:4244:9: 4393:14 (#0)",
        "pieces": [
          "src/tail.rs:4244:9: 4393:14 (#0)"
        ],
        "num_lines": 150,
        "source": "if fstat(fd, &mut stats) < 0 as libc::c_int {\n                ok = 0 as libc::c_int != 0;\n                (*f).errnum = *__errno_location();\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(f),\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(f),\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            } else if !(stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint\n                || stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                    == 0o10000 as libc::c_int as libc::c_uint\n                || stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                    == 0o140000 as libc::c_int as libc::c_uint\n                || stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                    == 0o20000 as libc::c_int as libc::c_uint)\n            {\n                ok = 0 as libc::c_int != 0;\n                (*f).errnum = -(1 as libc::c_int);\n                (*f).tailable = 0 as libc::c_int != 0;\n                (*f).ignore = !reopen_inaccessible_files;\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s: cannot follow end of this type of file%s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            pretty_name(f),\n                        ),\n                        if (*f).ignore as libc::c_int != 0 {\n                            gettext(\n                                b\"; giving up on this name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ) as *const libc::c_char\n                        } else {\n                            b\"\\0\" as *const u8 as *const libc::c_char\n                        },\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s: cannot follow end of this type of file%s\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                pretty_name(f),\n                            ),\n                            if (*f).ignore as libc::c_int != 0 {\n                                gettext(\n                                    b\"; giving up on this name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ) as *const libc::c_char\n                            } else {\n                                b\"\\0\" as *const u8 as *const libc::c_char\n                            },\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s: cannot follow end of this type of file%s\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                pretty_name(f),\n                            ),\n                            if (*f).ignore as libc::c_int != 0 {\n                                gettext(\n                                    b\"; giving up on this name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ) as *const libc::c_char\n                            } else {\n                                b\"\\0\" as *const u8 as *const libc::c_char\n                            },\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut fd: i32",
          "mut ok: bool",
          "mut stats: stat"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut fd: i32",
          "mut ok: bool",
          "mut stats: stat"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/tail.rs:4395:9: 4408:2 (#0)",
        "pieces": [
          "src/tail.rs:4395:9: 4408:2 (#0)"
        ],
        "num_lines": 18,
        "source": "if !ok {\n                (*f).ignore = !reopen_inaccessible_files;\n                close_fd(fd, pretty_name(f));\n                (*f).fd = -(1 as libc::c_int);\n            } else {\n                record_open_fd(\n                    f,\n                    fd,\n                    read_pos as off_t,\n                    &mut stats,\n                    if is_stdin as libc::c_int != 0 {\n                        -(1 as libc::c_int)\n                    } else {\n                        1 as libc::c_int\n                    },\n                );\n                (*f).remote = fremote(fd, pretty_name(f));\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut fd: i32",
          "mut ok: bool",
          "is_stdin: bool",
          "mut read_pos: u64",
          "mut stats: stat"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut fd: i32",
          "mut ok: bool",
          "is_stdin: bool",
          "mut read_pos: u64",
          "mut stats: stat"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/tail.rs:4412:9: 4445:12 (#0)",
        "pieces": [
          "src/tail.rs:4412:9: 4445:12 (#0)"
        ],
        "num_lines": 43,
        "source": "if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, pretty_name(f)),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            ok = 0 as libc::c_int != 0;",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut ok: bool"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut ok: bool"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/tail.rs:4154:5: 4450:3 (#0)",
        "pieces": [
          "src/tail.rs:4154:5: 4166:4 (#0)",
          "src/tail.rs:4212:1: 4220:8 (#0)",
          "src/tail.rs:4243:1: 4244:8 (#0)",
          "src/tail.rs:4394:1: 4395:8 (#0)",
          "src/tail.rs:4410:1: 4412:8 (#0)",
          "src/tail.rs:4447:1: 4450:3 (#0)"
        ],
        "num_lines": 33,
        "source": "let mut fd: libc::c_int = 0;\n    let mut ok: bool = false;\n    let mut is_stdin: bool = strcmp(\n        (*f).name,\n        b\"-\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int;\n    if is_stdin {\n        have_read_stdin = 1 as libc::c_int != 0;\n        fd = 0 as libc::c_int;\n        xset_binary_mode(0 as libc::c_int, 0 as libc::c_int);\n    } else {\n        fd = open_safer((*f).name, 0 as libc::c_int | 0 as libc::c_int);\n    }\n    (*f)\n        .tailable = !(reopen_inaccessible_files as libc::c_int != 0\n        && fd == -(1 as libc::c_int));\n    if fd == -(1 as libc::c_int) {\n       <<chunk 0>>    } else {\n        let mut read_pos: uintmax_t = 0;\n        if print_headers {\n            write_header(pretty_name(f));\n        }\n        ok = tail(pretty_name(f), fd, n_units, &mut read_pos);\n        if forever {\n           <<chunk 1>>           <<chunk 2>>           <<chunk 3>>        } else if !is_stdin && close(fd) != 0 {\n           <<chunk 4>>        }\n    }\n    return ok;",
        "sub_chunks": [
          0,
          1,
          2,
          3,
          4
        ],
        "live_in": [
          "mut f: *mut File_spec",
          "mut n_units: u64"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut n_units: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:255 ~ tail[5173]::wd_hasher)",
    "span": "src/tail.rs:3140:1: 3146:2 (#0)",
    "pieces": [
      "src/tail.rs:3140:1: 3146:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn wd_hasher(\n    mut entry: *const libc::c_void,\n    mut tabsize: size_t,\n) -> size_t {\n    let mut spec: *const File_spec = entry as *const File_spec;\n    return ((*spec).wd as libc::c_ulong).wrapping_rem(tabsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:254 ~ tail[5173]::tailable_stdin)",
    "span": "src/tail.rs:3121:1: 3139:2 (#0)",
    "pieces": [
      "src/tail.rs:3121:1: 3139:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn tailable_stdin(\n    mut f: *const File_spec,\n    mut n_files: size_t,\n) -> bool {\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if !(*f.offset(i as isize)).ignore\n            && strcmp(\n                (*f.offset(i as isize)).name,\n                b\"-\\0\" as *const u8 as *const libc::c_char,\n            ) == 0 as libc::c_int\n        {\n            return 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:242 ~ tail[5173]::writers_are_dead)",
    "span": "src/tail.rs:2714:1: 2727:2 (#0)",
    "pieces": [
      "src/tail.rs:2714:1: 2727:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "unsafe extern \"C\" fn writers_are_dead() -> bool {\n    if nbpids == 0 {\n        return 0 as libc::c_int != 0;\n    }\n    let mut i: libc::c_int = 0 as libc::c_int;\n    while i < nbpids {\n        if kill(*pids.offset(i as isize), 0 as libc::c_int) == 0 as libc::c_int\n            || *__errno_location() == 1 as libc::c_int\n        {\n            return 0 as libc::c_int != 0;\n        }\n        i += 1;\n        i;\n    }\n    return 1 as libc::c_int != 0;\n}",
    "calls": [
      {
        "caller": "DefId(0:290 ~ tail[5173]::tail_forever_inotify)",
        "span": "src/tail.rs:3543:21: 3543:59 (#0)",
        "source": "let writers_dead = writers_are_dead();"
      },
      {
        "caller": "DefId(0:279 ~ tail[5173]::tail_forever)",
        "span": "src/tail.rs:3028:5: 3028:39 (#0)",
        "source": "writers_dead = writers_are_dead();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:243 ~ tail[5173]::tail_forever)",
    "span": "src/tail.rs:2729:1: 3053:2 (#0)",
    "pieces": [
      "src/tail.rs:2729:1: 2734:4 (#0)",
      "src/tail.rs:3053:1: 3053:2 (#0)"
    ],
    "sub_chunks": [
      6
    ],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn tail_forever(\n    mut f: *mut File_spec,\n    mut n_files: size_t,\n    mut sleep_interval: libc::c_double,\n) {\n   <<chunk 6>>}",
    "calls": [
      {
        "caller": "DefId(0:318 ~ tail[5173]::main_0)",
        "span": "src/tail.rs:5465:9: 5465:50 (#0)",
        "source": "tail_forever(F, n_files, sleep_interval);"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:844:1: 844:51 (#0)",
        "source": "static mut nbpids: libc::c_int = 0 as libc::c_int;"
      },
      {
        "span": "src/tail.rs:836:1: 836:57 (#0)",
        "source": "static mut follow_mode: Follow_mode = Follow_descriptor;"
      },
      {
        "span": "src/tail.rs:454:1: 454:46 (#0)",
        "source": "pub const Follow_descriptor: Follow_mode = 2;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/tail.rs:2851:29: 2890:41 (#0)",
        "pieces": [
          "src/tail.rs:2851:29: 2890:41 (#0)"
        ],
        "num_lines": 54,
        "source": "(*f.offset(i as isize)).fd = -(1 as libc::c_int);\n                            (*f.offset(i as isize)).errnum = *__errno_location();\n                            if 0 != 0 {\n                                error(\n                                    0 as libc::c_int,\n                                    *__errno_location(),\n                                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        name,\n                                    ),\n                                );\n                                if 0 as libc::c_int != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                            } else {\n                                ({\n                                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                                    error(\n                                        __errstatus,\n                                        *__errno_location(),\n                                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                        quotearg_n_style_colon(\n                                            0 as libc::c_int,\n                                            shell_escape_quoting_style,\n                                            name,\n                                        ),\n                                    );\n                                    if __errstatus != 0 as libc::c_int {\n                                        unreachable!();\n                                    } else {};\n                                    \n                                });\n                                ({\n                                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                                    error(\n                                        __errstatus,\n                                        *__errno_location(),\n                                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                        quotearg_n_style_colon(\n                                            0 as libc::c_int,\n                                            shell_escape_quoting_style,\n                                            name,\n                                        ),\n                                    );\n                                    if __errstatus != 0 as libc::c_int {\n                                        unreachable!();\n                                    } else {};\n                                    \n                                });\n                            };\n                            close(fd);\n                            current_block_47 = 17778012151635330486;",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut i: u64",
          "mut current_block_47: u64",
          "mut fd: i32",
          "mut name: *const i8"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut i: u64",
          "mut current_block_47: u64",
          "mut fd: i32",
          "mut name: *const i8"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/tail.rs:2893:29: 2921:2 (#0)",
        "pieces": [
          "src/tail.rs:2893:29: 2921:2 (#0)"
        ],
        "num_lines": 38,
        "source": "if (*f.offset(i as isize)).mode == stats.st_mode\n                                && (!(stats.st_mode\n                                    & 0o170000 as libc::c_int as libc::c_uint\n                                    == 0o100000 as libc::c_int as libc::c_uint)\n                                    || (*f.offset(i as isize)).size == stats.st_size)\n                                && timespec_cmp(\n                                    (*f.offset(i as isize)).mtime,\n                                    get_stat_mtime(&mut stats),\n                                ) == 0 as libc::c_int\n                            {\n                                let ref mut fresh1 = (*f.offset(i as isize))\n                                    .n_unchanged_stats;\n                                let fresh2 = *fresh1;\n                                *fresh1 = (*fresh1).wrapping_add(1);\n                                if max_n_unchanged_stats_between_opens <= fresh2\n                                    && follow_mode as libc::c_uint\n                                        == Follow_name as libc::c_int as libc::c_uint\n                                {\n                                    recheck(\n                                        &mut *f.offset(i as isize),\n                                        (*f.offset(i as isize)).blocking != 0,\n                                    );\n                                    (*f.offset(i as isize))\n                                        .n_unchanged_stats = 0 as libc::c_int as uintmax_t;\n                                }\n                                if fd != (*f.offset(i as isize)).fd\n                                    || stats.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                                        == 0o100000 as libc::c_int as libc::c_uint\n                                    || (1 as libc::c_int as libc::c_ulong) < n_files\n                                {\n                                    current_block_47 = 17778012151635330486;\n                                } else {\n                                    read_unchanged = 1 as libc::c_int != 0;\n                                    current_block_47 = 8693738493027456495;\n                                }\n                            } else {\n                                current_block_47 = 8693738493027456495;\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "blocking: bool",
          "mut i: u64",
          "mut current_block_47: u64",
          "mut fd: i32",
          "mut mode: u32",
          "mut stats: stat",
          "mut read_unchanged: bool"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "blocking: bool",
          "mut i: u64",
          "mut current_block_47: u64",
          "mut fd: i32",
          "mut mode: u32",
          "mut stats: stat",
          "mut read_unchanged: bool",
          "file_spec: &mut File_spec"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/tail.rs:2923:29: 2958:2 (#0)",
        "pieces": [
          "src/tail.rs:2923:29: 2958:2 (#0)"
        ],
        "num_lines": 116,
        "source": "match current_block_47 {\n                                17778012151635330486 => {}\n                                _ => {\n                                    if fd == (*f.offset(i as isize)).fd {} else {\n                                        __assert_fail(\n                                            b\"fd == f[i].fd\\0\" as *const u8 as *const libc::c_char,\n                                            b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                                            1258 as libc::c_int as libc::c_uint,\n                                            (*::core::mem::transmute::<\n                                                &[u8; 54],\n                                                &[libc::c_char; 54],\n                                            >(\n                                                b\"void tail_forever(struct File_spec *, size_t, double)\\0\",\n                                            ))\n                                                .as_ptr(),\n                                        );\n                                    }\n                                    'c_14118: {\n                                        if fd == (*f.offset(i as isize)).fd {} else {\n                                            __assert_fail(\n                                                b\"fd == f[i].fd\\0\" as *const u8 as *const libc::c_char,\n                                                b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                                                1258 as libc::c_int as libc::c_uint,\n                                                (*::core::mem::transmute::<\n                                                    &[u8; 54],\n                                                    &[libc::c_char; 54],\n                                                >(\n                                                    b\"void tail_forever(struct File_spec *, size_t, double)\\0\",\n                                                ))\n                                                    .as_ptr(),\n                                            );\n                                        }\n                                    };\n                                    (*f.offset(i as isize)).mtime = get_stat_mtime(&mut stats);\n                                    (*f.offset(i as isize)).mode = stats.st_mode;\n                                    if !read_unchanged {\n                                        (*f.offset(i as isize))\n                                            .n_unchanged_stats = 0 as libc::c_int as uintmax_t;\n                                    }\n                                    if mode & 0o170000 as libc::c_int as libc::c_uint\n                                        == 0o100000 as libc::c_int as libc::c_uint\n                                        && stats.st_size < (*f.offset(i as isize)).size\n                                    {\n                                        if 0 != 0 {\n                                            error(\n                                                0 as libc::c_int,\n                                                0 as libc::c_int,\n                                                gettext(\n                                                    b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char,\n                                                ),\n                                                quotearg_n_style_colon(\n                                                    0 as libc::c_int,\n                                                    shell_escape_quoting_style,\n                                                    name,\n                                                ),\n                                            );\n                                            if 0 as libc::c_int != 0 as libc::c_int {\n                                                unreachable!();\n                                            } else {};\n                                        } else {\n                                            ({\n                                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                                error(\n                                                    __errstatus,\n                                                    0 as libc::c_int,\n                                                    gettext(\n                                                        b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char,\n                                                    ),\n                                                    quotearg_n_style_colon(\n                                                        0 as libc::c_int,\n                                                        shell_escape_quoting_style,\n                                                        name,\n                                                    ),\n                                                );\n                                                if __errstatus != 0 as libc::c_int {\n                                                    unreachable!();\n                                                } else {};\n                                                \n                                            });\n                                            ({\n                                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                                error(\n                                                    __errstatus,\n                                                    0 as libc::c_int,\n                                                    gettext(\n                                                        b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char,\n                                                    ),\n                                                    quotearg_n_style_colon(\n                                                        0 as libc::c_int,\n                                                        shell_escape_quoting_style,\n                                                        name,\n                                                    ),\n                                                );\n                                                if __errstatus != 0 as libc::c_int {\n                                                    unreachable!();\n                                                } else {};\n                                                \n                                            });\n                                        };\n                                        xlseek(\n                                            fd,\n                                            0 as libc::c_int as off_t,\n                                            0 as libc::c_int,\n                                            name,\n                                        );\n                                        (*f.offset(i as isize)).size = 0 as libc::c_int as off_t;\n                                    }\n                                    if i != last {\n                                        if print_headers {\n                                            write_header(name);\n                                        }\n                                        last = i;\n                                    }\n                                    current_block_47 = 3222590281903869779;\n                                }\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut f: *mut File_spec",
          "mut last: u64",
          "mut i: u64",
          "mut current_block_47: u64",
          "mut fd: i32",
          "mut name: *const i8",
          "mut mode: u32",
          "mut stats: stat",
          "mut read_unchanged: bool"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut last: u64",
          "mut i: u64",
          "mut current_block_47: u64",
          "mut fd: i32",
          "mut name: *const i8",
          "mut mode: u32",
          "mut stats: stat",
          "mut read_unchanged: bool",
          "file: &mut File_spec"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/tail.rs:2763:9: 2997:22 (#0)",
        "pieces": [
          "src/tail.rs:2763:9: 2851:28 (#0)",
          "src/tail.rs:2892:1: 2893:28 (#0)",
          "src/tail.rs:2923:1: 2923:28 (#0)",
          "src/tail.rs:2960:1: 2997:22 (#0)"
        ],
        "num_lines": 130,
        "source": "fd = (*f.offset(i as isize)).fd;\n                    name = pretty_name(&mut *f.offset(i as isize));\n                    mode = (*f.offset(i as isize)).mode;\n                    if (*f.offset(i as isize)).blocking != blocking as libc::c_int {\n                        let mut old_flags: libc::c_int = rpl_fcntl(fd, 3 as libc::c_int);\n                        let mut new_flags: libc::c_int = old_flags\n                            | (if blocking as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                0o4000 as libc::c_int\n                            });\n                        if old_flags < 0 as libc::c_int\n                            || new_flags != old_flags\n                                && rpl_fcntl(fd, 4 as libc::c_int, new_flags)\n                                    == -(1 as libc::c_int)\n                        {\n                            if !((*f.offset(i as isize)).mode\n                                & 0o170000 as libc::c_int as libc::c_uint\n                                == 0o100000 as libc::c_int as libc::c_uint\n                                && *__errno_location() == 1 as libc::c_int)\n                            {\n                                if 0 != 0 {\n                                    error(\n                                        1 as libc::c_int,\n                                        *__errno_location(),\n                                        gettext(\n                                            b\"%s: cannot change nonblocking mode\\0\" as *const u8\n                                                as *const libc::c_char,\n                                        ),\n                                        quotearg_n_style_colon(\n                                            0 as libc::c_int,\n                                            shell_escape_quoting_style,\n                                            name,\n                                        ),\n                                    );\n                                    if 1 as libc::c_int != 0 as libc::c_int {\n                                        unreachable!();\n                                    } else {};\n                                } else {\n                                    ({\n                                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                                        error(\n                                            __errstatus,\n                                            *__errno_location(),\n                                            gettext(\n                                                b\"%s: cannot change nonblocking mode\\0\" as *const u8\n                                                    as *const libc::c_char,\n                                            ),\n                                            quotearg_n_style_colon(\n                                                0 as libc::c_int,\n                                                shell_escape_quoting_style,\n                                                name,\n                                            ),\n                                        );\n                                        if __errstatus != 0 as libc::c_int {\n                                            unreachable!();\n                                        } else {};\n                                        \n                                    });\n                                    ({\n                                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                                        error(\n                                            __errstatus,\n                                            *__errno_location(),\n                                            gettext(\n                                                b\"%s: cannot change nonblocking mode\\0\" as *const u8\n                                                    as *const libc::c_char,\n                                            ),\n                                            quotearg_n_style_colon(\n                                                0 as libc::c_int,\n                                                shell_escape_quoting_style,\n                                                name,\n                                            ),\n                                        );\n                                        if __errstatus != 0 as libc::c_int {\n                                            unreachable!();\n                                        } else {};\n                                        \n                                    });\n                                };\n                            }\n                        } else {\n                            (*f.offset(i as isize)).blocking = blocking as libc::c_int;\n                        }\n                    }\n                    let mut read_unchanged: bool = 0 as libc::c_int != 0;\n                    if (*f.offset(i as isize)).blocking == 0 {\n                        if fstat(fd, &mut stats) != 0 as libc::c_int {\n                           <<chunk 0>>                        } else {\n                           <<chunk 1>>                           <<chunk 2>>                        }\n                    } else {\n                        current_block_47 = 3222590281903869779;\n                    }\n                    match current_block_47 {\n                        17778012151635330486 => {}\n                        _ => {\n                            let mut bytes_to_read: uintmax_t = 0;\n                            if (*f.offset(i as isize)).blocking != 0 {\n                                bytes_to_read = (18446744073709551615 as libc::c_ulong)\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong);\n                            } else if mode & 0o170000 as libc::c_int as libc::c_uint\n                                == 0o100000 as libc::c_int as libc::c_uint\n                                && (*f.offset(i as isize)).remote as libc::c_int != 0\n                            {\n                                bytes_to_read = (stats.st_size\n                                    - (*f.offset(i as isize)).size) as uintmax_t;\n                            } else {\n                                bytes_to_read = 18446744073709551615 as libc::c_ulong;\n                            }\n                            bytes_read = dump_remainder(\n                                0 as libc::c_int != 0,\n                                name,\n                                fd,\n                                bytes_to_read,\n                            );\n                            if read_unchanged as libc::c_int != 0 && bytes_read != 0 {\n                                (*f.offset(i as isize))\n                                    .n_unchanged_stats = 0 as libc::c_int as uintmax_t;\n                            }\n                            any_input = (any_input as libc::c_int\n                                | (bytes_read != 0 as libc::c_int as libc::c_ulong)\n                                    as libc::c_int) != 0;\n                            let ref mut fresh3 = (*f.offset(i as isize)).size;\n                            *fresh3 = (*fresh3 as libc::c_ulong).wrapping_add(bytes_read)\n                                as off_t as off_t;\n                        }\n                    }",
        "sub_chunks": [
          0,
          1,
          2
        ],
        "live_in": [
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "blocking: bool",
          "mut last: u64",
          "mut i: u64",
          "mut any_input: bool",
          "mut current_block_47: u64",
          "mut fd: i32",
          "mut name: *const i8",
          "mut mode: u32",
          "mut stats: stat",
          "mut bytes_read: u64"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "blocking: bool",
          "mut last: u64",
          "mut i: u64",
          "mut any_input: bool",
          "mut current_block_47: u64",
          "mut fd: i32",
          "mut name: *const i8",
          "mut mode: u32",
          "mut stats: stat",
          "mut bytes_read: u64",
          "mut read_unchanged: bool"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/tail.rs:2753:5: 3002:3 (#0)",
        "pieces": [
          "src/tail.rs:2753:5: 2763:8 (#0)",
          "src/tail.rs:2998:1: 3002:3 (#0)"
        ],
        "num_lines": 31,
        "source": "let mut fd: libc::c_int = 0;\n            let mut name: *const libc::c_char = 0 as *const libc::c_char;\n            let mut mode: mode_t = 0;\n            let mut stats: stat = stat {\n                st_dev: 0,\n                st_ino: 0,\n                st_mode: 0,\n                st_nlink: 0,\n                st_uid: 0,\n                st_gid: 0,\n                st_rdev: 0,\n                __pad1: 0,\n                st_size: 0,\n                st_blksize: 0,\n                __pad2: 0,\n                st_blocks: 0,\n                st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n                st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n                st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n                __glibc_reserved: [0; 2],\n            };\n            let mut bytes_read: uintmax_t = 0;\n            if !(*f.offset(i as isize)).ignore {\n                if (*f.offset(i as isize)).fd < 0 as libc::c_int {\n                    recheck(&mut *f.offset(i as isize), blocking);\n                } else {\n                   <<chunk 3>>                }\n            }\n            i = i.wrapping_add(1);\n            i;",
        "sub_chunks": [
          3
        ],
        "live_in": [
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "blocking: bool",
          "mut last: u64",
          "mut i: u64",
          "mut any_input: bool",
          "mut current_block_47: u64"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "blocking: bool",
          "mut last: u64",
          "mut i: u64",
          "mut any_input: bool",
          "mut current_block_47: u64"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/tail.rs:2744:5: 3044:3 (#0)",
        "pieces": [
          "src/tail.rs:2744:5: 2753:4 (#0)",
          "src/tail.rs:3004:1: 3044:3 (#0)"
        ],
        "num_lines": 109,
        "source": "let mut i: size_t = 0;\n        let mut any_input: bool = 0 as libc::c_int != 0;\n        let mut current_block_47: u64;\n        i = 0 as libc::c_int as size_t;\n        while i < n_files {\n           <<chunk 4>>        }\n        if !any_live_files(f, n_files) {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(b\"no files remaining\\0\" as *const u8 as *const libc::c_char),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"no files remaining\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"no files remaining\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            break;\n        } else {\n            if (!any_input || blocking as libc::c_int != 0)\n                && fflush_unlocked(stdout) != 0 as libc::c_int\n            {\n                write_error();\n            }\n            check_output_alive();\n            if any_input {\n                continue;\n            }\n            if writers_dead {\n                break;\n            }\n            writers_dead = writers_are_dead();\n            if !writers_dead && xnanosleep(sleep_interval) != 0 {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot read realtime clock\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot read realtime clock\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot read realtime clock\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        }",
        "sub_chunks": [
          4
        ],
        "live_in": [
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "mut sleep_interval: f64",
          "blocking: bool",
          "mut last: u64",
          "mut writers_dead: bool"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "mut sleep_interval: f64"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/tail.rs:2734:5: 3051:3 (#0)",
        "pieces": [
          "src/tail.rs:2734:5: 2744:4 (#0)",
          "src/tail.rs:3046:1: 3051:3 (#0)"
        ],
        "num_lines": 14,
        "source": "let mut blocking: bool = nbpids == 0\n        && follow_mode as libc::c_uint\n            == Follow_descriptor as libc::c_int as libc::c_uint\n        && n_files == 1 as libc::c_int as libc::c_ulong\n        && (*f.offset(0 as libc::c_int as isize)).fd != -(1 as libc::c_int)\n        && !((*f.offset(0 as libc::c_int as isize)).mode\n            & 0o170000 as libc::c_int as libc::c_uint\n            == 0o100000 as libc::c_int as libc::c_uint);\n    let mut last: size_t = 0;\n    let mut writers_dead: bool = 0 as libc::c_int != 0;\n    last = n_files.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    loop {\n       <<chunk 5>>    };",
        "sub_chunks": [
          5
        ],
        "live_in": [
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "mut sleep_interval: f64"
        ],
        "live_out": [
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "mut sleep_interval: f64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:250 ~ tail[5173]::any_non_remote_file)",
    "span": "src/tail.rs:3065:1: 3073:2 (#0)",
    "pieces": [
      "src/tail.rs:3065:1: 3073:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "unsafe extern \"C\" fn any_non_remote_file(\n    mut f: *const File_spec,\n    mut n_files: size_t,\n) -> bool {\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if 0 as libc::c_int <= (*f.offset(i as isize)).fd\n            && !(*f.offset(i as isize)).remote\n        {\n            return 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:241 ~ tail[5173]::any_live_files)",
    "span": "src/tail.rs:2691:1: 2713:2 (#0)",
    "pieces": [
      "src/tail.rs:2691:1: 2713:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "unsafe extern \"C\" fn any_live_files(\n    mut f: *const File_spec,\n    mut n_files: size_t,\n) -> bool {\n    if reopen_inaccessible_files as libc::c_int != 0\n        && follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n    {\n        return 1 as libc::c_int != 0;\n    }\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if 0 as libc::c_int <= (*f.offset(i as isize)).fd {\n            return 1 as libc::c_int != 0\n        } else if !(*f.offset(i as isize)).ignore\n            && reopen_inaccessible_files as libc::c_int != 0\n        {\n            return 1 as libc::c_int != 0\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:169 ~ tail[5173]::usable_st_size)",
    "span": "src/tail.rs:593:1: 599:2 (#0)",
    "pieces": [
      "src/tail.rs:593:1: 599:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn usable_st_size(mut sb: *const stat) -> bool {\n    return (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        || (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o120000 as libc::c_int as libc::c_uint\n        || ((*sb).st_mode).wrapping_sub((*sb).st_mode) != 0 || 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:272 ~ tail[5173]::ignore_fifo_and_pipe)",
    "span": "src/tail.rs:5091:1: 5118:2 (#0)",
    "pieces": [
      "src/tail.rs:5091:1: 5118:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "unsafe extern \"C\" fn ignore_fifo_and_pipe(\n    mut f: *mut File_spec,\n    mut n_files: size_t,\n) -> size_t {\n    let mut n_viable: size_t = 0 as libc::c_int as size_t;\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        let mut is_a_fifo_or_pipe: bool = strcmp(\n            (*f.offset(i as isize)).name,\n            b\"-\\0\" as *const u8 as *const libc::c_char,\n        ) == 0 as libc::c_int && !(*f.offset(i as isize)).ignore\n            && 0 as libc::c_int <= (*f.offset(i as isize)).fd\n            && ((*f.offset(i as isize)).mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o10000 as libc::c_int as libc::c_uint\n                || 1 as libc::c_int != 1 as libc::c_int\n                    && isapipe((*f.offset(i as isize)).fd) != 0);\n        if is_a_fifo_or_pipe {\n            (*f.offset(i as isize)).fd = -(1 as libc::c_int);\n            (*f.offset(i as isize)).ignore = 1 as libc::c_int != 0;\n        } else {\n            n_viable = n_viable.wrapping_add(1);\n            n_viable;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return n_viable;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:215 ~ tail[5173]::file_lines)",
    "span": "src/tail.rs:1453:1: 1689:2 (#0)",
    "pieces": [
      "src/tail.rs:1453:1: 1462:4 (#0)",
      "src/tail.rs:1689:1: 1689:2 (#0)"
    ],
    "sub_chunks": [
      2
    ],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn file_lines(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut sb: *const stat,\n    mut n_lines: uintmax_t,\n    mut start_pos: off_t,\n    mut end_pos: off_t,\n    mut read_pos: *mut uintmax_t,\n) -> bool {\n   <<chunk 2>>}",
    "calls": [],
    "globals": [
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/tail.rs:847:1: 847:33 (#0)",
        "source": "static mut page_size: idx_t = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/tail.rs:1522:9: 1555:12 (#0)",
        "pieces": [
          "src/tail.rs:1522:9: 1555:12 (#0)"
        ],
        "num_lines": 39,
        "source": "if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        ok = 0 as libc::c_int != 0;",
        "sub_chunks": [],
        "live_in": [
          "mut pretty_filename: *const i8",
          "mut ok: bool"
        ],
        "live_out": [
          "mut pretty_filename: *const i8",
          "mut ok: bool"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/tail.rs:1558:9: 1685:10 (#0)",
        "pieces": [
          "src/tail.rs:1558:9: 1685:10 (#0)"
        ],
        "num_lines": 128,
        "source": "*read_pos = (pos as libc::c_ulong).wrapping_add(bytes_read);\n        if bytes_read != 0\n            && *buffer\n                .offset(\n                    bytes_read.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                ) as libc::c_int != line_end as libc::c_int\n        {\n            n_lines = n_lines.wrapping_sub(1);\n            n_lines;\n        }\n        's_79: loop {\n            let mut n: size_t = bytes_read;\n            while n != 0 {\n                let mut nl: *const libc::c_char = 0 as *const libc::c_char;\n                nl = memrchr(buffer as *const libc::c_void, line_end as libc::c_int, n)\n                    as *const libc::c_char;\n                if nl.is_null() {\n                    break;\n                }\n                n = nl.offset_from(buffer) as libc::c_long as size_t;\n                let fresh0 = n_lines;\n                n_lines = n_lines.wrapping_sub(1);\n                if !(fresh0 == 0 as libc::c_int as libc::c_ulong) {\n                    continue;\n                }\n                xwrite_stdout(\n                    nl.offset(1 as libc::c_int as isize),\n                    bytes_read\n                        .wrapping_sub(n.wrapping_add(1 as libc::c_int as libc::c_ulong)),\n                );\n                *read_pos = (*read_pos as libc::c_ulong)\n                    .wrapping_add(\n                        dump_remainder(\n                            0 as libc::c_int != 0,\n                            pretty_filename,\n                            fd,\n                            (end_pos as libc::c_ulong)\n                                .wrapping_sub(\n                                    (pos as libc::c_ulong).wrapping_add(bytes_read),\n                                ),\n                        ),\n                    ) as uintmax_t as uintmax_t;\n                break 's_79;\n            }\n            if pos == start_pos {\n                xlseek(fd, start_pos, 0 as libc::c_int, pretty_filename);\n                *read_pos = (start_pos as libc::c_ulong)\n                    .wrapping_add(\n                        dump_remainder(\n                            0 as libc::c_int != 0,\n                            pretty_filename,\n                            fd,\n                            end_pos as uintmax_t,\n                        ),\n                    );\n                break;\n            } else {\n                pos -= bufsize as libc::c_long;\n                xlseek(fd, pos, 0 as libc::c_int, pretty_filename);\n                bytes_read = safe_read(\n                    fd,\n                    buffer as *mut libc::c_void,\n                    bufsize as size_t,\n                );\n                if bytes_read == -(1 as libc::c_int) as size_t {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_filename,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    pretty_filename,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    pretty_filename,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                    break;\n                } else {\n                    *read_pos = (pos as libc::c_ulong).wrapping_add(bytes_read);\n                    if !(bytes_read > 0 as libc::c_int as libc::c_ulong) {\n                        break;\n                    }\n                }\n            }\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut pretty_filename: *const i8",
          "mut fd: i32",
          "mut n_lines: u64",
          "mut start_pos: i64",
          "mut end_pos: i64",
          "mut read_pos: *mut u64",
          "mut buffer: *mut i8",
          "mut bytes_read: u64",
          "mut bufsize: i32",
          "mut pos: i64",
          "mut ok: bool"
        ],
        "live_out": [
          "mut pretty_filename: *const i8",
          "mut fd: i32",
          "mut n_lines: u64",
          "mut start_pos: i64",
          "mut end_pos: i64",
          "mut read_pos: *mut u64",
          "mut buffer: *mut i8",
          "mut bytes_read: u64",
          "mut bufsize: i32",
          "mut pos: i64",
          "mut ok: bool",
          "mut n: u64"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/tail.rs:1462:5: 1688:15 (#0)",
        "pieces": [
          "src/tail.rs:1462:5: 1522:8 (#0)",
          "src/tail.rs:1557:1: 1558:8 (#0)",
          "src/tail.rs:1686:1: 1688:15 (#0)"
        ],
        "num_lines": 66,
        "source": "let mut buffer: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut bytes_read: size_t = 0;\n    let mut bufsize: blksize_t = 8192 as libc::c_int;\n    let mut pos: off_t = end_pos;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    if n_lines == 0 as libc::c_int as libc::c_ulong {\n        return 1 as libc::c_int != 0;\n    }\n    if (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n    {} else {\n        __assert_fail(\n            b\"((((sb->st_mode)) & 0170000) == (0100000))\\0\" as *const u8\n                as *const libc::c_char,\n            b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n            543 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 95],\n                &[libc::c_char; 95],\n            >(\n                b\"_Bool file_lines(const char *, int, const struct stat *, uintmax_t, off_t, off_t, uintmax_t *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_10359: {\n        if (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o100000 as libc::c_int as libc::c_uint\n        {} else {\n            __assert_fail(\n                b\"((((sb->st_mode)) & 0170000) == (0100000))\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"tail.c\\0\" as *const u8 as *const libc::c_char,\n                543 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 95],\n                    &[libc::c_char; 95],\n                >(\n                    b\"_Bool file_lines(const char *, int, const struct stat *, uintmax_t, off_t, off_t, uintmax_t *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    if (*sb).st_size % page_size == 0 as libc::c_int as libc::c_long {\n        bufsize = (if 8192 as libc::c_int as libc::c_long > page_size {\n            8192 as libc::c_int as libc::c_long\n        } else {\n            page_size\n        }) as blksize_t;\n    }\n    buffer = xmalloc(bufsize as size_t) as *mut libc::c_char;\n    bytes_read = ((pos - start_pos) % bufsize as libc::c_long) as size_t;\n    if bytes_read == 0 as libc::c_int as libc::c_ulong {\n        bytes_read = bufsize as size_t;\n    }\n    pos = (pos as libc::c_ulong).wrapping_sub(bytes_read) as off_t as off_t;\n    xlseek(fd, pos, 0 as libc::c_int, pretty_filename);\n    bytes_read = safe_read(fd, buffer as *mut libc::c_void, bytes_read);\n    if bytes_read == -(1 as libc::c_int) as size_t {\n       <<chunk 0>>    } else {\n       <<chunk 1>>    }\n    free(buffer as *mut libc::c_void);\n    return ok;",
        "sub_chunks": [
          0,
          1
        ],
        "live_in": [
          "mut pretty_filename: *const i8",
          "mut fd: i32",
          "mut sb: *const stat",
          "mut n_lines: u64",
          "mut start_pos: i64",
          "mut end_pos: i64",
          "mut read_pos: *mut u64"
        ],
        "live_out": [
          "mut pretty_filename: *const i8",
          "mut fd: i32",
          "mut sb: *const stat",
          "mut n_lines: u64",
          "mut start_pos: i64",
          "mut end_pos: i64",
          "mut read_pos: *mut u64",
          "mut buffer: *mut i8",
          "mut bytes_read: u64",
          "mut bufsize: i32",
          "mut pos: i64",
          "mut ok: bool"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:257 ~ tail[5173]::check_fspec)",
    "span": "src/tail.rs:3156:1: 3267:2 (#0)",
    "pieces": [
      "src/tail.rs:3156:1: 3267:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 112,
    "source": "unsafe extern \"C\" fn check_fspec(\n    mut fspec: *mut File_spec,\n    mut prev_fspec: *mut *mut File_spec,\n) {\n    let mut stats: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut name: *const libc::c_char = 0 as *const libc::c_char;\n    if (*fspec).fd == -(1 as libc::c_int) {\n        return;\n    }\n    name = pretty_name(fspec);\n    if fstat((*fspec).fd, &mut stats) != 0 as libc::c_int {\n        (*fspec).errnum = *__errno_location();\n        close_fd((*fspec).fd, name);\n        (*fspec).fd = -(1 as libc::c_int);\n        return;\n    }\n    if (*fspec).mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint && stats.st_size < (*fspec).size\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char),\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    name,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(b\"%s: file truncated\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        xlseek((*fspec).fd, 0 as libc::c_int as off_t, 0 as libc::c_int, name);\n        (*fspec).size = 0 as libc::c_int as off_t;\n    } else if (*fspec).mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint && stats.st_size == (*fspec).size\n        && timespec_cmp((*fspec).mtime, get_stat_mtime(&mut stats)) == 0 as libc::c_int\n    {\n        return\n    }\n    let mut want_header: bool = print_headers as libc::c_int != 0\n        && fspec != *prev_fspec;\n    let mut bytes_read: uintmax_t = dump_remainder(\n        want_header,\n        name,\n        (*fspec).fd,\n        18446744073709551615 as libc::c_ulong,\n    );\n    (*fspec)\n        .size = ((*fspec).size as libc::c_ulong).wrapping_add(bytes_read) as off_t\n        as off_t;\n    if bytes_read != 0 {\n        *prev_fspec = fspec;\n        if fflush_unlocked(stdout) != 0 as libc::c_int {\n            write_error();\n        }\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:290 ~ tail[5173]::tail_forever_inotify)",
        "span": "src/tail.rs:3883:5: 3883:41 (#0)",
        "source": "check_fspec(fspec, &mut prev_fspec);"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:391:1: 391:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/tail.rs:840:1: 840:40 (#0)",
        "source": "static mut print_headers: bool = false;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:259 ~ tail[5173]::tail_forever_inotify)",
    "span": "src/tail.rs:3268:1: 3892:2 (#0)",
    "pieces": [
      "src/tail.rs:3268:1: 3275:4 (#0)",
      "src/tail.rs:3507:1: 3514:8 (#0)",
      "src/tail.rs:3891:1: 3892:2 (#0)"
    ],
    "sub_chunks": [
      8,
      7
    ],
    "num_lines": 18,
    "source": "unsafe extern \"C\" fn tail_forever_inotify(\n    mut wd: libc::c_int,\n    mut f: *mut File_spec,\n    mut n_files: size_t,\n    mut sleep_interval: libc::c_double,\n    mut wd_to_namep: *mut *mut Hash_table,\n) {\n   <<chunk 8>>    evlen = (evlen as libc::c_ulong)\n        .wrapping_add(\n            (::core::mem::size_of::<inotify_event>() as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong),\n        ) as size_t as size_t;\n    evbuf = xmalloc(evlen) as *mut libc::c_char;\n    loop {\n       <<chunk 7>>    };\n}",
    "calls": [
      {
        "caller": "DefId(0:318 ~ tail[5173]::main_0)",
        "span": "src/tail.rs:5414:17: 5414:79 (#0)",
        "source": "tail_forever_inotify(wd, F, n_files, sleep_interval, &mut ht);"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:838:1: 838:41 (#0)",
        "source": "static mut monitor_output: bool = false;"
      },
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/tail.rs:3311:13: 3367:2 (#0)",
        "pieces": [
          "src/tail.rs:3311:13: 3367:2 (#0)"
        ],
        "num_lines": 141,
        "source": "let mut fnlen: size_t = strlen((*f.offset(i as isize)).name);\n            if evlen < fnlen {\n                evlen = fnlen;\n            }\n            (*f.offset(i as isize)).wd = -(1 as libc::c_int);\n            if follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n            {\n                let mut dirlen: size_t = dir_len((*f.offset(i as isize)).name);\n                let mut prev: libc::c_char = *((*f.offset(i as isize)).name)\n                    .offset(dirlen as isize);\n                (*f.offset(i as isize))\n                    .basename_start = (last_component((*f.offset(i as isize)).name))\n                    .offset_from((*f.offset(i as isize)).name) as libc::c_long as size_t;\n                *((*f.offset(i as isize)).name)\n                    .offset(dirlen as isize) = '\\0' as i32 as libc::c_char;\n                (*f.offset(i as isize))\n                    .parent_wd = inotify_add_watch(\n                    wd,\n                    if dirlen != 0 {\n                        (*f.offset(i as isize)).name as *const libc::c_char\n                    } else {\n                        b\".\\0\" as *const u8 as *const libc::c_char\n                    },\n                    (0x100 as libc::c_int | 0x200 as libc::c_int | 0x80 as libc::c_int\n                        | 0x4 as libc::c_int | 0x400 as libc::c_int) as uint32_t,\n                );\n                *((*f.offset(i as isize)).name).offset(dirlen as isize) = prev;\n                if (*f.offset(i as isize)).parent_wd < 0 as libc::c_int {\n                    if *__errno_location() != 28 as libc::c_int {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot watch parent directory of %s\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    (*f.offset(i as isize)).name,\n                                ),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    gettext(\n                                        b\"cannot watch parent directory of %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quotearg_style(\n                                        shell_escape_always_quoting_style,\n                                        (*f.offset(i as isize)).name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    gettext(\n                                        b\"cannot watch parent directory of %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quotearg_style(\n                                        shell_escape_always_quoting_style,\n                                        (*f.offset(i as isize)).name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    } else {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"inotify resources exhausted\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"inotify resources exhausted\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"inotify resources exhausted\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    }\n                    found_unwatchable_dir = 1 as libc::c_int != 0;\n                    break;\n                }\n            }\n            (*f.offset(i as isize))\n                .wd = inotify_add_watch(\n                wd,\n                (*f.offset(i as isize)).name,\n                inotify_wd_mask,\n            );",
        "sub_chunks": [],
        "live_in": [
          "mut wd: i32",
          "mut f: *mut File_spec",
          "mut found_unwatchable_dir: bool",
          "mut evlen: u64",
          "mut len: u64",
          "mut inotify_wd_mask: u32",
          "mut i: u64"
        ],
        "live_out": [
          "mut wd: i32",
          "mut f: *mut File_spec",
          "mut found_unwatchable_dir: bool",
          "mut evlen: u64",
          "mut len: u64",
          "mut inotify_wd_mask: u32",
          "mut i: u64",
          "fnlen: usize"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/tail.rs:3369:13: 3395:2 (#0)",
        "pieces": [
          "src/tail.rs:3369:13: 3395:2 (#0)"
        ],
        "num_lines": 119,
        "source": "if (*f.offset(i as isize)).wd < 0 as libc::c_int {\n                if (*f.offset(i as isize)).fd != -(1 as libc::c_int) {\n                    tailed_but_unwatchable = 1 as libc::c_int != 0;\n                }\n                if *__errno_location() == 28 as libc::c_int\n                    || *__errno_location() == 12 as libc::c_int\n                {\n                    no_inotify_resources = 1 as libc::c_int != 0;\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"inotify resources exhausted\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"inotify resources exhausted\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"inotify resources exhausted\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    break;\n                } else if *__errno_location() != (*f.offset(i as isize)).errnum {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                (*f.offset(i as isize)).name,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    (*f.offset(i as isize)).name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    (*f.offset(i as isize)).name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n            } else {\n                if (hash_insert(\n                    wd_to_name,\n                    &mut *f.offset(i as isize) as *mut File_spec as *const libc::c_void,\n                ))\n                    .is_null()\n                {\n                    xalloc_die();\n                }\n                found_watchable_file = 1 as libc::c_int != 0;\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut wd: i32",
          "mut f: *mut File_spec",
          "mut wd_to_name: *mut hash_table",
          "mut found_watchable_file: bool",
          "mut tailed_but_unwatchable: bool",
          "mut no_inotify_resources: bool",
          "mut i: u64"
        ],
        "live_out": [
          "mut wd: i32",
          "mut f: *mut File_spec",
          "mut wd_to_name: *mut hash_table",
          "mut found_watchable_file: bool",
          "mut tailed_but_unwatchable: bool",
          "mut no_inotify_resources: bool",
          "mut i: u64"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/tail.rs:3531:5: 3625:52 (#0)",
        "pieces": [
          "src/tail.rs:3531:5: 3625:52 (#0)"
        ],
        "num_lines": 95,
        "source": "let mut file_change: libc::c_int = 0;\n            let mut pfd: [pollfd; 2] = [pollfd {\n                fd: 0,\n                events: 0,\n                revents: 0,\n            }; 2];\n            loop {\n                let mut delay: libc::c_int = -(1 as libc::c_int);\n                if nbpids != 0 {\n                    if writers_dead {\n                        exit(0 as libc::c_int);\n                    }\n                    writers_dead = writers_are_dead();\n                    if writers_dead as libc::c_int != 0\n                        || sleep_interval <= 0 as libc::c_int as libc::c_double\n                    {\n                        delay = 0 as libc::c_int;\n                    } else if sleep_interval\n                        < (2147483647 as libc::c_int / 1000 as libc::c_int\n                            - 1 as libc::c_int) as libc::c_double\n                    {\n                        let mut ddelay: libc::c_double = sleep_interval\n                            * 1000 as libc::c_int as libc::c_double;\n                        delay = ddelay as libc::c_int;\n                        delay += ((delay as libc::c_double) < ddelay) as libc::c_int;\n                    }\n                }\n                pfd[0 as libc::c_int as usize].fd = wd;\n                pfd[0 as libc::c_int as usize]\n                    .events = 0x1 as libc::c_int as libc::c_short;\n                pfd[1 as libc::c_int as usize].fd = 1 as libc::c_int;\n                pfd[1 as libc::c_int as usize]\n                    .revents = 0 as libc::c_int as libc::c_short;\n                pfd[1 as libc::c_int as usize]\n                    .events = pfd[1 as libc::c_int as usize].revents;\n                file_change = poll(\n                    pfd.as_mut_ptr(),\n                    (monitor_output as libc::c_int + 1 as libc::c_int) as nfds_t,\n                    delay,\n                );\n                if !(file_change == 0 as libc::c_int) {\n                    break;\n                }\n            }\n            if file_change < 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"error waiting for inotify and output events\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error waiting for inotify and output events\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error waiting for inotify and output events\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            if pfd[1 as libc::c_int as usize].revents != 0 {\n                die_pipe();\n            }\n            len = safe_read(wd, evbuf as *mut libc::c_void, evlen);\n            evbuf_off = 0 as libc::c_int as size_t;",
        "sub_chunks": [],
        "live_in": [
          "mut wd: i32",
          "mut sleep_interval: f64",
          "mut writers_dead: bool",
          "mut evlen: u64",
          "mut evbuf: *mut i8",
          "mut evbuf_off: u64",
          "mut len: u64"
        ],
        "live_out": [
          "mut wd: i32",
          "mut sleep_interval: f64",
          "mut writers_dead: bool",
          "mut evlen: u64",
          "mut evbuf: *mut i8",
          "mut evbuf_off: u64",
          "mut len: u64",
          "mut file_change: i32",
          "mut pfd: [pollfd; 2]"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/tail.rs:3628:5: 3648:2 (#0)",
        "pieces": [
          "src/tail.rs:3628:5: 3648:2 (#0)"
        ],
        "num_lines": 62,
        "source": "if (len == 0 as libc::c_int as libc::c_ulong\n                || len == -(1 as libc::c_int) as size_t\n                    && *__errno_location() == 22 as libc::c_int)\n                && {\n                    let fresh4 = max_realloc;\n                    max_realloc = max_realloc.wrapping_sub(1);\n                    fresh4 != 0\n                }\n            {\n                len = 0 as libc::c_int as size_t;\n                evlen = (evlen as libc::c_ulong)\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong) as size_t as size_t;\n                evbuf = xrealloc(evbuf as *mut libc::c_void, evlen) as *mut libc::c_char;\n                continue;\n            } else if len == 0 as libc::c_int as libc::c_ulong\n                || len == -(1 as libc::c_int) as size_t\n            {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading inotify event\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading inotify event\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading inotify event\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut max_realloc: u32",
          "mut evlen: u64",
          "mut evbuf: *mut i8",
          "mut len: u64"
        ],
        "live_out": [
          "mut max_realloc: u32",
          "mut evlen: u64",
          "mut evbuf: *mut i8",
          "mut len: u64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/tail.rs:3678:5: 3814:78 (#0)",
        "pieces": [
          "src/tail.rs:3678:5: 3814:78 (#0)"
        ],
        "num_lines": 137,
        "source": "let mut j: size_t = 0;\n            j = 0 as libc::c_int as size_t;\n            while j < n_files {\n                if (*f.offset(j as isize)).parent_wd == (*ev).wd\n                    && strcmp(\n                        ((*ev).name).as_mut_ptr(),\n                        ((*f.offset(j as isize)).name)\n                            .offset((*f.offset(j as isize)).basename_start as isize),\n                    ) == 0 as libc::c_int\n                {\n                    break;\n                }\n                j = j.wrapping_add(1);\n                j;\n            }\n            if j == n_files {\n                continue;\n            }\n            fspec = &mut *f.offset(j as isize) as *mut File_spec;\n            let mut new_wd: libc::c_int = -(1 as libc::c_int);\n            let mut deleting: bool = (*ev).mask & 0x200 as libc::c_int as libc::c_uint\n                != 0;\n            if !deleting {\n                new_wd = inotify_add_watch(\n                    wd,\n                    (*f.offset(j as isize)).name,\n                    inotify_wd_mask,\n                );\n            }\n            if !deleting && new_wd < 0 as libc::c_int {\n                if *__errno_location() == 28 as libc::c_int\n                    || *__errno_location() == 12 as libc::c_int\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"inotify resources exhausted\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"inotify resources exhausted\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"inotify resources exhausted\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    return;\n                } else {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                (*f.offset(j as isize)).name,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    (*f.offset(j as isize)).name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot watch %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    (*f.offset(j as isize)).name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n            }\n            let mut new_watch: bool = false;\n            new_watch = !deleting\n                && ((*fspec).wd < 0 as libc::c_int || new_wd != (*fspec).wd);",
        "sub_chunks": [],
        "live_in": [
          "mut wd: i32",
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "mut inotify_wd_mask: u32",
          "mut fspec: *mut File_spec",
          "mut ev: *mut inotify_event"
        ],
        "live_out": [
          "mut wd: i32",
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "mut inotify_wd_mask: u32",
          "mut fspec: *mut File_spec",
          "mut ev: *mut inotify_event",
          "mut j: u64",
          "mut new_wd: i32",
          "mut deleting: bool",
          "mut new_watch: bool"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/tail.rs:3817:5: 3842:2 (#0)",
        "pieces": [
          "src/tail.rs:3817:5: 3842:2 (#0)"
        ],
        "num_lines": 30,
        "source": "if new_watch {\n                if 0 as libc::c_int <= (*fspec).wd {\n                    inotify_rm_watch(wd, (*fspec).wd);\n                    hash_remove(wd_to_name, fspec as *const libc::c_void);\n                }\n                (*fspec).wd = new_wd;\n                if new_wd == -(1 as libc::c_int) {\n                    continue;\n                }\n                let mut prev_0: *mut File_spec = hash_remove(\n                    wd_to_name,\n                    fspec as *const libc::c_void,\n                ) as *mut File_spec;\n                if !prev_0.is_null() && prev_0 != fspec {\n                    if follow_mode as libc::c_uint\n                        == Follow_name as libc::c_int as libc::c_uint\n                    {\n                        recheck(prev_0, 0 as libc::c_int != 0);\n                    }\n                    (*prev_0).wd = -(1 as libc::c_int);\n                    close_fd((*prev_0).fd, pretty_name(prev_0));\n                }\n                if (hash_insert(wd_to_name, fspec as *const libc::c_void)).is_null() {\n                    xalloc_die();\n                }\n            }\n            if follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n            {\n                recheck(fspec, 0 as libc::c_int != 0);\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut wd: i32",
          "mut wd_to_name: *mut hash_table",
          "mut fspec: *mut File_spec",
          "mut new_wd: i32",
          "mut new_watch: bool"
        ],
        "live_out": [
          "mut wd: i32",
          "mut wd_to_name: *mut hash_table",
          "mut fspec: *mut File_spec",
          "mut new_wd: i32",
          "mut new_watch: bool"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/tail.rs:3846:5: 3867:100 (#0)",
        "pieces": [
          "src/tail.rs:3846:5: 3867:100 (#0)"
        ],
        "num_lines": 23,
        "source": "let mut key: File_spec = File_spec {\n                name: 0 as *mut libc::c_char,\n                size: 0,\n                mtime: timespec { tv_sec: 0, tv_nsec: 0 },\n                dev: 0,\n                ino: 0,\n                mode: 0,\n                ignore: false,\n                remote: false,\n                tailable: false,\n                fd: 0,\n                errnum: 0,\n                blocking: 0,\n                wd: 0,\n                parent_wd: 0,\n                basename_start: 0,\n                n_unchanged_stats: 0,\n            };\n            key.wd = (*ev).wd;\n            fspec = hash_lookup(\n                wd_to_name,\n                &mut key as *mut File_spec as *const libc::c_void,\n            ) as *mut File_spec;",
        "sub_chunks": [],
        "live_in": [
          "mut wd: i32",
          "mut wd_to_name: *mut hash_table",
          "mut fspec: *mut File_spec",
          "mut ev: *mut inotify_event"
        ],
        "live_out": [
          "mut wd: i32",
          "mut wd_to_name: *mut hash_table",
          "mut fspec: *mut File_spec",
          "mut ev: *mut inotify_event"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/tail.rs:3514:9: 3889:3 (#0)",
        "pieces": [
          "src/tail.rs:3514:9: 3531:4 (#0)",
          "src/tail.rs:3626:1: 3628:4 (#0)",
          "src/tail.rs:3650:1: 3678:4 (#0)",
          "src/tail.rs:3815:1: 3817:4 (#0)",
          "src/tail.rs:3844:1: 3846:4 (#0)",
          "src/tail.rs:3869:1: 3889:3 (#0)"
        ],
        "num_lines": 133,
        "source": "let mut fspec: *mut File_spec = 0 as *mut File_spec;\n        let mut ev: *mut inotify_event = 0 as *mut inotify_event;\n        let mut void_ev: *mut libc::c_void = 0 as *mut libc::c_void;\n        if follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n            && !reopen_inaccessible_files\n            && hash_get_n_entries(wd_to_name) == 0 as libc::c_int as libc::c_ulong\n        {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(b\"no files remaining\\0\" as *const u8 as *const libc::c_char),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"no files remaining\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"no files remaining\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if len <= evbuf_off {\n           <<chunk 2>>           <<chunk 3>>        }\n        void_ev = evbuf.offset(evbuf_off as isize) as *mut libc::c_void;\n        ev = void_ev as *mut inotify_event;\n        evbuf_off = (evbuf_off as libc::c_ulong)\n            .wrapping_add(\n                (::core::mem::size_of::<inotify_event>() as libc::c_ulong)\n                    .wrapping_add((*ev).len as libc::c_ulong),\n            ) as size_t as size_t;\n        if (*ev).mask & 0x400 as libc::c_int as libc::c_uint != 0 && (*ev).len == 0 {\n            i = 0 as libc::c_int as size_t;\n            while i < n_files {\n                if (*ev).wd == (*f.offset(i as isize)).parent_wd {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"directory containing watched file was removed\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"directory containing watched file was removed\\0\"\n                                        as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"directory containing watched file was removed\\0\"\n                                        as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    return;\n                }\n                i = i.wrapping_add(1);\n                i;\n            }\n        }\n        if (*ev).len != 0 {\n           <<chunk 4>>           <<chunk 5>>        } else {\n           <<chunk 6>>        }\n        if fspec.is_null() {\n            continue;\n        }\n        if (*ev).mask\n            & (0x4 as libc::c_int | 0x200 as libc::c_int | 0x400 as libc::c_int\n                | 0x800 as libc::c_int) as libc::c_uint != 0\n        {\n            if (*ev).mask & 0x400 as libc::c_int as libc::c_uint != 0 {\n                inotify_rm_watch(wd, (*fspec).wd);\n                hash_remove(wd_to_name, fspec as *const libc::c_void);\n            }\n            recheck(fspec, 0 as libc::c_int != 0);\n        } else {\n            check_fspec(fspec, &mut prev_fspec);\n        }",
        "sub_chunks": [
          2,
          3,
          4,
          5,
          6
        ],
        "live_in": [
          "mut wd: i32",
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "mut sleep_interval: f64",
          "mut max_realloc: u32",
          "mut wd_to_name: *mut hash_table",
          "mut writers_dead: bool",
          "mut prev_fspec: *mut File_spec",
          "mut evlen: u64",
          "mut evbuf: *mut i8",
          "mut evbuf_off: u64",
          "mut len: u64",
          "mut inotify_wd_mask: u32",
          "mut i: u64"
        ],
        "live_out": [
          "mut wd: i32",
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "mut sleep_interval: f64",
          "mut max_realloc: u32",
          "mut wd_to_name: *mut hash_table",
          "mut writers_dead: bool",
          "mut prev_fspec: *mut File_spec",
          "mut evlen: u64",
          "mut evbuf: *mut i8",
          "mut evbuf_off: u64",
          "mut len: u64",
          "mut inotify_wd_mask: u32",
          "mut i: u64"
        ]
      },
      {
        "chunk_id": 8,
        "span": "src/tail.rs:3275:5: 3506:6 (#0)",
        "pieces": [
          "src/tail.rs:3275:5: 3311:12 (#0)",
          "src/tail.rs:3369:1: 3369:12 (#0)",
          "src/tail.rs:3397:1: 3506:6 (#0)"
        ],
        "num_lines": 148,
        "source": "let mut max_realloc: libc::c_uint = 3 as libc::c_int as libc::c_uint;\n    let mut wd_to_name: *mut Hash_table = 0 as *mut Hash_table;\n    let mut found_watchable_file: bool = 0 as libc::c_int != 0;\n    let mut tailed_but_unwatchable: bool = 0 as libc::c_int != 0;\n    let mut found_unwatchable_dir: bool = 0 as libc::c_int != 0;\n    let mut no_inotify_resources: bool = 0 as libc::c_int != 0;\n    let mut writers_dead: bool = 0 as libc::c_int != 0;\n    let mut prev_fspec: *mut File_spec = 0 as *mut File_spec;\n    let mut evlen: size_t = 0 as libc::c_int as size_t;\n    let mut evbuf: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut evbuf_off: size_t = 0 as libc::c_int as size_t;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    wd_to_name = hash_initialize(\n        n_files,\n        0 as *const Hash_tuning,\n        Some(wd_hasher as unsafe extern \"C\" fn(*const libc::c_void, size_t) -> size_t),\n        Some(\n            wd_comparator\n                as unsafe extern \"C\" fn(*const libc::c_void, *const libc::c_void) -> bool,\n        ),\n        None,\n    );\n    if wd_to_name.is_null() {\n        xalloc_die();\n    }\n    *wd_to_namep = wd_to_name;\n    let mut inotify_wd_mask: uint32_t = 0x2 as libc::c_int as uint32_t;\n    if follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint {\n        inotify_wd_mask\n            |= (0x4 as libc::c_int | 0x400 as libc::c_int | 0x800 as libc::c_int)\n                as libc::c_uint;\n    }\n    let mut i: size_t = 0;\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if !(*f.offset(i as isize)).ignore {\n           <<chunk 0>>           <<chunk 1>>        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    if no_inotify_resources as libc::c_int != 0\n        || found_unwatchable_dir as libc::c_int != 0\n        || follow_mode as libc::c_uint\n            == Follow_descriptor as libc::c_int as libc::c_uint\n            && tailed_but_unwatchable as libc::c_int != 0\n    {\n        return;\n    }\n    if follow_mode as libc::c_uint == Follow_descriptor as libc::c_int as libc::c_uint\n        && !found_watchable_file\n    {\n        exit(1 as libc::c_int);\n    }\n    prev_fspec = &mut *f\n        .offset(n_files.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n        as *mut File_spec;\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if !(*f.offset(i as isize)).ignore {\n            if follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n            {\n                recheck(&mut *f.offset(i as isize), 0 as libc::c_int != 0);\n            } else if (*f.offset(i as isize)).fd != -(1 as libc::c_int) {\n                let mut stats: stat = stat {\n                    st_dev: 0,\n                    st_ino: 0,\n                    st_mode: 0,\n                    st_nlink: 0,\n                    st_uid: 0,\n                    st_gid: 0,\n                    st_rdev: 0,\n                    __pad1: 0,\n                    st_size: 0,\n                    st_blksize: 0,\n                    __pad2: 0,\n                    st_blocks: 0,\n                    st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    __glibc_reserved: [0; 2],\n                };\n                if stat((*f.offset(i as isize)).name, &mut stats) == 0 as libc::c_int\n                    && ((*f.offset(i as isize)).dev != stats.st_dev\n                        || (*f.offset(i as isize)).ino != stats.st_ino)\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"%s was replaced\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(\n                                shell_escape_always_quoting_style,\n                                pretty_name(&mut *f.offset(i as isize)),\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"%s was replaced\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    pretty_name(&mut *f.offset(i as isize)),\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"%s was replaced\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(\n                                    shell_escape_always_quoting_style,\n                                    pretty_name(&mut *f.offset(i as isize)),\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    return;\n                }\n            }\n            check_fspec(&mut *f.offset(i as isize), &mut prev_fspec);\n        }\n        i = i.wrapping_add(1);\n        i;\n    }",
        "sub_chunks": [
          0,
          1
        ],
        "live_in": [
          "mut wd: i32",
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "mut wd_to_namep: *mut *mut hash_table"
        ],
        "live_out": [
          "mut wd: i32",
          "mut f: *mut File_spec",
          "mut n_files: u64",
          "mut wd_to_namep: *mut *mut hash_table",
          "mut max_realloc: u32",
          "mut wd_to_name: *mut hash_table",
          "mut found_watchable_file: bool",
          "mut tailed_but_unwatchable: bool",
          "mut found_unwatchable_dir: bool",
          "mut no_inotify_resources: bool",
          "mut writers_dead: bool",
          "mut prev_fspec: *mut File_spec",
          "mut evlen: u64",
          "mut evbuf: *mut i8",
          "mut evbuf_off: u64",
          "mut len: u64",
          "mut inotify_wd_mask: u32",
          "mut i: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:270 ~ tail[5173]::parse_obsolete_option)",
    "span": "src/tail.rs:4453:1: 4610:2 (#0)",
    "pieces": [
      "src/tail.rs:4453:1: 4458:4 (#0)",
      "src/tail.rs:4608:1: 4610:2 (#0)"
    ],
    "sub_chunks": [
      0
    ],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn parse_obsolete_option(\n    mut argc: libc::c_int,\n    mut argv: *const *mut libc::c_char,\n    mut n_units: *mut uintmax_t,\n) -> bool {\n   <<chunk 0>>    forever = t_forever;\n    return 1 as libc::c_int != 0;\n}",
    "calls": [
      {
        "caller": "DefId(0:318 ~ tail[5173]::main_0)",
        "span": "src/tail.rs:5147:5: 5147:71 (#0)",
        "source": "obsolete_option = parse_obsolete_option(argc, argv, &mut n_units);"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:837:1: 837:34 (#0)",
        "source": "static mut forever: bool = false;"
      },
      {
        "span": "src/tail.rs:835:1: 835:38 (#0)",
        "source": "static mut count_lines: bool = false;"
      },
      {
        "span": "src/tail.rs:839:1: 839:37 (#0)",
        "source": "static mut from_start: bool = false;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/tail.rs:4458:5: 4607:33 (#0)",
        "pieces": [
          "src/tail.rs:4458:5: 4607:33 (#0)"
        ],
        "num_lines": 150,
        "source": "let mut p: *const libc::c_char = 0 as *const libc::c_char;\n    let mut n_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut n_string_end: *const libc::c_char = 0 as *const libc::c_char;\n    let mut default_count: libc::c_int = 10 as libc::c_int;\n    let mut t_from_start: bool = false;\n    let mut t_count_lines: bool = 1 as libc::c_int != 0;\n    let mut t_forever: bool = 0 as libc::c_int != 0;\n    if !(argc == 2 as libc::c_int\n        || argc == 3 as libc::c_int\n            && !(*(*argv.offset(2 as libc::c_int as isize))\n                .offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32\n                && *(*argv.offset(2 as libc::c_int as isize))\n                    .offset(1 as libc::c_int as isize) as libc::c_int != 0)\n        || 3 as libc::c_int <= argc && argc <= 4 as libc::c_int\n            && strcmp(\n                *argv.offset(2 as libc::c_int as isize),\n                b\"--\\0\" as *const u8 as *const libc::c_char,\n            ) == 0 as libc::c_int)\n    {\n        return 0 as libc::c_int != 0;\n    }\n    let mut posix_ver: libc::c_int = posix2_version();\n    let mut obsolete_usage: bool = posix_ver < 200112 as libc::c_int;\n    let mut traditional_usage: bool = obsolete_usage as libc::c_int != 0\n        || 200809 as libc::c_int <= posix_ver;\n    p = *argv.offset(1 as libc::c_int as isize);\n    let fresh5 = p;\n    p = p.offset(1);\n    match *fresh5 as libc::c_int {\n        43 => {\n            if !traditional_usage {\n                return 0 as libc::c_int != 0;\n            }\n            t_from_start = 1 as libc::c_int != 0;\n        }\n        45 => {\n            if !obsolete_usage\n                && *p\n                    .offset(\n                        (*p.offset(0 as libc::c_int as isize) as libc::c_int\n                            == 'c' as i32) as libc::c_int as isize,\n                    ) == 0\n            {\n                return 0 as libc::c_int != 0;\n            }\n            t_from_start = 0 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    }\n    n_string = p;\n    while (*p as libc::c_uint).wrapping_sub('0' as i32 as libc::c_uint)\n        <= 9 as libc::c_int as libc::c_uint\n    {\n        p = p.offset(1);\n        p;\n    }\n    n_string_end = p;\n    let mut current_block_19: u64;\n    match *p as libc::c_int {\n        98 => {\n            default_count *= 512 as libc::c_int;\n            current_block_19 = 12856559154846489347;\n        }\n        99 => {\n            current_block_19 = 12856559154846489347;\n        }\n        108 => {\n            current_block_19 = 7044594549367080378;\n        }\n        _ => {\n            current_block_19 = 5783071609795492627;\n        }\n    }\n    match current_block_19 {\n        12856559154846489347 => {\n            t_count_lines = 0 as libc::c_int != 0;\n            current_block_19 = 7044594549367080378;\n        }\n        _ => {}\n    }\n    match current_block_19 {\n        7044594549367080378 => {\n            p = p.offset(1);\n            p;\n        }\n        _ => {}\n    }\n    if *p as libc::c_int == 'f' as i32 {\n        t_forever = 1 as libc::c_int != 0;\n        p = p.offset(1);\n        p;\n    }\n    if *p != 0 {\n        return 0 as libc::c_int != 0;\n    }\n    if n_string == n_string_end {\n        *n_units = default_count as uintmax_t;\n    } else if xstrtoumax(\n        n_string,\n        0 as *mut *mut libc::c_char,\n        10 as libc::c_int,\n        n_units,\n        b\"b\\0\" as *const u8 as *const libc::c_char,\n    ) as libc::c_uint & !(LONGINT_INVALID_SUFFIX_CHAR as libc::c_int) as libc::c_uint\n        != LONGINT_OK as libc::c_int as libc::c_uint\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"invalid number\\0\" as *const u8 as *const libc::c_char),\n                quote(*argv.offset(1 as libc::c_int as isize)),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(b\"invalid number\\0\" as *const u8 as *const libc::c_char),\n                    quote(*argv.offset(1 as libc::c_int as isize)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(b\"invalid number\\0\" as *const u8 as *const libc::c_char),\n                    quote(*argv.offset(1 as libc::c_int as isize)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    from_start = t_from_start;\n    count_lines = t_count_lines;",
        "sub_chunks": [],
        "live_in": [
          "mut argc: i32",
          "mut argv: *const *mut i8",
          "mut n_units: *mut u64"
        ],
        "live_out": [
          "mut argc: i32",
          "mut argv: *const *mut i8",
          "mut n_units: *mut u64",
          "mut p: *const i8",
          "mut n_string: *const i8",
          "mut n_string_end: *const i8",
          "mut default_count: i32",
          "mut t_from_start: bool",
          "mut t_count_lines: bool",
          "mut t_forever: bool",
          "mut posix_ver: i32",
          "mut obsolete_usage: bool",
          "mut traditional_usage: bool",
          "fresh5: *const i8",
          "mut current_block_19: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:273 ~ tail[5173]::main_0)",
    "span": "src/tail.rs:5119:1: 5506:2 (#0)",
    "pieces": [
      "src/tail.rs:5119:1: 5123:4 (#0)",
      "src/tail.rs:5234:1: 5234:4 (#0)",
      "src/tail.rs:5336:1: 5336:4 (#0)",
      "src/tail.rs:5467:1: 5467:4 (#0)",
      "src/tail.rs:5506:1: 5506:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1,
      2,
      3
    ],
    "num_lines": 9,
    "source": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n   <<chunk 0>>   <<chunk 1>>   <<chunk 2>>   <<chunk 3>>}",
    "calls": [
      {
        "caller": "DefId(0:322 ~ tail[5173]::main)",
        "span": "src/tail.rs:5519:21: 5521:6 (#0)",
        "source": "unsafe {\n        main_0(argc, argv_ptr.as_mut_ptr()) as i32\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/tail.rs:479:1: 479:43 (#0)",
        "source": "pub const multiple_files: header_mode = 0;"
      },
      {
        "span": "src/tail.rs:850:1: 850:42 (#0)",
        "source": "static mut disable_inotify: bool = false;"
      },
      {
        "span": "src/tail.rs:840:1: 840:40 (#0)",
        "source": "static mut print_headers: bool = false;"
      },
      {
        "span": "src/tail.rs:454:1: 454:46 (#0)",
        "source": "pub const Follow_descriptor: Follow_mode = 2;"
      },
      {
        "span": "src/tail.rs:838:1: 838:41 (#0)",
        "source": "static mut monitor_output: bool = false;"
      },
      {
        "span": "src/tail.rs:847:1: 847:33 (#0)",
        "source": "static mut page_size: idx_t = 0;"
      },
      {
        "span": "src/tail.rs:844:1: 844:51 (#0)",
        "source": "static mut nbpids: libc::c_int = 0 as libc::c_int;"
      },
      {
        "span": "src/tail.rs:841:1: 841:39 (#0)",
        "source": "static mut line_end: libc::c_char = 0;"
      },
      {
        "span": "src/tail.rs:848:1: 848:42 (#0)",
        "source": "static mut have_read_stdin: bool = false;"
      },
      {
        "span": "src/tail.rs:390:1: 390:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/tail.rs:839:1: 839:37 (#0)",
        "source": "static mut from_start: bool = false;"
      },
      {
        "span": "src/tail.rs:837:1: 837:34 (#0)",
        "source": "static mut forever: bool = false;"
      },
      {
        "span": "src/tail.rs:835:1: 835:38 (#0)",
        "source": "static mut count_lines: bool = false;"
      },
      {
        "span": "src/tail.rs:836:1: 836:57 (#0)",
        "source": "static mut follow_mode: Follow_mode = Follow_descriptor;"
      }
    ],
    "imports": [
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/tail.rs:5123:5: 5233:6 (#0)",
        "pieces": [
          "src/tail.rs:5123:5: 5233:6 (#0)"
        ],
        "num_lines": 111,
        "source": "let mut header_mode: header_mode = multiple_files;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut n_units: uintmax_t = 10 as libc::c_int as uintmax_t;\n    let mut n_files: size_t = 0;\n    let mut file: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut F: *mut File_spec = 0 as *mut File_spec;\n    let mut i: size_t = 0;\n    let mut obsolete_option: bool = false;\n    let mut sleep_interval: libc::c_double = 1.0f64;\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    page_size = getpagesize() as idx_t;\n    have_read_stdin = 0 as libc::c_int != 0;\n    count_lines = 1 as libc::c_int != 0;\n    print_headers = 0 as libc::c_int != 0;\n    from_start = print_headers;\n    forever = from_start;\n    line_end = '\\n' as i32 as libc::c_char;\n    obsolete_option = parse_obsolete_option(argc, argv, &mut n_units);\n    argc -= obsolete_option as libc::c_int;\n    argv = argv.offset(obsolete_option as libc::c_int as isize);\n    parse_options(argc, argv, &mut n_units, &mut header_mode, &mut sleep_interval);\n    if from_start {\n        if n_units != 0 {\n            n_units = n_units.wrapping_sub(1);\n            n_units;\n        }\n    }\n    if optind < argc {\n        n_files = (argc - optind) as size_t;\n        file = argv.offset(optind as isize);\n    } else {\n        static mut dummy_stdin: *mut libc::c_char = b\"-\\0\" as *const u8\n            as *const libc::c_char as *mut libc::c_char;\n        n_files = 1 as libc::c_int as size_t;\n        file = &mut dummy_stdin;\n    }\n    let mut found_hyphen: bool = 0 as libc::c_int != 0;\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if strcmp(*file.offset(i as isize), b\"-\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int\n        {\n            found_hyphen = 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    if found_hyphen as libc::c_int != 0\n        && follow_mode as libc::c_uint == Follow_name as libc::c_int as libc::c_uint\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"cannot follow %s by name\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"cannot follow %s by name\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"-\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"cannot follow %s by name\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"-\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut argc: i32",
          "mut argv: *mut *mut i8"
        ],
        "live_out": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut header_mode: u32",
          "mut ok: bool",
          "mut n_units: u64",
          "mut n_files: u64",
          "mut file: *mut *mut i8",
          "mut F: *mut File_spec",
          "mut i: u64",
          "mut obsolete_option: bool",
          "mut sleep_interval: f64",
          "mut found_hyphen: bool"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/tail.rs:5234:5: 5335:6 (#0)",
        "pieces": [
          "src/tail.rs:5234:5: 5335:6 (#0)"
        ],
        "num_lines": 100,
        "source": "if forever as libc::c_int != 0 && found_hyphen as libc::c_int != 0 {\n        let mut in_stat: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        let mut blocking_stdin: bool = false;\n        blocking_stdin = nbpids == 0\n            && follow_mode as libc::c_uint\n                == Follow_descriptor as libc::c_int as libc::c_uint\n            && n_files == 1 as libc::c_int as libc::c_ulong\n            && fstat(0 as libc::c_int, &mut in_stat) == 0\n            && !(in_stat.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint);\n        if !blocking_stdin && isatty(0 as libc::c_int) != 0 {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"warning: following standard input indefinitely is ineffective\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: following standard input indefinitely is ineffective\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"warning: following standard input indefinitely is ineffective\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    }\n    if n_units == 0 && !forever && !from_start {\n        return 0 as libc::c_int;\n    }\n    F = xnmalloc(n_files, ::core::mem::size_of::<File_spec>() as libc::c_ulong)\n        as *mut File_spec;\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        let ref mut fresh7 = (*F.offset(i as isize)).name;\n        *fresh7 = *file.offset(i as isize);\n        i = i.wrapping_add(1);\n        i;\n    }\n    if header_mode as libc::c_uint == always as libc::c_int as libc::c_uint\n        || header_mode as libc::c_uint == multiple_files as libc::c_int as libc::c_uint\n            && n_files > 1 as libc::c_int as libc::c_ulong\n    {\n        print_headers = 1 as libc::c_int != 0;\n    }\n    xset_binary_mode(1 as libc::c_int, 0 as libc::c_int);\n    i = 0 as libc::c_int as size_t;\n    while i < n_files {\n        ok = (ok as libc::c_int\n            & tail_file(&mut *F.offset(i as isize), n_units) as libc::c_int) != 0;\n        i = i.wrapping_add(1);\n        i;\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut header_mode: u32",
          "mut ok: bool",
          "mut n_units: u64",
          "mut n_files: u64",
          "mut file: *mut *mut i8",
          "mut F: *mut File_spec",
          "mut i: u64",
          "mut found_hyphen: bool"
        ],
        "live_out": [
          "mut header_mode: u32",
          "mut ok: bool",
          "mut n_units: u64",
          "mut n_files: u64",
          "mut file: *mut *mut i8",
          "mut F: *mut File_spec",
          "mut i: u64",
          "mut found_hyphen: bool",
          "fd1: i32",
          "mode1: i32"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/tail.rs:5336:5: 5466:6 (#0)",
        "pieces": [
          "src/tail.rs:5336:5: 5466:6 (#0)"
        ],
        "num_lines": 131,
        "source": "if forever as libc::c_int != 0 && ignore_fifo_and_pipe(F, n_files) != 0 {\n        let mut out_stat: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        if fstat(1 as libc::c_int, &mut out_stat) < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        monitor_output = out_stat.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o10000 as libc::c_int as libc::c_uint\n            || 1 as libc::c_int != 1 as libc::c_int && isapipe(1 as libc::c_int) != 0;\n        if !disable_inotify\n            && (tailable_stdin(F, n_files) as libc::c_int != 0\n                || any_remote_file(F, n_files) as libc::c_int != 0\n                || !any_non_remote_file(F, n_files)\n                || any_symlinks(F, n_files) as libc::c_int != 0\n                || any_non_regular_fifo(F, n_files) as libc::c_int != 0\n                || !ok\n                    && follow_mode as libc::c_uint\n                        == Follow_descriptor as libc::c_int as libc::c_uint)\n        {\n            disable_inotify = 1 as libc::c_int != 0;\n        }\n        if !disable_inotify {\n            let mut wd: libc::c_int = inotify_init();\n            if 0 as libc::c_int <= wd {\n                if fflush_unlocked(stdout) != 0 as libc::c_int {\n                    write_error();\n                }\n                let mut ht: *mut Hash_table = 0 as *mut Hash_table;\n                tail_forever_inotify(wd, F, n_files, sleep_interval, &mut ht);\n                hash_free(ht);\n                close(wd);\n                *__errno_location() = 0 as libc::c_int;\n            }\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"inotify cannot be used, reverting to polling\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"inotify cannot be used, reverting to polling\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"inotify cannot be used, reverting to polling\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        disable_inotify = 1 as libc::c_int != 0;\n        tail_forever(F, n_files, sleep_interval);\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut ok: bool",
          "mut n_files: u64",
          "mut F: *mut File_spec",
          "mut sleep_interval: f64"
        ],
        "live_out": [
          "mut ok: bool",
          "mut n_files: u64",
          "mut F: *mut File_spec",
          "mut sleep_interval: f64"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/tail.rs:5467:5: 5505:84 (#0)",
        "pieces": [
          "src/tail.rs:5467:5: 5505:84 (#0)"
        ],
        "num_lines": 39,
        "source": "if have_read_stdin as libc::c_int != 0 && close(0 as libc::c_int) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"-\\0\" as *const u8 as *const libc::c_char,\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    exit(if ok as libc::c_int != 0 { 0 as libc::c_int } else { 1 as libc::c_int });",
        "sub_chunks": [],
        "live_in": [
          "mut ok: bool"
        ],
        "live_out": [
          "mut ok: bool"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:277 ~ tail[5173]::main)",
    "span": "src/tail.rs:5507:1: 5523:2 (#0)",
    "pieces": [
      "src/tail.rs:5507:1: 5523:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:163 ~ tail[5173]::timespec_cmp)",
    "span": "src/tail.rs:505:1: 520:2 (#0)",
    "pieces": [
      "src/tail.rs:505:1: 520:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn timespec_cmp(mut a: timespec, mut b: timespec) -> libc::c_int {\n    return 2 as libc::c_int\n        * ((a.tv_sec > b.tv_sec) as libc::c_int - (a.tv_sec < b.tv_sec) as libc::c_int)\n        + ((a.tv_nsec > b.tv_nsec) as libc::c_int\n            - (a.tv_nsec < b.tv_nsec) as libc::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:249 ~ tail[5173]::any_remote_file)",
    "span": "src/tail.rs:3054:1: 3063:2 (#0)",
    "pieces": [
      "src/tail.rs:3054:1: 3063:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "unsafe extern \"C\" fn any_remote_file(\n    mut f: *const File_spec,\n    mut n_files: size_t,\n) -> bool {\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if 0 as libc::c_int <= (*f.offset(i as isize)).fd\n            && (*f.offset(i as isize)).remote as libc::c_int != 0\n        {\n            return 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:253 ~ tail[5173]::any_non_regular_fifo)",
    "span": "src/tail.rs:3107:1: 3119:2 (#0)",
    "pieces": [
      "src/tail.rs:3107:1: 3119:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn any_non_regular_fifo(\n    mut f: *const File_spec,\n    mut n_files: size_t,\n) -> bool {\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n_files {\n        if 0 as libc::c_int <= (*f.offset(i as isize)).fd\n            && !((*f.offset(i as isize)).mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint)\n            && !((*f.offset(i as isize)).mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o10000 as libc::c_int as libc::c_uint)\n        {\n            return 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tail.rs:53:1: 53:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/tail.rs:66:1: 66:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/tail.rs:65:1: 65:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:61:1: 61:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/tail.rs:4624:6: 4624:28 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/tail.rs:4625:1: 4625:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/tail.rs:69:1: 69:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/tail.rs:73:1: 73:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/tail.rs:3899:5: 3899:23 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/tail.rs:3901:1: 3901:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:58:1: 58:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/tail.rs:56:1: 56:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/tail.rs:63:1: 63:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/tail.rs:54:1: 54:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/tail.rs:60:1: 60:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/tail.rs:67:1: 67:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/tail.rs:71:1: 71:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/tail.rs:51:1: 51:24 (#0)",
        "source": "use std::cmp::Ordering;"
      },
      {
        "span": "src/tail.rs:3900:1: 3900:36 (#0)",
        "source": "use std::os::unix::fs::MetadataExt;"
      }
    ],
    "chunks": []
  }
]