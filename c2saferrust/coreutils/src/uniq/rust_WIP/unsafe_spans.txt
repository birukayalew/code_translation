src/uniq.rs:323:24: 323:118
unsafe { CStr::from_ptr(gettext(b"GNU coreutils\0".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:327:23: 327:64
unsafe { setlocale(5, std::ptr::null()) }
src/uniq.rs:329:22: 329:83
unsafe { CStr::from_ptr(lc_messages).to_str().unwrap_or("") }
src/uniq.rs:331:34: 331:184
unsafe { CStr::from_ptr(gettext(b"Report any translation bugs to <https://translationproject.org/team/>\0".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:357:9: 363:10
unsafe {
            error(
                1,
                saved_errno.raw_os_error().unwrap_or(0),
                gettext(b"write error\0".as_ptr() as *const libc::c_char),
            );
        }
src/uniq.rs:370:13: 376:14
unsafe {
                error(
                    errstatus,
                    saved_errno.raw_os_error().unwrap_or(0),
                    gettext(b"write error\0".as_ptr() as *const libc::c_char),
                );
            }
src/uniq.rs:383:13: 389:14
unsafe {
                error(
                    errstatus,
                    saved_errno.raw_os_error().unwrap_or(0),
                    gettext(b"write error\0".as_ptr() as *const libc::c_char),
                );
            }
src/uniq.rs:434:13: 434:26
unsafe { *p }
src/uniq.rs:446:27: 453:6
unsafe {
        mbrtoc32(
            &mut ch,
            p,
            lim.offset_from(p) as libc::c_long as size_t,
            &mut mbs,
        )
    }
src/uniq.rs:463:1: 481:2
unsafe extern "C" fn skip_buf_matching(
    mut buf: *const libc::c_char,
    mut lim: *const libc::c_char,
    mut predicate: Option::<unsafe extern "C" fn(mcel_t) -> bool>,
    mut ok: bool,
) -> *mut libc::c_char {
    let mut s: *const libc::c_char = buf;
    let mut g: mcel_t = mcel_t { ch: 0, err: 0, len: 0 };
    while s < lim
        && {
            g = mcel_scan(s, lim);
            predicate.expect("non-null function pointer")(g) as libc::c_int
                == ok as libc::c_int
        }
    {
        s = s.offset(g.len as libc::c_int as isize);
    }
    return s as *mut libc::c_char;
}
src/uniq.rs:636:1: 742:2
pub unsafe extern "C" fn usage(mut status: libc::c_int) {
    if status != 0 as libc::c_int {
        fprintf(
            stderr,
            gettext(
                b"Try '%s --help' for more information.\n\0" as *const u8
                    as *const libc::c_char,
            ),
            program_name,
        );
    } else {
        printf(
            gettext(
                b"Usage: %s [OPTION]... [INPUT [OUTPUT]]\n\0" as *const u8
                    as *const libc::c_char,
            ),
            program_name,
        );
        fputs_unlocked(
            gettext(
                b"Filter adjacent matching lines from INPUT (or standard input),\nwriting to OUTPUT (or standard output).\n\nWith no options, matching lines are merged to the first occurrence.\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        emit_mandatory_arg_note();
        fputs_unlocked(
            gettext(
                b"  -c, --count           prefix lines by the number of occurrences\n  -d, --repeated        only print duplicate lines, one for each group\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        fputs_unlocked(
            gettext(
                b"  -D                    print all duplicate lines\n      --all-repeated[=METHOD]  like -D, but allow separating groups\n                                 with an empty line;\n                                 METHOD={none(default),prepend,separate}\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        fputs_unlocked(
            gettext(
                b"  -f, --skip-fields=N   avoid comparing the first N fields\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        fputs_unlocked(
            gettext(
                b"      --group[=METHOD]  show all items, separating groups with an empty line;\n                          METHOD={separate(default),prepend,append,both}\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        fputs_unlocked(
            gettext(
                b"  -i, --ignore-case     ignore differences in case when comparing\n  -s, --skip-chars=N    avoid comparing the first N characters\n  -u, --unique          only print unique lines\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        fputs_unlocked(
            gettext(
                b"  -z, --zero-terminated     line delimiter is NUL, not newline\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        fputs_unlocked(
            gettext(
                b"  -w, --check-chars=N   compare no more than N characters in lines\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        fputs_unlocked(
            gettext(
                b"      --help        display this help and exit\n\0" as *const u8
                    as *const libc::c_char,
            ),
            stdout,
        );
        fputs_unlocked(
            gettext(
                b"      --version     output version information and exit\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        fputs_unlocked(
            gettext(
                b"\nA field is a run of blanks (usually spaces and/or TABs), then non-blank\ncharacters.  Fields are skipped before chars.\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        fputs_unlocked(
            gettext(
                b"\n'uniq' does not detect repeated lines unless they are adjacent.\nYou may want to sort the input first, or use 'sort -u' without 'uniq'.\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        emit_ancillary_info("uniq");
    }
    exit(status);
}
src/uniq.rs:744:5: 747:6
unsafe {
        let posix_ver = posix2_version();
        200112 <= posix_ver && posix_ver < 200809
    }
src/uniq.rs:763:9: 765:10
unsafe {
            error(1, 0, error_msg.as_ptr() as *const i8); // Pass raw pointer to error function
        }
src/uniq.rs:775:1: 782:2
unsafe extern "C" fn newline_or_blank(mut g: mcel_t) -> bool {
    let is_newline = g.ch == '\n' as u32;
let is_blank = match char::from_u32(g.ch) {
    Some(c) => c32isblank(c),
    None => false,
};
return is_newline || is_blank;
}
src/uniq.rs:783:1: 831:2
unsafe extern "C" fn find_field(
    mut line: *const linebuffer,
    mut plen: *mut idx_t,
) -> *mut libc::c_char {
    let mut lp: *mut libc::c_char = (*line).buffer;
    let mut lim: *const libc::c_char = lp
        .offset((*line).length as isize)
        .offset(-(1 as libc::c_int as isize));
    let mut i: idx_t = skip_fields;
    while (0 as libc::c_int as libc::c_long) < i && lp < lim as *mut libc::c_char {
        lp = skip_buf_matching(
            lp,
            lim,
            Some(newline_or_blank as unsafe extern "C" fn(mcel_t) -> bool),
            1 as libc::c_int != 0,
        );
        lp = skip_buf_matching(
            lp,
            lim,
            Some(newline_or_blank as unsafe extern "C" fn(mcel_t) -> bool),
            0 as libc::c_int != 0,
        );
        i -= 1;
        i;
    }
    let mut i_0: idx_t = skip_chars;
    while (0 as libc::c_int as libc::c_long) < i_0 && lp < lim as *mut libc::c_char {
        lp = lp.offset((mcel_scan(lp, lim)).len as libc::c_int as isize);
        i_0 -= 1;
        i_0;
    }
    let mut len: idx_t = 0;
    if lim.offset_from(lp) as libc::c_long <= check_chars {
        len = lim.offset_from(lp) as libc::c_long;
    } else if __ctype_get_mb_cur_max() <= 1 as libc::c_int as libc::c_ulong {
        len = check_chars;
    } else {
        let mut ep: *mut libc::c_char = lp;
        let mut i_1: idx_t = check_chars;
        while (0 as libc::c_int as libc::c_long) < i_1 && lp < lim as *mut libc::c_char {
            ep = ep.offset((mcel_scan(lp, lim)).len as libc::c_int as isize);
            i_1 -= 1;
            i_1;
        }
        len = ep.offset_from(lp) as libc::c_long;
    }
    *plen = len;
    return lp;
}
src/uniq.rs:832:1: 853:2
unsafe extern "C" fn different(
    mut old: *mut libc::c_char,
    mut new: *mut libc::c_char,
    mut oldlen: idx_t,
    mut newlen: idx_t,
) -> bool {
    if ignore_case {
        return oldlen != newlen
            || memcasecmp(
                old as *const libc::c_void,
                new as *const libc::c_void,
                oldlen as size_t,
            ) != 0
    } else {
        return oldlen != newlen
            || memcmp(
                old as *const libc::c_void,
                new as *const libc::c_void,
                oldlen as libc::c_ulong,
            ) != 0
    };
}
src/uniq.rs:854:1: 884:2
unsafe extern "C" fn writeline(
    mut line: *const linebuffer,
    mut match_0: bool,
    mut linecount: intmax_t,
) {
    if if linecount == 0 as libc::c_int as libc::c_long {
        output_unique as libc::c_int
    } else if !match_0 {
        output_first_repeated as libc::c_int
    } else {
        output_later_repeated as libc::c_int
    } == 0
    {
        return;
    }
    if count_occurrences {
        printf(
            b"%7jd \0" as *const u8 as *const libc::c_char,
            linecount + 1 as libc::c_int as libc::c_long,
        );
    }
    if fwrite_unlocked(
        (*line).buffer as *const libc::c_void,
        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
        (*line).length as size_t,
        stdout,
    ) != (*line).length as libc::c_ulong
    {
        write_error();
    }
}
src/uniq.rs:885:1: 1198:2
unsafe extern "C" fn check_file(
    mut infile: *const libc::c_char,
    mut outfile: *const libc::c_char,
    mut delimiter: libc::c_char,
) {
    let mut current_block: u64;
    let mut lb1: linebuffer = linebuffer {
        size: 0,
        length: 0,
        buffer: 0 as *mut libc::c_char,
    };
    let mut lb2: linebuffer = linebuffer {
        size: 0,
        length: 0,
        buffer: 0 as *mut libc::c_char,
    };
    let mut thisline: *mut linebuffer = 0 as *mut linebuffer;
    let mut prevline: *mut linebuffer = 0 as *mut linebuffer;
    if !(strcmp(infile, b"-\0" as *const u8 as *const libc::c_char) == 0 as libc::c_int
        || !(freopen_safer(infile, b"r\0" as *const u8 as *const libc::c_char, stdin))
            .is_null())
    {
        if 0 != 0 {
            error(
                1 as libc::c_int,
                *__errno_location(),
                b"%s\0" as *const u8 as *const libc::c_char,
                quotearg_n_style_colon(
                    0 as libc::c_int,
                    shell_escape_quoting_style,
                    infile,
                ),
            );
            if 1 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    quotearg_n_style_colon(
                        0 as libc::c_int,
                        shell_escape_quoting_style,
                        infile,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    quotearg_n_style_colon(
                        0 as libc::c_int,
                        shell_escape_quoting_style,
                        infile,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
    }
    if !(strcmp(outfile, b"-\0" as *const u8 as *const libc::c_char) == 0 as libc::c_int
        || !(freopen_safer(outfile, b"w\0" as *const u8 as *const libc::c_char, stdout))
            .is_null())
    {
        if 0 != 0 {
            error(
                1 as libc::c_int,
                *__errno_location(),
                b"%s\0" as *const u8 as *const libc::c_char,
                quotearg_n_style_colon(
                    0 as libc::c_int,
                    shell_escape_quoting_style,
                    outfile,
                ),
            );
            if 1 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    quotearg_n_style_colon(
                        0 as libc::c_int,
                        shell_escape_quoting_style,
                        outfile,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    quotearg_n_style_colon(
                        0 as libc::c_int,
                        shell_escape_quoting_style,
                        outfile,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
    }
    fadvise(stdin, FADVISE_SEQUENTIAL);
    thisline = &mut lb1;
    prevline = &mut lb2;
    initbuffer(thisline);
    initbuffer(prevline);
    if output_unique as libc::c_int != 0 && output_first_repeated as libc::c_int != 0
        && !count_occurrences
    {
        let mut prevfield: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut prevlen: idx_t = 0;
        let mut first_group_printed: bool = 0 as libc::c_int != 0;
        while feof_unlocked(stdin) == 0
            && !(readlinebuffer_delim(thisline, stdin, delimiter)).is_null()
        {
            let mut thislen: idx_t = 0;
            let mut thisfield: *mut libc::c_char = find_field(thisline, &mut thislen);
            let mut new_group: bool = prevfield.is_null()
                || different(thisfield, prevfield, thislen, prevlen) as libc::c_int != 0;
            if new_group as libc::c_int != 0
                && grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint
                && (grouping as libc::c_uint == GM_PREPEND as libc::c_int as libc::c_uint
                    || grouping as libc::c_uint == GM_BOTH as libc::c_int as libc::c_uint
                    || first_group_printed as libc::c_int != 0
                        && (grouping as libc::c_uint
                            == GM_APPEND as libc::c_int as libc::c_uint
                            || grouping as libc::c_uint
                                == GM_SEPARATE as libc::c_int as libc::c_uint))
            {
                putchar_unlocked(delimiter as libc::c_int);
            }
            if new_group as libc::c_int != 0
                || grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint
            {
                if fwrite_unlocked(
                    (*thisline).buffer as *const libc::c_void,
                    ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    (*thisline).length as size_t,
                    stdout,
                ) != (*thisline).length as libc::c_ulong
                {
                    write_error();
                }
                swap_lines(&mut prevline, &mut thisline);
                prevfield = thisfield;
                prevlen = thislen;
                first_group_printed = 1 as libc::c_int != 0;
            }
        }
        if (grouping as libc::c_uint == GM_BOTH as libc::c_int as libc::c_uint
            || grouping as libc::c_uint == GM_APPEND as libc::c_int as libc::c_uint)
            && first_group_printed as libc::c_int != 0
        {
            putchar_unlocked(delimiter as libc::c_int);
        }
    } else if !(readlinebuffer_delim(prevline, stdin, delimiter)).is_null() {
        let mut prevlen_0: idx_t = 0;
        let mut prevfield_0: *mut libc::c_char = find_field(prevline, &mut prevlen_0);
        let mut match_count: intmax_t = 0 as libc::c_int as intmax_t;
        let mut first_delimiter: bool = 1 as libc::c_int != 0;
        loop {
            if !(feof_unlocked(stdin) == 0) {
                current_block = 6476622998065200121;
                break;
            }
            if (readlinebuffer_delim(thisline, stdin, delimiter)).is_null() {
                if ferror_unlocked(stdin) != 0 {
                    current_block = 6469497169255231809;
                    break;
                } else {
                    current_block = 6476622998065200121;
                    break;
                }
            } else {
                let mut thislen_0: idx_t = 0;
                let mut thisfield_0: *mut libc::c_char = find_field(
                    thisline,
                    &mut thislen_0,
                );
                let mut match_0: bool = !different(
                    thisfield_0,
                    prevfield_0,
                    thislen_0,
                    prevlen_0,
                );
                match_count += match_0 as libc::c_long;
                if match_count == 9223372036854775807 as libc::c_long {
                    if count_occurrences {
                        if 0 != 0 {
                            error(
                                1 as libc::c_int,
                                0 as libc::c_int,
                                gettext(
                                    b"too many repeated lines\0" as *const u8
                                        as *const libc::c_char,
                                ),
                            );
                            if 1 as libc::c_int != 0 as libc::c_int {
                                unreachable!();
                            } else {};
                        } else {
                            ({
                                let __errstatus: libc::c_int = 1 as libc::c_int;
                                error(
                                    __errstatus,
                                    0 as libc::c_int,
                                    gettext(
                                        b"too many repeated lines\0" as *const u8
                                            as *const libc::c_char,
                                    ),
                                );
                                if __errstatus != 0 as libc::c_int {
                                    unreachable!();
                                } else {};
                                
                            });
                            ({
                                let __errstatus: libc::c_int = 1 as libc::c_int;
                                error(
                                    __errstatus,
                                    0 as libc::c_int,
                                    gettext(
                                        b"too many repeated lines\0" as *const u8
                                            as *const libc::c_char,
                                    ),
                                );
                                if __errstatus != 0 as libc::c_int {
                                    unreachable!();
                                } else {};
                                
                            });
                        };
                    }
                    match_count -= 1;
                    match_count;
                }
                if delimit_groups as libc::c_uint
                    != DM_NONE as libc::c_int as libc::c_uint
                {
                    if !match_0 {
                        if match_count != 0 {
                            first_delimiter = 0 as libc::c_int != 0;
                        }
                    } else if match_count == 1 as libc::c_int as libc::c_long {
                        if delimit_groups as libc::c_uint
                            == DM_PREPEND as libc::c_int as libc::c_uint
                            || delimit_groups as libc::c_uint
                                == DM_SEPARATE as libc::c_int as libc::c_uint
                                && !first_delimiter
                        {
                            putchar_unlocked(delimiter as libc::c_int);
                        }
                    }
                }
                if !match_0 || output_later_repeated as libc::c_int != 0 {
                    writeline(prevline, match_0, match_count);
                    swap_lines(&mut prevline, &mut thisline);
                    prevfield_0 = thisfield_0;
                    prevlen_0 = thislen_0;
                    if !match_0 {
                        match_count = 0 as libc::c_int as intmax_t;
                    }
                }
            }
        }
        match current_block {
            6469497169255231809 => {}
            _ => {
                writeline(prevline, 0 as libc::c_int != 0, match_count);
            }
        }
    }
    if ferror_unlocked(stdin) != 0 || rpl_fclose(stdin) != 0 {
    let errstatus = 1;
    error(
        errstatus,
        *__errno_location(),
        gettext(b"error reading %s\0" as *const u8 as *const libc::c_char),
        quotearg_style(shell_escape_always_quoting_style, infile),
    );
    unreachable!();
}

drop(lb1);
drop(lb2);

}
src/uniq.rs:1199:1: 1943:2
unsafe fn main_0(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut optc: libc::c_int = 0 as libc::c_int;
    let mut posixly_correct: bool = !(getenv(
        b"POSIXLY_CORRECT\0" as *const u8 as *const libc::c_char,
    ))
        .is_null();
    let mut skip_field_option_type: Skip_field_option_type = SFO_NONE;
    let mut nfiles: libc::c_int = 0 as libc::c_int;
    let mut file: [*const libc::c_char; 2] = [0 as *const libc::c_char; 2];
    let mut delimiter: libc::c_char = '\n' as i32 as libc::c_char;
    let mut output_option_used: bool = 0 as libc::c_int != 0;
    file[1 as libc::c_int as usize] = b"-\0" as *const u8 as *const libc::c_char;
    file[0 as libc::c_int as usize] = file[1 as libc::c_int as usize];
    set_program_name(*argv.offset(0 as libc::c_int as isize));
    setlocale(6 as libc::c_int, b"\0" as *const u8 as *const libc::c_char);
    bindtextdomain(
        b"coreutils\0" as *const u8 as *const libc::c_char,
        b"/usr/local/share/locale\0" as *const u8 as *const libc::c_char,
    );
    textdomain(b"coreutils\0" as *const u8 as *const libc::c_char);
    atexit(Some(close_stdout as unsafe extern "C" fn() -> ()));
    loop {
        if optc == -(1 as libc::c_int)
            || posixly_correct as libc::c_int != 0 && nfiles != 0 as libc::c_int
            || {
                optc = getopt_long(
                    argc,
                    argv,
                    b"-0123456789Dcdf:is:uw:z\0" as *const u8 as *const libc::c_char,
                    longopts.as_ptr(),
                    0 as *mut libc::c_int,
                );
                optc == -(1 as libc::c_int)
            }
        {
            if argc <= optind {
    break;
}
if nfiles == 2 {
    let extra_operand = quote(unsafe { *argv.offset(optind as isize) });
    error(0, 0, gettext(b"extra operand %s\0" as *const u8 as *const libc::c_char), extra_operand);
    usage(1);
}
let fresh0 = optind;
optind += 1;
let fresh1 = nfiles;
nfiles += 1;
file[fresh1 as usize] = unsafe { *argv.offset(fresh0 as isize) };

        } else {
            match optc {
    1 => {
         let mut size: intmax_t = 0;
                    if *optarg.offset(0 as libc::c_int as isize) as libc::c_int
                        == '+' as i32 && !strict_posix2()
                        && xstrtoimax(
                            optarg,
                            0 as *mut *mut libc::c_char,
                            10 as libc::c_int,
                            &mut size,
                            b"\0" as *const u8 as *const libc::c_char,
                        ) as libc::c_uint
                            <= LONGINT_OVERFLOW as libc::c_int as libc::c_uint
                    {
                        skip_chars = if size < 9223372036854775807 as libc::c_long {
                            size
                        } else {
                            9223372036854775807 as libc::c_long
                        };
                    } else if nfiles == 2 as libc::c_int {
                        if 0 != 0 {
                            error(
                                0 as libc::c_int,
                                0 as libc::c_int,
                                gettext(
                                    b"extra operand %s\0" as *const u8 as *const libc::c_char,
                                ),
                                quote(optarg),
                            );
                            if 0 as libc::c_int != 0 as libc::c_int {
                                unreachable!();
                            } else {};
                        } else {
                            ({
                                let __errstatus: libc::c_int = 0 as libc::c_int;
                                error(
                                    __errstatus,
                                    0 as libc::c_int,
                                    gettext(
                                        b"extra operand %s\0" as *const u8 as *const libc::c_char,
                                    ),
                                    quote(optarg),
                                );
                                if __errstatus != 0 as libc::c_int {
                                    unreachable!();
                                } else {};
                                
                            });
                            ({
                                let __errstatus: libc::c_int = 0 as libc::c_int;
                                error(
                                    __errstatus,
                                    0 as libc::c_int,
                                    gettext(
                                        b"extra operand %s\0" as *const u8 as *const libc::c_char,
                                    ),
                                    quote(optarg),
                                );
                                if __errstatus != 0 as libc::c_int {
                                    unreachable!();
                                } else {};
                                
                            });
                        };
                        usage(1 as libc::c_int);
                    } else {
                        let fresh2 = nfiles;
                        nfiles = nfiles + 1;
                        file[fresh2 as usize] = optarg;
                    }

    }
    48..=57 => {
         if skip_field_option_type as libc::c_uint
                        == SFO_NEW as libc::c_int as libc::c_uint
                    {
                        skip_fields = 0 as libc::c_int as idx_t;
                    }
                    if !(!((if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t
                        && ((if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            skip_fields
                        }) - 1 as libc::c_int as libc::c_long)
                            < 0 as libc::c_int as libc::c_long
                        && ((if 1 as libc::c_int != 0 {
                            0 as libc::c_int
                        } else {
                            10 as libc::c_int
                        }) - 1 as libc::c_int) < 0 as libc::c_int
                        && (if (10 as libc::c_int) < 0 as libc::c_int {
                            if skip_fields < 0 as libc::c_int as libc::c_long {
                                if ((if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        -(1 as libc::c_int) as idx_t
                                    }) + 10 as libc::c_int as libc::c_long
                                }) - 1 as libc::c_int as libc::c_long)
                                    < 0 as libc::c_int as libc::c_long
                                {
                                    (skip_fields
                                        < -(1 as libc::c_int) as idx_t
                                            / 10 as libc::c_int as libc::c_long) as libc::c_int
                                } else {
                                    ((if (if (if ((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int
                                    } else {
                                        10 as libc::c_int
                                    }) - 1 as libc::c_int) < 0 as libc::c_int
                                    {
                                        !(((((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) + 1 as libc::c_int)
                                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) + 0 as libc::c_int
                                    }) < 0 as libc::c_int
                                    {
                                        ((10 as libc::c_int)
                                            < -(if ((if 1 as libc::c_int != 0 {
                                                0 as libc::c_int
                                            } else {
                                                10 as libc::c_int
                                            }) - 1 as libc::c_int) < 0 as libc::c_int
                                            {
                                                ((((if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    10 as libc::c_int
                                                }) + 1 as libc::c_int)
                                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    10 as libc::c_int
                                                }) - 1 as libc::c_int
                                            })) as libc::c_int
                                    } else {
                                        ((0 as libc::c_int) < 10 as libc::c_int) as libc::c_int
                                    }) != 0
                                    {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) as libc::c_long + -(1 as libc::c_int) as idx_t
                                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                    } else {
                                        -(1 as libc::c_int) as idx_t
                                            / -(10 as libc::c_int) as libc::c_long
                                    }) <= -(1 as libc::c_int) as libc::c_long - skip_fields)
                                        as libc::c_int
                                }
                            } else {
                                if (if (if ((if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int
                                    } else {
                                        10 as libc::c_int
                                    }) as libc::c_long + 0 as libc::c_int as idx_t
                                }) - 1 as libc::c_int as libc::c_long)
                                    < 0 as libc::c_int as libc::c_long
                                {
                                    !(((((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) as libc::c_long + 0 as libc::c_int as idx_t
                                    }) + 1 as libc::c_int as libc::c_long)
                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                        - 1 as libc::c_int as libc::c_long)
                                        * 2 as libc::c_int as libc::c_long
                                        + 1 as libc::c_int as libc::c_long)
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) as libc::c_long + 0 as libc::c_int as idx_t
                                    }) + 0 as libc::c_int as libc::c_long
                                }) < 0 as libc::c_int as libc::c_long
                                {
                                    (((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int
                                    } else {
                                        10 as libc::c_int
                                    }) as libc::c_long + 0 as libc::c_int as idx_t)
                                        < -(if ((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int
                                            } else {
                                                10 as libc::c_int
                                            }) as libc::c_long + 0 as libc::c_int as idx_t
                                        }) - 1 as libc::c_int as libc::c_long)
                                            < 0 as libc::c_int as libc::c_long
                                        {
                                            ((((if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    10 as libc::c_int
                                                }) as libc::c_long + 0 as libc::c_int as idx_t
                                            }) + 1 as libc::c_int as libc::c_long)
                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                - 1 as libc::c_int as libc::c_long)
                                                * 2 as libc::c_int as libc::c_long
                                                + 1 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    10 as libc::c_int
                                                }) as libc::c_long + 0 as libc::c_int as idx_t
                                            }) - 1 as libc::c_int as libc::c_long
                                        })) as libc::c_int
                                } else {
                                    ((0 as libc::c_int as libc::c_long)
                                        < (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) as libc::c_long + 0 as libc::c_int as idx_t)
                                        as libc::c_int
                                }) != 0 && 10 as libc::c_int == -(1 as libc::c_int)
                                {
                                    if ((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        skip_fields
                                    }) - 1 as libc::c_int as libc::c_long)
                                        < 0 as libc::c_int as libc::c_long
                                    {
                                        ((0 as libc::c_int as libc::c_long)
                                            < skip_fields + 0 as libc::c_int as idx_t) as libc::c_int
                                    } else {
                                        ((0 as libc::c_int as libc::c_long) < skip_fields
                                            && (-(1 as libc::c_int) as libc::c_long
                                                - 0 as libc::c_int as idx_t)
                                                < skip_fields - 1 as libc::c_int as libc::c_long)
                                            as libc::c_int
                                    }
                                } else {
                                    ((0 as libc::c_int as idx_t
                                        / 10 as libc::c_int as libc::c_long) < skip_fields)
                                        as libc::c_int
                                }
                            }
                        } else {
                            if 10 as libc::c_int == 0 as libc::c_int {
                                0 as libc::c_int
                            } else {
                                if skip_fields < 0 as libc::c_int as libc::c_long {
                                    if (if (if ((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            skip_fields
                                        }) + 0 as libc::c_int as idx_t
                                    }) - 1 as libc::c_int as libc::c_long)
                                        < 0 as libc::c_int as libc::c_long
                                    {
                                        !(((((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                skip_fields
                                            }) + 0 as libc::c_int as idx_t
                                        }) + 1 as libc::c_int as libc::c_long)
                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                            - 1 as libc::c_int as libc::c_long)
                                            * 2 as libc::c_int as libc::c_long
                                            + 1 as libc::c_int as libc::c_long)
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                skip_fields
                                            }) + 0 as libc::c_int as idx_t
                                        }) + 0 as libc::c_int as libc::c_long
                                    }) < 0 as libc::c_int as libc::c_long
                                    {
                                        (((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            skip_fields
                                        }) + 0 as libc::c_int as idx_t)
                                            < -(if ((if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    skip_fields
                                                }) + 0 as libc::c_int as idx_t
                                            }) - 1 as libc::c_int as libc::c_long)
                                                < 0 as libc::c_int as libc::c_long
                                            {
                                                ((((if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    (if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int as libc::c_long
                                                    } else {
                                                        skip_fields
                                                    }) + 0 as libc::c_int as idx_t
                                                }) + 1 as libc::c_int as libc::c_long)
                                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                    - 1 as libc::c_int as libc::c_long)
                                                    * 2 as libc::c_int as libc::c_long
                                                    + 1 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    (if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int as libc::c_long
                                                    } else {
                                                        skip_fields
                                                    }) + 0 as libc::c_int as idx_t
                                                }) - 1 as libc::c_int as libc::c_long
                                            })) as libc::c_int
                                    } else {
                                        ((0 as libc::c_int as libc::c_long)
                                            < (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                skip_fields
                                            }) + 0 as libc::c_int as idx_t) as libc::c_int
                                    }) != 0
                                        && skip_fields == -(1 as libc::c_int) as libc::c_long
                                    {
                                        if ((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) - 1 as libc::c_int) < 0 as libc::c_int
                                        {
                                            ((0 as libc::c_int as libc::c_long)
                                                < 10 as libc::c_int as libc::c_long
                                                    + 0 as libc::c_int as idx_t) as libc::c_int
                                        } else {
                                            ((-(1 as libc::c_int) as libc::c_long
                                                - 0 as libc::c_int as idx_t)
                                                < (10 as libc::c_int - 1 as libc::c_int) as libc::c_long)
                                                as libc::c_int
                                        }
                                    } else {
                                        (0 as libc::c_int as idx_t / skip_fields
                                            < 10 as libc::c_int as libc::c_long) as libc::c_int
                                    }
                                } else {
                                    ((-(1 as libc::c_int) as idx_t
                                        / 10 as libc::c_int as libc::c_long) < skip_fields)
                                        as libc::c_int
                                }
                            }
                        }) != 0
                    {
                        let (fresh7, _fresh8) = skip_fields
                            .overflowing_mul((10 as libc::c_int).into());
                        *(&mut skip_fields as *mut idx_t) = fresh7;
                        1 as libc::c_int
                    } else {
                        let (fresh9, fresh10) = skip_fields
                            .overflowing_mul((10 as libc::c_int).into());
                        *(&mut skip_fields as *mut idx_t) = fresh9;
                        fresh10 as libc::c_int
                    }) != 0)
                        && {
                            let (fresh11, fresh12) = skip_fields
                                .overflowing_add((optc - '0' as i32).into());
                            *(&mut skip_fields as *mut idx_t) = fresh11;
                            !fresh12
                        })
                    {
                        skip_fields = 9223372036854775807 as libc::c_long;
                    }
                    skip_field_option_type = SFO_OBSOLETE;

    }
    99 => {
        count_occurrences = true;
        output_option_used = true;
    }
    100 => {
        output_unique = false;
        output_option_used = true;
    }
    68 => {
         output_unique = false;
output_later_repeated = true;

if optarg.is_null() {
    delimit_groups = DM_NONE;
} else {
    let optarg_str = unsafe { std::ffi::CStr::from_ptr(optarg) };
    delimit_groups = delimit_method_map[__xargmatch_internal(
        std::ffi::CString::new("--all-repeated").unwrap().as_ptr(),
        optarg_str.as_ptr(),
        delimit_method_string.as_ptr(),
        delimit_method_map.as_ptr() as *const libc::c_void,
        std::mem::size_of::<delimit_method>() as u64,
        argmatch_die,
        true,
    ) as usize];
}

output_option_used = true;


    }
    256 => {
         if optarg.is_null() {
    grouping = GM_SEPARATE;
} else {
    let optarg_str = unsafe { std::ffi::CStr::from_ptr(optarg) };
    grouping = grouping_method_map[__xargmatch_internal(
        std::ffi::CString::new("--group").unwrap().as_ptr(),
        optarg_str.as_ptr(),
        grouping_method_string.as_ptr(),
        grouping_method_map.as_ptr() as *const libc::c_void,
        std::mem::size_of::<grouping_method>() as u64,
        argmatch_die,
        true,
    ) as usize];
}


    }
    102 => {
        skip_field_option_type = SFO_NEW;
        skip_fields = size_opt(
            unsafe { CStr::from_ptr(optarg) },
            unsafe { CStr::from_bytes_with_nul_unchecked(b"invalid number of fields to skip\0") },
        );
    }
    105 => {
        ignore_case = true;
    }
    115 => {
        skip_chars = size_opt(
            unsafe { CStr::from_ptr(optarg) },
            unsafe { CStr::from_bytes_with_nul_unchecked(b"invalid number of bytes to skip\0") },
        );
    }
    117 => {
        output_first_repeated = false;
        output_option_used = true;
    }
    119 => {
        check_chars = size_opt(
            unsafe { CStr::from_ptr(optarg) },
            unsafe { CStr::from_bytes_with_nul_unchecked(b"invalid number of bytes to compare\0") },
        );
    }
    122 => {
        delimiter = b'\0' as i8;
    }
    -2 => {
        usage(0);
    }
    -3 => {
         version_etc(
                        stdout,
                        b"uniq\0" as *const u8 as *const libc::c_char,
                        b"GNU coreutils\0" as *const u8 as *const libc::c_char,
                        Version,
                        proper_name_lite(
                            b"Richard M. Stallman\0" as *const u8 as *const libc::c_char,
                            b"Richard M. Stallman\0" as *const u8 as *const libc::c_char,
                        ),
                        proper_name_lite(
                            b"David MacKenzie\0" as *const u8 as *const libc::c_char,
                            b"David MacKenzie\0" as *const u8 as *const libc::c_char,
                        ),
                        0 as *mut libc::c_void as *mut libc::c_char,
                    );
                    exit(0 as libc::c_int);

    }
    _ => {
        usage(1);
    }
}
/*
The variables live at this point are:
(mut optc: i32, mut skip_field_option_type: u32, mut nfiles: i32, mut file: [*const i8; 2], mut delimiter: i8, mut output_option_used: bool)
*/

        }
    }
    if grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint
        && output_option_used as libc::c_int != 0
    {
        if 0 != 0 {
            error(
                0 as libc::c_int,
                0 as libc::c_int,
                gettext(
                    b"--group is mutually exclusive with -c/-d/-D/-u\0" as *const u8
                        as *const libc::c_char,
                ),
            );
            if 0 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"--group is mutually exclusive with -c/-d/-D/-u\0" as *const u8
                            as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"--group is mutually exclusive with -c/-d/-D/-u\0" as *const u8
                            as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
        usage(1 as libc::c_int);
    }
    if grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint
        && count_occurrences as libc::c_int != 0
    {
        if 0 != 0 {
            error(
                0 as libc::c_int,
                0 as libc::c_int,
                gettext(
                    b"grouping and printing repeat counts is meaningless\0" as *const u8
                        as *const libc::c_char,
                ),
            );
            if 0 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"grouping and printing repeat counts is meaningless\0"
                            as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"grouping and printing repeat counts is meaningless\0"
                            as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
        usage(1 as libc::c_int);
    }
    if count_occurrences as libc::c_int != 0 && output_later_repeated as libc::c_int != 0
    {
        if 0 != 0 {
            error(
                0 as libc::c_int,
                0 as libc::c_int,
                gettext(
                    b"printing all duplicated lines and repeat counts is meaningless\0"
                        as *const u8 as *const libc::c_char,
                ),
            );
            if 0 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"printing all duplicated lines and repeat counts is meaningless\0"
                            as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"printing all duplicated lines and repeat counts is meaningless\0"
                            as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
        usage(1 as libc::c_int);
    }
    check_file(
        file[0 as libc::c_int as usize],
        file[1 as libc::c_int as usize],
        delimiter,
    );
    return 0 as libc::c_int;
}
src/uniq.rs:1954:5: 1961:6
unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *mut libc::c_char,
            ) as i32,
        )
    }
