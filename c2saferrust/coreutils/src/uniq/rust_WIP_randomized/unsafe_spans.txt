src/uniq.rs:340:24: 340:128
unsafe { std::ffi::CStr::from_ptr(gettext(b"GNU coreutils\0".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:347:23: 347:64
unsafe { setlocale(5, std::ptr::null()) }
src/uniq.rs:348:34: 348:100
unsafe { std::ffi::CStr::from_ptr(lc_messages).to_string_lossy() }
src/uniq.rs:349:30: 349:190
unsafe { std::ffi::CStr::from_ptr(gettext(b"Report any translation bugs to <https://translationproject.org/team/>\0".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:374:9: 380:10
unsafe {
            error(
                1,
                saved_errno.raw_os_error().unwrap_or(0),
                gettext(CString::new("write error").unwrap().as_ptr()),
            );
        }
src/uniq.rs:387:13: 393:14
unsafe {
                error(
                    __errstatus,
                    saved_errno.raw_os_error().unwrap_or(0),
                    gettext(CString::new("write error").unwrap().as_ptr()),
                );
            }
src/uniq.rs:400:13: 406:14
unsafe {
                error(
                    __errstatus,
                    saved_errno.raw_os_error().unwrap_or(0),
                    gettext(CString::new("write error").unwrap().as_ptr()),
                );
            }
src/uniq.rs:451:13: 451:26
unsafe { *p }
src/uniq.rs:462:27: 469:6
unsafe {
        mbrtoc32(
            &mut ch,
            p,
            lim.offset_from(p) as size_t,
            &mut mbs,
        )
    }
src/uniq.rs:478:1: 496:2
unsafe extern "C" fn skip_buf_matching(
    mut buf: *const libc::c_char,
    mut lim: *const libc::c_char,
    mut predicate: Option::<unsafe extern "C" fn(mcel_t) -> bool>,
    mut ok: bool,
) -> *mut libc::c_char {
    let mut s: *const libc::c_char = buf;
    let mut g: mcel_t = mcel_t { ch: 0, err: 0, len: 0 };
    while s < lim
        && {
            g = mcel_scan(s, lim);
            predicate.expect("non-null function pointer")(g) as libc::c_int
                == ok as libc::c_int
        }
    {
        s = s.offset(g.len as libc::c_int as isize);
    }
    return s as *mut libc::c_char;
}
src/uniq.rs:655:13: 655:218
unsafe { std::ffi::CStr::from_ptr(gettext(format!("Try '{} --help' for more information.\n", unsafe { std::ffi::CStr::from_ptr(program_name).to_string_lossy() }).as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:660:13: 660:219
unsafe { std::ffi::CStr::from_ptr(gettext(format!("Usage: {} [OPTION]... [INPUT [OUTPUT]]\n", unsafe { std::ffi::CStr::from_ptr(program_name).to_string_lossy() }).as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:664:13: 664:277
unsafe { std::ffi::CStr::from_ptr(gettext("Filter adjacent matching lines from INPUT (or standard input),\nwriting to OUTPUT (or standard output).\n\nWith no options, matching lines are merged to the first occurrence.\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:666:9: 666:46
unsafe { emit_mandatory_arg_note(); }
src/uniq.rs:669:13: 669:240
unsafe { std::ffi::CStr::from_ptr(gettext("  -c, --count           prefix lines by the number of occurrences\n  -d, --repeated        only print duplicate lines, one for each group\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:673:13: 673:349
unsafe { std::ffi::CStr::from_ptr(gettext("  -D                    print all duplicate lines\n      --all-repeated[=METHOD]  like -D, but allow separating groups\n                                 with an empty line;\n                                 METHOD={none(default),prepend,separate}\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:677:13: 677:161
unsafe { std::ffi::CStr::from_ptr(gettext("  -f, --skip-fields=N   avoid comparing the first N fields\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:681:13: 681:254
unsafe { std::ffi::CStr::from_ptr(gettext("      --group[=METHOD]  show all items, separating groups with an empty line;\n                          METHOD={separate(default),prepend,append,both}\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:685:13: 685:281
unsafe { std::ffi::CStr::from_ptr(gettext("  -i, --ignore-case     ignore differences in case when comparing\n  -s, --skip-chars=N    avoid comparing the first N characters\n  -u, --unique          only print unique lines\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:689:13: 689:165
unsafe { std::ffi::CStr::from_ptr(gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:693:13: 693:169
unsafe { std::ffi::CStr::from_ptr(gettext("  -w, --check-chars=N   compare no more than N characters in lines\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:697:13: 697:149
unsafe { std::ffi::CStr::from_ptr(gettext("      --help        display this help and exit\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:701:13: 701:158
unsafe { std::ffi::CStr::from_ptr(gettext("      --version     output version information and exit\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:705:13: 705:223
unsafe { std::ffi::CStr::from_ptr(gettext("\nA field is a run of blanks (usually spaces and/or TABs), then non-blank\ncharacters.  Fields are skipped before chars.\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:709:13: 709:240
unsafe { std::ffi::CStr::from_ptr(gettext("\n'uniq' does not detect repeated lines unless they are adjacent.\nYou may want to sort the input first, or use 'sort -u' without 'uniq'.\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:717:5: 720:6
unsafe {
        let posix_ver: i32 = posix2_version();
        200112 <= posix_ver && posix_ver < 200809
    }
src/uniq.rs:723:1: 784:2
unsafe extern "C" fn size_opt(
    mut opt: *const libc::c_char,
    mut msgid: *const libc::c_char,
) -> idx_t {
    let mut size: intmax_t = 0;
    if (LONGINT_OVERFLOW as libc::c_int as libc::c_uint)
        < xstrtoimax(
            opt,
            0 as *mut *mut libc::c_char,
            10 as libc::c_int,
            &mut size,
            b"\0" as *const u8 as *const libc::c_char,
        ) as libc::c_uint || size < 0 as libc::c_int as libc::c_long
    {
        if 0 != 0 {
            error(
                1 as libc::c_int,
                0 as libc::c_int,
                b"%s: %s\0" as *const u8 as *const libc::c_char,
                opt,
                gettext(msgid),
            );
            if 1 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    b"%s: %s\0" as *const u8 as *const libc::c_char,
                    opt,
                    gettext(msgid),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    b"%s: %s\0" as *const u8 as *const libc::c_char,
                    opt,
                    gettext(msgid),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
    }
    return if size < 9223372036854775807 as libc::c_long {
        size
    } else {
        9223372036854775807 as libc::c_long
    };
}
src/uniq.rs:785:1: 792:2
unsafe extern "C" fn newline_or_blank(mut g: mcel_t) -> bool {
    let is_newline = g.ch == '\n' as u32;
let is_blank = match char::from_u32(g.ch) {
    Some(c) => c32isblank(c),
    None => false,
};
return is_newline || is_blank;
}
src/uniq.rs:793:1: 841:2
unsafe extern "C" fn find_field(
    mut line: *const linebuffer,
    mut plen: *mut idx_t,
) -> *mut libc::c_char {
    let mut lp: *mut libc::c_char = (*line).buffer;
    let mut lim: *const libc::c_char = lp
        .offset((*line).length as isize)
        .offset(-(1 as libc::c_int as isize));
    let mut i: idx_t = skip_fields;
    while (0 as libc::c_int as libc::c_long) < i && lp < lim as *mut libc::c_char {
        lp = skip_buf_matching(
            lp,
            lim,
            Some(newline_or_blank as unsafe extern "C" fn(mcel_t) -> bool),
            1 as libc::c_int != 0,
        );
        lp = skip_buf_matching(
            lp,
            lim,
            Some(newline_or_blank as unsafe extern "C" fn(mcel_t) -> bool),
            0 as libc::c_int != 0,
        );
        i -= 1;
        i;
    }
    let mut i_0: idx_t = skip_chars;
    while (0 as libc::c_int as libc::c_long) < i_0 && lp < lim as *mut libc::c_char {
        lp = lp.offset((mcel_scan(lp, lim)).len as libc::c_int as isize);
        i_0 -= 1;
        i_0;
    }
    let mut len: idx_t = 0;
    if lim.offset_from(lp) as libc::c_long <= check_chars {
        len = lim.offset_from(lp) as libc::c_long;
    } else if __ctype_get_mb_cur_max() <= 1 as libc::c_int as libc::c_ulong {
        len = check_chars;
    } else {
        let mut ep: *mut libc::c_char = lp;
        let mut i_1: idx_t = check_chars;
        while (0 as libc::c_int as libc::c_long) < i_1 && lp < lim as *mut libc::c_char {
            ep = ep.offset((mcel_scan(lp, lim)).len as libc::c_int as isize);
            i_1 -= 1;
            i_1;
        }
        len = ep.offset_from(lp) as libc::c_long;
    }
    *plen = len;
    return lp;
}
src/uniq.rs:842:1: 863:2
unsafe extern "C" fn different(
    mut old: *mut libc::c_char,
    mut new: *mut libc::c_char,
    mut oldlen: idx_t,
    mut newlen: idx_t,
) -> bool {
    if ignore_case {
        return oldlen != newlen
            || memcasecmp(
                old as *const libc::c_void,
                new as *const libc::c_void,
                oldlen as size_t,
            ) != 0
    } else {
        return oldlen != newlen
            || memcmp(
                old as *const libc::c_void,
                new as *const libc::c_void,
                oldlen as libc::c_ulong,
            ) != 0
    };
}
src/uniq.rs:864:1: 894:2
unsafe extern "C" fn writeline(
    mut line: *const linebuffer,
    mut match_0: bool,
    mut linecount: intmax_t,
) {
    if if linecount == 0 as libc::c_int as libc::c_long {
        output_unique as libc::c_int
    } else if !match_0 {
        output_first_repeated as libc::c_int
    } else {
        output_later_repeated as libc::c_int
    } == 0
    {
        return;
    }
    if count_occurrences {
        printf(
            b"%7jd \0" as *const u8 as *const libc::c_char,
            linecount + 1 as libc::c_int as libc::c_long,
        );
    }
    if fwrite_unlocked(
        (*line).buffer as *const libc::c_void,
        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
        (*line).length as size_t,
        stdout,
    ) != (*line).length as libc::c_ulong
    {
        write_error();
    }
}
src/uniq.rs:895:1: 1152:2
unsafe extern "C" fn check_file(
    mut infile: *const libc::c_char,
    mut outfile: *const libc::c_char,
    mut delimiter: libc::c_char,
) {
    let mut current_block: u64;
    let mut lb1: linebuffer = linebuffer {
        size: 0,
        length: 0,
        buffer: 0 as *mut libc::c_char,
    };
    let mut lb2: linebuffer = linebuffer {
        size: 0,
        length: 0,
        buffer: 0 as *mut libc::c_char,
    };
    let mut thisline: *mut linebuffer = 0 as *mut linebuffer;
    let mut prevline: *mut linebuffer = 0 as *mut linebuffer;
    if !(strcmp(infile, b"-\0" as *const u8 as *const libc::c_char) == 0 as libc::c_int
        || !(freopen_safer(infile, b"r\0" as *const u8 as *const libc::c_char, stdin))
            .is_null())
    {
        if 0 != 0 {
            error(
                1 as libc::c_int,
                *__errno_location(),
                b"%s\0" as *const u8 as *const libc::c_char,
                quotearg_n_style_colon(
                    0 as libc::c_int,
                    shell_escape_quoting_style,
                    infile,
                ),
            );
            if 1 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    quotearg_n_style_colon(
                        0 as libc::c_int,
                        shell_escape_quoting_style,
                        infile,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    quotearg_n_style_colon(
                        0 as libc::c_int,
                        shell_escape_quoting_style,
                        infile,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
    }
    if !(strcmp(outfile, b"-\0" as *const u8 as *const libc::c_char) == 0 as libc::c_int
        || !(freopen_safer(outfile, b"w\0" as *const u8 as *const libc::c_char, stdout))
            .is_null())
    {
        if 0 != 0 {
            error(
                1 as libc::c_int,
                *__errno_location(),
                b"%s\0" as *const u8 as *const libc::c_char,
                quotearg_n_style_colon(
                    0 as libc::c_int,
                    shell_escape_quoting_style,
                    outfile,
                ),
            );
            if 1 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    quotearg_n_style_colon(
                        0 as libc::c_int,
                        shell_escape_quoting_style,
                        outfile,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    quotearg_n_style_colon(
                        0 as libc::c_int,
                        shell_escape_quoting_style,
                        outfile,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
    }
    fadvise(stdin, FADVISE_SEQUENTIAL);
    thisline = &mut lb1;
    prevline = &mut lb2;
    initbuffer(thisline);
    initbuffer(prevline);
    if output_unique as libc::c_int != 0 && output_first_repeated as libc::c_int != 0
        && !count_occurrences
    {
        let mut prevfield: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut prevlen: idx_t = 0;
        let mut first_group_printed: bool = 0 as libc::c_int != 0;
        while feof_unlocked(stdin) == 0
            && !(readlinebuffer_delim(thisline, stdin, delimiter)).is_null()
        {
            let mut thislen: idx_t = 0;
            let mut thisfield: *mut libc::c_char = find_field(thisline, &mut thislen);
            let mut new_group: bool = prevfield.is_null()
                || different(thisfield, prevfield, thislen, prevlen) as libc::c_int != 0;
            if new_group as libc::c_int != 0
                && grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint
                && (grouping as libc::c_uint == GM_PREPEND as libc::c_int as libc::c_uint
                    || grouping as libc::c_uint == GM_BOTH as libc::c_int as libc::c_uint
                    || first_group_printed as libc::c_int != 0
                        && (grouping as libc::c_uint
                            == GM_APPEND as libc::c_int as libc::c_uint
                            || grouping as libc::c_uint
                                == GM_SEPARATE as libc::c_int as libc::c_uint))
            {
                putchar_unlocked(delimiter as libc::c_int);
            }
            if new_group as libc::c_int != 0
                || grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint
            {
                if fwrite_unlocked(
                    (*thisline).buffer as *const libc::c_void,
                    ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    (*thisline).length as size_t,
                    stdout,
                ) != (*thisline).length as libc::c_ulong
                {
                    write_error();
                }
                swap_lines(&mut prevline, &mut thisline);
                prevfield = thisfield;
                prevlen = thislen;
                first_group_printed = 1 as libc::c_int != 0;
            }
        }
        if (grouping as libc::c_uint == GM_BOTH as libc::c_int as libc::c_uint
            || grouping as libc::c_uint == GM_APPEND as libc::c_int as libc::c_uint)
            && first_group_printed as libc::c_int != 0
        {
            putchar_unlocked(delimiter as libc::c_int);
        }
    } else if !(readlinebuffer_delim(prevline, stdin, delimiter)).is_null() {
        let mut prevlen_0: idx_t = 0;
let mut prevfield_0: *mut libc::c_char = find_field(prevline, &mut prevlen_0);
let mut match_count: i64 = 0;
let mut first_delimiter: bool = true;

loop {
    if feof_unlocked(stdin) != 0 {
        break;
    }
    let thisline_result = readlinebuffer_delim(thisline, stdin, delimiter);
    if thisline_result.is_null() {
        if ferror_unlocked(stdin) != 0 {
            break;
        } else {
            break;
        }
    } else {
        let mut thislen_0: idx_t = 0;
        let thisfield_0: *mut libc::c_char = find_field(thisline, &mut thislen_0);
        let match_0: bool = !different(thisfield_0, prevfield_0, thislen_0, prevlen_0);
        match_count += match_0 as i64;

        if match_count == i64::MAX {
            if count_occurrences {
                error(1, 0, gettext(b"too many repeated lines\0" as *const u8 as *const libc::c_char));
                unreachable!();
            } else {
                error(1, 0, gettext(b"too many repeated lines\0" as *const u8 as *const libc::c_char));
                unreachable!();
            }
        }
        match_count -= 1;

        if delimit_groups != DM_NONE {
            if !match_0 {
                if match_count != 0 {
                    first_delimiter = false;
                }
            } else if match_count == 1 {
                if delimit_groups == DM_PREPEND || (delimit_groups == DM_SEPARATE && !first_delimiter) {
                    print!("{}", delimiter as u8 as char);
                }
            }
        }

        if !match_0 || output_later_repeated {
            writeline(prevline, match_0, match_count);
            swap_lines(&mut prevline, &mut thisline);
            prevfield_0 = thisfield_0;
            prevlen_0 = thislen_0;
            if !match_0 {
                match_count = 0;
            }
        }
    }
}

writeline(prevline, false, match_count);

    }
    if ferror_unlocked(stdin) != 0 || rpl_fclose(stdin) != 0 {
    let errstatus = 1;
    error(
        errstatus,
        *__errno_location(),
        gettext(b"error reading %s\0" as *const u8 as *const libc::c_char),
        quotearg_style(shell_escape_always_quoting_style, infile),
    );
    unreachable!();
}

drop(lb1);
drop(lb2);

}
src/uniq.rs:1153:1: 1861:2
unsafe fn main_0(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut optc: libc::c_int = 0 as libc::c_int;
    let mut posixly_correct: bool = !(getenv(
        b"POSIXLY_CORRECT\0" as *const u8 as *const libc::c_char,
    ))
        .is_null();
    let mut skip_field_option_type: Skip_field_option_type = SFO_NONE;
    let mut nfiles: libc::c_int = 0 as libc::c_int;
    let mut file: [*const libc::c_char; 2] = [0 as *const libc::c_char; 2];
    let mut delimiter: libc::c_char = '\n' as i32 as libc::c_char;
    let mut output_option_used: bool = 0 as libc::c_int != 0;
    file[1 as libc::c_int as usize] = b"-\0" as *const u8 as *const libc::c_char;
    file[0 as libc::c_int as usize] = file[1 as libc::c_int as usize];
    set_program_name(*argv.offset(0 as libc::c_int as isize));
    setlocale(6 as libc::c_int, b"\0" as *const u8 as *const libc::c_char);
    bindtextdomain(
        b"coreutils\0" as *const u8 as *const libc::c_char,
        b"/usr/local/share/locale\0" as *const u8 as *const libc::c_char,
    );
    textdomain(b"coreutils\0" as *const u8 as *const libc::c_char);
    atexit(Some(close_stdout as unsafe extern "C" fn() -> ()));
    loop {
        if optc == -1
    || (posixly_correct && nfiles != 0)
    || {
        optc = getopt_long(
            argc,
            argv,
            b"-0123456789Dcdf:is:uw:z\0".as_ptr() as *const i8,
            longopts.as_ptr(),
            std::ptr::null_mut(),
        );
        optc == -1
    }
{
    if argc <= optind {
    break;
}
if nfiles == 2 {
    let extra_operand = quote(unsafe { *argv.offset(optind as isize) });
    error(0, 0, gettext(b"extra operand %s\0" as *const u8 as *const libc::c_char), extra_operand);
    usage(1);
}
let fresh0 = optind;
optind += 1;
let fresh1 = nfiles;
nfiles += 1;
file[fresh1 as usize] = unsafe { *argv.offset(fresh0 as isize) };


} else {
    match optc {
    1 => {
        let mut size: i64 = 0;
if unsafe { *optarg } == '+' as i8 && !strict_posix2() {
    let mut endptr: *mut i8 = std::ptr::null_mut();
    let parsed_size = xstrtoimax(optarg, &mut endptr, 10, &mut size, std::ptr::null());
    if parsed_size <= LONGINT_OVERFLOW as u32 {
        size = parsed_size as i64;
    }
    skip_chars = if size < i64::MAX {
        size
    } else {
        i64::MAX
    };
} else if nfiles == 2 {
    error(
        0,
        0,
        gettext(b"extra operand %s\0" as *const u8 as *const libc::c_char),
    );
    usage(1);
} else {
    let fresh2 = nfiles;
    nfiles += 1;
    file[fresh2 as usize] = optarg;
}


    }
    48..=57 => {
         if skip_field_option_type as libc::c_uint
                        == SFO_NEW as libc::c_int as libc::c_uint
                    {
                        skip_fields = 0 as libc::c_int as idx_t;
                    }
                    if !(!((if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t
                        && ((if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            skip_fields
                        }) - 1 as libc::c_int as libc::c_long)
                            < 0 as libc::c_int as libc::c_long
                        && ((if 1 as libc::c_int != 0 {
                            0 as libc::c_int
                        } else {
                            10 as libc::c_int
                        }) - 1 as libc::c_int) < 0 as libc::c_int
                        && (if (10 as libc::c_int) < 0 as libc::c_int {
                            if skip_fields < 0 as libc::c_int as libc::c_long {
                                if ((if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        -(1 as libc::c_int) as idx_t
                                    }) + 10 as libc::c_int as libc::c_long
                                }) - 1 as libc::c_int as libc::c_long)
                                    < 0 as libc::c_int as libc::c_long
                                {
                                    (skip_fields
                                        < -(1 as libc::c_int) as idx_t
                                            / 10 as libc::c_int as libc::c_long) as libc::c_int
                                } else {
                                    ((if (if (if ((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int
                                    } else {
                                        10 as libc::c_int
                                    }) - 1 as libc::c_int) < 0 as libc::c_int
                                    {
                                        !(((((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) + 1 as libc::c_int)
                                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) + 0 as libc::c_int
                                    }) < 0 as libc::c_int
                                    {
                                        ((10 as libc::c_int)
                                            < -(if ((if 1 as libc::c_int != 0 {
                                                0 as libc::c_int
                                            } else {
                                                10 as libc::c_int
                                            }) - 1 as libc::c_int) < 0 as libc::c_int
                                            {
                                                ((((if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    10 as libc::c_int
                                                }) + 1 as libc::c_int)
                                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    10 as libc::c_int
                                                }) - 1 as libc::c_int
                                            })) as libc::c_int
                                    } else {
                                        ((0 as libc::c_int) < 10 as libc::c_int) as libc::c_int
                                    }) != 0
                                    {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) as libc::c_long + -(1 as libc::c_int) as idx_t
                                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                    } else {
                                        -(1 as libc::c_int) as idx_t
                                            / -(10 as libc::c_int) as libc::c_long
                                    }) <= -(1 as libc::c_int) as libc::c_long - skip_fields)
                                        as libc::c_int
                                }
                            } else {
                                if (if (if ((if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int
                                    } else {
                                        10 as libc::c_int
                                    }) as libc::c_long + 0 as libc::c_int as idx_t
                                }) - 1 as libc::c_int as libc::c_long)
                                    < 0 as libc::c_int as libc::c_long
                                {
                                    !(((((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) as libc::c_long + 0 as libc::c_int as idx_t
                                    }) + 1 as libc::c_int as libc::c_long)
                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                        - 1 as libc::c_int as libc::c_long)
                                        * 2 as libc::c_int as libc::c_long
                                        + 1 as libc::c_int as libc::c_long)
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) as libc::c_long + 0 as libc::c_int as idx_t
                                    }) + 0 as libc::c_int as libc::c_long
                                }) < 0 as libc::c_int as libc::c_long
                                {
                                    (((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int
                                    } else {
                                        10 as libc::c_int
                                    }) as libc::c_long + 0 as libc::c_int as idx_t)
                                        < -(if ((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int
                                            } else {
                                                10 as libc::c_int
                                            }) as libc::c_long + 0 as libc::c_int as idx_t
                                        }) - 1 as libc::c_int as libc::c_long)
                                            < 0 as libc::c_int as libc::c_long
                                        {
                                            ((((if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    10 as libc::c_int
                                                }) as libc::c_long + 0 as libc::c_int as idx_t
                                            }) + 1 as libc::c_int as libc::c_long)
                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                - 1 as libc::c_int as libc::c_long)
                                                * 2 as libc::c_int as libc::c_long
                                                + 1 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    10 as libc::c_int
                                                }) as libc::c_long + 0 as libc::c_int as idx_t
                                            }) - 1 as libc::c_int as libc::c_long
                                        })) as libc::c_int
                                } else {
                                    ((0 as libc::c_int as libc::c_long)
                                        < (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) as libc::c_long + 0 as libc::c_int as idx_t)
                                        as libc::c_int
                                }) != 0 && 10 as libc::c_int == -(1 as libc::c_int)
                                {
                                    if ((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        skip_fields
                                    }) - 1 as libc::c_int as libc::c_long)
                                        < 0 as libc::c_int as libc::c_long
                                    {
                                        ((0 as libc::c_int as libc::c_long)
                                            < skip_fields + 0 as libc::c_int as idx_t) as libc::c_int
                                    } else {
                                        ((0 as libc::c_int as libc::c_long) < skip_fields
                                            && (-(1 as libc::c_int) as libc::c_long
                                                - 0 as libc::c_int as idx_t)
                                                < skip_fields - 1 as libc::c_int as libc::c_long)
                                            as libc::c_int
                                    }
                                } else {
                                    ((0 as libc::c_int as idx_t
                                        / 10 as libc::c_int as libc::c_long) < skip_fields)
                                        as libc::c_int
                                }
                            }
                        } else {
                            if 10 as libc::c_int == 0 as libc::c_int {
                                0 as libc::c_int
                            } else {
                                if skip_fields < 0 as libc::c_int as libc::c_long {
                                    if (if (if ((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            skip_fields
                                        }) + 0 as libc::c_int as idx_t
                                    }) - 1 as libc::c_int as libc::c_long)
                                        < 0 as libc::c_int as libc::c_long
                                    {
                                        !(((((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                skip_fields
                                            }) + 0 as libc::c_int as idx_t
                                        }) + 1 as libc::c_int as libc::c_long)
                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                            - 1 as libc::c_int as libc::c_long)
                                            * 2 as libc::c_int as libc::c_long
                                            + 1 as libc::c_int as libc::c_long)
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                skip_fields
                                            }) + 0 as libc::c_int as idx_t
                                        }) + 0 as libc::c_int as libc::c_long
                                    }) < 0 as libc::c_int as libc::c_long
                                    {
                                        (((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            skip_fields
                                        }) + 0 as libc::c_int as idx_t)
                                            < -(if ((if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    skip_fields
                                                }) + 0 as libc::c_int as idx_t
                                            }) - 1 as libc::c_int as libc::c_long)
                                                < 0 as libc::c_int as libc::c_long
                                            {
                                                ((((if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    (if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int as libc::c_long
                                                    } else {
                                                        skip_fields
                                                    }) + 0 as libc::c_int as idx_t
                                                }) + 1 as libc::c_int as libc::c_long)
                                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                    - 1 as libc::c_int as libc::c_long)
                                                    * 2 as libc::c_int as libc::c_long
                                                    + 1 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    (if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int as libc::c_long
                                                    } else {
                                                        skip_fields
                                                    }) + 0 as libc::c_int as idx_t
                                                }) - 1 as libc::c_int as libc::c_long
                                            })) as libc::c_int
                                    } else {
                                        ((0 as libc::c_int as libc::c_long)
                                            < (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                skip_fields
                                            }) + 0 as libc::c_int as idx_t) as libc::c_int
                                    }) != 0
                                        && skip_fields == -(1 as libc::c_int) as libc::c_long
                                    {
                                        if ((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) - 1 as libc::c_int) < 0 as libc::c_int
                                        {
                                            ((0 as libc::c_int as libc::c_long)
                                                < 10 as libc::c_int as libc::c_long
                                                    + 0 as libc::c_int as idx_t) as libc::c_int
                                        } else {
                                            ((-(1 as libc::c_int) as libc::c_long
                                                - 0 as libc::c_int as idx_t)
                                                < (10 as libc::c_int - 1 as libc::c_int) as libc::c_long)
                                                as libc::c_int
                                        }
                                    } else {
                                        (0 as libc::c_int as idx_t / skip_fields
                                            < 10 as libc::c_int as libc::c_long) as libc::c_int
                                    }
                                } else {
                                    ((-(1 as libc::c_int) as idx_t
                                        / 10 as libc::c_int as libc::c_long) < skip_fields)
                                        as libc::c_int
                                }
                            }
                        }) != 0
                    {
                        let (fresh7, _fresh8) = skip_fields
                            .overflowing_mul((10 as libc::c_int).into());
                        *(&mut skip_fields as *mut idx_t) = fresh7;
                        1 as libc::c_int
                    } else {
                        let (fresh9, fresh10) = skip_fields
                            .overflowing_mul((10 as libc::c_int).into());
                        *(&mut skip_fields as *mut idx_t) = fresh9;
                        fresh10 as libc::c_int
                    }) != 0)
                        && {
                            let (fresh11, fresh12) = skip_fields
                                .overflowing_add((optc - '0' as i32).into());
                            *(&mut skip_fields as *mut idx_t) = fresh11;
                            !fresh12
                        })
                    {
                        skip_fields = 9223372036854775807 as libc::c_long;
                    }
                    skip_field_option_type = SFO_OBSOLETE;

    }
    99 => {
        count_occurrences = true;
        output_option_used = true;
    }
    100 => {
        output_unique = false;
        output_option_used = true;
    }
    68 => {
         output_unique = false;
output_later_repeated = true;

if optarg.is_null() {
    delimit_groups = DM_NONE;
} else {
    delimit_groups = delimit_method_map[__xargmatch_internal(
        b"--all-repeated\0".as_ptr() as *const i8,
        optarg,
        delimit_method_string.as_ptr() as *const *const i8,
        delimit_method_map.as_ptr() as *const libc::c_void,
        std::mem::size_of::<delimit_method>() as u64,
        argmatch_die,
        true,
    ) as usize];
}

output_option_used = true;


    }
    256 => {
        if optarg.is_null() {
    grouping = GM_SEPARATE;
} else {
    let arg = unsafe { std::ffi::CStr::from_ptr(optarg).to_str().unwrap() };
    grouping = grouping_method_map[__xargmatch_internal(
        std::ffi::CString::new("--group").unwrap().as_ptr(),
        optarg,
        grouping_method_string.as_ptr(),
        grouping_method_map.as_ptr() as *const std::ffi::c_void,
        std::mem::size_of::<grouping_method>() as u64,
        argmatch_die,
        true,
    ) as usize];
}


    }
    102 => {
        skip_field_option_type = SFO_NEW;
        skip_fields = size_opt(
            optarg,
            b"invalid number of fields to skip\0" as *const u8 as *const libc::c_char,
        );
    }
    105 => {
        ignore_case = true;
    }
    115 => {
        skip_chars = size_opt(
            optarg,
            b"invalid number of bytes to skip\0" as *const u8 as *const libc::c_char,
        );
    }
    117 => {
        output_first_repeated = false;
        output_option_used = true;
    }
    119 => {
        check_chars = size_opt(
            optarg,
            b"invalid number of bytes to compare\0" as *const u8 as *const libc::c_char,
        );
    }
    122 => {
        delimiter = '\0' as libc::c_char;
    }
    -2 => {
        usage(0);
    }
    -3 => {
         version_etc(
    stdout,
    CString::new("uniq").unwrap().as_ptr(),
    CString::new("GNU coreutils").unwrap().as_ptr(),
    Version,
    proper_name_lite(
        CString::new("Richard M. Stallman").unwrap().as_ptr(),
        CString::new("Richard M. Stallman").unwrap().as_ptr(),
    ),
    proper_name_lite(
        CString::new("David MacKenzie").unwrap().as_ptr(),
        CString::new("David MacKenzie").unwrap().as_ptr(),
    ),
    std::ptr::null_mut::<libc::c_char>(),
);
std::process::exit(0);


    }
    _ => {
        usage(1);
    }
}
/*
The variables live at this point are:
(mut optc: i32, mut skip_field_option_type: u32, mut nfiles: i32, mut file: [*const i8; 2], mut delimiter: i8, mut output_option_used: bool)
*/


}
/*
The variables live at this point are:
(mut argc: i32, mut argv: *mut *mut i8, mut optc: i32, mut posixly_correct: bool, mut skip_field_option_type: u32, mut nfiles: i32, mut file: [*const i8; 2], mut delimiter: i8, mut output_option_used: bool)
*/

    }
    if grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint
        && output_option_used as libc::c_int != 0
    {
        if 0 != 0 {
            error(
                0 as libc::c_int,
                0 as libc::c_int,
                gettext(
                    b"--group is mutually exclusive with -c/-d/-D/-u\0" as *const u8
                        as *const libc::c_char,
                ),
            );
            if 0 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"--group is mutually exclusive with -c/-d/-D/-u\0" as *const u8
                            as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"--group is mutually exclusive with -c/-d/-D/-u\0" as *const u8
                            as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
        usage(1);
    }
    if grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint
        && count_occurrences as libc::c_int != 0
    {
        if 0 != 0 {
            error(
                0 as libc::c_int,
                0 as libc::c_int,
                gettext(
                    b"grouping and printing repeat counts is meaningless\0" as *const u8
                        as *const libc::c_char,
                ),
            );
            if 0 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"grouping and printing repeat counts is meaningless\0"
                            as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"grouping and printing repeat counts is meaningless\0"
                            as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
        usage(1);
    }
    if count_occurrences as libc::c_int != 0 && output_later_repeated as libc::c_int != 0
    {
        if 0 != 0 {
            error(
                0 as libc::c_int,
                0 as libc::c_int,
                gettext(
                    b"printing all duplicated lines and repeat counts is meaningless\0"
                        as *const u8 as *const libc::c_char,
                ),
            );
            if 0 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"printing all duplicated lines and repeat counts is meaningless\0"
                            as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"printing all duplicated lines and repeat counts is meaningless\0"
                            as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
        usage(1);
    }
    check_file(
        file[0 as libc::c_int as usize],
        file[1 as libc::c_int as usize],
        delimiter,
    );
    return 0 as libc::c_int;
}
src/uniq.rs:1872:5: 1879:6
unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *mut libc::c_char,
            ) as i32,
        )
    }
