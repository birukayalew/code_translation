src/uniq.rs:325:23: 325:64
unsafe { setlocale(5, std::ptr::null()) }
src/uniq.rs:327:31: 327:79
unsafe { std::ffi::CStr::from_ptr(lc_messages) }
src/uniq.rs:357:9: 363:10
unsafe {
            error(
                1,
                saved_errno,
                gettext(CString::new("write error").unwrap().as_ptr()),
            );
        }
src/uniq.rs:370:13: 376:14
unsafe {
                error(
                    errstatus,
                    saved_errno,
                    gettext(CString::new("write error").unwrap().as_ptr()),
                );
            }
src/uniq.rs:383:13: 389:14
unsafe {
                error(
                    errstatus,
                    saved_errno,
                    gettext(CString::new("write error").unwrap().as_ptr()),
                );
            }
src/uniq.rs:433:13: 433:26
unsafe { *p }
src/uniq.rs:434:8: 434:34
unsafe { mcel_isbasic(c) }
src/uniq.rs:444:27: 451:6
unsafe {
        mbrtoc32(
            &mut ch,
            p,
            lim.offset_from(p) as libc::c_long as size_t,
            &mut mbs,
        )
    }
src/uniq.rs:461:1: 479:2
unsafe extern "C" fn skip_buf_matching(
    mut buf: *const libc::c_char,
    mut lim: *const libc::c_char,
    mut predicate: Option::<unsafe extern "C" fn(mcel_t) -> bool>,
    mut ok: bool,
) -> *mut libc::c_char {
    let mut s: *const libc::c_char = buf;
    let mut g: mcel_t = mcel_t { ch: 0, err: 0, len: 0 };
    while s < lim
        && {
            g = mcel_scan(s, lim);
            predicate.expect("non-null function pointer")(g) as libc::c_int
                == ok as libc::c_int
        }
    {
        s = s.offset(g.len as libc::c_int as isize);
    }
    return s as *mut libc::c_char;
}
src/uniq.rs:641:13: 641:208
unsafe { CStr::from_ptr(gettext(CString::new(format!("Try '{} --help' for more information.\n", unsafe { CStr::from_ptr(program_name).to_string_lossy() })).unwrap().as_ptr())).to_string_lossy() }
src/uniq.rs:646:13: 646:209
unsafe { CStr::from_ptr(gettext(CString::new(format!("Usage: {} [OPTION]... [INPUT [OUTPUT]]\n", unsafe { CStr::from_ptr(program_name).to_string_lossy() })).unwrap().as_ptr())).to_string_lossy() }
src/uniq.rs:651:13: 651:267
unsafe { CStr::from_ptr(gettext("Filter adjacent matching lines from INPUT (or standard input),\nwriting to OUTPUT (or standard output).\n\nWith no options, matching lines are merged to the first occurrence.\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:657:13: 657:230
unsafe { CStr::from_ptr(gettext("  -c, --count           prefix lines by the number of occurrences\n  -d, --repeated        only print duplicate lines, one for each group\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:662:13: 662:339
unsafe { CStr::from_ptr(gettext("  -D                    print all duplicate lines\n      --all-repeated[=METHOD]  like -D, but allow separating groups\n                                 with an empty line;\n                                 METHOD={none(default),prepend,separate}\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:667:13: 667:151
unsafe { CStr::from_ptr(gettext("  -f, --skip-fields=N   avoid comparing the first N fields\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:672:13: 672:244
unsafe { CStr::from_ptr(gettext("      --group[=METHOD]  show all items, separating groups with an empty line;\n                          METHOD={separate(default),prepend,append,both}\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:677:13: 677:271
unsafe { CStr::from_ptr(gettext("  -i, --ignore-case     ignore differences in case when comparing\n  -s, --skip-chars=N    avoid comparing the first N characters\n  -u, --unique          only print unique lines\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:682:13: 682:155
unsafe { CStr::from_ptr(gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:687:13: 687:159
unsafe { CStr::from_ptr(gettext("  -w, --check-chars=N   compare no more than N characters in lines\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:692:13: 692:139
unsafe { CStr::from_ptr(gettext("      --help        display this help and exit\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:697:13: 697:148
unsafe { CStr::from_ptr(gettext("      --version     output version information and exit\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:702:13: 702:213
unsafe { CStr::from_ptr(gettext("\nA field is a run of blanks (usually spaces and/or TABs), then non-blank\ncharacters.  Fields are skipped before chars.\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:707:13: 707:230
unsafe { CStr::from_ptr(gettext("\n'uniq' does not detect repeated lines unless they are adjacent.\nYou may want to sort the input first, or use 'sort -u' without 'uniq'.\n".as_ptr() as *const i8)).to_string_lossy() }
src/uniq.rs:715:5: 718:6
unsafe {
        let posix_ver: i32 = posix2_version();
        200112 <= posix_ver && posix_ver < 200809
    }
src/uniq.rs:721:1: 782:2
unsafe extern "C" fn size_opt(
    mut opt: *const libc::c_char,
    mut msgid: *const libc::c_char,
) -> idx_t {
    let mut size: intmax_t = 0;
    if (LONGINT_OVERFLOW as libc::c_int as libc::c_uint)
        < xstrtoimax(
            opt,
            0 as *mut *mut libc::c_char,
            10 as libc::c_int,
            &mut size,
            b"\0" as *const u8 as *const libc::c_char,
        ) as libc::c_uint || size < 0 as libc::c_int as libc::c_long
    {
        if 0 != 0 {
            error(
                1 as libc::c_int,
                0 as libc::c_int,
                b"%s: %s\0" as *const u8 as *const libc::c_char,
                opt,
                gettext(msgid),
            );
            if 1 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    b"%s: %s\0" as *const u8 as *const libc::c_char,
                    opt,
                    gettext(msgid),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    b"%s: %s\0" as *const u8 as *const libc::c_char,
                    opt,
                    gettext(msgid),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
    }
    return if size < 9223372036854775807 as libc::c_long {
        size
    } else {
        9223372036854775807 as libc::c_long
    };
}
src/uniq.rs:783:1: 785:2
unsafe extern "C" fn newline_or_blank(mut g: mcel_t) -> bool {
    return g.ch == '\n' as i32 as u32 || c32isblank(char::from_u32(g.ch).unwrap_or('\0'));
}
src/uniq.rs:786:1: 834:2
unsafe extern "C" fn find_field(
    mut line: *const linebuffer,
    mut plen: *mut idx_t,
) -> *mut libc::c_char {
    let mut lp: *mut libc::c_char = (*line).buffer;
    let mut lim: *const libc::c_char = lp
        .offset((*line).length as isize)
        .offset(-(1 as libc::c_int as isize));
    let mut i: idx_t = skip_fields;
    while (0 as libc::c_int as libc::c_long) < i && lp < lim as *mut libc::c_char {
        lp = skip_buf_matching(
            lp,
            lim,
            Some(newline_or_blank as unsafe extern "C" fn(mcel_t) -> bool),
            1 as libc::c_int != 0,
        );
        lp = skip_buf_matching(
            lp,
            lim,
            Some(newline_or_blank as unsafe extern "C" fn(mcel_t) -> bool),
            0 as libc::c_int != 0,
        );
        i -= 1;
        i;
    }
    let mut i_0: idx_t = skip_chars;
    while (0 as libc::c_int as libc::c_long) < i_0 && lp < lim as *mut libc::c_char {
        lp = lp.offset((mcel_scan(lp, lim)).len as libc::c_int as isize);
        i_0 -= 1;
        i_0;
    }
    let mut len: idx_t = 0;
    if lim.offset_from(lp) as libc::c_long <= check_chars {
        len = lim.offset_from(lp) as libc::c_long;
    } else if __ctype_get_mb_cur_max() <= 1 as libc::c_int as libc::c_ulong {
        len = check_chars;
    } else {
        let mut ep: *mut libc::c_char = lp;
        let mut i_1: idx_t = check_chars;
        while (0 as libc::c_int as libc::c_long) < i_1 && lp < lim as *mut libc::c_char {
            ep = ep.offset((mcel_scan(lp, lim)).len as libc::c_int as isize);
            i_1 -= 1;
            i_1;
        }
        len = ep.offset_from(lp) as libc::c_long;
    }
    *plen = len;
    return lp;
}
src/uniq.rs:835:1: 856:2
unsafe extern "C" fn different(
    mut old: *mut libc::c_char,
    mut new: *mut libc::c_char,
    mut oldlen: idx_t,
    mut newlen: idx_t,
) -> bool {
    if ignore_case {
        return oldlen != newlen
            || memcasecmp(
                old as *const libc::c_void,
                new as *const libc::c_void,
                oldlen as size_t,
            ) != 0
    } else {
        return oldlen != newlen
            || memcmp(
                old as *const libc::c_void,
                new as *const libc::c_void,
                oldlen as libc::c_ulong,
            ) != 0
    };
}
src/uniq.rs:857:1: 887:2
unsafe extern "C" fn writeline(
    mut line: *const linebuffer,
    mut match_0: bool,
    mut linecount: intmax_t,
) {
    if if linecount == 0 as libc::c_int as libc::c_long {
        output_unique as libc::c_int
    } else if !match_0 {
        output_first_repeated as libc::c_int
    } else {
        output_later_repeated as libc::c_int
    } == 0
    {
        return;
    }
    if count_occurrences {
        printf(
            b"%7jd \0" as *const u8 as *const libc::c_char,
            linecount + 1 as libc::c_int as libc::c_long,
        );
    }
    if fwrite_unlocked(
        (*line).buffer as *const libc::c_void,
        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
        (*line).length as size_t,
        stdout,
    ) != (*line).length as libc::c_ulong
    {
        write_error();
    }
}
src/uniq.rs:888:1: 1229:2
unsafe extern "C" fn check_file(
    mut infile: *const libc::c_char,
    mut outfile: *const libc::c_char,
    mut delimiter: libc::c_char,
) {
    let mut current_block: u64;
    let mut lb1: linebuffer = linebuffer {
        size: 0,
        length: 0,
        buffer: 0 as *mut libc::c_char,
    };
    let mut lb2: linebuffer = linebuffer {
        size: 0,
        length: 0,
        buffer: 0 as *mut libc::c_char,
    };
    let mut thisline: *mut linebuffer = 0 as *mut linebuffer;
    let mut prevline: *mut linebuffer = 0 as *mut linebuffer;
    if !(strcmp(infile, b"-\0" as *const u8 as *const libc::c_char) == 0 as libc::c_int
        || !(freopen_safer(infile, b"r\0" as *const u8 as *const libc::c_char, stdin))
            .is_null())
    {
        if 0 != 0 {
            error(
                1 as libc::c_int,
                *__errno_location(),
                b"%s\0" as *const u8 as *const libc::c_char,
                quotearg_n_style_colon(
                    0 as libc::c_int,
                    shell_escape_quoting_style,
                    infile,
                ),
            );
            if 1 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    quotearg_n_style_colon(
                        0 as libc::c_int,
                        shell_escape_quoting_style,
                        infile,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    quotearg_n_style_colon(
                        0 as libc::c_int,
                        shell_escape_quoting_style,
                        infile,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
    }
    if !(strcmp(outfile, b"-\0" as *const u8 as *const libc::c_char) == 0 as libc::c_int
        || !(freopen_safer(outfile, b"w\0" as *const u8 as *const libc::c_char, stdout))
            .is_null())
    {
        if 0 != 0 {
            error(
                1 as libc::c_int,
                *__errno_location(),
                b"%s\0" as *const u8 as *const libc::c_char,
                quotearg_n_style_colon(
                    0 as libc::c_int,
                    shell_escape_quoting_style,
                    outfile,
                ),
            );
            if 1 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    quotearg_n_style_colon(
                        0 as libc::c_int,
                        shell_escape_quoting_style,
                        outfile,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    quotearg_n_style_colon(
                        0 as libc::c_int,
                        shell_escape_quoting_style,
                        outfile,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
    }
    fadvise(stdin, FADVISE_SEQUENTIAL);
    thisline = &mut lb1;
    prevline = &mut lb2;
    initbuffer(thisline);
    initbuffer(prevline);
    if output_unique as libc::c_int != 0 && output_first_repeated as libc::c_int != 0
        && !count_occurrences
    {
        let mut prevfield: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut prevlen: idx_t = 0;
        let mut first_group_printed: bool = 0 as libc::c_int != 0;
        while feof_unlocked(stdin) == 0
            && !(readlinebuffer_delim(thisline, stdin, delimiter)).is_null()
        {
            let mut thislen: idx_t = 0;
            let mut thisfield: *mut libc::c_char = find_field(thisline, &mut thislen);
            let mut new_group: bool = prevfield.is_null()
                || different(thisfield, prevfield, thislen, prevlen) as libc::c_int != 0;
            if new_group as libc::c_int != 0
                && grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint
                && (grouping as libc::c_uint == GM_PREPEND as libc::c_int as libc::c_uint
                    || grouping as libc::c_uint == GM_BOTH as libc::c_int as libc::c_uint
                    || first_group_printed as libc::c_int != 0
                        && (grouping as libc::c_uint
                            == GM_APPEND as libc::c_int as libc::c_uint
                            || grouping as libc::c_uint
                                == GM_SEPARATE as libc::c_int as libc::c_uint))
            {
                putchar_unlocked(delimiter as libc::c_int);
            }
            if new_group as libc::c_int != 0
                || grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint
            {
                if fwrite_unlocked(
                    (*thisline).buffer as *const libc::c_void,
                    ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    (*thisline).length as size_t,
                    stdout,
                ) != (*thisline).length as libc::c_ulong
                {
                    write_error();
                }
                swap_lines(&mut prevline, &mut thisline);
                prevfield = thisfield;
                prevlen = thislen;
                first_group_printed = 1 as libc::c_int != 0;
            }
        }
        if (grouping as libc::c_uint == GM_BOTH as libc::c_int as libc::c_uint
            || grouping as libc::c_uint == GM_APPEND as libc::c_int as libc::c_uint)
            && first_group_printed as libc::c_int != 0
        {
            putchar_unlocked(delimiter as libc::c_int);
        }
    } else if !(readlinebuffer_delim(prevline, stdin, delimiter)).is_null() {
        let mut prevlen_0: idx_t = 0;
        let mut prevfield_0: *mut libc::c_char = find_field(prevline, &mut prevlen_0);
        let mut match_count: intmax_t = 0 as libc::c_int as intmax_t;
        let mut first_delimiter: bool = 1 as libc::c_int != 0;
        loop {
            if !(feof_unlocked(stdin) == 0) {
                current_block = 6476622998065200121;
                break;
            }
            if (readlinebuffer_delim(thisline, stdin, delimiter)).is_null() {
                if ferror_unlocked(stdin) != 0 {
                    current_block = 6469497169255231809;
                    break;
                } else {
                    current_block = 6476622998065200121;
                    break;
                }
            } else {
                let mut thislen_0: idx_t = 0;
                let mut thisfield_0: *mut libc::c_char = find_field(
                    thisline,
                    &mut thislen_0,
                );
                let mut match_0: bool = !different(
                    thisfield_0,
                    prevfield_0,
                    thislen_0,
                    prevlen_0,
                );
                match_count += match_0 as libc::c_long;
                if match_count == 9223372036854775807 as libc::c_long {
                    if count_occurrences {
                        if 0 != 0 {
                            error(
                                1 as libc::c_int,
                                0 as libc::c_int,
                                gettext(
                                    b"too many repeated lines\0" as *const u8
                                        as *const libc::c_char,
                                ),
                            );
                            if 1 as libc::c_int != 0 as libc::c_int {
                                unreachable!();
                            } else {};
                        } else {
                            ({
                                let __errstatus: libc::c_int = 1 as libc::c_int;
                                error(
                                    __errstatus,
                                    0 as libc::c_int,
                                    gettext(
                                        b"too many repeated lines\0" as *const u8
                                            as *const libc::c_char,
                                    ),
                                );
                                if __errstatus != 0 as libc::c_int {
                                    unreachable!();
                                } else {};
                                
                            });
                            ({
                                let __errstatus: libc::c_int = 1 as libc::c_int;
                                error(
                                    __errstatus,
                                    0 as libc::c_int,
                                    gettext(
                                        b"too many repeated lines\0" as *const u8
                                            as *const libc::c_char,
                                    ),
                                );
                                if __errstatus != 0 as libc::c_int {
                                    unreachable!();
                                } else {};
                                
                            });
                        };
                    }
                    match_count -= 1;
                    match_count;
                }
                if delimit_groups as libc::c_uint
                    != DM_NONE as libc::c_int as libc::c_uint
                {
                    if !match_0 {
                        if match_count != 0 {
                            first_delimiter = 0 as libc::c_int != 0;
                        }
                    } else if match_count == 1 as libc::c_int as libc::c_long {
                        if delimit_groups as libc::c_uint
                            == DM_PREPEND as libc::c_int as libc::c_uint
                            || delimit_groups as libc::c_uint
                                == DM_SEPARATE as libc::c_int as libc::c_uint
                                && !first_delimiter
                        {
                            putchar_unlocked(delimiter as libc::c_int);
                        }
                    }
                }
                if !match_0 || output_later_repeated as libc::c_int != 0 {
                    writeline(prevline, match_0, match_count);
                    swap_lines(&mut prevline, &mut thisline);
                    prevfield_0 = thisfield_0;
                    prevlen_0 = thislen_0;
                    if !match_0 {
                        match_count = 0 as libc::c_int as intmax_t;
                    }
                }
            }
        }
        match current_block {
            6469497169255231809 => {}
            _ => {
                writeline(prevline, 0 as libc::c_int != 0, match_count);
            }
        }
    }
    if ferror_unlocked(stdin) != 0 || rpl_fclose(stdin) != 0 as libc::c_int {
        if 0 != 0 {
            error(
                1 as libc::c_int,
                *__errno_location(),
                gettext(b"error reading %s\0" as *const u8 as *const libc::c_char),
                quotearg_style(shell_escape_always_quoting_style, infile),
            );
            if 1 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    gettext(b"error reading %s\0" as *const u8 as *const libc::c_char),
                    quotearg_style(shell_escape_always_quoting_style, infile),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    gettext(b"error reading %s\0" as *const u8 as *const libc::c_char),
                    quotearg_style(shell_escape_always_quoting_style, infile),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
    }
    free(lb1.buffer as *mut libc::c_void);
    free(lb2.buffer as *mut libc::c_void);
}
src/uniq.rs:1230:1: 2002:2
unsafe fn main_0(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut optc: libc::c_int = 0 as libc::c_int;
    let mut posixly_correct: bool = !(getenv(
        b"POSIXLY_CORRECT\0" as *const u8 as *const libc::c_char,
    ))
        .is_null();
    let mut skip_field_option_type: Skip_field_option_type = SFO_NONE;
    let mut nfiles: libc::c_int = 0 as libc::c_int;
    let mut file: [*const libc::c_char; 2] = [0 as *const libc::c_char; 2];
    let mut delimiter: libc::c_char = '\n' as i32 as libc::c_char;
    let mut output_option_used: bool = 0 as libc::c_int != 0;
    file[1 as libc::c_int as usize] = b"-\0" as *const u8 as *const libc::c_char;
    file[0 as libc::c_int as usize] = file[1 as libc::c_int as usize];
    set_program_name(*argv.offset(0 as libc::c_int as isize));
    setlocale(6 as libc::c_int, b"\0" as *const u8 as *const libc::c_char);
    bindtextdomain(
        b"coreutils\0" as *const u8 as *const libc::c_char,
        b"/usr/local/share/locale\0" as *const u8 as *const libc::c_char,
    );
    textdomain(b"coreutils\0" as *const u8 as *const libc::c_char);
    atexit(Some(close_stdout as unsafe extern "C" fn() -> ()));
    loop {
        if optc == -(1 as libc::c_int)
            || posixly_correct as libc::c_int != 0 && nfiles != 0 as libc::c_int
            || {
                optc = getopt_long(
                    argc,
                    argv,
                    b"-0123456789Dcdf:is:uw:z\0" as *const u8 as *const libc::c_char,
                    longopts.as_ptr(),
                    0 as *mut libc::c_int,
                );
                optc == -(1 as libc::c_int)
            }
        {
            if argc <= optind {
                break;
            }
            if nfiles == 2 as libc::c_int {
                if 0 != 0 {
                    error(
                        0 as libc::c_int,
                        0 as libc::c_int,
                        gettext(
                            b"extra operand %s\0" as *const u8 as *const libc::c_char,
                        ),
                        quote(*argv.offset(optind as isize)),
                    );
                    if 0 as libc::c_int != 0 as libc::c_int {
                        unreachable!();
                    } else {};
                } else {
                    ({
                        let __errstatus: libc::c_int = 0 as libc::c_int;
                        error(
                            __errstatus,
                            0 as libc::c_int,
                            gettext(
                                b"extra operand %s\0" as *const u8 as *const libc::c_char,
                            ),
                            quote(*argv.offset(optind as isize)),
                        );
                        if __errstatus != 0 as libc::c_int {
                            unreachable!();
                        } else {};
                        
                    });
                    ({
                        let __errstatus: libc::c_int = 0 as libc::c_int;
                        error(
                            __errstatus,
                            0 as libc::c_int,
                            gettext(
                                b"extra operand %s\0" as *const u8 as *const libc::c_char,
                            ),
                            quote(*argv.offset(optind as isize)),
                        );
                        if __errstatus != 0 as libc::c_int {
                            unreachable!();
                        } else {};
                        
                    });
                };
                usage(1);
            }
            let fresh0 = optind;
            optind = optind + 1;
            let fresh1 = nfiles;
            nfiles = nfiles + 1;
            file[fresh1 as usize] = *argv.offset(fresh0 as isize);
        } else {
            match optc {
                1 => {
                    let mut size: intmax_t = 0;
                    if *optarg.offset(0 as libc::c_int as isize) as libc::c_int
                        == '+' as i32 && !strict_posix2()
                        && xstrtoimax(
                            optarg,
                            0 as *mut *mut libc::c_char,
                            10 as libc::c_int,
                            &mut size,
                            b"\0" as *const u8 as *const libc::c_char,
                        ) as libc::c_uint
                            <= LONGINT_OVERFLOW as libc::c_int as libc::c_uint
                    {
                        skip_chars = if size < 9223372036854775807 as libc::c_long {
                            size
                        } else {
                            9223372036854775807 as libc::c_long
                        };
                    } else if nfiles == 2 as libc::c_int {
                        if 0 != 0 {
                            error(
                                0 as libc::c_int,
                                0 as libc::c_int,
                                gettext(
                                    b"extra operand %s\0" as *const u8 as *const libc::c_char,
                                ),
                                quote(optarg),
                            );
                            if 0 as libc::c_int != 0 as libc::c_int {
                                unreachable!();
                            } else {};
                        } else {
                            ({
                                let __errstatus: libc::c_int = 0 as libc::c_int;
                                error(
                                    __errstatus,
                                    0 as libc::c_int,
                                    gettext(
                                        b"extra operand %s\0" as *const u8 as *const libc::c_char,
                                    ),
                                    quote(optarg),
                                );
                                if __errstatus != 0 as libc::c_int {
                                    unreachable!();
                                } else {};
                                
                            });
                            ({
                                let __errstatus: libc::c_int = 0 as libc::c_int;
                                error(
                                    __errstatus,
                                    0 as libc::c_int,
                                    gettext(
                                        b"extra operand %s\0" as *const u8 as *const libc::c_char,
                                    ),
                                    quote(optarg),
                                );
                                if __errstatus != 0 as libc::c_int {
                                    unreachable!();
                                } else {};
                                
                            });
                        };
                        usage(1);
                    } else {
                        let fresh2 = nfiles;
                        nfiles = nfiles + 1;
                        file[fresh2 as usize] = optarg;
                    }
                }
                48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => {
                    if skip_field_option_type as libc::c_uint
                        == SFO_NEW as libc::c_int as libc::c_uint
                    {
                        skip_fields = 0 as libc::c_int as idx_t;
                    }
                    if !(!((if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t
                        && ((if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            skip_fields
                        }) - 1 as libc::c_int as libc::c_long)
                            < 0 as libc::c_int as libc::c_long
                        && ((if 1 as libc::c_int != 0 {
                            0 as libc::c_int
                        } else {
                            10 as libc::c_int
                        }) - 1 as libc::c_int) < 0 as libc::c_int
                        && (if (10 as libc::c_int) < 0 as libc::c_int {
                            if skip_fields < 0 as libc::c_int as libc::c_long {
                                if ((if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        -(1 as libc::c_int) as idx_t
                                    }) + 10 as libc::c_int as libc::c_long
                                }) - 1 as libc::c_int as libc::c_long)
                                    < 0 as libc::c_int as libc::c_long
                                {
                                    (skip_fields
                                        < -(1 as libc::c_int) as idx_t
                                            / 10 as libc::c_int as libc::c_long) as libc::c_int
                                } else {
                                    ((if (if (if ((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int
                                    } else {
                                        10 as libc::c_int
                                    }) - 1 as libc::c_int) < 0 as libc::c_int
                                    {
                                        !(((((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) + 1 as libc::c_int)
                                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) + 0 as libc::c_int
                                    }) < 0 as libc::c_int
                                    {
                                        ((10 as libc::c_int)
                                            < -(if ((if 1 as libc::c_int != 0 {
                                                0 as libc::c_int
                                            } else {
                                                10 as libc::c_int
                                            }) - 1 as libc::c_int) < 0 as libc::c_int
                                            {
                                                ((((if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    10 as libc::c_int
                                                }) + 1 as libc::c_int)
                                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    10 as libc::c_int
                                                }) - 1 as libc::c_int
                                            })) as libc::c_int
                                    } else {
                                        ((0 as libc::c_int) < 10 as libc::c_int) as libc::c_int
                                    }) != 0
                                    {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) as libc::c_long + -(1 as libc::c_int) as idx_t
                                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                    } else {
                                        -(1 as libc::c_int) as idx_t
                                            / -(10 as libc::c_int) as libc::c_long
                                    }) <= -(1 as libc::c_int) as libc::c_long - skip_fields)
                                        as libc::c_int
                                }
                            } else {
                                if (if (if ((if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int
                                    } else {
                                        10 as libc::c_int
                                    }) as libc::c_long + 0 as libc::c_int as idx_t
                                }) - 1 as libc::c_int as libc::c_long)
                                    < 0 as libc::c_int as libc::c_long
                                {
                                    !(((((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) as libc::c_long + 0 as libc::c_int as idx_t
                                    }) + 1 as libc::c_int as libc::c_long)
                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                        - 1 as libc::c_int as libc::c_long)
                                        * 2 as libc::c_int as libc::c_long
                                        + 1 as libc::c_int as libc::c_long)
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) as libc::c_long + 0 as libc::c_int as idx_t
                                    }) + 0 as libc::c_int as libc::c_long
                                }) < 0 as libc::c_int as libc::c_long
                                {
                                    (((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int
                                    } else {
                                        10 as libc::c_int
                                    }) as libc::c_long + 0 as libc::c_int as idx_t)
                                        < -(if ((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int
                                            } else {
                                                10 as libc::c_int
                                            }) as libc::c_long + 0 as libc::c_int as idx_t
                                        }) - 1 as libc::c_int as libc::c_long)
                                            < 0 as libc::c_int as libc::c_long
                                        {
                                            ((((if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    10 as libc::c_int
                                                }) as libc::c_long + 0 as libc::c_int as idx_t
                                            }) + 1 as libc::c_int as libc::c_long)
                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                - 1 as libc::c_int as libc::c_long)
                                                * 2 as libc::c_int as libc::c_long
                                                + 1 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    10 as libc::c_int
                                                }) as libc::c_long + 0 as libc::c_int as idx_t
                                            }) - 1 as libc::c_int as libc::c_long
                                        })) as libc::c_int
                                } else {
                                    ((0 as libc::c_int as libc::c_long)
                                        < (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) as libc::c_long + 0 as libc::c_int as idx_t)
                                        as libc::c_int
                                }) != 0 && 10 as libc::c_int == -(1 as libc::c_int)
                                {
                                    if ((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        skip_fields
                                    }) - 1 as libc::c_int as libc::c_long)
                                        < 0 as libc::c_int as libc::c_long
                                    {
                                        ((0 as libc::c_int as libc::c_long)
                                            < skip_fields + 0 as libc::c_int as idx_t) as libc::c_int
                                    } else {
                                        ((0 as libc::c_int as libc::c_long) < skip_fields
                                            && (-(1 as libc::c_int) as libc::c_long
                                                - 0 as libc::c_int as idx_t)
                                                < skip_fields - 1 as libc::c_int as libc::c_long)
                                            as libc::c_int
                                    }
                                } else {
                                    ((0 as libc::c_int as idx_t
                                        / 10 as libc::c_int as libc::c_long) < skip_fields)
                                        as libc::c_int
                                }
                            }
                        } else {
                            if 10 as libc::c_int == 0 as libc::c_int {
                                0 as libc::c_int
                            } else {
                                if skip_fields < 0 as libc::c_int as libc::c_long {
                                    if (if (if ((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            skip_fields
                                        }) + 0 as libc::c_int as idx_t
                                    }) - 1 as libc::c_int as libc::c_long)
                                        < 0 as libc::c_int as libc::c_long
                                    {
                                        !(((((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                skip_fields
                                            }) + 0 as libc::c_int as idx_t
                                        }) + 1 as libc::c_int as libc::c_long)
                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                            - 1 as libc::c_int as libc::c_long)
                                            * 2 as libc::c_int as libc::c_long
                                            + 1 as libc::c_int as libc::c_long)
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                skip_fields
                                            }) + 0 as libc::c_int as idx_t
                                        }) + 0 as libc::c_int as libc::c_long
                                    }) < 0 as libc::c_int as libc::c_long
                                    {
                                        (((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            skip_fields
                                        }) + 0 as libc::c_int as idx_t)
                                            < -(if ((if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    skip_fields
                                                }) + 0 as libc::c_int as idx_t
                                            }) - 1 as libc::c_int as libc::c_long)
                                                < 0 as libc::c_int as libc::c_long
                                            {
                                                ((((if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    (if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int as libc::c_long
                                                    } else {
                                                        skip_fields
                                                    }) + 0 as libc::c_int as idx_t
                                                }) + 1 as libc::c_int as libc::c_long)
                                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                    - 1 as libc::c_int as libc::c_long)
                                                    * 2 as libc::c_int as libc::c_long
                                                    + 1 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    (if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int as libc::c_long
                                                    } else {
                                                        skip_fields
                                                    }) + 0 as libc::c_int as idx_t
                                                }) - 1 as libc::c_int as libc::c_long
                                            })) as libc::c_int
                                    } else {
                                        ((0 as libc::c_int as libc::c_long)
                                            < (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                skip_fields
                                            }) + 0 as libc::c_int as idx_t) as libc::c_int
                                    }) != 0
                                        && skip_fields == -(1 as libc::c_int) as libc::c_long
                                    {
                                        if ((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int
                                        } else {
                                            10 as libc::c_int
                                        }) - 1 as libc::c_int) < 0 as libc::c_int
                                        {
                                            ((0 as libc::c_int as libc::c_long)
                                                < 10 as libc::c_int as libc::c_long
                                                    + 0 as libc::c_int as idx_t) as libc::c_int
                                        } else {
                                            ((-(1 as libc::c_int) as libc::c_long
                                                - 0 as libc::c_int as idx_t)
                                                < (10 as libc::c_int - 1 as libc::c_int) as libc::c_long)
                                                as libc::c_int
                                        }
                                    } else {
                                        (0 as libc::c_int as idx_t / skip_fields
                                            < 10 as libc::c_int as libc::c_long) as libc::c_int
                                    }
                                } else {
                                    ((-(1 as libc::c_int) as idx_t
                                        / 10 as libc::c_int as libc::c_long) < skip_fields)
                                        as libc::c_int
                                }
                            }
                        }) != 0
                    {
                        let (fresh7, _fresh8) = skip_fields
                            .overflowing_mul((10 as libc::c_int).into());
                        *(&mut skip_fields as *mut idx_t) = fresh7;
                        1 as libc::c_int
                    } else {
                        let (fresh9, fresh10) = skip_fields
                            .overflowing_mul((10 as libc::c_int).into());
                        *(&mut skip_fields as *mut idx_t) = fresh9;
                        fresh10 as libc::c_int
                    }) != 0)
                        && {
                            let (fresh11, fresh12) = skip_fields
                                .overflowing_add((optc - '0' as i32).into());
                            *(&mut skip_fields as *mut idx_t) = fresh11;
                            !fresh12
                        })
                    {
                        skip_fields = 9223372036854775807 as libc::c_long;
                    }
                    skip_field_option_type = SFO_OBSOLETE;
                }
                99 => {
                    count_occurrences = 1 as libc::c_int != 0;
                    output_option_used = 1 as libc::c_int != 0;
                }
                100 => {
                    output_unique = 0 as libc::c_int != 0;
                    output_option_used = 1 as libc::c_int != 0;
                }
                68 => {
                    output_unique = 0 as libc::c_int != 0;
                    output_later_repeated = 1 as libc::c_int != 0;
                    if optarg.is_null() {
                        delimit_groups = DM_NONE;
                    } else {
                        delimit_groups = delimit_method_map[__xargmatch_internal(
                            b"--all-repeated\0" as *const u8 as *const libc::c_char,
                            optarg,
                            delimit_method_string.as_ptr(),
                            delimit_method_map.as_ptr() as *const libc::c_void,
                            ::core::mem::size_of::<delimit_method>() as libc::c_ulong,
                            argmatch_die,
                            1 as libc::c_int != 0,
                        ) as usize];
                    }
                    output_option_used = 1 as libc::c_int != 0;
                }
                256 => {
                    if optarg.is_null() {
                        grouping = GM_SEPARATE;
                    } else {
                        grouping = grouping_method_map[__xargmatch_internal(
                            b"--group\0" as *const u8 as *const libc::c_char,
                            optarg,
                            grouping_method_string.as_ptr(),
                            grouping_method_map.as_ptr() as *const libc::c_void,
                            ::core::mem::size_of::<grouping_method>() as libc::c_ulong,
                            argmatch_die,
                            1 as libc::c_int != 0,
                        ) as usize];
                    }
                }
                102 => {
                    skip_field_option_type = SFO_NEW;
                    skip_fields = size_opt(
                        optarg,
                        b"invalid number of fields to skip\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                105 => {
                    ignore_case = 1 as libc::c_int != 0;
                }
                115 => {
                    skip_chars = size_opt(
                        optarg,
                        b"invalid number of bytes to skip\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                117 => {
                    output_first_repeated = 0 as libc::c_int != 0;
                    output_option_used = 1 as libc::c_int != 0;
                }
                119 => {
                    check_chars = size_opt(
                        optarg,
                        b"invalid number of bytes to compare\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                122 => {
                    delimiter = '\0' as i32 as libc::c_char;
                }
                -2 => {
                    usage(0);
                }
                -3 => {
                    version_etc(
                        stdout,
                        b"uniq\0" as *const u8 as *const libc::c_char,
                        b"GNU coreutils\0" as *const u8 as *const libc::c_char,
                        Version,
                        proper_name_lite(
                            b"Richard M. Stallman\0" as *const u8 as *const libc::c_char,
                            b"Richard M. Stallman\0" as *const u8 as *const libc::c_char,
                        ),
                        proper_name_lite(
                            b"David MacKenzie\0" as *const u8 as *const libc::c_char,
                            b"David MacKenzie\0" as *const u8 as *const libc::c_char,
                        ),
                        0 as *mut libc::c_void as *mut libc::c_char,
                    );
                    exit(0 as libc::c_int);
                }
                _ => {
                    usage(1);
                }
            }
        }
    }
    if grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint
        && output_option_used as libc::c_int != 0
    {
        if 0 != 0 {
            error(
                0 as libc::c_int,
                0 as libc::c_int,
                gettext(
                    b"--group is mutually exclusive with -c/-d/-D/-u\0" as *const u8
                        as *const libc::c_char,
                ),
            );
            if 0 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"--group is mutually exclusive with -c/-d/-D/-u\0" as *const u8
                            as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"--group is mutually exclusive with -c/-d/-D/-u\0" as *const u8
                            as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
        usage(1);
    }
    if grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint
        && count_occurrences as libc::c_int != 0
    {
        if 0 != 0 {
            error(
                0 as libc::c_int,
                0 as libc::c_int,
                gettext(
                    b"grouping and printing repeat counts is meaningless\0" as *const u8
                        as *const libc::c_char,
                ),
            );
            if 0 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"grouping and printing repeat counts is meaningless\0"
                            as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"grouping and printing repeat counts is meaningless\0"
                            as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
        usage(1);
    }
    if count_occurrences as libc::c_int != 0 && output_later_repeated as libc::c_int != 0
    {
        if 0 != 0 {
            error(
                0 as libc::c_int,
                0 as libc::c_int,
                gettext(
                    b"printing all duplicated lines and repeat counts is meaningless\0"
                        as *const u8 as *const libc::c_char,
                ),
            );
            if 0 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"printing all duplicated lines and repeat counts is meaningless\0"
                            as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 0 as libc::c_int;
                error(
                    __errstatus,
                    0 as libc::c_int,
                    gettext(
                        b"printing all duplicated lines and repeat counts is meaningless\0"
                            as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
        usage(1);
    }
    check_file(
        file[0 as libc::c_int as usize],
        file[1 as libc::c_int as usize],
        delimiter,
    );
    return 0 as libc::c_int;
}
src/uniq.rs:2014:18: 2016:6
unsafe {
        main_0((argv.len() - 1) as libc::c_int, argv.as_mut_ptr())
    }
