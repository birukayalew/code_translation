[
  {
    "func_defid": "DefId(0:98 ~ rust[fc84]::src::close_stream::close_stream)",
    "span": "src/close_stream.rs:51:1: 67:2 (#0)",
    "pieces": [
      "src/close_stream.rs:51:1: 67:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/close_stream.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1036 ~ rust[fc84]::src::xmalloc::check_nonnull)",
    "span": "src/xmalloc.rs:134:1: 139:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:134:1: 139:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:1183 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:146:48: 149:2 (#0)",
        "source": "{\n    let ptr = imalloc(s);\n    check_nonnull(ptr)\n}"
      },
      {
        "caller": "DefId(0:1182 ~ rust[fc84]::src::xmalloc::xmalloc)",
        "span": "src/xmalloc.rs:143:5: 143:37 (#0)",
        "source": "return check_nonnull(malloc(s));"
      },
      {
        "caller": "DefId(0:1197 ~ rust[fc84]::src::xmalloc::xicalloc)",
        "span": "src/xmalloc.rs:1001:84: 1007:2 (#0)",
        "source": "{\n    let result = icalloc(n, s);\nif result.is_null() {\n    return _gl_alloc_nomem(); // Handle allocation failure\n}\ncheck_nonnull(result)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1037 ~ rust[fc84]::src::xmalloc::xmalloc)",
    "span": "src/xmalloc.rs:142:1: 144:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:142:1: 144:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}",
    "calls": [
      {
        "caller": "DefId(0:1184 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:156:9: 156:50 (#0)",
        "source": "unsafe { xmalloc(n.try_into().unwrap()) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1053 ~ rust[fc84]::src::xmalloc::xmemdup)",
    "span": "src/xmalloc.rs:1009:1: 1013:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1009:1: 1013:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:868 ~ rust[fc84]::src::quotearg::set_char_quoting)",
    "span": "src/quotearg.rs:214:1: 232:2 (#0)",
    "pieces": [
      "src/quotearg.rs:214:1: 232:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 30,
    "source": "pub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:998 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1560:5: 1560:58 (#0)",
        "source": "set_char_quoting(Some(&mut options), ':' as char, 1);"
      },
      {
        "caller": "DefId(0:993 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1516:5: 1516:76 (#0)",
        "source": "let result = set_char_quoting(Some(&mut options), ch as u8 as char, 1);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:175:1: 181:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:789 ~ rust[fc84]::src::progname::set_program_name)",
    "span": "src/progname.rs:59:1: 96:2 (#0)",
    "pieces": [
      "src/progname.rs:59:1: 96:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "pub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/progname.rs:57:1: 57:77 (#0)",
        "source": "pub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/progname.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:61 ~ rust[fc84]::src::c_ctype::c_isalpha)",
    "span": "src/c_ctype.rs:30:1: 32:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:30:1: 32:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:74 ~ rust[fc84]::src::c_ctype::c_toupper)",
    "span": "src/c_ctype.rs:162:1: 167:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:162:1: 167:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:280 ~ rust[fc84]::src::ialloc::_gl_alloc_nomem)",
    "span": "src/ialloc.rs:102:1: 105:2 (#0)",
    "pieces": [
      "src/ialloc.rs:102:1: 105:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:3:1: 3:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:1:1: 1:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:5:1: 5:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/ialloc.rs:5:5: 5:13 (#0)",
        "source": "std::vec"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:277 ~ rust[fc84]::src::ialloc::icalloc)",
    "span": "src/ialloc.rs:50:1: 66:2 (#0)",
    "pieces": [
      "src/ialloc.rs:50:1: 66:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:7:1: 7:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:5:1: 5:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/ialloc.rs:3:1: 3:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:5:5: 5:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/ialloc.rs:1:1: 1:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:79 ~ rust[fc84]::src::c_strcasecmp::c_tolower)",
    "span": "src/c_strcasecmp.rs:6:1: 11:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:6:1: 11:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:90 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:15:5: 15:54 (#0)",
        "source": "let c1 = s1.chars().map(|c| c_tolower(c as i32));"
      },
      {
        "caller": "DefId(0:90 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:16:5: 16:54 (#0)",
        "source": "let c2 = s2.chars().map(|c| c_tolower(c as i32));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:872 ~ rust[fc84]::src::quotearg::gettext_quote)",
    "span": "src/quotearg.rs:279:1: 316:2 (#0)",
    "pieces": [
      "src/quotearg.rs:279:1: 316:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "unsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:970 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:364:21: 364:74 (#0)",
        "source": "let left_quote = gettext_quote(\"`\\0\", quoting_style);"
      },
      {
        "caller": "DefId(0:970 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:365:21: 365:75 (#0)",
        "source": "let right_quote = gettext_quote(\"'\\0\", quoting_style);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:873 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
    "span": "src/quotearg.rs:318:1: 1213:2 (#0)",
    "pieces": [
      "src/quotearg.rs:318:1: 1213:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 902,
    "source": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:970 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1154:41: 1166:10 (#0)",
        "source": "{\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        }"
      },
      {
        "caller": "DefId(0:970 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1183:13: 1193:15 (#0)",
        "source": "return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );"
      },
      {
        "caller": "DefId(0:974 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1282:5: 1292:7 (#0)",
        "source": "quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:971 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
        "span": "src/quotearg.rs:1223:13: 1235:6 (#0)",
        "source": "unsafe {\n        quotearg_buffer_restyled(\n            buffer.as_mut_ptr(),\n            buffersize,\n            arg.as_ptr(),\n            argsize,\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        )\n    }"
      },
      {
        "caller": "DefId(0:984 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1405:9: 1415:11 (#0)",
        "source": "quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );"
      },
      {
        "caller": "DefId(0:974 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1269:5: 1280:58 (#0)",
        "source": "let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:984 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1385:5: 1395:7 (#0)",
        "source": "let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:81:1: 81:46 (#0)",
        "source": "pub const c_quoting_style: quoting_style = 5;"
      },
      {
        "span": "src/quotearg.rs:84:1: 84:57 (#0)",
        "source": "pub const shell_always_quoting_style: quoting_style = 2;"
      },
      {
        "span": "src/quotearg.rs:89:1: 89:52 (#0)",
        "source": "pub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;"
      },
      {
        "span": "src/quotearg.rs:82:1: 82:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:886 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
    "span": "src/quotearg.rs:1341:1: 1419:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1341:1: 1419:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 79,
    "source": "unsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}",
    "calls": [
      {
        "caller": "DefId(0:986 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
        "span": "src/quotearg.rs:1440:5: 1443:6 (#0)",
        "source": "unsafe {\n        options = &default_quoting_options;\n        quotearg_n_options(n, arg.as_ptr(), argsize, options)\n    }"
      },
      {
        "caller": "DefId(0:1001 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1599:5: 1599:56 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut o);"
      },
      {
        "caller": "DefId(0:985 ~ rust[fc84]::src::quotearg::quotearg_n)",
        "span": "src/quotearg.rs:1425:5: 1430:7 (#0)",
        "source": "return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );"
      },
      {
        "caller": "DefId(0:993 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1517:5: 1517:77 (#0)",
        "source": "return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);"
      },
      {
        "caller": "DefId(0:989 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1468:5: 1468:82 (#0)",
        "source": "return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);"
      },
      {
        "caller": "DefId(0:998 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1562:18: 1569:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            18446744073709551615 as libc::c_ulong,\n            &mut options,\n        )\n    }"
      },
      {
        "caller": "DefId(0:990 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1478:5: 1480:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg.as_ptr() as *const libc::c_char, argsize, &o)\n    }"
      },
      {
        "caller": "DefId(0:1005 ~ rust[fc84]::src::quotearg::quote_n_mem)",
        "span": "src/quotearg.rs:1661:5: 1661:76 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1310:1: 1312:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1300:1: 1300:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      },
      {
        "span": "src/quotearg.rs:90:1: 90:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      },
      {
        "span": "src/quotearg.rs:1301:1: 1309:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:870 ~ rust[fc84]::src::quotearg::set_custom_quoting)",
    "span": "src/quotearg.rs:250:1: 264:2 (#0)",
    "pieces": [
      "src/quotearg.rs:250:1: 264:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}",
    "calls": [
      {
        "caller": "DefId(0:1001 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1598:5: 1598:57 (#0)",
        "source": "set_custom_quoting(&mut o, left_quote, right_quote);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:175:1: 181:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:76:1: 76:52 (#0)",
        "source": "pub const custom_quoting_style: quoting_style = 10;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:903 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
    "span": "src/quotearg.rs:1590:1: 1600:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1590:1: 1600:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}",
    "calls": [
      {
        "caller": "DefId(0:1000 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
        "span": "src/quotearg.rs:1581:5: 1587:7 (#0)",
        "source": "return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );"
      },
      {
        "caller": "DefId(0:1003 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
        "span": "src/quotearg.rs:1633:9: 1639:11 (#0)",
        "source": "let result = quotearg_n_custom_mem(\n            0,\n            left_quote_c.as_ptr(),\n            right_quote_c.as_ptr(),\n            arg_c.as_ptr(),\n            argsize,\n        );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:175:1: 181:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:871 ~ rust[fc84]::src::quotearg::quoting_options_from_style)",
    "span": "src/quotearg.rs:265:1: 277:2 (#0)",
    "pieces": [
      "src/quotearg.rs:265:1: 277:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}",
    "calls": [
      {
        "caller": "DefId(0:990 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1476:5: 1476:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:989 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1467:5: 1467:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:998 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1559:5: 1559:45 (#0)",
        "source": "options = quoting_options_from_style(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:892 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
    "span": "src/quotearg.rs:1471:1: 1481:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1471:1: 1481:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:992 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
        "span": "src/quotearg.rs:1496:5: 1496:58 (#0)",
        "source": "let result_ptr = quotearg_n_style_mem(0, s, arg_str);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:50 ~ rust[fc84]::src::argmatch::argmatch_invalid)",
    "span": "src/argmatch.rs:157:1: 185:2 (#0)",
    "pieces": [
      "src/argmatch.rs:157:1: 185:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 54,
    "source": "pub unsafe extern \"C\" fn argmatch_invalid(\n    mut context: *const libc::c_char,\n    mut value: *const libc::c_char,\n    mut problem: ptrdiff_t,\n) {\n    let mut format: *const libc::c_char = if problem\n        == -(1 as libc::c_int) as libc::c_long\n    {\n        gettext(b\"invalid argument %s for %s\\0\" as *const u8 as *const libc::c_char)\n    } else {\n        gettext(b\"ambiguous argument %s for %s\\0\" as *const u8 as *const libc::c_char)\n    };\n    if 0 != 0 {\n        error(\n            0 as libc::c_int,\n            0 as libc::c_int,\n            format,\n            quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n            quote_n(1 as libc::c_int, context),\n        );\n        if 0 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 0 as libc::c_int;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                format,\n                quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n                quote_n(1 as libc::c_int, context),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 0 as libc::c_int;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                format,\n                quotearg_n_style(0 as libc::c_int, locale_quoting_style, value),\n                quote_n(1 as libc::c_int, context),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:58 ~ rust[fc84]::src::argmatch::__xargmatch_internal)",
        "span": "src/argmatch.rs:252:9: 252:45 (#0)",
        "source": "argmatch_invalid(context, arg, res);"
      }
    ],
    "globals": [
      {
        "span": "src/argmatch.rs:87:1: 87:51 (#0)",
        "source": "pub const locale_quoting_style: quoting_style = 8;"
      }
    ],
    "imports": [
      {
        "span": "src/argmatch.rs:5:1: 5:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/argmatch.rs:3:1: 3:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:65 ~ rust[fc84]::src::c_ctype::c_isdigit)",
    "span": "src/c_ctype.rs:73:1: 75:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:73:1: 75:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:72 ~ rust[fc84]::src::c_ctype::c_isxdigit)",
    "span": "src/c_ctype.rs:145:1: 147:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:145:1: 147:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:250 ~ rust[fc84]::src::fseeko::rpl_fseeko)",
    "span": "src/fseeko.rs:52:1: 74:2 (#0)",
    "pieces": [
      "src/fseeko.rs:52:1: 74:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fseeko.rs:1:1: 1:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/fseeko.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:53 ~ rust[fc84]::src::argmatch::argmatch_to_argument)",
    "span": "src/argmatch.rs:260:1: 282:2 (#0)",
    "pieces": [
      "src/argmatch.rs:260:1: 282:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn argmatch_to_argument(\n    mut value: *const libc::c_void,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) -> *const libc::c_char {\n    let mut i: size_t = 0;\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if memcmp(\n            value,\n            (vallist as *const libc::c_char).offset(valsize.wrapping_mul(i) as isize)\n                as *const libc::c_void,\n            valsize,\n        ) == 0\n        {\n            return *arglist.offset(i as isize);\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as *const libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/argmatch.rs:5:1: 5:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/argmatch.rs:3:1: 3:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:900 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
    "span": "src/quotearg.rs:1547:1: 1572:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1547:1: 1572:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:86:1: 86:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:895 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
    "span": "src/quotearg.rs:1503:1: 1518:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1503:1: 1518:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}",
    "calls": [
      {
        "caller": "DefId(0:995 ~ rust[fc84]::src::quotearg::quotearg_char)",
        "span": "src/quotearg.rs:1522:5: 1524:6 (#0)",
        "source": "unsafe {\n        quotearg_char_mem(arg_cstr.as_ptr(), u64::MAX, ch as libc::c_char)\n    }"
      },
      {
        "caller": "DefId(0:997 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
        "span": "src/quotearg.rs:1541:9: 1541:96 (#0)",
        "source": "result_ptr = quotearg_char_mem(c_string.as_ptr(), argsize, ':' as i32 as libc::c_char);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:86:1: 86:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      },
      {
        "span": "src/quotearg.rs:175:1: 181:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:897 ~ rust[fc84]::src::quotearg::quotearg_char)",
    "span": "src/quotearg.rs:1520:1: 1525:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1520:1: 1525:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}",
    "calls": [
      {
        "caller": "DefId(0:996 ~ rust[fc84]::src::quotearg::quotearg_colon)",
        "span": "src/quotearg.rs:1529:5: 1529:46 (#0)",
        "source": "let result_ptr = quotearg_char(arg, ':');"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:907 ~ rust[fc84]::src::quotearg::quote_n_mem)",
    "span": "src/quotearg.rs:1656:1: 1662:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1656:1: 1662:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:1007 ~ rust[fc84]::src::quotearg::quote_n)",
        "span": "src/quotearg.rs:1681:5: 1681:71 (#0)",
        "source": "return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:1006 ~ rust[fc84]::src::quotearg::quote_mem)",
        "span": "src/quotearg.rs:1670:9: 1670:65 (#0)",
        "source": "result_ptr = quote_n_mem(0, c_string.as_ptr(), argsize);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1645:1: 1654:3 (#0)",
        "source": "pub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:909 ~ rust[fc84]::src::quotearg::quote_n)",
    "span": "src/quotearg.rs:1677:1: 1682:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1677:1: 1682:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:1008 ~ rust[fc84]::src::quotearg::quote)",
        "span": "src/quotearg.rs:1686:5: 1686:45 (#0)",
        "source": "unsafe { quote_n(0, c_string.as_ptr()) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:910 ~ rust[fc84]::src::quotearg::quote)",
    "span": "src/quotearg.rs:1684:1: 1687:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1684:1: 1687:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:126 ~ rust[fc84]::src::closeout::close_stdout_set_ignore_EPIPE)",
    "span": "src/closeout.rs:83:1: 87:2 (#0)",
    "pieces": [
      "src/closeout.rs:83:1: 87:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:81:1: 81:39 (#0)",
        "source": "static mut ignore_EPIPE: bool = false;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:4:1: 4:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/closeout.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/closeout.rs:5:1: 5:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:750 ~ rust[fc84]::src::mcel::mcel_err)",
    "span": "src/mcel.rs:152:1: 160:2 (#0)",
    "pieces": [
      "src/mcel.rs:152:1: 160:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "pub unsafe extern \"C\" fn mcel_err(mut err: libc::c_uchar) -> mcel_t {\n    if MCEL_ERR_MIN as libc::c_int <= err as libc::c_int {} else {\n        unreachable!();\n    };\n    return {\n        let mut init = mcel_t {\n            ch: 0,\n            err: err,\n            len: 1 as libc::c_int as libc::c_uchar,\n        };\n        init\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:817 ~ rust[fc84]::src::mcel::mcel_scan)",
        "span": "src/mcel.rs:110:9: 110:45 (#0)",
        "source": "return mcel_err(c as libc::c_uchar);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/mcel.rs:8:1: 8:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/mcel.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:713 ~ rust[fc84]::src::mbrtoc32::mbszero)",
    "span": "src/mbrtoc32.rs:36:1: 42:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:36:1: 42:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:780 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
        "span": "src/mbrtoc32.rs:64:9: 64:21 (#0)",
        "source": "mbszero(ps);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:715 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
    "span": "src/mbrtoc32.rs:48:1: 78:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:48:1: 78:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 31,
    "source": "pub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/mbrtoc32.rs:43:1: 46:3 (#0)",
        "source": "static mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};"
      }
    ],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:986 ~ rust[fc84]::src::version_etc::version_etc_arn)",
    "span": "src/version_etc.rs:67:1: 249:2 (#0)",
    "pieces": [
      "src/version_etc.rs:67:1: 249:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 183,
    "source": "pub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1104 ~ rust[fc84]::src::version_etc::version_etc_ar)",
        "span": "src/version_etc.rs:264:5: 264:81 (#0)",
        "source": "version_etc_arn(stream, command_name, package, version, authors, n_authors);"
      },
      {
        "caller": "DefId(0:1105 ~ rust[fc84]::src::version_etc::version_etc_va)",
        "span": "src/version_etc.rs:286:5: 293:7 (#0)",
        "source": "version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/version_etc.rs:64:1: 64:48 (#0)",
        "source": "pub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;"
      }
    ],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:987 ~ rust[fc84]::src::version_etc::version_etc_ar)",
    "span": "src/version_etc.rs:251:1: 265:2 (#0)",
    "pieces": [
      "src/version_etc.rs:251:1: 265:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:305 ~ rust[fc84]::src::linebuffer::freebuffer)",
    "span": "src/linebuffer.rs:137:1: 142:2 (#0)",
    "pieces": [
      "src/linebuffer.rs:137:1: 142:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn freebuffer(mut linebuffer: *mut linebuffer) {\n    free((*linebuffer).buffer as *mut libc::c_void);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/linebuffer.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/linebuffer.rs:1:1: 1:20 (#0)",
        "source": "use std::mem::drop;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:80 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
    "span": "src/c_strcasecmp.rs:14:1: 26:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:14:1: 26:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "pub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:857 ~ rust[fc84]::src::quotearg::c32isprint)",
    "span": "src/quotearg.rs:136:1: 138:2 (#0)",
    "pieces": [
      "src/quotearg.rs:136:1: 138:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:894 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
    "span": "src/quotearg.rs:1491:1: 1500:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1491:1: 1500:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:259 ~ rust[fc84]::src::hard_locale::hard_locale)",
    "span": "src/hard_locale.rs:14:1: 31:2 (#0)",
    "pieces": [
      "src/hard_locale.rs:14:1: 31:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hard_locale.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hard_locale.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:898 ~ rust[fc84]::src::quotearg::quotearg_colon)",
    "span": "src/quotearg.rs:1528:1: 1533:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1528:1: 1533:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:919 ~ rust[fc84]::src::setlocale_null::setlocale_null_r)",
    "span": "src/setlocale_null.rs:16:1: 24:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:16:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:3:1: 3:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/setlocale_null.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/setlocale_null.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:71 ~ rust[fc84]::src::c_ctype::c_isupper)",
    "span": "src/c_ctype.rs:138:1: 140:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:138:1: 140:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:51 ~ rust[fc84]::src::argmatch::argmatch_valid)",
    "span": "src/argmatch.rs:188:1: 227:2 (#0)",
    "pieces": [
      "src/argmatch.rs:188:1: 227:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 40,
    "source": "pub unsafe extern \"C\" fn argmatch_valid(\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) {\n    let mut i: size_t = 0;\n    let mut last_val: *const libc::c_char = 0 as *const libc::c_char;\n    fputs_unlocked(\n        gettext(b\"Valid arguments are:\\0\" as *const u8 as *const libc::c_char),\n        stderr,\n    );\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if i == 0 as libc::c_int as libc::c_ulong\n            || memcmp(\n                last_val as *const libc::c_void,\n                (vallist as *const libc::c_char).offset(valsize.wrapping_mul(i) as isize)\n                    as *const libc::c_void,\n                valsize,\n            ) != 0\n        {\n            fprintf(\n                stderr,\n                b\"\\n  - %s\\0\" as *const u8 as *const libc::c_char,\n                quote(*arglist.offset(i as isize)),\n            );\n            last_val = (vallist as *const libc::c_char)\n                .offset(valsize.wrapping_mul(i) as isize);\n        } else {\n            fprintf(\n                stderr,\n                b\", %s\\0\" as *const u8 as *const libc::c_char,\n                quote(*arglist.offset(i as isize)),\n            );\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    putc_unlocked('\\n' as i32, stderr);\n}",
    "calls": [
      {
        "caller": "DefId(0:58 ~ rust[fc84]::src::argmatch::__xargmatch_internal)",
        "span": "src/argmatch.rs:253:9: 253:110 (#0)",
        "source": "argmatch_valid(arglist.as_ptr() as *const *const libc::c_char, vallist, valsize.try_into().unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/argmatch.rs:3:1: 3:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/argmatch.rs:5:1: 5:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:49 ~ rust[fc84]::src::argmatch::argmatch_exact)",
    "span": "src/argmatch.rs:144:1: 154:2 (#0)",
    "pieces": [
      "src/argmatch.rs:144:1: 154:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn argmatch_exact(\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n) -> ptrdiff_t {\n    let mut i: size_t = 0;\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if strcmp(*arglist.offset(i as isize), arg) == 0 {\n            return i as ptrdiff_t;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return -(1 as libc::c_int) as ptrdiff_t;\n}",
    "calls": [
      {
        "caller": "DefId(0:58 ~ rust[fc84]::src::argmatch::__xargmatch_internal)",
        "span": "src/argmatch.rs:245:13: 245:132 (#0)",
        "source": "res = argmatch_exact(arg.to_str().unwrap(), &arglist.iter().map(|s| s.to_str().unwrap()).collect::<Vec<_>>()) as isize;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/argmatch.rs:3:1: 3:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/argmatch.rs:5:1: 5:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:48 ~ rust[fc84]::src::argmatch::argmatch)",
    "span": "src/argmatch.rs:107:1: 142:2 (#0)",
    "pieces": [
      "src/argmatch.rs:107:1: 142:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn argmatch(\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n) -> ptrdiff_t {\n    let mut i: size_t = 0;\n    let mut arglen: size_t = 0;\n    let mut matchind: ptrdiff_t = -(1 as libc::c_int) as ptrdiff_t;\n    let mut ambiguous: bool = 0 as libc::c_int != 0;\n    arglen = strlen(arg);\n    i = 0 as libc::c_int as size_t;\n    while !(*arglist.offset(i as isize)).is_null() {\n        if strncmp(*arglist.offset(i as isize), arg, arglen) == 0 {\n            if strlen(*arglist.offset(i as isize)) == arglen {\n                return i as ptrdiff_t\n            } else if matchind == -(1 as libc::c_int) as libc::c_long {\n                matchind = i as ptrdiff_t;\n            } else if vallist.is_null()\n                || memcmp(\n                    (vallist as *const libc::c_char)\n                        .offset(valsize.wrapping_mul(matchind as libc::c_ulong) as isize)\n                        as *const libc::c_void,\n                    (vallist as *const libc::c_char)\n                        .offset(valsize.wrapping_mul(i) as isize) as *const libc::c_void,\n                    valsize,\n                ) != 0\n            {\n                ambiguous = 1 as libc::c_int != 0;\n            }\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    if ambiguous { return -(2 as libc::c_int) as ptrdiff_t } else { return matchind };\n}",
    "calls": [
      {
        "caller": "DefId(0:58 ~ rust[fc84]::src::argmatch::__xargmatch_internal)",
        "span": "src/argmatch.rs:241:13: 241:137 (#0)",
        "source": "res = argmatch(arg.as_ptr(), arglist.as_ptr() as *const *const libc::c_char, vallist, valsize.try_into().unwrap()) as isize;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/argmatch.rs:3:1: 3:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/argmatch.rs:5:1: 5:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:52 ~ rust[fc84]::src::argmatch::__xargmatch_internal)",
    "span": "src/argmatch.rs:229:1: 257:2 (#0)",
    "pieces": [
      "src/argmatch.rs:229:1: 257:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 24,
    "source": "pub unsafe extern \"C\" fn __xargmatch_internal(\n    mut context: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut arglist: *const *const libc::c_char,\n    mut vallist: *const libc::c_void,\n    mut valsize: size_t,\n    mut exit_fn: argmatch_exit_fn,\n    mut allow_abbreviation: bool,\n) -> ptrdiff_t {\n    let mut res: ptrdiff_t = 0;\n    if allow_abbreviation {\n        res = argmatch(arg, arglist, vallist, valsize);\n    } else {\n        res = argmatch_exact(arg, arglist);\n    }\n    if res >= 0 as libc::c_int as libc::c_long {\n        return res;\n    }\n    argmatch_invalid(context, arg, res);\n    argmatch_valid(arglist, vallist, valsize);\n    (Some(exit_fn.expect(\"non-null function pointer\")))\n        .expect(\"non-null function pointer\")();\n    return -(1 as libc::c_int) as ptrdiff_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/argmatch.rs:3:1: 3:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/argmatch.rs:5:1: 5:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1034 ~ rust[fc84]::src::xmalloc::_gl_alloc_nomem)",
    "span": "src/xmalloc.rs:112:1: 117:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:112:1: 117:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:1197 ~ rust[fc84]::src::xmalloc::xicalloc)",
        "span": "src/xmalloc.rs:1004:5: 1004:30 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:1177 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:70:49: 92:2 (#0)",
        "source": "{\n    if n < 0 || n > usize::MAX as i64 {\n        if s != 0 {\n            return _gl_alloc_nomem();\n        }\n        return std::ptr::null_mut();\n    }\n    if s < 0 || s > usize::MAX as i64 {\n        if n != 0 {\n            return _gl_alloc_nomem();\n        }\n        return std::ptr::null_mut();\n    }\n\n    let total_size = (n as usize).checked_mul(s as usize);\n    match total_size {\n        Some(size) => {\n            let ptr = unsafe { libc::calloc(size, 1) };\n            ptr\n        }\n        None => _gl_alloc_nomem(),\n    }\n}"
      },
      {
        "caller": "DefId(0:1177 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:79:13: 79:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:1176 ~ rust[fc84]::src::xmalloc::irealloc)",
        "span": "src/xmalloc.rs:65:9: 65:34 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:1177 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:73:13: 73:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:1178 ~ rust[fc84]::src::xmalloc::ireallocarray)",
        "span": "src/xmalloc.rs:106:9: 106:34 (#0)",
        "source": "return _gl_alloc_nomem();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1032 ~ rust[fc84]::src::xmalloc::icalloc)",
    "span": "src/xmalloc.rs:70:1: 92:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:70:1: 92:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:1197 ~ rust[fc84]::src::xmalloc::xicalloc)",
        "span": "src/xmalloc.rs:1002:5: 1002:32 (#0)",
        "source": "let result = icalloc(n, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1052 ~ rust[fc84]::src::xmalloc::xicalloc)",
    "span": "src/xmalloc.rs:1001:1: 1007:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1001:1: 1007:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:891 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
    "span": "src/quotearg.rs:1462:1: 1469:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1462:1: 1469:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:991 ~ rust[fc84]::src::quotearg::quotearg_style)",
        "span": "src/quotearg.rs:1486:18: 1486:70 (#0)",
        "source": "unsafe { quotearg_n_style(0, s, c_string.as_ptr()) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:902 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
    "span": "src/quotearg.rs:1575:1: 1588:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1575:1: 1588:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:1002 ~ rust[fc84]::src::quotearg::quotearg_custom)",
        "span": "src/quotearg.rs:1613:9: 1613:106 (#0)",
        "source": "result_ptr = quotearg_n_custom(0, left_quote_c.as_ptr(), right_quote_c.as_ptr(), arg_c.as_ptr());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:904 ~ rust[fc84]::src::quotearg::quotearg_custom)",
    "span": "src/quotearg.rs:1602:1: 1619:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1602:1: 1619:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:749 ~ rust[fc84]::src::mcel::mcel_cmp)",
    "span": "src/mcel.rs:143:1: 147:2 (#0)",
    "pieces": [
      "src/mcel.rs:143:1: 147:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn mcel_cmp(mut c1: mcel_t, mut c2: mcel_t) -> libc::c_int {\n    let mut ch1: libc::c_int = c1.ch as libc::c_int;\n    let mut ch2: libc::c_int = c2.ch as libc::c_int;\n    return (c1.err as libc::c_int - c2.err as libc::c_int)\n        * ((1 as libc::c_int) << MCEL_ERR_SHIFT as libc::c_int) + (ch1 - ch2);\n}",
    "calls": [
      {
        "caller": "DefId(0:819 ~ rust[fc84]::src::mcel::mcel_tocmp)",
        "span": "src/mcel.rs:131:5: 131:45 (#0)",
        "source": "let cmp: libc::c_int = mcel_cmp(c1, c2);"
      }
    ],
    "globals": [
      {
        "span": "src/mcel.rs:51:1: 51:48 (#0)",
        "source": "pub const MCEL_ERR_SHIFT: C2RustUnnamed_3 = 14;"
      }
    ],
    "imports": [
      {
        "span": "src/mcel.rs:8:1: 8:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/mcel.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:748 ~ rust[fc84]::src::mcel::mcel_tocmp)",
    "span": "src/mcel.rs:126:1: 138:2 (#0)",
    "pieces": [
      "src/mcel.rs:126:1: 138:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "pub unsafe extern \"C\" fn mcel_tocmp(\n    mut to: Option::<unsafe extern \"C\" fn(wint_t) -> wint_t>,\n    mut c1: mcel_t,\n    mut c2: mcel_t,\n) -> libc::c_int {\n    let mut cmp: libc::c_int = mcel_cmp(c1, c2);\n    if (c1.err as libc::c_int - c2.err as libc::c_int | (cmp == 0) as libc::c_int)\n        as libc::c_long != 0\n    {\n        return cmp;\n    }\n    let mut ch1: libc::c_int = to.expect(\"non-null function pointer\")(c1.ch)\n        as libc::c_int;\n    let mut ch2: libc::c_int = to.expect(\"non-null function pointer\")(c2.ch)\n        as libc::c_int;\n    return ch1 - ch2;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/mcel.rs:8:1: 8:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/mcel.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1050 ~ rust[fc84]::src::xmalloc::xizalloc)",
    "span": "src/xmalloc.rs:982:1: 990:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:982:1: 990:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:759 ~ rust[fc84]::src::memcasecmp::memcasecmp)",
    "span": "src/memcasecmp.rs:8:1: 21:2 (#0)",
    "pieces": [
      "src/memcasecmp.rs:8:1: 21:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 29,
    "source": "pub unsafe extern \"C\" fn memcasecmp(\n    mut vs1: *const libc::c_void,\n    mut vs2: *const libc::c_void,\n    mut n: size_t,\n) -> libc::c_int {\n    let mut i: size_t = 0;\n    let mut s1: *const libc::c_char = vs1 as *const libc::c_char;\n    let mut s2: *const libc::c_char = vs2 as *const libc::c_char;\n    i = 0 as libc::c_int as size_t;\n    while i < n {\n        let mut u1: libc::c_uchar = *s1.offset(i as isize) as libc::c_uchar;\n        let mut u2: libc::c_uchar = *s2.offset(i as isize) as libc::c_uchar;\n        let mut U1: libc::c_int = toupper(u1 as libc::c_int);\n        let mut U2: libc::c_int = toupper(u2 as libc::c_int);\n        let mut diff: libc::c_int = if 127 as libc::c_int * 2 as libc::c_int\n            + 1 as libc::c_int <= 2147483647 as libc::c_int\n        {\n            U1 - U2\n        } else {\n            (U1 > U2) as libc::c_int - (U1 < U2) as libc::c_int\n        };\n        if diff != 0 {\n            return diff;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/memcasecmp.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:177 ~ rust[fc84]::src::fclose::rpl_fclose)",
    "span": "src/fclose.rs:53:1: 73:2 (#0)",
    "pieces": [
      "src/fclose.rs:53:1: 73:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fclose.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:887 ~ rust[fc84]::src::quotearg::quotearg_n)",
    "span": "src/quotearg.rs:1421:1: 1431:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1421:1: 1431:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:987 ~ rust[fc84]::src::quotearg::quotearg)",
        "span": "src/quotearg.rs:1450:9: 1450:42 (#0)",
        "source": "quotearg_n(0, c_string.as_ptr());"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:175:1: 181:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:889 ~ rust[fc84]::src::quotearg::quotearg)",
    "span": "src/quotearg.rs:1447:1: 1453:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1447:1: 1453:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1088 ~ rust[fc84]::src::xstrtoimax::bkm_scale)",
    "span": "src/xstrtoimax.rs:41:1: 87:2 (#0)",
    "pieces": [
      "src/xstrtoimax.rs:41:1: 87:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 348,
    "source": "unsafe extern \"C\" fn bkm_scale(\n    mut x: *mut intmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: intmax_t = 0;\n    if if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { *x })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as intmax_t\n                    }) + scale_factor as libc::c_long\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (*x < -(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + -(1 as libc::c_int) as intmax_t\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as intmax_t / -scale_factor as libc::c_long\n                    }) <= -(1 as libc::c_int) as libc::c_long - *x) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n                        as libc::c_long + 0 as libc::c_int as intmax_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        *x\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < *x + 0 as libc::c_int as intmax_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < *x\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < *x - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as intmax_t / scale_factor as libc::c_long) < *x)\n                        as libc::c_int\n                }\n            }\n        } else {\n            if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    *x\n                                }) + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < scale_factor as libc::c_long\n                                    + 0 as libc::c_int as intmax_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_long)\n                                as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as intmax_t / *x\n                            < scale_factor as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        < *x) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_long {\n            !if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n                -(1 as libc::c_int) as intmax_t\n            } else {\n                (((1 as libc::c_int as intmax_t)\n                    << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            }\n        } else if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n            -(1 as libc::c_int) as intmax_t\n        } else {\n            (((1 as libc::c_int as intmax_t)\n                << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}",
    "calls": [
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:217:17: 217:57 (#0)",
        "source": "let overflow = bkm_scale(&mut tmp, 512);"
      },
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:220:17: 220:58 (#0)",
        "source": "let overflow = bkm_scale(&mut tmp, 1024);"
      },
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:250:17: 250:55 (#0)",
        "source": "let overflow = bkm_scale(&mut tmp, 2);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoimax.rs:26:1: 26:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xstrtoimax.rs:27:1: 27:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoimax.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1010 ~ rust[fc84]::src::xalloc_die::xalloc_die)",
    "span": "src/xalloc_die.rs:16:1: 53:2 (#0)",
    "pieces": [
      "src/xalloc_die.rs:16:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "pub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalloc_die.rs:1:1: 1:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/xalloc_die.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:127 ~ rust[fc84]::src::closeout::close_stdout)",
    "span": "src/closeout.rs:90:1: 166:2 (#0)",
    "pieces": [
      "src/closeout.rs:90:1: 166:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 96,
    "source": "pub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:67:1: 67:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/closeout.rs:5:1: 5:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/closeout.rs:4:1: 4:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/closeout.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1040 ~ rust[fc84]::src::xmalloc::xrealloc)",
    "span": "src/xmalloc.rs:167:1: 178:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:167:1: 178:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:1193 ~ rust[fc84]::src::xmalloc::xpalloc)",
        "span": "src/xmalloc.rs:971:5: 971:61 (#0)",
        "source": "pa = xrealloc(pa as *mut libc::c_void, nbytes as usize);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:876 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
    "span": "src/quotearg.rs:1251:1: 1298:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1251:1: 1298:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}",
    "calls": [
      {
        "caller": "DefId(0:973 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
        "span": "src/quotearg.rs:1246:18: 1246:106 (#0)",
        "source": "unsafe { quotearg_alloc_mem(arg.as_ptr() as *const libc::c_char, argsize, size_ptr, o) }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:90:1: 90:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      },
      {
        "span": "src/quotearg.rs:175:1: 181:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:954 ~ rust[fc84]::src::skipchars::mcel_isbasic)",
    "span": "src/skipchars.rs:154:1: 156:2 (#0)",
    "pieces": [
      "src/skipchars.rs:154:1: 156:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn mcel_isbasic(mut c: libc::c_char) -> bool {\n    return (0 as libc::c_int <= c as libc::c_int\n        && (c as libc::c_int) < MCEL_ERR_MIN as libc::c_int) as libc::c_int\n        as libc::c_long != 0;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/skipchars.rs:42:1: 42:47 (#0)",
        "source": "pub const MCEL_ERR_MIN: C2RustUnnamed_2 = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/skipchars.rs:7:1: 7:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/skipchars.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/skipchars.rs:9:1: 9:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:195 ~ rust[fc84]::src::fflush::clear_ungetc_buffer_preserving_position)",
    "span": "src/fflush.rs:53:1: 57:2 (#0)",
    "pieces": [
      "src/fflush.rs:53:1: 57:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:228 ~ rust[fc84]::src::fflush::rpl_fflush)",
        "span": "src/fflush.rs:64:17: 64:60 (#0)",
        "source": "clear_ungetc_buffer_preserving_position(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/fflush.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fflush.rs:3:1: 3:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1033 ~ rust[fc84]::src::xmalloc::ireallocarray)",
    "span": "src/xmalloc.rs:95:1: 108:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:95:1: 108:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1188 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:210:5: 210:39 (#0)",
        "source": "let new_ptr = ireallocarray(n, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1042 ~ rust[fc84]::src::xmalloc::xreallocarray)",
    "span": "src/xmalloc.rs:196:1: 206:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:196:1: 206:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:1192 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
        "span": "src/xmalloc.rs:264:5: 264:32 (#0)",
        "source": "p = xreallocarray(p, n, s);"
      },
      {
        "caller": "DefId(0:1189 ~ rust[fc84]::src::xmalloc::xnmalloc)",
        "span": "src/xmalloc.rs:220:5: 220:56 (#0)",
        "source": "return xreallocarray(0 as *mut libc::c_void, n, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1044 ~ rust[fc84]::src::xmalloc::xnmalloc)",
    "span": "src/xmalloc.rs:219:1: 221:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:219:1: 221:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [
      {
        "caller": "DefId(0:1184 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:158:9: 158:57 (#0)",
        "source": "unsafe { xnmalloc(n.try_into().unwrap(), size) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1039 ~ rust[fc84]::src::xmalloc::xcharalloc)",
    "span": "src/xmalloc.rs:152:1: 164:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:152:1: 164:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1047 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
    "span": "src/xmalloc.rs:241:1: 267:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:241:1: 267:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:50:1: 50:47 (#0)",
        "source": "pub const DEFAULT_MXFAST: C2RustUnnamed = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:905 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
    "span": "src/quotearg.rs:1622:1: 1642:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1622:1: 1642:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1089 ~ rust[fc84]::src::xstrtoimax::bkm_scale_by_power)",
    "span": "src/xstrtoimax.rs:89:1: 100:2 (#0)",
    "pieces": [
      "src/xstrtoimax.rs:89:1: 100:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn bkm_scale_by_power(\n    mut x: *mut intmax_t,\n    mut base: libc::c_int,\n    mut power: libc::c_int,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    loop {\n        let fresh8 = power;\n        power = power - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);\n    }\n    return err;\n}",
    "calls": [
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:253:17: 253:66 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 8);"
      },
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:238:17: 238:66 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 5);"
      },
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:229:17: 229:66 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 3);"
      },
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:235:17: 235:66 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 2);"
      },
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:226:17: 226:66 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 6);"
      },
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:244:17: 244:66 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 9);"
      },
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:241:17: 241:67 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 10);"
      },
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:256:17: 256:66 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 7);"
      },
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:232:17: 232:66 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 1);"
      },
      {
        "caller": "DefId(0:1235 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:247:17: 247:66 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 4);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoimax.rs:27:1: 27:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoimax.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:867 ~ rust[fc84]::src::quotearg::set_quoting_style)",
    "span": "src/quotearg.rs:202:1: 211:2 (#0)",
    "pieces": [
      "src/quotearg.rs:202:1: 211:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:175:1: 181:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:988 ~ rust[fc84]::src::version_etc::version_etc_va)",
    "span": "src/version_etc.rs:267:1: 294:2 (#0)",
    "pieces": [
      "src/version_etc.rs:267:1: 294:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "pub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:1108 ~ rust[fc84]::src::version_etc::version_etc)",
        "span": "src/version_etc.rs:305:5: 305:82 (#0)",
        "source": "version_etc_va(stream, command_name, package, version, authors.as_va_list());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:991 ~ rust[fc84]::src::version_etc::version_etc)",
    "span": "src/version_etc.rs:296:1: 306:2 (#0)",
    "pieces": [
      "src/version_etc.rs:296:1: 306:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:874 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
    "span": "src/quotearg.rs:1215:1: 1237:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1215:1: 1237:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:175:1: 181:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:956 ~ rust[fc84]::src::skipchars::mcel_ch)",
    "span": "src/skipchars.rs:170:1: 180:2 (#0)",
    "pieces": [
      "src/skipchars.rs:170:1: 180:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn mcel_ch(mut ch: char32_t, mut len: size_t) -> mcel_t {\n    if (0 as libc::c_int as libc::c_ulong) < len {} else {\n        unreachable!();\n    };\n    if len <= MCEL_LEN_MAX as libc::c_int as libc::c_ulong {} else {\n        unreachable!();\n    };\n    if ch <= MCEL_CHAR_MAX as libc::c_int as libc::c_uint {} else {\n        unreachable!();\n    };\n    return {\n        let mut init = mcel_t {\n            ch: ch,\n            err: 0,\n            len: len as libc::c_uchar,\n        };\n        init\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1067 ~ rust[fc84]::src::skipchars::mcel_scan)",
        "span": "src/skipchars.rs:128:9: 128:42 (#0)",
        "source": "return mcel_ch(c as char32_t, 1);"
      },
      {
        "caller": "DefId(0:1066 ~ rust[fc84]::src::skipchars::mcel_scant)",
        "span": "src/skipchars.rs:107:9: 107:66 (#0)",
        "source": "return mcel_ch(p.chars().next().unwrap() as char32_t, 1);"
      },
      {
        "caller": "DefId(0:1067 ~ rust[fc84]::src::skipchars::mcel_scan)",
        "span": "src/skipchars.rs:150:5: 150:38 (#0)",
        "source": "return mcel_ch(ch, len as usize);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/skipchars.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/skipchars.rs:7:1: 7:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/skipchars.rs:9:1: 9:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:920 ~ rust[fc84]::src::setlocale_null::setlocale_null)",
    "span": "src/setlocale_null.rs:27:1: 36:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:27:1: 36:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/setlocale_null.rs:3:1: 3:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/setlocale_null.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:697 ~ rust[fc84]::src::localcharset::locale_charset)",
    "span": "src/localcharset.rs:393:1: 405:2 (#0)",
    "pieces": [
      "src/localcharset.rs:393:1: 405:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/localcharset.rs:7:1: 7:39 (#0)",
        "source": "pub const CODESET: C2RustUnnamed = 14;"
      }
    ],
    "imports": [
      {
        "span": "src/localcharset.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/localcharset.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:156 ~ rust[fc84]::src::fadvise::fdadvise)",
    "span": "src/fadvise.rs:64:1: 73:2 (#0)",
    "pieces": [
      "src/fadvise.rs:64:1: 73:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn fdadvise(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut len: off_t,\n    mut advice: fadvice_t,\n) {\n    posix_fadvise(fd, offset, len, advice as libc::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:183 ~ rust[fc84]::src::fadvise::fadvise)",
        "span": "src/fadvise.rs:78:5: 78:32 (#0)",
        "source": "fdadvise(fd, 0, 0, advice);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fadvise.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/fadvise.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:888 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
    "span": "src/quotearg.rs:1433:1: 1444:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1433:1: 1444:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:988 ~ rust[fc84]::src::quotearg::quotearg_mem)",
        "span": "src/quotearg.rs:1457:5: 1457:45 (#0)",
        "source": "let result_ptr = quotearg_n_mem(0, arg);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:175:1: 181:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:890 ~ rust[fc84]::src::quotearg::quotearg_mem)",
    "span": "src/quotearg.rs:1456:1: 1459:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1456:1: 1459:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:64 ~ rust[fc84]::src::c_ctype::c_iscntrl)",
    "span": "src/c_ctype.rs:62:1: 68:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:62:1: 68:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:196 ~ rust[fc84]::src::fflush::rpl_fflush)",
    "span": "src/fflush.rs:60:1: 71:2 (#0)",
    "pieces": [
      "src/fflush.rs:60:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fflush.rs:3:1: 3:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/fflush.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:276 ~ rust[fc84]::src::ialloc::ireallocarray)",
    "span": "src/ialloc.rs:28:1: 45:2 (#0)",
    "pieces": [
      "src/ialloc.rs:28:1: 45:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:1:1: 1:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:3:1: 3:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:5:5: 5:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/ialloc.rs:5:1: 5:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:16 (#0)",
        "source": "use std::alloc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:751 ~ rust[fc84]::src::mcel::mcel_ch)",
    "span": "src/mcel.rs:165:1: 175:2 (#0)",
    "pieces": [
      "src/mcel.rs:165:1: 175:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn mcel_ch(mut ch: char32_t, mut len: size_t) -> mcel_t {\n    if (0 as libc::c_int as libc::c_ulong) < len {} else {\n        unreachable!();\n    };\n    if len <= MCEL_LEN_MAX as libc::c_int as libc::c_ulong {} else {\n        unreachable!();\n    };\n    if ch <= MCEL_CHAR_MAX as libc::c_int as libc::c_uint {} else {\n        unreachable!();\n    };\n    return {\n        let mut init = mcel_t {\n            ch: ch,\n            err: 0,\n            len: len as libc::c_uchar,\n        };\n        init\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:817 ~ rust[fc84]::src::mcel::mcel_scan)",
        "span": "src/mcel.rs:90:9: 90:42 (#0)",
        "source": "return mcel_ch(c as char32_t, 1);"
      },
      {
        "caller": "DefId(0:816 ~ rust[fc84]::src::mcel::mcel_scant)",
        "span": "src/mcel.rs:68:9: 68:51 (#0)",
        "source": "return mcel_ch(first_char as char32_t, 1);"
      },
      {
        "caller": "DefId(0:817 ~ rust[fc84]::src::mcel::mcel_scan)",
        "span": "src/mcel.rs:113:5: 113:38 (#0)",
        "source": "return mcel_ch(ch, len as usize);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/mcel.rs:8:1: 8:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/mcel.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:746 ~ rust[fc84]::src::mcel::mcel_scan)",
    "span": "src/mcel.rs:87:1: 114:2 (#0)",
    "pieces": [
      "src/mcel.rs:87:1: 114:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn mcel_scan(\n    mut p: *const libc::c_char,\n    mut lim: *const libc::c_char,\n) -> mcel_t {\n    let mut c: libc::c_char = *p;\n    if mcel_isbasic(c) {\n        return mcel_ch(c as char32_t, 1 as libc::c_int as size_t);\n    }\n    let mut mbs: mbstate_t = mbstate_t {\n        __count: 0,\n        __value: C2RustUnnamed { __wch: 0 },\n    };\n    mbs.__count = 0 as libc::c_int;\n    let mut ch: char32_t = 0;\n    let mut len: size_t = mbrtoc32(\n        &mut ch,\n        p,\n        lim.offset_from(p) as libc::c_long as size_t,\n        &mut mbs,\n    );\n    if ((-(1 as libc::c_int) as size_t).wrapping_div(2 as libc::c_int as libc::c_ulong)\n        < len) as libc::c_int as libc::c_long != 0\n    {\n        return mcel_err(c as libc::c_uchar);\n    }\n    return mcel_ch(ch, len);\n}",
    "calls": [
      {
        "caller": "DefId(0:816 ~ rust[fc84]::src::mcel::mcel_scant)",
        "span": "src/mcel.rs:81:5: 81:35 (#0)",
        "source": "return mcel_scan(&p_str, lim);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/mcel.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/mcel.rs:8:1: 8:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:745 ~ rust[fc84]::src::mcel::mcel_scant)",
    "span": "src/mcel.rs:63:1: 82:2 (#0)",
    "pieces": [
      "src/mcel.rs:63:1: 82:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn mcel_scant(\n    mut p: *const libc::c_char,\n    mut terminator: libc::c_char,\n) -> mcel_t {\n    if mcel_isbasic(*p) {\n        return mcel_ch(*p as char32_t, 1 as libc::c_int as size_t);\n    }\n    let mut lim: *const libc::c_char = p.offset(1 as libc::c_int as isize);\n    let mut i: libc::c_int = 0 as libc::c_int;\n    while i < MCEL_LEN_MAX as libc::c_int - 1 as libc::c_int {\n        lim = lim\n            .offset(\n                (*lim as libc::c_int != terminator as libc::c_int) as libc::c_int\n                    as isize,\n            );\n        i += 1;\n        i;\n    }\n    return mcel_scan(p, lim);\n}",
    "calls": [
      {
        "caller": "DefId(0:815 ~ rust[fc84]::src::mcel::mcel_scanz)",
        "span": "src/mcel.rs:55:38: 58:2 (#0)",
        "source": "{\n    let c_str = std::ffi::CString::new(p).unwrap();\n    mcel_scant(c_str.as_ptr(), '\\0' as libc::c_char)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/mcel.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/mcel.rs:8:1: 8:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:899 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
    "span": "src/quotearg.rs:1536:1: 1544:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1536:1: 1544:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1051 ~ rust[fc84]::src::xmalloc::xcalloc)",
    "span": "src/xmalloc.rs:993:1: 998:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:993:1: 998:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1049 ~ rust[fc84]::src::xmalloc::xzalloc)",
    "span": "src/xmalloc.rs:976:1: 979:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:976:1: 979:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:744 ~ rust[fc84]::src::mcel::mcel_scanz)",
    "span": "src/mcel.rs:55:1: 58:2 (#0)",
    "pieces": [
      "src/mcel.rs:55:1: 58:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn mcel_scanz(mut p: *const libc::c_char) -> mcel_t {\n    return mcel_scant(p, '\\0' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/mcel.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/mcel.rs:8:1: 8:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1056 ~ rust[fc84]::src::xmalloc::xstrdup)",
    "span": "src/xmalloc.rs:1032:1: 1034:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1032:1: 1034:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:884 ~ rust[fc84]::src::quotearg::quotearg_free)",
    "span": "src/quotearg.rs:1314:1: 1339:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1314:1: 1339:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:1310:1: 1312:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1299:1: 1299:50 (#0)",
        "source": "static mut slot0: [libc::c_char; 256] = [0; 256];"
      },
      {
        "span": "src/quotearg.rs:1300:1: 1300:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      },
      {
        "span": "src/quotearg.rs:1301:1: 1309:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:723 ~ rust[fc84]::src::mbszero::mbszero)",
    "span": "src/mbszero.rs:27:1: 32:2 (#0)",
    "pieces": [
      "src/mbszero.rs:27:1: 32:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/mbszero.rs:1:1: 1:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/mbszero.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1035 ~ rust[fc84]::src::xmalloc::imalloc)",
    "span": "src/xmalloc.rs:120:1: 132:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:120:1: 132:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1183 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:147:5: 147:26 (#0)",
        "source": "let ptr = imalloc(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1038 ~ rust[fc84]::src::xmalloc::ximalloc)",
    "span": "src/xmalloc.rs:146:1: 149:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:146:1: 149:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1054 ~ rust[fc84]::src::xmalloc::ximemdup)",
    "span": "src/xmalloc.rs:1016:1: 1020:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1016:1: 1020:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:955 ~ rust[fc84]::src::skipchars::mcel_err)",
    "span": "src/skipchars.rs:159:1: 167:2 (#0)",
    "pieces": [
      "src/skipchars.rs:159:1: 167:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn mcel_err(mut err: libc::c_uchar) -> mcel_t {\n    if MCEL_ERR_MIN as libc::c_int <= err as libc::c_int {} else {\n        unreachable!();\n    };\n    return {\n        let mut init = mcel_t {\n            ch: 0,\n            err: err,\n            len: 1 as libc::c_int as libc::c_uchar,\n        };\n        init\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1067 ~ rust[fc84]::src::skipchars::mcel_scan)",
        "span": "src/skipchars.rs:147:9: 147:45 (#0)",
        "source": "return mcel_err(c as libc::c_uchar);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/skipchars.rs:9:1: 9:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/skipchars.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/skipchars.rs:7:1: 7:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:953 ~ rust[fc84]::src::skipchars::mcel_scan)",
    "span": "src/skipchars.rs:125:1: 151:2 (#0)",
    "pieces": [
      "src/skipchars.rs:125:1: 151:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "unsafe extern \"C\" fn mcel_scan(\n    mut p: *const libc::c_char,\n    mut lim: *const libc::c_char,\n) -> mcel_t {\n    let mut c: libc::c_char = *p;\n    if mcel_isbasic(c) {\n        return mcel_ch(c as char32_t, 1 as libc::c_int as size_t);\n    }\n    let mut mbs: mbstate_t = mbstate_t {\n        __count: 0,\n        __value: C2RustUnnamed { __wch: 0 },\n    };\n    mbs.__count = 0 as libc::c_int;\n    let mut ch: char32_t = 0;\n    let mut len: size_t = mbrtoc32(\n        &mut ch,\n        p,\n        lim.offset_from(p) as libc::c_long as size_t,\n        &mut mbs,\n    );\n    if ((-(1 as libc::c_int) as size_t).wrapping_div(2 as libc::c_int as libc::c_ulong)\n        < len) as libc::c_int as libc::c_long != 0\n    {\n        return mcel_err(c as libc::c_uchar);\n    }\n    return mcel_ch(ch, len);\n}",
    "calls": [
      {
        "caller": "DefId(0:1066 ~ rust[fc84]::src::skipchars::mcel_scant)",
        "span": "src/skipchars.rs:121:5: 121:94 (#0)",
        "source": "return mcel_scan(p.as_ptr() as *const libc::c_char, lim.as_ptr() as *const libc::c_char);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/skipchars.rs:9:1: 9:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/skipchars.rs:7:1: 7:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/skipchars.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:304 ~ rust[fc84]::src::linebuffer::readlinebuffer_delim)",
    "span": "src/linebuffer.rs:88:1: 135:2 (#0)",
    "pieces": [
      "src/linebuffer.rs:88:1: 135:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "pub unsafe extern \"C\" fn readlinebuffer_delim(\n    mut linebuffer: *mut linebuffer,\n    mut stream: *mut FILE,\n    mut delimiter: libc::c_char,\n) -> *mut linebuffer {\n    let mut c: libc::c_int = 0;\n    let mut buffer: *mut libc::c_char = (*linebuffer).buffer;\n    let mut p: *mut libc::c_char = (*linebuffer).buffer;\n    let mut end: *mut libc::c_char = buffer.offset((*linebuffer).size as isize);\n    if feof_unlocked(stream) != 0 {\n        return 0 as *mut linebuffer;\n    }\n    loop {\n        c = getc_unlocked(stream);\n        if c == -(1 as libc::c_int) {\n            if p == buffer || ferror_unlocked(stream) != 0 {\n                return 0 as *mut linebuffer;\n            }\n            if *p.offset(-(1 as libc::c_int) as isize) as libc::c_int\n                == delimiter as libc::c_int\n            {\n                break;\n            }\n            c = delimiter as libc::c_int;\n        }\n        if p == end {\n            let mut oldsize: idx_t = (*linebuffer).size;\n            buffer = xpalloc(\n                buffer as *mut libc::c_void,\n                &mut (*linebuffer).size,\n                1 as libc::c_int as idx_t,\n                -(1 as libc::c_int) as ptrdiff_t,\n                1 as libc::c_int as idx_t,\n            ) as *mut libc::c_char;\n            p = buffer.offset(oldsize as isize);\n            (*linebuffer).buffer = buffer;\n            end = buffer.offset((*linebuffer).size as isize);\n        }\n        let fresh0 = p;\n        p = p.offset(1);\n        *fresh0 = c as libc::c_char;\n        if !(c != delimiter as libc::c_int) {\n            break;\n        }\n    }\n    (*linebuffer).length = p.offset_from(buffer) as libc::c_long;\n    return linebuffer;\n}",
    "calls": [
      {
        "caller": "DefId(0:365 ~ rust[fc84]::src::linebuffer::readlinebuffer)",
        "span": "src/linebuffer.rs:85:5: 85:82 (#0)",
        "source": "return readlinebuffer_delim(linebuffer, stream, '\\n' as i32 as libc::c_char);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/linebuffer.rs:1:1: 1:20 (#0)",
        "source": "use std::mem::drop;"
      },
      {
        "span": "src/linebuffer.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:303 ~ rust[fc84]::src::linebuffer::readlinebuffer)",
    "span": "src/linebuffer.rs:81:1: 86:2 (#0)",
    "pieces": [
      "src/linebuffer.rs:81:1: 86:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn readlinebuffer(\n    mut linebuffer: *mut linebuffer,\n    mut stream: *mut FILE,\n) -> *mut linebuffer {\n    return readlinebuffer_delim(linebuffer, stream, '\\n' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/linebuffer.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/linebuffer.rs:1:1: 1:20 (#0)",
        "source": "use std::mem::drop;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:875 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
    "span": "src/quotearg.rs:1240:1: 1248:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1240:1: 1248:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:231 ~ rust[fc84]::src::freopen_safer::protect_fd)",
    "span": "src/freopen_safer.rs:58:1: 76:2 (#0)",
    "pieces": [
      "src/freopen_safer.rs:58:1: 76:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "unsafe extern \"C\" fn protect_fd(mut fd: libc::c_int) -> bool {\n    let mut value: libc::c_int = open(\n        b\"/dev/null\\0\" as *const u8 as *const libc::c_char,\n        0 as libc::c_int,\n    );\n    if value != fd {\n        if 0 as libc::c_int <= value {\n            close(value);\n            *__errno_location() = 9 as libc::c_int;\n        }\n        return 0 as libc::c_int != 0;\n    }\n    return 1 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/freopen_safer.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/freopen_safer.rs:1:1: 1:26 (#0)",
        "source": "use std::fs::OpenOptions;"
      },
      {
        "span": "src/freopen_safer.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:798 ~ rust[fc84]::src::propername_lite::proper_name_lite)",
    "span": "src/propername_lite.rs:8:1: 24:2 (#0)",
    "pieces": [
      "src/propername_lite.rs:8:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "pub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/propername_lite.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:747 ~ rust[fc84]::src::mcel::mcel_isbasic)",
    "span": "src/mcel.rs:119:1: 121:2 (#0)",
    "pieces": [
      "src/mcel.rs:119:1: 121:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn mcel_isbasic(mut c: libc::c_char) -> bool {\n    return (0 as libc::c_int <= c as libc::c_int\n        && (c as libc::c_int) < MCEL_ERR_MIN as libc::c_int) as libc::c_int\n        as libc::c_long != 0;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/mcel.rs:42:1: 42:47 (#0)",
        "source": "pub const MCEL_ERR_MIN: C2RustUnnamed_2 = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/mcel.rs:8:1: 8:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/mcel.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:124 ~ rust[fc84]::src::closeout::close_stdout_set_file_name)",
    "span": "src/closeout.rs:69:1: 79:2 (#0)",
    "pieces": [
      "src/closeout.rs:69:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/closeout.rs:4:1: 4:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/closeout.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/closeout.rs:5:1: 5:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:858 ~ rust[fc84]::src::quotearg::mbszero)",
    "span": "src/quotearg.rs:141:1: 147:2 (#0)",
    "pieces": [
      "src/quotearg.rs:141:1: 147:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1043 ~ rust[fc84]::src::xmalloc::xireallocarray)",
    "span": "src/xmalloc.rs:208:1: 216:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:208:1: 216:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:66 ~ rust[fc84]::src::c_ctype::c_isgraph)",
    "span": "src/c_ctype.rs:80:1: 85:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:80:1: 85:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:46 ~ rust[fc84]::src::argmatch::__argmatch_die)",
    "span": "src/argmatch.rs:96:1: 100:2 (#0)",
    "pieces": [
      "src/argmatch.rs:96:1: 100:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn __argmatch_die() {\n    usage(1 as libc::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/argmatch.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/argmatch.rs:5:1: 5:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/argmatch.rs:3:1: 3:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:930 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:18:1: 23:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:18:1: 23:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:1038 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
        "span": "src/setlocale_null_unlocked.rs:31:9: 31:52 (#0)",
        "source": "result = setlocale_null_unlocked(category);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:68 ~ rust[fc84]::src::c_ctype::c_isprint)",
    "span": "src/c_ctype.rs:100:1: 111:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:100:1: 111:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:157 ~ rust[fc84]::src::fadvise::fadvise)",
    "span": "src/fadvise.rs:76:1: 79:2 (#0)",
    "pieces": [
      "src/fadvise.rs:76:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn fadvise(mut fp: *mut FILE, mut advice: fadvice_t) {\n    if !fp.is_null() {\n        fdadvise(\n            fileno(fp),\n            0 as libc::c_int as off_t,\n            0 as libc::c_int as off_t,\n            advice,\n        );\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fadvise.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/fadvise.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1031 ~ rust[fc84]::src::xmalloc::irealloc)",
    "span": "src/xmalloc.rs:55:1: 67:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:55:1: 67:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1041 ~ rust[fc84]::src::xmalloc::xirealloc)",
    "span": "src/xmalloc.rs:181:1: 193:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:181:1: 193:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:279 ~ rust[fc84]::src::ialloc::imalloc)",
    "span": "src/ialloc.rs:84:1: 96:2 (#0)",
    "pieces": [
      "src/ialloc.rs:84:1: 96:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:5:5: 5:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:5:1: 5:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/ialloc.rs:3:1: 3:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:1:1: 1:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1045 ~ rust[fc84]::src::xmalloc::xinmalloc)",
    "span": "src/xmalloc.rs:223:1: 227:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:223:1: 227:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:278 ~ rust[fc84]::src::ialloc::irealloc)",
    "span": "src/ialloc.rs:71:1: 79:2 (#0)",
    "pieces": [
      "src/ialloc.rs:71:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:8:1: 8:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:3:1: 3:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:5:1: 5:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/ialloc.rs:5:5: 5:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/ialloc.rs:1:1: 1:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:16 (#0)",
        "source": "use std::alloc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1090 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
    "span": "src/xstrtoimax.rs:103:1: 282:2 (#0)",
    "pieces": [
      "src/xstrtoimax.rs:103:1: 282:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 180,
    "source": "pub unsafe extern \"C\" fn xstrtoimax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut intmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: intmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 78],\n                &[libc::c_char; 78],\n            >(\n                b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2247: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 78],\n                    &[libc::c_char; 78],\n                >(\n                    b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoimax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as intmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if **p as libc::c_int != '\\0' as i32 {\n        let mut base: libc::c_int = 1024 as libc::c_int;\n        let mut suffixes: libc::c_int = 1 as libc::c_int;\n        let mut overflow: strtol_error = LONGINT_OK;\n        if (strchr(valid_suffixes, **p as libc::c_int)).is_null() {\n            *val = tmp;\n            return (err as libc::c_uint\n                | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                as strtol_error;\n        }\n        match **p as libc::c_int {\n            69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n                if !(strchr(valid_suffixes, '0' as i32)).is_null() {\n                    match *(*p.offset(0 as libc::c_int as isize))\n                        .offset(1 as libc::c_int as isize) as libc::c_int\n                    {\n                        105 => {\n                            if *(*p.offset(0 as libc::c_int as isize))\n                                .offset(2 as libc::c_int as isize) as libc::c_int\n                                == 'B' as i32\n                            {\n                                suffixes += 2 as libc::c_int;\n                            }\n                        }\n                        66 | 68 => {\n                            base = 1000 as libc::c_int;\n                            suffixes += 1;\n                            suffixes;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n            _ => {}\n        }\n        match **p as libc::c_int {\n            98 => {\n                overflow = bkm_scale(&mut tmp, 512 as libc::c_int);\n            }\n            66 => {\n                overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);\n            }\n            99 => {\n                overflow = LONGINT_OK;\n            }\n            69 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);\n            }\n            71 | 103 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);\n            }\n            107 | 75 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);\n            }\n            77 | 109 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);\n            }\n            80 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);\n            }\n            81 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);\n            }\n            82 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);\n            }\n            84 | 116 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);\n            }\n            119 => {\n                overflow = bkm_scale(&mut tmp, 2 as libc::c_int);\n            }\n            89 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);\n            }\n            90 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);\n            }\n            _ => {\n                *val = tmp;\n                return (err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                    as strtol_error;\n            }\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | overflow as libc::c_uint);\n        *p = (*p).offset(suffixes as isize);\n        if **p != 0 {\n            err = ::core::mem::transmute::<\n                libc::c_uint,\n                strtol_error,\n            >(\n                err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint,\n            );\n        }\n    }\n    *val = tmp;\n    return err;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/xstrtoimax.rs:26:1: 26:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xstrtoimax.rs:23:1: 23:45 (#0)",
        "source": "pub const LONGINT_INVALID: strtol_error = 4;"
      },
      {
        "span": "src/xstrtoimax.rs:25:1: 25:57 (#0)",
        "source": "pub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;"
      },
      {
        "span": "src/xstrtoimax.rs:27:1: 27:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoimax.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:62 ~ rust[fc84]::src::c_ctype::c_isascii)",
    "span": "src/c_ctype.rs:37:1: 50:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:37:1: 50:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:866 ~ rust[fc84]::src::quotearg::get_quoting_style)",
    "span": "src/quotearg.rs:193:1: 199:2 (#0)",
    "pieces": [
      "src/quotearg.rs:193:1: 199:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:175:1: 181:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:893 ~ rust[fc84]::src::quotearg::quotearg_style)",
    "span": "src/quotearg.rs:1484:1: 1488:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1484:1: 1488:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:63 ~ rust[fc84]::src::c_ctype::c_isblank)",
    "span": "src/c_ctype.rs:55:1: 57:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:55:1: 57:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:952 ~ rust[fc84]::src::skipchars::mcel_scant)",
    "span": "src/skipchars.rs:105:1: 122:2 (#0)",
    "pieces": [
      "src/skipchars.rs:105:1: 122:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "unsafe extern \"C\" fn mcel_scant(\n    mut p: *const libc::c_char,\n    mut terminator: libc::c_char,\n) -> mcel_t {\n    if mcel_isbasic(*p) {\n        return mcel_ch(*p as char32_t, 1 as libc::c_int as size_t);\n    }\n    let mut lim: *const libc::c_char = p.offset(1 as libc::c_int as isize);\n    let mut i: libc::c_int = 0 as libc::c_int;\n    while i < MCEL_LEN_MAX as libc::c_int - 1 as libc::c_int {\n        lim = lim\n            .offset(\n                (*lim as libc::c_int != terminator as libc::c_int) as libc::c_int\n                    as isize,\n            );\n        i += 1;\n        i;\n    }\n    return mcel_scan(p, lim);\n}",
    "calls": [
      {
        "caller": "DefId(0:1065 ~ rust[fc84]::src::skipchars::mcel_scanz)",
        "span": "src/skipchars.rs:98:49: 102:2 (#0)",
        "source": "{\n    let c_str = unsafe { CStr::from_ptr(p) };\n    let str_slice = c_str.to_str().unwrap(); // Handle potential errors as needed\n    mcel_scant(str_slice, '\\0')\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/skipchars.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/skipchars.rs:9:1: 9:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/skipchars.rs:7:1: 7:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:67 ~ rust[fc84]::src::c_ctype::c_islower)",
    "span": "src/c_ctype.rs:90:1: 95:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:90:1: 95:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:211 ~ rust[fc84]::src::fpurge::fpurge)",
    "span": "src/fpurge.rs:47:1: 50:2 (#0)",
    "pieces": [
      "src/fpurge.rs:47:1: 50:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn fpurge(mut fp: *mut FILE) -> libc::c_int {\n    __fpurge(fp);\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fpurge.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:908 ~ rust[fc84]::src::quotearg::quote_mem)",
    "span": "src/quotearg.rs:1664:1: 1674:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1664:1: 1674:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:73 ~ rust[fc84]::src::c_ctype::c_tolower)",
    "span": "src/c_ctype.rs:152:1: 157:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:152:1: 157:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:992 ~ rust[fc84]::src::version_etc::emit_bug_reporting_address)",
    "span": "src/version_etc.rs:308:1: 321:2 (#0)",
    "pieces": [
      "src/version_etc.rs:308:1: 321:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:69 ~ rust[fc84]::src::c_ctype::c_ispunct)",
    "span": "src/c_ctype.rs:116:1: 123:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:116:1: 123:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:767 ~ rust[fc84]::src::posixver::posix2_version)",
    "span": "src/posixver.rs:13:1: 27:2 (#0)",
    "pieces": [
      "src/posixver.rs:13:1: 27:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn posix2_version() -> libc::c_int {\n    let mut v: libc::c_long = 200809 as libc::c_long;\n    let mut s: *const libc::c_char = getenv(\n        b\"_POSIX2_VERSION\\0\" as *const u8 as *const libc::c_char,\n    );\n    if !s.is_null() && *s as libc::c_int != 0 {\n        let mut e: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut i: libc::c_long = strtol(s, &mut e, 10 as libc::c_int);\n        if *e == 0 {\n            v = i;\n        }\n    }\n    return (if v < (-(2147483647 as libc::c_int) - 1 as libc::c_int) as libc::c_long {\n        (-(2147483647 as libc::c_int) - 1 as libc::c_int) as libc::c_long\n    } else if v < 2147483647 as libc::c_int as libc::c_long {\n        v\n    } else {\n        2147483647 as libc::c_int as libc::c_long\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/posixver.rs:1:1: 1:14 (#0)",
        "source": "use std::env;"
      },
      {
        "span": "src/posixver.rs:1:5: 1:13 (#0)",
        "source": "std::env"
      },
      {
        "span": "src/posixver.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:949 ~ rust[fc84]::src::skipchars::skip_buf_matching)",
    "span": "src/skipchars.rs:53:1: 71:2 (#0)",
    "pieces": [
      "src/skipchars.rs:53:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn skip_buf_matching(\n    mut buf: *const libc::c_char,\n    mut lim: *const libc::c_char,\n    mut predicate: Option::<unsafe extern \"C\" fn(mcel_t) -> bool>,\n    mut ok: bool,\n) -> *mut libc::c_char {\n    let mut s: *const libc::c_char = buf;\n    let mut g: mcel_t = mcel_t { ch: 0, err: 0, len: 0 };\n    while s < lim\n        && {\n            g = mcel_scan(s, lim);\n            predicate.expect(\"non-null function pointer\")(g) as libc::c_int\n                == ok as libc::c_int\n        }\n    {\n        s = s.offset(g.len as libc::c_int as isize);\n    }\n    return s as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/skipchars.rs:9:1: 9:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/skipchars.rs:7:1: 7:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/skipchars.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:931 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:25:1: 54:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:25:1: 54:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1055 ~ rust[fc84]::src::xmalloc::ximemdup0)",
    "span": "src/xmalloc.rs:1023:1: 1029:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1023:1: 1029:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1046 ~ rust[fc84]::src::xmalloc::x2realloc)",
    "span": "src/xmalloc.rs:230:1: 238:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:230:1: 238:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:865 ~ rust[fc84]::src::quotearg::clone_quoting_options)",
    "span": "src/quotearg.rs:183:1: 190:2 (#0)",
    "pieces": [
      "src/quotearg.rs:183:1: 190:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:175:1: 181:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:951 ~ rust[fc84]::src::skipchars::mcel_scanz)",
    "span": "src/skipchars.rs:98:1: 102:2 (#0)",
    "pieces": [
      "src/skipchars.rs:98:1: 102:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn mcel_scanz(mut p: *const libc::c_char) -> mcel_t {\n    return mcel_scant(p, '\\0' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/skipchars.rs:9:1: 9:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/skipchars.rs:7:1: 7:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/skipchars.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:232 ~ rust[fc84]::src::freopen_safer::freopen_safer)",
    "span": "src/freopen_safer.rs:79:1: 146:2 (#0)",
    "pieces": [
      "src/freopen_safer.rs:79:1: 146:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 68,
    "source": "pub unsafe extern \"C\" fn freopen_safer(\n    mut name: *const libc::c_char,\n    mut mode: *const libc::c_char,\n    mut f: *mut FILE,\n) -> *mut FILE {\n    let mut protect_in: bool = 0 as libc::c_int != 0;\n    let mut protect_out: bool = 0 as libc::c_int != 0;\n    let mut protect_err: bool = 0 as libc::c_int != 0;\n    let mut saved_errno: libc::c_int = 0;\n    let mut current_block_8: u64;\n    match fileno(f) {\n        2 => {\n            current_block_8 = 8409498848974359248;\n        }\n        1 => {\n            current_block_8 = 878006807312935268;\n        }\n        0 => {\n            current_block_8 = 2868539653012386629;\n        }\n        _ => {\n            if dup2(2 as libc::c_int, 2 as libc::c_int) != 2 as libc::c_int {\n                protect_err = 1 as libc::c_int != 0;\n            }\n            current_block_8 = 8409498848974359248;\n        }\n    }\n    match current_block_8 {\n        8409498848974359248 => {\n            if dup2(1 as libc::c_int, 1 as libc::c_int) != 1 as libc::c_int {\n                protect_out = 1 as libc::c_int != 0;\n            }\n            current_block_8 = 878006807312935268;\n        }\n        _ => {}\n    }\n    match current_block_8 {\n        878006807312935268 => {\n            if dup2(0 as libc::c_int, 0 as libc::c_int) != 0 as libc::c_int {\n                protect_in = 1 as libc::c_int != 0;\n            }\n        }\n        _ => {}\n    }\n    if protect_in as libc::c_int != 0 && !protect_fd(0 as libc::c_int) {\n        f = 0 as *mut FILE;\n    } else if protect_out as libc::c_int != 0 && !protect_fd(1 as libc::c_int) {\n        f = 0 as *mut FILE;\n    } else if protect_err as libc::c_int != 0 && !protect_fd(2 as libc::c_int) {\n        f = 0 as *mut FILE;\n    } else {\n        f = freopen(name, mode, f);\n    }\n    saved_errno = *__errno_location();\n    if protect_err {\n        close(2 as libc::c_int);\n    }\n    if protect_out {\n        close(1 as libc::c_int);\n    }\n    if protect_in {\n        close(0 as libc::c_int);\n    }\n    if f.is_null() {\n        *__errno_location() = saved_errno;\n    }\n    return f;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/freopen_safer.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/freopen_safer.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/freopen_safer.rs:1:1: 1:26 (#0)",
        "source": "use std::fs::OpenOptions;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:869 ~ rust[fc84]::src::quotearg::set_quoting_flags)",
    "span": "src/quotearg.rs:235:1: 247:2 (#0)",
    "pieces": [
      "src/quotearg.rs:235:1: 247:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:175:1: 181:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:19:1: 19:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/quotearg.rs:21:5: 21:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:302 ~ rust[fc84]::src::linebuffer::initbuffer)",
    "span": "src/linebuffer.rs:73:1: 79:2 (#0)",
    "pieces": [
      "src/linebuffer.rs:73:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn initbuffer(mut linebuffer: *mut linebuffer) {\n    memset(\n        linebuffer as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<linebuffer>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/linebuffer.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/linebuffer.rs:1:1: 1:20 (#0)",
        "source": "use std::mem::drop;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:950 ~ rust[fc84]::src::skipchars::skip_str_matching)",
    "span": "src/skipchars.rs:76:1: 95:2 (#0)",
    "pieces": [
      "src/skipchars.rs:76:1: 95:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn skip_str_matching(\n    mut str: *const libc::c_char,\n    mut predicate: Option::<unsafe extern \"C\" fn(mcel_t) -> bool>,\n    mut ok: bool,\n) -> *mut libc::c_char {\n    let mut s: *const libc::c_char = str;\n    let mut g: mcel_t = mcel_t { ch: 0, err: 0, len: 0 };\n    while *s as libc::c_int != 0\n        && {\n            g = mcel_scanz(s);\n            predicate.expect(\"non-null function pointer\")(g) as libc::c_int\n                == ok as libc::c_int\n        }\n    {\n        s = s.offset(g.len as libc::c_int as isize);\n    }\n    return s as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/skipchars.rs:9:1: 9:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/skipchars.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/skipchars.rs:7:1: 7:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1048 ~ rust[fc84]::src::xmalloc::xpalloc)",
    "span": "src/xmalloc.rs:269:1: 974:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:269:1: 974:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 706,
    "source": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:52:1: 52:51 (#0)",
        "source": "pub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:24: 16:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:28 (#0)",
        "source": "use std::num::NonZeroUsize;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:22 (#0)",
        "source": "use std::ffi::c_void;"
      },
      {
        "span": "src/xmalloc.rs:28:1: 28:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:18: 16:22 (#0)",
        "source": "self"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:60 ~ rust[fc84]::src::c_ctype::c_isalnum)",
    "span": "src/c_ctype.rs:20:1: 25:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:20:1: 25:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:70 ~ rust[fc84]::src::c_ctype::c_isspace)",
    "span": "src/c_ctype.rs:128:1: 133:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:128:1: 133:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:131 ~ uniq[1a58]::mcel_err)",
    "span": "src/uniq.rs:416:1: 424:2 (#0)",
    "pieces": [
      "src/uniq.rs:416:1: 424:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn mcel_err(mut err: libc::c_uchar) -> mcel_t {\n    if MCEL_ERR_MIN as libc::c_int <= err as libc::c_int {} else {\n        unreachable!();\n    };\n    return {\n        let mut init = mcel_t {\n            ch: 0,\n            err: err,\n            len: 1 as libc::c_int as libc::c_uchar,\n        };\n        init\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:144 ~ uniq[1a58]::mcel_scan)",
        "span": "src/uniq.rs:454:9: 454:45 (#0)",
        "source": "return mcel_err(c as libc::c_uchar);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:130 ~ uniq[1a58]::mcel_ch)",
    "span": "src/uniq.rs:403:1: 413:2 (#0)",
    "pieces": [
      "src/uniq.rs:403:1: 413:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn mcel_ch(mut ch: char32_t, mut len: size_t) -> mcel_t {\n    if (0 as libc::c_int as libc::c_ulong) < len {} else {\n        unreachable!();\n    };\n    if len <= MCEL_LEN_MAX as libc::c_int as libc::c_ulong {} else {\n        unreachable!();\n    };\n    if ch <= MCEL_CHAR_MAX as libc::c_int as libc::c_uint {} else {\n        unreachable!();\n    };\n    return {\n        let mut init = mcel_t {\n            ch: ch,\n            err: 0,\n            len: len as libc::c_uchar,\n        };\n        init\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:144 ~ uniq[1a58]::mcel_scan)",
        "span": "src/uniq.rs:435:9: 435:42 (#0)",
        "source": "return mcel_ch(c as char32_t, 1);"
      },
      {
        "caller": "DefId(0:144 ~ uniq[1a58]::mcel_scan)",
        "span": "src/uniq.rs:457:5: 457:29 (#0)",
        "source": "return mcel_ch(ch, len);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:133 ~ uniq[1a58]::mcel_scan)",
    "span": "src/uniq.rs:432:1: 458:2 (#0)",
    "pieces": [
      "src/uniq.rs:432:1: 458:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "unsafe extern \"C\" fn mcel_scan(\n    mut p: *const libc::c_char,\n    mut lim: *const libc::c_char,\n) -> mcel_t {\n    let mut c: libc::c_char = *p;\n    if mcel_isbasic(c) {\n        return mcel_ch(c as char32_t, 1 as libc::c_int as size_t);\n    }\n    let mut mbs: mbstate_t = mbstate_t {\n        __count: 0,\n        __value: C2RustUnnamed { __wch: 0 },\n    };\n    mbs.__count = 0 as libc::c_int;\n    let mut ch: char32_t = 0;\n    let mut len: size_t = mbrtoc32(\n        &mut ch,\n        p,\n        lim.offset_from(p) as libc::c_long as size_t,\n        &mut mbs,\n    );\n    if ((-(1 as libc::c_int) as size_t).wrapping_div(2 as libc::c_int as libc::c_ulong)\n        < len) as libc::c_int as libc::c_long != 0\n    {\n        return mcel_err(c as libc::c_uchar);\n    }\n    return mcel_ch(ch, len);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:129 ~ uniq[1a58]::c32isblank)",
    "span": "src/uniq.rs:398:1: 400:2 (#0)",
    "pieces": [
      "src/uniq.rs:398:1: 400:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn c32isblank(mut wc: wint_t) -> libc::c_int {\n    return iswblank(wc);\n}",
    "calls": [
      {
        "caller": "DefId(0:170 ~ uniq[1a58]::newline_or_blank)",
        "span": "src/uniq.rs:784:5: 784:91 (#0)",
        "source": "return g.ch == '\\n' as i32 as u32 || c32isblank(char::from_u32(g.ch).unwrap_or('\\0'));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:135 ~ uniq[1a58]::swap_lines)",
    "span": "src/uniq.rs:480:1: 485:2 (#0)",
    "pieces": [
      "src/uniq.rs:480:1: 485:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn swap_lines(\n    mut a: *mut *mut linebuffer,\n    mut b: *mut *mut linebuffer,\n) {\n    let mut tmp: *mut linebuffer = *a;\n    *a = *b;\n    *b = tmp;\n}",
    "calls": [
      {
        "caller": "DefId(0:174 ~ uniq[1a58]::check_file)",
        "span": "src/uniq.rs:1171:21: 1171:62 (#0)",
        "source": "swap_lines(&mut prevline, &mut thisline);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:128 ~ uniq[1a58]::write_error)",
    "span": "src/uniq.rs:352:1: 395:2 (#0)",
    "pieces": [
      "src/uniq.rs:352:1: 395:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "unsafe extern \"C\" fn write_error() {\n    let mut saved_errno: libc::c_int = *__errno_location();\n    fflush_unlocked(stdout);\n    fpurge(stdout);\n    clearerr_unlocked(stdout);\n    if 0 != 0 {\n        error(\n            1 as libc::c_int,\n            saved_errno,\n            gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n        );\n        if 1 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:173 ~ uniq[1a58]::writeline)",
        "span": "src/uniq.rs:885:9: 885:23 (#0)",
        "source": "write_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:162 ~ uniq[1a58]::writeline)",
    "span": "src/uniq.rs:857:1: 887:2 (#0)",
    "pieces": [
      "src/uniq.rs:857:1: 887:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 31,
    "source": "unsafe extern \"C\" fn writeline(\n    mut line: *const linebuffer,\n    mut match_0: bool,\n    mut linecount: intmax_t,\n) {\n    if if linecount == 0 as libc::c_int as libc::c_long {\n        output_unique as libc::c_int\n    } else if !match_0 {\n        output_first_repeated as libc::c_int\n    } else {\n        output_later_repeated as libc::c_int\n    } == 0\n    {\n        return;\n    }\n    if count_occurrences {\n        printf(\n            b\"%7jd \\0\" as *const u8 as *const libc::c_char,\n            linecount + 1 as libc::c_int as libc::c_long,\n        );\n    }\n    if fwrite_unlocked(\n        (*line).buffer as *const libc::c_void,\n        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,\n        (*line).length as size_t,\n        stdout,\n    ) != (*line).length as libc::c_ulong\n    {\n        write_error();\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:174 ~ uniq[1a58]::check_file)",
        "span": "src/uniq.rs:1183:17: 1183:73 (#0)",
        "source": "writeline(prevline, 0 as libc::c_int != 0, match_count);"
      },
      {
        "caller": "DefId(0:174 ~ uniq[1a58]::check_file)",
        "span": "src/uniq.rs:1170:21: 1170:63 (#0)",
        "source": "writeline(prevline, match_0, match_count);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:161 ~ uniq[1a58]::different)",
    "span": "src/uniq.rs:835:1: 856:2 (#0)",
    "pieces": [
      "src/uniq.rs:835:1: 856:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 22,
    "source": "unsafe extern \"C\" fn different(\n    mut old: *mut libc::c_char,\n    mut new: *mut libc::c_char,\n    mut oldlen: idx_t,\n    mut newlen: idx_t,\n) -> bool {\n    if ignore_case {\n        return oldlen != newlen\n            || memcasecmp(\n                old as *const libc::c_void,\n                new as *const libc::c_void,\n                oldlen as size_t,\n            ) != 0\n    } else {\n        return oldlen != newlen\n            || memcmp(\n                old as *const libc::c_void,\n                new as *const libc::c_void,\n                oldlen as libc::c_ulong,\n            ) != 0\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:174 ~ uniq[1a58]::check_file)",
        "span": "src/uniq.rs:1094:17: 1099:19 (#0)",
        "source": "let mut match_0: bool = !different(\n                    thisfield_0,\n                    prevfield_0,\n                    thislen_0,\n                    prevlen_0,\n                );"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:160 ~ uniq[1a58]::find_field)",
    "span": "src/uniq.rs:786:1: 834:2 (#0)",
    "pieces": [
      "src/uniq.rs:786:1: 834:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 49,
    "source": "unsafe extern \"C\" fn find_field(\n    mut line: *const linebuffer,\n    mut plen: *mut idx_t,\n) -> *mut libc::c_char {\n    let mut lp: *mut libc::c_char = (*line).buffer;\n    let mut lim: *const libc::c_char = lp\n        .offset((*line).length as isize)\n        .offset(-(1 as libc::c_int as isize));\n    let mut i: idx_t = skip_fields;\n    while (0 as libc::c_int as libc::c_long) < i && lp < lim as *mut libc::c_char {\n        lp = skip_buf_matching(\n            lp,\n            lim,\n            Some(newline_or_blank as unsafe extern \"C\" fn(mcel_t) -> bool),\n            1 as libc::c_int != 0,\n        );\n        lp = skip_buf_matching(\n            lp,\n            lim,\n            Some(newline_or_blank as unsafe extern \"C\" fn(mcel_t) -> bool),\n            0 as libc::c_int != 0,\n        );\n        i -= 1;\n        i;\n    }\n    let mut i_0: idx_t = skip_chars;\n    while (0 as libc::c_int as libc::c_long) < i_0 && lp < lim as *mut libc::c_char {\n        lp = lp.offset((mcel_scan(lp, lim)).len as libc::c_int as isize);\n        i_0 -= 1;\n        i_0;\n    }\n    let mut len: idx_t = 0;\n    if lim.offset_from(lp) as libc::c_long <= check_chars {\n        len = lim.offset_from(lp) as libc::c_long;\n    } else if __ctype_get_mb_cur_max() <= 1 as libc::c_int as libc::c_ulong {\n        len = check_chars;\n    } else {\n        let mut ep: *mut libc::c_char = lp;\n        let mut i_1: idx_t = check_chars;\n        while (0 as libc::c_int as libc::c_long) < i_1 && lp < lim as *mut libc::c_char {\n            ep = ep.offset((mcel_scan(lp, lim)).len as libc::c_int as isize);\n            i_1 -= 1;\n            i_1;\n        }\n        len = ep.offset_from(lp) as libc::c_long;\n    }\n    *plen = len;\n    return lp;\n}",
    "calls": [
      {
        "caller": "DefId(0:174 ~ uniq[1a58]::check_file)",
        "span": "src/uniq.rs:1072:9: 1072:87 (#0)",
        "source": "let mut prevfield_0: *mut libc::c_char = find_field(prevline, &mut prevlen_0);"
      },
      {
        "caller": "DefId(0:174 ~ uniq[1a58]::check_file)",
        "span": "src/uniq.rs:1090:17: 1093:19 (#0)",
        "source": "let mut thisfield_0: *mut libc::c_char = find_field(\n                    thisline,\n                    &mut thislen_0,\n                );"
      }
    ],
    "globals": [
      {
        "span": "src/uniq.rs:489:1: 489:69 (#0)",
        "source": "static mut check_chars: idx_t = 9223372036854775807 as libc::c_long;"
      },
      {
        "span": "src/uniq.rs:487:1: 487:59 (#0)",
        "source": "static mut skip_fields: idx_t = 0 as libc::c_int as idx_t;"
      },
      {
        "span": "src/uniq.rs:488:1: 488:58 (#0)",
        "source": "static mut skip_chars: idx_t = 0 as libc::c_int as idx_t;"
      }
    ],
    "imports": [
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:163 ~ uniq[1a58]::check_file)",
    "span": "src/uniq.rs:888:1: 1229:2 (#0)",
    "pieces": [
      "src/uniq.rs:888:1: 1229:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 342,
    "source": "unsafe extern \"C\" fn check_file(\n    mut infile: *const libc::c_char,\n    mut outfile: *const libc::c_char,\n    mut delimiter: libc::c_char,\n) {\n    let mut current_block: u64;\n    let mut lb1: linebuffer = linebuffer {\n        size: 0,\n        length: 0,\n        buffer: 0 as *mut libc::c_char,\n    };\n    let mut lb2: linebuffer = linebuffer {\n        size: 0,\n        length: 0,\n        buffer: 0 as *mut libc::c_char,\n    };\n    let mut thisline: *mut linebuffer = 0 as *mut linebuffer;\n    let mut prevline: *mut linebuffer = 0 as *mut linebuffer;\n    if !(strcmp(infile, b\"-\\0\" as *const u8 as *const libc::c_char) == 0 as libc::c_int\n        || !(freopen_safer(infile, b\"r\\0\" as *const u8 as *const libc::c_char, stdin))\n            .is_null())\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    infile,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if !(strcmp(outfile, b\"-\\0\" as *const u8 as *const libc::c_char) == 0 as libc::c_int\n        || !(freopen_safer(outfile, b\"w\\0\" as *const u8 as *const libc::c_char, stdout))\n            .is_null())\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    outfile,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        outfile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        outfile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    fadvise(stdin, FADVISE_SEQUENTIAL);\n    thisline = &mut lb1;\n    prevline = &mut lb2;\n    initbuffer(thisline);\n    initbuffer(prevline);\n    if output_unique as libc::c_int != 0 && output_first_repeated as libc::c_int != 0\n        && !count_occurrences\n    {\n        let mut prevfield: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut prevlen: idx_t = 0;\n        let mut first_group_printed: bool = 0 as libc::c_int != 0;\n        while feof_unlocked(stdin) == 0\n            && !(readlinebuffer_delim(thisline, stdin, delimiter)).is_null()\n        {\n            let mut thislen: idx_t = 0;\n            let mut thisfield: *mut libc::c_char = find_field(thisline, &mut thislen);\n            let mut new_group: bool = prevfield.is_null()\n                || different(thisfield, prevfield, thislen, prevlen) as libc::c_int != 0;\n            if new_group as libc::c_int != 0\n                && grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint\n                && (grouping as libc::c_uint == GM_PREPEND as libc::c_int as libc::c_uint\n                    || grouping as libc::c_uint == GM_BOTH as libc::c_int as libc::c_uint\n                    || first_group_printed as libc::c_int != 0\n                        && (grouping as libc::c_uint\n                            == GM_APPEND as libc::c_int as libc::c_uint\n                            || grouping as libc::c_uint\n                                == GM_SEPARATE as libc::c_int as libc::c_uint))\n            {\n                putchar_unlocked(delimiter as libc::c_int);\n            }\n            if new_group as libc::c_int != 0\n                || grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint\n            {\n                if fwrite_unlocked(\n                    (*thisline).buffer as *const libc::c_void,\n                    ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,\n                    (*thisline).length as size_t,\n                    stdout,\n                ) != (*thisline).length as libc::c_ulong\n                {\n                    write_error();\n                }\n                swap_lines(&mut prevline, &mut thisline);\n                prevfield = thisfield;\n                prevlen = thislen;\n                first_group_printed = 1 as libc::c_int != 0;\n            }\n        }\n        if (grouping as libc::c_uint == GM_BOTH as libc::c_int as libc::c_uint\n            || grouping as libc::c_uint == GM_APPEND as libc::c_int as libc::c_uint)\n            && first_group_printed as libc::c_int != 0\n        {\n            putchar_unlocked(delimiter as libc::c_int);\n        }\n    } else if !(readlinebuffer_delim(prevline, stdin, delimiter)).is_null() {\n        let mut prevlen_0: idx_t = 0;\n        let mut prevfield_0: *mut libc::c_char = find_field(prevline, &mut prevlen_0);\n        let mut match_count: intmax_t = 0 as libc::c_int as intmax_t;\n        let mut first_delimiter: bool = 1 as libc::c_int != 0;\n        loop {\n            if !(feof_unlocked(stdin) == 0) {\n                current_block = 6476622998065200121;\n                break;\n            }\n            if (readlinebuffer_delim(thisline, stdin, delimiter)).is_null() {\n                if ferror_unlocked(stdin) != 0 {\n                    current_block = 6469497169255231809;\n                    break;\n                } else {\n                    current_block = 6476622998065200121;\n                    break;\n                }\n            } else {\n                let mut thislen_0: idx_t = 0;\n                let mut thisfield_0: *mut libc::c_char = find_field(\n                    thisline,\n                    &mut thislen_0,\n                );\n                let mut match_0: bool = !different(\n                    thisfield_0,\n                    prevfield_0,\n                    thislen_0,\n                    prevlen_0,\n                );\n                match_count += match_0 as libc::c_long;\n                if match_count == 9223372036854775807 as libc::c_long {\n                    if count_occurrences {\n                        if 0 != 0 {\n                            error(\n                                1 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"too many repeated lines\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if 1 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"too many repeated lines\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"too many repeated lines\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    }\n                    match_count -= 1;\n                    match_count;\n                }\n                if delimit_groups as libc::c_uint\n                    != DM_NONE as libc::c_int as libc::c_uint\n                {\n                    if !match_0 {\n                        if match_count != 0 {\n                            first_delimiter = 0 as libc::c_int != 0;\n                        }\n                    } else if match_count == 1 as libc::c_int as libc::c_long {\n                        if delimit_groups as libc::c_uint\n                            == DM_PREPEND as libc::c_int as libc::c_uint\n                            || delimit_groups as libc::c_uint\n                                == DM_SEPARATE as libc::c_int as libc::c_uint\n                                && !first_delimiter\n                        {\n                            putchar_unlocked(delimiter as libc::c_int);\n                        }\n                    }\n                }\n                if !match_0 || output_later_repeated as libc::c_int != 0 {\n                    writeline(prevline, match_0, match_count);\n                    swap_lines(&mut prevline, &mut thisline);\n                    prevfield_0 = thisfield_0;\n                    prevlen_0 = thislen_0;\n                    if !match_0 {\n                        match_count = 0 as libc::c_int as intmax_t;\n                    }\n                }\n            }\n        }\n        match current_block {\n            6469497169255231809 => {}\n            _ => {\n                writeline(prevline, 0 as libc::c_int != 0, match_count);\n            }\n        }\n    }\n    if ferror_unlocked(stdin) != 0 || rpl_fclose(stdin) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, infile),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, infile),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, infile),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    free(lb1.buffer as *mut libc::c_void);\n    free(lb2.buffer as *mut libc::c_void);\n}",
    "calls": [
      {
        "caller": "DefId(0:175 ~ uniq[1a58]::main_0)",
        "span": "src/uniq.rs:1996:5: 2000:7 (#0)",
        "source": "check_file(\n        file[0 as libc::c_int as usize],\n        file[1 as libc::c_int as usize],\n        delimiter,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/uniq.rs:231:1: 231:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/uniq.rs:230:1: 230:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/uniq.rs:248:1: 248:45 (#0)",
        "source": "pub const FADVISE_SEQUENTIAL: fadvice_t = 2;"
      }
    ],
    "imports": [
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:158 ~ uniq[1a58]::size_opt)",
    "span": "src/uniq.rs:721:1: 782:2 (#0)",
    "pieces": [
      "src/uniq.rs:721:1: 782:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 62,
    "source": "unsafe extern \"C\" fn size_opt(\n    mut opt: *const libc::c_char,\n    mut msgid: *const libc::c_char,\n) -> idx_t {\n    let mut size: intmax_t = 0;\n    if (LONGINT_OVERFLOW as libc::c_int as libc::c_uint)\n        < xstrtoimax(\n            opt,\n            0 as *mut *mut libc::c_char,\n            10 as libc::c_int,\n            &mut size,\n            b\"\\0\" as *const u8 as *const libc::c_char,\n        ) as libc::c_uint || size < 0 as libc::c_int as libc::c_long\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                0 as libc::c_int,\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                opt,\n                gettext(msgid),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    opt,\n                    gettext(msgid),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    opt,\n                    gettext(msgid),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    return if size < 9223372036854775807 as libc::c_long {\n        size\n    } else {\n        9223372036854775807 as libc::c_long\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:175 ~ uniq[1a58]::main_0)",
        "span": "src/uniq.rs:1803:21: 1807:23 (#0)",
        "source": "skip_chars = size_opt(\n                        optarg,\n                        b\"invalid number of bytes to skip\\0\" as *const u8\n                            as *const libc::c_char,\n                    );"
      },
      {
        "caller": "DefId(0:175 ~ uniq[1a58]::main_0)",
        "span": "src/uniq.rs:1793:21: 1797:23 (#0)",
        "source": "skip_fields = size_opt(\n                        optarg,\n                        b\"invalid number of fields to skip\\0\" as *const u8\n                            as *const libc::c_char,\n                    );"
      },
      {
        "caller": "DefId(0:175 ~ uniq[1a58]::main_0)",
        "span": "src/uniq.rs:1814:21: 1818:23 (#0)",
        "source": "check_chars = size_opt(\n                        optarg,\n                        b\"invalid number of bytes to compare\\0\" as *const u8\n                            as *const libc::c_char,\n                    );"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:125 ~ uniq[1a58]::emit_ancillary_info)",
    "span": "src/uniq.rs:298:1: 349:2 (#0)",
    "pieces": [
      "src/uniq.rs:298:1: 349:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 115,
    "source": "unsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:167 ~ uniq[1a58]::usage)",
        "span": "src/uniq.rs:709:9: 709:37 (#0)",
        "source": "emit_ancillary_info(\"uniq\");"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:124 ~ uniq[1a58]::emit_mandatory_arg_note)",
    "span": "src/uniq.rs:289:1: 295:2 (#0)",
    "pieces": [
      "src/uniq.rs:289:1: 295:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_mandatory_arg_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nMandatory arguments to long options are mandatory for short options too.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:167 ~ uniq[1a58]::usage)",
        "span": "src/uniq.rs:653:9: 653:35 (#0)",
        "source": "emit_mandatory_arg_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:156 ~ uniq[1a58]::usage)",
    "span": "src/uniq.rs:637:1: 712:2 (#0)",
    "pieces": [
      "src/uniq.rs:637:1: 712:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 107,
    "source": "pub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [INPUT [OUTPUT]]\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Filter adjacent matching lines from INPUT (or standard input),\\nwriting to OUTPUT (or standard output).\\n\\nWith no options, matching lines are merged to the first occurrence.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_mandatory_arg_note();\n        fputs_unlocked(\n            gettext(\n                b\"  -c, --count           prefix lines by the number of occurrences\\n  -d, --repeated        only print duplicate lines, one for each group\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -D                    print all duplicate lines\\n      --all-repeated[=METHOD]  like -D, but allow separating groups\\n                                 with an empty line;\\n                                 METHOD={none(default),prepend,separate}\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -f, --skip-fields=N   avoid comparing the first N fields\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --group[=METHOD]  show all items, separating groups with an empty line;\\n                          METHOD={separate(default),prepend,append,both}\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -i, --ignore-case     ignore differences in case when comparing\\n  -s, --skip-chars=N    avoid comparing the first N characters\\n  -u, --unique          only print unique lines\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -z, --zero-terminated     line delimiter is NUL, not newline\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -w, --check-chars=N   compare no more than N characters in lines\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"\\nA field is a run of blanks (usually spaces and/or TABs), then non-blank\\ncharacters.  Fields are skipped before chars.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"\\n'uniq' does not detect repeated lines unless they are adjacent.\\nYou may want to sort the input first, or use 'sort -u' without 'uniq'.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_ancillary_info(b\"uniq\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}",
    "calls": [
      {
        "caller": "DefId(0:175 ~ uniq[1a58]::main_0)",
        "span": "src/uniq.rs:1845:21: 1845:30 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:175 ~ uniq[1a58]::main_0)",
        "span": "src/uniq.rs:1824:21: 1824:30 (#0)",
        "source": "usage(0);"
      },
      {
        "caller": "DefId(0:175 ~ uniq[1a58]::main_0)",
        "span": "src/uniq.rs:1946:9: 1946:18 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:175 ~ uniq[1a58]::main_0)",
        "span": "src/uniq.rs:1388:25: 1388:34 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:175 ~ uniq[1a58]::main_0)",
        "span": "src/uniq.rs:1994:9: 1994:18 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:175 ~ uniq[1a58]::main_0)",
        "span": "src/uniq.rs:1897:9: 1897:18 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:175 ~ uniq[1a58]::main_0)",
        "span": "src/uniq.rs:1316:17: 1316:26 (#0)",
        "source": "usage(1);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:164 ~ uniq[1a58]::main_0)",
    "span": "src/uniq.rs:1230:1: 2002:2 (#0)",
    "pieces": [
      "src/uniq.rs:1230:1: 2002:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 773,
    "source": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut optc: libc::c_int = 0 as libc::c_int;\n    let mut posixly_correct: bool = !(getenv(\n        b\"POSIXLY_CORRECT\\0\" as *const u8 as *const libc::c_char,\n    ))\n        .is_null();\n    let mut skip_field_option_type: Skip_field_option_type = SFO_NONE;\n    let mut nfiles: libc::c_int = 0 as libc::c_int;\n    let mut file: [*const libc::c_char; 2] = [0 as *const libc::c_char; 2];\n    let mut delimiter: libc::c_char = '\\n' as i32 as libc::c_char;\n    let mut output_option_used: bool = 0 as libc::c_int != 0;\n    file[1 as libc::c_int as usize] = b\"-\\0\" as *const u8 as *const libc::c_char;\n    file[0 as libc::c_int as usize] = file[1 as libc::c_int as usize];\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    loop {\n        if optc == -(1 as libc::c_int)\n            || posixly_correct as libc::c_int != 0 && nfiles != 0 as libc::c_int\n            || {\n                optc = getopt_long(\n                    argc,\n                    argv,\n                    b\"-0123456789Dcdf:is:uw:z\\0\" as *const u8 as *const libc::c_char,\n                    longopts.as_ptr(),\n                    0 as *mut libc::c_int,\n                );\n                optc == -(1 as libc::c_int)\n            }\n        {\n            if argc <= optind {\n                break;\n            }\n            if nfiles == 2 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quote(*argv.offset(optind as isize)),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quote(*argv.offset(optind as isize)),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quote(*argv.offset(optind as isize)),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                usage(1 as libc::c_int);\n            }\n            let fresh0 = optind;\n            optind = optind + 1;\n            let fresh1 = nfiles;\n            nfiles = nfiles + 1;\n            file[fresh1 as usize] = *argv.offset(fresh0 as isize);\n        } else {\n            match optc {\n                1 => {\n                    let mut size: intmax_t = 0;\n                    if *optarg.offset(0 as libc::c_int as isize) as libc::c_int\n                        == '+' as i32 && !strict_posix2()\n                        && xstrtoimax(\n                            optarg,\n                            0 as *mut *mut libc::c_char,\n                            10 as libc::c_int,\n                            &mut size,\n                            b\"\\0\" as *const u8 as *const libc::c_char,\n                        ) as libc::c_uint\n                            <= LONGINT_OVERFLOW as libc::c_int as libc::c_uint\n                    {\n                        skip_chars = if size < 9223372036854775807 as libc::c_long {\n                            size\n                        } else {\n                            9223372036854775807 as libc::c_long\n                        };\n                    } else if nfiles == 2 as libc::c_int {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                                    ),\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"extra operand %s\\0\" as *const u8 as *const libc::c_char,\n                                    ),\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                        usage(1 as libc::c_int);\n                    } else {\n                        let fresh2 = nfiles;\n                        nfiles = nfiles + 1;\n                        file[fresh2 as usize] = optarg;\n                    }\n                }\n                48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => {\n                    if skip_field_option_type as libc::c_uint\n                        == SFO_NEW as libc::c_int as libc::c_uint\n                    {\n                        skip_fields = 0 as libc::c_int as idx_t;\n                    }\n                    if !(!((if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                        && ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            skip_fields\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        && ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            10 as libc::c_int\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        && (if (10 as libc::c_int) < 0 as libc::c_int {\n                            if skip_fields < 0 as libc::c_int as libc::c_long {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        -(1 as libc::c_int) as idx_t\n                                    }) + 10 as libc::c_int as libc::c_long\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    (skip_fields\n                                        < -(1 as libc::c_int) as idx_t\n                                            / 10 as libc::c_int as libc::c_long) as libc::c_int\n                                } else {\n                                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                                    {\n                                        !(((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) + 1 as libc::c_int)\n                                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) + 0 as libc::c_int\n                                    }) < 0 as libc::c_int\n                                    {\n                                        ((10 as libc::c_int)\n                                            < -(if ((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                                            {\n                                                ((((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    10 as libc::c_int\n                                                }) + 1 as libc::c_int)\n                                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    10 as libc::c_int\n                                                }) - 1 as libc::c_int\n                                            })) as libc::c_int\n                                    } else {\n                                        ((0 as libc::c_int) < 10 as libc::c_int) as libc::c_int\n                                    }) != 0\n                                    {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + -(1 as libc::c_int) as idx_t\n                                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                    } else {\n                                        -(1 as libc::c_int) as idx_t\n                                            / -(10 as libc::c_int) as libc::c_long\n                                    }) <= -(1 as libc::c_int) as libc::c_long - skip_fields)\n                                        as libc::c_int\n                                }\n                            } else {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) as libc::c_long + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    10 as libc::c_int\n                                                }) as libc::c_long + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    10 as libc::c_int\n                                                }) as libc::c_long + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + 0 as libc::c_int as idx_t)\n                                        as libc::c_int\n                                }) != 0 && 10 as libc::c_int == -(1 as libc::c_int)\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        skip_fields\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < skip_fields + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((0 as libc::c_int as libc::c_long) < skip_fields\n                                            && (-(1 as libc::c_int) as libc::c_long\n                                                - 0 as libc::c_int as idx_t)\n                                                < skip_fields - 1 as libc::c_int as libc::c_long)\n                                            as libc::c_int\n                                    }\n                                } else {\n                                    ((0 as libc::c_int as idx_t\n                                        / 10 as libc::c_int as libc::c_long) < skip_fields)\n                                        as libc::c_int\n                                }\n                            }\n                        } else {\n                            if 10 as libc::c_int == 0 as libc::c_int {\n                                0 as libc::c_int\n                            } else {\n                                if skip_fields < 0 as libc::c_int as libc::c_long {\n                                    if (if (if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            skip_fields\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        !(((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                skip_fields\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long)\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                skip_fields\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 0 as libc::c_int as libc::c_long\n                                    }) < 0 as libc::c_int as libc::c_long\n                                    {\n                                        (((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            skip_fields\n                                        }) + 0 as libc::c_int as idx_t)\n                                            < -(if ((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    skip_fields\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long)\n                                                < 0 as libc::c_int as libc::c_long\n                                            {\n                                                ((((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        skip_fields\n                                                    }) + 0 as libc::c_int as idx_t\n                                                }) + 1 as libc::c_int as libc::c_long)\n                                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                    - 1 as libc::c_int as libc::c_long)\n                                                    * 2 as libc::c_int as libc::c_long\n                                                    + 1 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        skip_fields\n                                                    }) + 0 as libc::c_int as idx_t\n                                                }) - 1 as libc::c_int as libc::c_long\n                                            })) as libc::c_int\n                                    } else {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                skip_fields\n                                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                    }) != 0\n                                        && skip_fields == -(1 as libc::c_int) as libc::c_long\n                                    {\n                                        if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                                        {\n                                            ((0 as libc::c_int as libc::c_long)\n                                                < 10 as libc::c_int as libc::c_long\n                                                    + 0 as libc::c_int as idx_t) as libc::c_int\n                                        } else {\n                                            ((-(1 as libc::c_int) as libc::c_long\n                                                - 0 as libc::c_int as idx_t)\n                                                < (10 as libc::c_int - 1 as libc::c_int) as libc::c_long)\n                                                as libc::c_int\n                                        }\n                                    } else {\n                                        (0 as libc::c_int as idx_t / skip_fields\n                                            < 10 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    ((-(1 as libc::c_int) as idx_t\n                                        / 10 as libc::c_int as libc::c_long) < skip_fields)\n                                        as libc::c_int\n                                }\n                            }\n                        }) != 0\n                    {\n                        let (fresh7, _fresh8) = skip_fields\n                            .overflowing_mul((10 as libc::c_int).into());\n                        *(&mut skip_fields as *mut idx_t) = fresh7;\n                        1 as libc::c_int\n                    } else {\n                        let (fresh9, fresh10) = skip_fields\n                            .overflowing_mul((10 as libc::c_int).into());\n                        *(&mut skip_fields as *mut idx_t) = fresh9;\n                        fresh10 as libc::c_int\n                    }) != 0)\n                        && {\n                            let (fresh11, fresh12) = skip_fields\n                                .overflowing_add((optc - '0' as i32).into());\n                            *(&mut skip_fields as *mut idx_t) = fresh11;\n                            !fresh12\n                        })\n                    {\n                        skip_fields = 9223372036854775807 as libc::c_long;\n                    }\n                    skip_field_option_type = SFO_OBSOLETE;\n                }\n                99 => {\n                    count_occurrences = 1 as libc::c_int != 0;\n                    output_option_used = 1 as libc::c_int != 0;\n                }\n                100 => {\n                    output_unique = 0 as libc::c_int != 0;\n                    output_option_used = 1 as libc::c_int != 0;\n                }\n                68 => {\n                    output_unique = 0 as libc::c_int != 0;\n                    output_later_repeated = 1 as libc::c_int != 0;\n                    if optarg.is_null() {\n                        delimit_groups = DM_NONE;\n                    } else {\n                        delimit_groups = delimit_method_map[__xargmatch_internal(\n                            b\"--all-repeated\\0\" as *const u8 as *const libc::c_char,\n                            optarg,\n                            delimit_method_string.as_ptr(),\n                            delimit_method_map.as_ptr() as *const libc::c_void,\n                            ::core::mem::size_of::<delimit_method>() as libc::c_ulong,\n                            argmatch_die,\n                            1 as libc::c_int != 0,\n                        ) as usize];\n                    }\n                    output_option_used = 1 as libc::c_int != 0;\n                }\n                256 => {\n                    if optarg.is_null() {\n                        grouping = GM_SEPARATE;\n                    } else {\n                        grouping = grouping_method_map[__xargmatch_internal(\n                            b\"--group\\0\" as *const u8 as *const libc::c_char,\n                            optarg,\n                            grouping_method_string.as_ptr(),\n                            grouping_method_map.as_ptr() as *const libc::c_void,\n                            ::core::mem::size_of::<grouping_method>() as libc::c_ulong,\n                            argmatch_die,\n                            1 as libc::c_int != 0,\n                        ) as usize];\n                    }\n                }\n                102 => {\n                    skip_field_option_type = SFO_NEW;\n                    skip_fields = size_opt(\n                        optarg,\n                        b\"invalid number of fields to skip\\0\" as *const u8\n                            as *const libc::c_char,\n                    );\n                }\n                105 => {\n                    ignore_case = 1 as libc::c_int != 0;\n                }\n                115 => {\n                    skip_chars = size_opt(\n                        optarg,\n                        b\"invalid number of bytes to skip\\0\" as *const u8\n                            as *const libc::c_char,\n                    );\n                }\n                117 => {\n                    output_first_repeated = 0 as libc::c_int != 0;\n                    output_option_used = 1 as libc::c_int != 0;\n                }\n                119 => {\n                    check_chars = size_opt(\n                        optarg,\n                        b\"invalid number of bytes to compare\\0\" as *const u8\n                            as *const libc::c_char,\n                    );\n                }\n                122 => {\n                    delimiter = '\\0' as i32 as libc::c_char;\n                }\n                -2 => {\n                    usage(0 as libc::c_int);\n                }\n                -3 => {\n                    version_etc(\n                        stdout,\n                        b\"uniq\\0\" as *const u8 as *const libc::c_char,\n                        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                        Version,\n                        proper_name_lite(\n                            b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                            b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        proper_name_lite(\n                            b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                            b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        0 as *mut libc::c_void as *mut libc::c_char,\n                    );\n                    exit(0 as libc::c_int);\n                }\n                _ => {\n                    usage(1 as libc::c_int);\n                }\n            }\n        }\n    }\n    if grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint\n        && output_option_used as libc::c_int != 0\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"--group is mutually exclusive with -c/-d/-D/-u\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"--group is mutually exclusive with -c/-d/-D/-u\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"--group is mutually exclusive with -c/-d/-D/-u\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if grouping as libc::c_uint != GM_NONE as libc::c_int as libc::c_uint\n        && count_occurrences as libc::c_int != 0\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"grouping and printing repeat counts is meaningless\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"grouping and printing repeat counts is meaningless\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"grouping and printing repeat counts is meaningless\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if count_occurrences as libc::c_int != 0 && output_later_repeated as libc::c_int != 0\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"printing all duplicated lines and repeat counts is meaningless\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"printing all duplicated lines and repeat counts is meaningless\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"printing all duplicated lines and repeat counts is meaningless\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    check_file(\n        file[0 as libc::c_int as usize],\n        file[1 as libc::c_int as usize],\n        delimiter,\n    );\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:178 ~ uniq[1a58]::main)",
        "span": "src/uniq.rs:2014:18: 2016:6 (#0)",
        "source": "unsafe {\n        main_0((argv.len() - 1) as libc::c_int, argv.as_mut_ptr())\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/uniq.rs:502:1: 502:53 (#0)",
        "source": "static mut delimit_groups: delimit_method = DM_NONE;"
      },
      {
        "span": "src/uniq.rs:278:1: 278:44 (#0)",
        "source": "pub const GM_SEPARATE: grouping_method = 3;"
      },
      {
        "span": "src/uniq.rs:503:1: 509:3 (#0)",
        "source": "static mut grouping_method_string: [*const libc::c_char; 5] = [\n    b\"prepend\\0\" as *const u8 as *const libc::c_char,\n    b\"append\\0\" as *const u8 as *const libc::c_char,\n    b\"separate\\0\" as *const u8 as *const libc::c_char,\n    b\"both\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];"
      },
      {
        "span": "src/uniq.rs:501:1: 501:89 (#0)",
        "source": "static mut delimit_method_map: [delimit_method; 3] = [DM_NONE, DM_PREPEND, DM_SEPARATE];"
      },
      {
        "span": "src/uniq.rs:490:1: 490:60 (#0)",
        "source": "static mut count_occurrences: bool = 0 as libc::c_int != 0;"
      },
      {
        "span": "src/uniq.rs:287:1: 287:48 (#0)",
        "source": "pub const SFO_NONE: Skip_field_option_type = 0;"
      },
      {
        "span": "src/uniq.rs:275:1: 275:39 (#0)",
        "source": "pub const DM_NONE: delimit_method = 0;"
      },
      {
        "span": "src/uniq.rs:285:1: 285:47 (#0)",
        "source": "pub const SFO_NEW: Skip_field_option_type = 2;"
      },
      {
        "span": "src/uniq.rs:492:1: 492:64 (#0)",
        "source": "static mut output_first_repeated: bool = 1 as libc::c_int != 0;"
      },
      {
        "span": "src/uniq.rs:488:1: 488:58 (#0)",
        "source": "static mut skip_chars: idx_t = 0 as libc::c_int as idx_t;"
      },
      {
        "span": "src/uniq.rs:510:1: 515:3 (#0)",
        "source": "static mut grouping_method_map: [grouping_method; 4] = [\n    GM_PREPEND,\n    GM_APPEND,\n    GM_SEPARATE,\n    GM_BOTH,\n];"
      },
      {
        "span": "src/uniq.rs:493:1: 493:64 (#0)",
        "source": "static mut output_later_repeated: bool = 0 as libc::c_int != 0;"
      },
      {
        "span": "src/uniq.rs:516:1: 516:48 (#0)",
        "source": "static mut grouping: grouping_method = GM_NONE;"
      },
      {
        "span": "src/uniq.rs:286:1: 286:52 (#0)",
        "source": "pub const SFO_OBSOLETE: Skip_field_option_type = 1;"
      },
      {
        "span": "src/uniq.rs:495:1: 500:3 (#0)",
        "source": "static mut delimit_method_string: [*const libc::c_char; 4] = [\n    b\"none\\0\" as *const u8 as *const libc::c_char,\n    b\"prepend\\0\" as *const u8 as *const libc::c_char,\n    b\"separate\\0\" as *const u8 as *const libc::c_char,\n    0 as *const libc::c_char,\n];"
      },
      {
        "span": "src/uniq.rs:491:1: 491:56 (#0)",
        "source": "static mut output_unique: bool = 1 as libc::c_int != 0;"
      },
      {
        "span": "src/uniq.rs:487:1: 487:59 (#0)",
        "source": "static mut skip_fields: idx_t = 0 as libc::c_int as idx_t;"
      },
      {
        "span": "src/uniq.rs:494:1: 494:38 (#0)",
        "source": "static mut ignore_case: bool = false;"
      },
      {
        "span": "src/uniq.rs:489:1: 489:69 (#0)",
        "source": "static mut check_chars: idx_t = 9223372036854775807 as libc::c_long;"
      }
    ],
    "imports": [
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:167 ~ uniq[1a58]::main)",
    "span": "src/uniq.rs:2003:1: 2019:2 (#0)",
    "pieces": [
      "src/uniq.rs:2003:1: 2019:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:157 ~ uniq[1a58]::strict_posix2)",
    "span": "src/uniq.rs:714:1: 719:2 (#0)",
    "pieces": [
      "src/uniq.rs:714:1: 719:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn strict_posix2() -> bool {\n    let mut posix_ver: libc::c_int = posix2_version();\n    return 200112 as libc::c_int <= posix_ver && posix_ver < 200809 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:159 ~ uniq[1a58]::newline_or_blank)",
    "span": "src/uniq.rs:783:1: 785:2 (#0)",
    "pieces": [
      "src/uniq.rs:783:1: 785:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn newline_or_blank(mut g: mcel_t) -> bool {\n    return g.ch == '\\n' as i32 as libc::c_uint || c32isblank(g.ch) != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:134 ~ uniq[1a58]::skip_buf_matching)",
    "span": "src/uniq.rs:461:1: 479:2 (#0)",
    "pieces": [
      "src/uniq.rs:461:1: 479:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn skip_buf_matching(\n    mut buf: *const libc::c_char,\n    mut lim: *const libc::c_char,\n    mut predicate: Option::<unsafe extern \"C\" fn(mcel_t) -> bool>,\n    mut ok: bool,\n) -> *mut libc::c_char {\n    let mut s: *const libc::c_char = buf;\n    let mut g: mcel_t = mcel_t { ch: 0, err: 0, len: 0 };\n    while s < lim\n        && {\n            g = mcel_scan(s, lim);\n            predicate.expect(\"non-null function pointer\")(g) as libc::c_int\n                == ok as libc::c_int\n        }\n    {\n        s = s.offset(g.len as libc::c_int as isize);\n    }\n    return s as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:132 ~ uniq[1a58]::mcel_isbasic)",
    "span": "src/uniq.rs:427:1: 429:2 (#0)",
    "pieces": [
      "src/uniq.rs:427:1: 429:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn mcel_isbasic(mut c: libc::c_char) -> bool {\n    return (0 as libc::c_int <= c as libc::c_int\n        && (c as libc::c_int) < MCEL_ERR_MIN as libc::c_int) as libc::c_int\n        as libc::c_long != 0;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/uniq.rs:258:1: 258:47 (#0)",
        "source": "pub const MCEL_ERR_MIN: C2RustUnnamed_3 = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/uniq.rs:14:1: 14:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/uniq.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/uniq.rs:15:1: 15:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/uniq.rs:12:1: 12:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/uniq.rs:19:1: 19:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  }
]