[
  {
    "func_defid": "DefId(0:39 ~ rust[fc84]::src::c_ctype::c_isascii)",
    "span": "src/c_ctype.rs:35:1: 37:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:35:1: 37:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:306 ~ rust[fc84]::src::ialloc::_gl_alloc_nomem)",
    "span": "src/ialloc.rs:119:1: 122:2 (#0)",
    "pieces": [
      "src/ialloc.rs:119:1: 122:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:7:1: 7:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:2:1: 2:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:304 ~ rust[fc84]::src::ialloc::irealloc)",
    "span": "src/ialloc.rs:80:1: 96:2 (#0)",
    "pieces": [
      "src/ialloc.rs:80:1: 96:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:4:1: 4:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:2:1: 2:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:852 ~ rust[fc84]::src::quotearg::gettext_quote)",
    "span": "src/quotearg.rs:288:1: 321:2 (#0)",
    "pieces": [
      "src/quotearg.rs:288:1: 321:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "unsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:966 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:367:13: 367:95 (#0)",
        "source": "left_quote = gettext_quote(b\"`\\0\".as_ptr() as *const libc::c_char, quoting_style);"
      },
      {
        "caller": "DefId(0:966 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:368:13: 368:96 (#0)",
        "source": "right_quote = gettext_quote(b\"'\\0\".as_ptr() as *const libc::c_char, quoting_style);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:853 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
    "span": "src/quotearg.rs:322:1: 1176:2 (#0)",
    "pieces": [
      "src/quotearg.rs:322:1: 333:4 (#0)",
      "src/quotearg.rs:1176:1: 1176:2 (#0)"
    ],
    "sub_chunks": [
      11
    ],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n   <<chunk 11>>}",
    "calls": [
      {
        "caller": "DefId(0:969 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1235:5: 1246:58 (#0)",
        "source": "let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:979 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1344:5: 1354:7 (#0)",
        "source": "let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:967 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
        "span": "src/quotearg.rs:1191:13: 1203:6 (#0)",
        "source": "unsafe {\n        quotearg_buffer_restyled(\n            buffer.as_mut_ptr(),\n            buffer.len().try_into().unwrap(),\n            arg.as_ptr(),\n            arg.len().try_into().unwrap(),\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        )\n    }"
      },
      {
        "caller": "DefId(0:966 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1146:13: 1156:15 (#0)",
        "source": "return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );"
      },
      {
        "caller": "DefId(0:966 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1117:5: 1127:7 (#0)",
        "source": "return quotearg_buffer_restyled(\n        buffer,\n        orig_buffersize,\n        arg,\n        argsize,\n        c_quoting_style,\n        flags,\n        quote_these_too,\n        left_quote,\n        right_quote,\n    );"
      },
      {
        "caller": "DefId(0:979 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1364:9: 1374:11 (#0)",
        "source": "quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );"
      },
      {
        "caller": "DefId(0:969 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1248:5: 1258:7 (#0)",
        "source": "quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:86:1: 86:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/quotearg.rs:93:1: 93:52 (#0)",
        "source": "pub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;"
      },
      {
        "span": "src/quotearg.rs:88:1: 88:57 (#0)",
        "source": "pub const shell_always_quoting_style: quoting_style = 2;"
      },
      {
        "span": "src/quotearg.rs:85:1: 85:46 (#0)",
        "source": "pub const c_quoting_style: quoting_style = 5;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/quotearg.rs:492:21: 536:2 (#0)",
        "pieces": [
          "src/quotearg.rs:492:21: 536:2 (#0)"
        ],
        "num_lines": 64,
        "source": "if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut pending_shell_escape_end: bool",
          "mut i: u64",
          "mut c: u8",
          "mut escaping: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut pending_shell_escape_end: bool",
          "mut i: u64",
          "mut c: u8",
          "mut escaping: bool"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/quotearg.rs:540:21: 670:22 (#0)",
        "pieces": [
          "src/quotearg.rs:540:21: 670:22 (#0)"
        ],
        "num_lines": 131,
        "source": "match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut elide_outer_quotes: bool",
          "mut i: u64",
          "mut c: u8"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut elide_outer_quotes: bool",
          "mut i: u64",
          "mut c: u8"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/quotearg.rs:701:21: 712:2 (#0)",
        "pieces": [
          "src/quotearg.rs:701:21: 712:2 (#0)"
        ],
        "num_lines": 17,
        "source": "esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut esc: u8"
        ],
        "live_out": [
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut esc: u8"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/quotearg.rs:716:21: 726:22 (#0)",
        "pieces": [
          "src/quotearg.rs:716:21: 726:22 (#0)"
        ],
        "num_lines": 11,
        "source": "if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut current_block: u64"
        ],
        "live_out": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut current_block: u64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/quotearg.rs:747:21: 784:2 (#0)",
        "pieces": [
          "src/quotearg.rs:747:21: 784:2 (#0)"
        ],
        "num_lines": 33,
        "source": "encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut pending_shell_escape_end: bool",
          "mut c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut pending_shell_escape_end: bool",
          "mut c_and_shell_quote_compat: bool"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/quotearg.rs:797:21: 866:58 (#0)",
        "pieces": [
          "src/quotearg.rs:797:21: 866:58 (#0)"
        ],
        "num_lines": 70,
        "source": "let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;",
        "sub_chunks": [],
        "live_in": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut i: u64",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut i: u64",
          "mut c: u8",
          "mut c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut i: u64",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut i: u64",
          "mut c: u8",
          "mut c_and_shell_quote_compat: bool",
          "mut m: u64",
          "mut printable: bool"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/quotearg.rs:867:21: 936:2 (#0)",
        "pieces": [
          "src/quotearg.rs:867:21: 936:2 (#0)"
        ],
        "num_lines": 96,
        "source": "if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut pending_shell_escape_end: bool",
          "mut i: u64",
          "mut c: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut m: u64",
          "mut printable: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut pending_shell_escape_end: bool",
          "mut i: u64",
          "mut c: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut m: u64",
          "mut printable: bool"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/quotearg.rs:459:5: 986:14 (#0)",
        "pieces": [
          "src/quotearg.rs:459:5: 492:20 (#0)",
          "src/quotearg.rs:538:1: 540:20 (#0)",
          "src/quotearg.rs:671:1: 701:20 (#0)",
          "src/quotearg.rs:714:1: 716:20 (#0)",
          "src/quotearg.rs:727:1: 747:20 (#0)",
          "src/quotearg.rs:786:1: 797:20 (#0)",
          "src/quotearg.rs:867:1: 867:20 (#0)",
          "src/quotearg.rs:938:1: 986:14 (#0)"
        ],
        "num_lines": 154,
        "source": "let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                   <<chunk 0>>                }\n                63 => {\n                   <<chunk 1>>                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                   <<chunk 2>>                }\n                123 | 125 => {\n                   <<chunk 3>>                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                   <<chunk 4>>                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                   <<chunk 5>>                   <<chunk 6>>                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }",
        "sub_chunks": [
          0,
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut pending_shell_escape_end: bool",
          "mut i: u64"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut pending_shell_escape_end: bool",
          "mut i: u64",
          "mut c: u8",
          "mut esc: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut c_and_shell_quote_compat: bool"
        ]
      },
      {
        "chunk_id": 8,
        "span": "src/quotearg.rs:987:12: 1099:15 (#0)",
        "pieces": [
          "src/quotearg.rs:987:12: 1099:15 (#0)"
        ],
        "num_lines": 113,
        "source": "match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut quote_these_too: *const u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut all_c_and_shell_quote_compat: bool",
          "mut pending_shell_escape_end: bool",
          "mut i: u64",
          "mut c: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut quote_these_too: *const u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut all_c_and_shell_quote_compat: bool",
          "mut pending_shell_escape_end: bool",
          "mut i: u64"
        ]
      },
      {
        "chunk_id": 9,
        "span": "src/quotearg.rs:348:9: 1114:3 (#0)",
        "pieces": [
          "src/quotearg.rs:348:9: 459:4 (#0)",
          "src/quotearg.rs:987:1: 987:11 (#0)",
          "src/quotearg.rs:1100:1: 1114:3 (#0)"
        ],
        "num_lines": 136,
        "source": "pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n           <<chunk 7>>           <<chunk 8>>        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }",
        "sub_chunks": [
          7,
          8
        ],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut all_c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut all_c_and_shell_quote_compat: bool",
          "mut pending_shell_escape_end: bool",
          "mut current_block_48: u64",
          "mut i: u64"
        ]
      },
      {
        "chunk_id": 10,
        "span": "src/quotearg.rs:1116:9: 1135:2 (#0)",
        "pieces": [
          "src/quotearg.rs:1116:9: 1135:2 (#0)"
        ],
        "num_lines": 20,
        "source": "if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut all_c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut all_c_and_shell_quote_compat: bool"
        ]
      },
      {
        "chunk_id": 11,
        "span": "src/quotearg.rs:333:5: 1175:7 (#0)",
        "pieces": [
          "src/quotearg.rs:333:5: 348:8 (#0)",
          "src/quotearg.rs:1116:1: 1116:8 (#0)",
          "src/quotearg.rs:1137:1: 1175:7 (#0)"
        ],
        "num_lines": 56,
        "source": "let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n       <<chunk 9>>       <<chunk 10>>    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };",
        "sub_chunks": [
          9,
          10
        ],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut all_c_and_shell_quote_compat: bool"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:866 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
    "span": "src/quotearg.rs:1300:1: 1378:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1300:1: 1378:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 79,
    "source": "unsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}",
    "calls": [
      {
        "caller": "DefId(0:996 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1556:5: 1556:56 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut o);"
      },
      {
        "caller": "DefId(0:984 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1426:5: 1428:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg.as_ptr(), u64::MAX, &o)\n    }"
      },
      {
        "caller": "DefId(0:993 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1520:9: 1525:11 (#0)",
        "source": "result_ptr = quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            u64::MAX,\n            &mut options,\n        );"
      },
      {
        "caller": "DefId(0:1000 ~ rust[fc84]::src::quotearg::quote_n_mem)",
        "span": "src/quotearg.rs:1616:5: 1618:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg.as_ptr(), argsize, &quote_quoting_options)\n    }"
      },
      {
        "caller": "DefId(0:985 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1440:5: 1442:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg.as_ptr() as *const libc::c_char, argsize, &o)\n    }"
      },
      {
        "caller": "DefId(0:988 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1479:5: 1479:77 (#0)",
        "source": "return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);"
      },
      {
        "caller": "DefId(0:980 ~ rust[fc84]::src::quotearg::quotearg_n)",
        "span": "src/quotearg.rs:1384:5: 1391:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            u64::MAX,\n            &default_quoting_options,\n        )\n    }"
      },
      {
        "caller": "DefId(0:981 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
        "span": "src/quotearg.rs:1400:5: 1402:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg.as_ptr(), argsize, &default_quoting_options)\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1267:1: 1275:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      },
      {
        "span": "src/quotearg.rs:94:1: 94:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      },
      {
        "span": "src/quotearg.rs:1276:1: 1278:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1266:1: 1266:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:867 ~ rust[fc84]::src::quotearg::quotearg_n)",
    "span": "src/quotearg.rs:1380:1: 1392:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1380:1: 1392:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:982 ~ rust[fc84]::src::quotearg::quotearg)",
        "span": "src/quotearg.rs:1407:5: 1407:41 (#0)",
        "source": "let result_ptr = quotearg_n(0, arg);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:178:1: 184:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1259 ~ rust[fc84]::src::xmalloc::_gl_alloc_nomem)",
    "span": "src/xmalloc.rs:107:1: 112:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:107:1: 112:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:1472 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:67:13: 67:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:1472 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:61:13: 61:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:1473 ~ rust[fc84]::src::xmalloc::ireallocarray)",
        "span": "src/xmalloc.rs:101:9: 101:37 (#0)",
        "source": "unsafe { _gl_alloc_nomem() }"
      },
      {
        "caller": "DefId(0:1471 ~ rust[fc84]::src::xmalloc::irealloc)",
        "span": "src/xmalloc.rs:51:5: 51:30 (#0)",
        "source": "return _gl_alloc_nomem();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1256 ~ rust[fc84]::src::xmalloc::irealloc)",
    "span": "src/xmalloc.rs:43:1: 53:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:43:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1481 ~ rust[fc84]::src::xmalloc::xirealloc)",
        "span": "src/xmalloc.rs:172:5: 172:30 (#0)",
        "source": "let ptr = irealloc(p, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:929 ~ rust[fc84]::src::setlocale_null::setlocale_null)",
    "span": "src/setlocale_null.rs:22:1: 31:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:22:1: 31:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/setlocale_null.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:45 ~ rust[fc84]::src::c_ctype::c_isprint)",
    "span": "src/c_ctype.rs:84:1: 86:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:84:1: 86:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:747 ~ rust[fc84]::src::open_safer::open_safer)",
    "span": "src/open_safer.rs:20:1: 32:2 (#0)",
    "pieces": [
      "src/open_safer.rs:20:1: 32:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "pub unsafe extern \"C\" fn open_safer(\n    mut file: *const libc::c_char,\n    mut flags: libc::c_int,\n    mut args: ...\n) -> libc::c_int {\n    let mut mode: mode_t = 0 as libc::c_int as mode_t;\n    if flags & 0o100 as libc::c_int != 0 {\n        let mut ap: ::core::ffi::VaListImpl;\n        ap = args.clone();\n        mode = ap.arg::<mode_t>();\n    }\n    return fd_safer(open(file, flags, mode));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/open_safer.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:215 ~ rust[fc84]::src::fd_safer_flag::fd_safer_flag)",
    "span": "src/fd_safer_flag.rs:12:1: 20:2 (#0)",
    "pieces": [
      "src/fd_safer_flag.rs:12:1: 20:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "pub unsafe extern \"C\" fn fd_safer_flag(\n    mut fd: libc::c_int,\n    mut flag: libc::c_int,\n) -> libc::c_int {\n    if 0 as libc::c_int <= fd && fd <= 2 as libc::c_int {\n        let mut f: libc::c_int = dup_safer_flag(fd, flag);\n        let mut e: libc::c_int = *__errno_location();\n        close(fd);\n        *__errno_location() = e;\n        fd = f;\n    }\n    return fd;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fd_safer_flag.rs:1:1: 1:41 (#0)",
        "source": "use std::os::unix::io::{AsRawFd, RawFd};"
      },
      {
        "span": "src/fd_safer_flag.rs:3:21: 3:30 (#0)",
        "source": "ErrorKind"
      },
      {
        "span": "src/fd_safer_flag.rs:1:34: 1:39 (#0)",
        "source": "RawFd"
      },
      {
        "span": "src/fd_safer_flag.rs:3:1: 3:32 (#0)",
        "source": "use std::io::{self, ErrorKind};"
      },
      {
        "span": "src/fd_safer_flag.rs:1:25: 1:32 (#0)",
        "source": "AsRawFd"
      },
      {
        "span": "src/fd_safer_flag.rs:3:15: 3:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/fd_safer_flag.rs:2:1: 2:19 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/fd_safer_flag.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:864 ~ rust[fc84]::src::quotearg::quotearg_free)",
    "span": "src/quotearg.rs:1280:1: 1299:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1280:1: 1299:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:1276:1: 1278:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1266:1: 1266:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      },
      {
        "span": "src/quotearg.rs:1265:1: 1265:50 (#0)",
        "source": "static mut slot0: [libc::c_char; 256] = [0; 256];"
      },
      {
        "span": "src/quotearg.rs:1267:1: 1275:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:233 ~ rust[fc84]::src::fflush::clear_ungetc_buffer_preserving_position)",
    "span": "src/fflush.rs:52:1: 56:2 (#0)",
    "pieces": [
      "src/fflush.rs:52:1: 56:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:300 ~ rust[fc84]::src::fflush::rpl_fflush)",
        "span": "src/fflush.rs:63:17: 63:60 (#0)",
        "source": "clear_ungetc_buffer_preserving_position(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/fflush.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:234 ~ rust[fc84]::src::fflush::rpl_fflush)",
    "span": "src/fflush.rs:59:1: 69:2 (#0)",
    "pieces": [
      "src/fflush.rs:59:1: 69:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/fflush.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:851 ~ rust[fc84]::src::quotearg::quoting_options_from_style)",
    "span": "src/quotearg.rs:271:1: 286:2 (#0)",
    "pieces": [
      "src/quotearg.rs:271:1: 286:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}",
    "calls": [
      {
        "caller": "DefId(0:993 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1515:5: 1515:45 (#0)",
        "source": "options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:984 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1425:5: 1425:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:985 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1437:5: 1437:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:90:1: 90:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:872 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
    "span": "src/quotearg.rs:1432:1: 1443:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1432:1: 1443:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:987 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
        "span": "src/quotearg.rs:1460:5: 1460:59 (#0)",
        "source": "let result_ptr = quotearg_n_style_mem(0, s, &arg_str);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:874 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
    "span": "src/quotearg.rs:1455:1: 1462:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1455:1: 1462:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:850 ~ rust[fc84]::src::quotearg::set_custom_quoting)",
    "span": "src/quotearg.rs:256:1: 270:2 (#0)",
    "pieces": [
      "src/quotearg.rs:256:1: 270:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}",
    "calls": [
      {
        "caller": "DefId(0:996 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1555:5: 1555:57 (#0)",
        "source": "set_custom_quoting(&mut o, left_quote, right_quote);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:178:1: 184:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:80:1: 80:52 (#0)",
        "source": "pub const custom_quoting_style: quoting_style = 10;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:883 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
    "span": "src/quotearg.rs:1547:1: 1557:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1547:1: 1557:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}",
    "calls": [
      {
        "caller": "DefId(0:995 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
        "span": "src/quotearg.rs:1538:5: 1544:7 (#0)",
        "source": "return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );"
      },
      {
        "caller": "DefId(0:998 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
        "span": "src/quotearg.rs:1587:41: 1595:6 (#0)",
        "source": "unsafe {\n        quotearg_n_custom_mem(\n            0,\n            left_quote.as_ptr() as *const libc::c_char,\n            right_quote.as_ptr() as *const libc::c_char,\n            arg.as_ptr() as *const libc::c_char,\n            argsize,\n        )\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:178:1: 184:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:882 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
    "span": "src/quotearg.rs:1532:1: 1545:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1532:1: 1545:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:997 ~ rust[fc84]::src::quotearg::quotearg_custom)",
        "span": "src/quotearg.rs:1568:18: 1575:6 (#0)",
        "source": "unsafe {\n        quotearg_n_custom(\n            0,\n            left_quote_c.as_ptr(),\n            right_quote_c.as_ptr(),\n            arg_c.as_ptr(),\n        )\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:884 ~ rust[fc84]::src::quotearg::quotearg_custom)",
    "span": "src/quotearg.rs:1559:1: 1578:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1559:1: 1578:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1267 ~ rust[fc84]::src::xmalloc::xreallocarray)",
    "span": "src/xmalloc.rs:176:1: 186:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:176:1: 186:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:1487 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
        "span": "src/xmalloc.rs:238:5: 238:32 (#0)",
        "source": "p = xreallocarray(p, n, s);"
      },
      {
        "caller": "DefId(0:1484 ~ rust[fc84]::src::xmalloc::xnmalloc)",
        "span": "src/xmalloc.rs:198:5: 198:56 (#0)",
        "source": "return xreallocarray(0 as *mut libc::c_void, n, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1269 ~ rust[fc84]::src::xmalloc::xnmalloc)",
    "span": "src/xmalloc.rs:197:1: 199:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:197:1: 199:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [
      {
        "caller": "DefId(0:1479 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:152:12: 154:6 (#0)",
        "source": "{\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1261 ~ rust[fc84]::src::xmalloc::check_nonnull)",
    "span": "src/xmalloc.rs:129:1: 134:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:129:1: 134:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:1481 ~ rust[fc84]::src::xmalloc::xirealloc)",
        "span": "src/xmalloc.rs:173:1: 173:27 (#0)",
        "source": "return check_nonnull(ptr);"
      },
      {
        "caller": "DefId(0:1483 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:194:1: 194:27 (#0)",
        "source": "return check_nonnull(ptr);"
      },
      {
        "caller": "DefId(0:1477 ~ rust[fc84]::src::xmalloc::xmalloc)",
        "span": "src/xmalloc.rs:139:1: 139:27 (#0)",
        "source": "return check_nonnull(ptr);"
      },
      {
        "caller": "DefId(0:1491 ~ rust[fc84]::src::xmalloc::xcalloc)",
        "span": "src/xmalloc.rs:964:1: 964:27 (#0)",
        "source": "return check_nonnull(ptr);"
      },
      {
        "caller": "DefId(0:1478 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:144:1: 144:27 (#0)",
        "source": "return check_nonnull(ptr);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1262 ~ rust[fc84]::src::xmalloc::xmalloc)",
    "span": "src/xmalloc.rs:137:1: 140:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:137:1: 140:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}",
    "calls": [
      {
        "caller": "DefId(0:1479 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:150:5: 152:6 (#0)",
        "source": "{\n        xmalloc(n)\n    }"
      },
      {
        "caller": "DefId(0:1493 ~ rust[fc84]::src::xmalloc::xmemdup)",
        "span": "src/xmalloc.rs:980:5: 980:37 (#0)",
        "source": "return memcpy(xmalloc(s), p, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1264 ~ rust[fc84]::src::xmalloc::xcharalloc)",
    "span": "src/xmalloc.rs:147:1: 155:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:147:1: 155:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:848 ~ rust[fc84]::src::quotearg::set_char_quoting)",
    "span": "src/quotearg.rs:219:1: 237:2 (#0)",
    "pieces": [
      "src/quotearg.rs:219:1: 237:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 30,
    "source": "pub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:993 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1516:5: 1516:63 (#0)",
        "source": "set_char_quoting(Some(&mut options), ':' as i32 as i8, 1);"
      },
      {
        "caller": "DefId(0:988 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1478:5: 1478:68 (#0)",
        "source": "let result = set_char_quoting(Some(&mut options), ch as i8, 1);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:178:1: 184:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:875 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
    "span": "src/quotearg.rs:1465:1: 1480:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1465:1: 1480:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}",
    "calls": [
      {
        "caller": "DefId(0:992 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
        "span": "src/quotearg.rs:1498:41: 1498:114 (#0)",
        "source": "unsafe { quotearg_char_mem(arg.as_ptr(), argsize, ':' as i32 as c_char) }"
      },
      {
        "caller": "DefId(0:990 ~ rust[fc84]::src::quotearg::quotearg_char)",
        "span": "src/quotearg.rs:1484:22: 1486:6 (#0)",
        "source": "unsafe {\n        quotearg_char_mem(arg.as_ptr(), 18446744073709551615 as libc::c_ulong, ch_as_c_char)\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:178:1: 184:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:90:1: 90:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:877 ~ rust[fc84]::src::quotearg::quotearg_char)",
    "span": "src/quotearg.rs:1482:1: 1488:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1482:1: 1488:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}",
    "calls": [
      {
        "caller": "DefId(0:991 ~ rust[fc84]::src::quotearg::quotearg_colon)",
        "span": "src/quotearg.rs:1491:46: 1493:2 (#0)",
        "source": "{\n    quotearg_char(arg, ':' as char)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1260 ~ rust[fc84]::src::xmalloc::imalloc)",
    "span": "src/xmalloc.rs:115:1: 127:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:115:1: 127:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1478 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:143:5: 143:70 (#0)",
        "source": "let ptr = imalloc(s.try_into().expect(\"Size conversion failed\"));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1263 ~ rust[fc84]::src::xmalloc::ximalloc)",
    "span": "src/xmalloc.rs:142:1: 145:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:142:1: 145:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1279 ~ rust[fc84]::src::xmalloc::ximemdup)",
    "span": "src/xmalloc.rs:983:1: 988:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:983:1: 988:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1313 ~ rust[fc84]::src::xstrtoimax::bkm_scale)",
    "span": "src/xstrtoimax.rs:41:1: 388:2 (#0)",
    "pieces": [
      "src/xstrtoimax.rs:41:1: 45:4 (#0)",
      "src/xstrtoimax.rs:388:1: 388:2 (#0)"
    ],
    "sub_chunks": [
      4
    ],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn bkm_scale(\n    mut x: *mut intmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n   <<chunk 4>>}",
    "calls": [
      {
        "caller": "DefId(0:1530 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:518:13: 518:50 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 1024);"
      },
      {
        "caller": "DefId(0:1530 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:548:13: 548:47 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 2);"
      },
      {
        "caller": "DefId(0:1530 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:515:13: 515:49 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 512);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoimax.rs:26:1: 26:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xstrtoimax.rs:27:1: 27:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoimax.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/xstrtoimax.rs:53:17: 127:18 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:53:17: 127:18 (#0)"
        ],
        "num_lines": 75,
        "source": "if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as intmax_t\n                    }) + scale_factor as libc::c_long\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (*x < -(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + -(1 as libc::c_int) as intmax_t\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as intmax_t / -scale_factor as libc::c_long\n                    }) <= -(1 as libc::c_int) as libc::c_long - *x) as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/xstrtoimax.rs:129:17: 232:18 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:129:17: 232:18 (#0)"
        ],
        "num_lines": 104,
        "source": "if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n                        as libc::c_long + 0 as libc::c_int as intmax_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        *x\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < *x + 0 as libc::c_int as intmax_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < *x\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < *x - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as intmax_t / scale_factor as libc::c_long) < *x)\n                        as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/xstrtoimax.rs:235:13: 351:14 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:235:13: 351:14 (#0)"
        ],
        "num_lines": 117,
        "source": "if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    *x\n                                }) + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < scale_factor as libc::c_long\n                                    + 0 as libc::c_int as intmax_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_long)\n                                as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as intmax_t / *x\n                            < scale_factor as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        < *x) as libc::c_int\n                }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/xstrtoimax.rs:363:9: 384:33 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:363:9: 384:33 (#0)"
        ],
        "num_lines": 22,
        "source": "*x = if *x < 0 as libc::c_int as libc::c_long {\n            !if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n                -(1 as libc::c_int) as intmax_t\n            } else {\n                (((1 as libc::c_int as intmax_t)\n                    << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            }\n        } else if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n            -(1 as libc::c_int) as intmax_t\n        } else {\n            (((1 as libc::c_int as intmax_t)\n                << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        };\n        return LONGINT_OVERFLOW;",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut i64"
        ],
        "live_out": [
          "mut x: *mut i64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/xstrtoimax.rs:45:5: 387:23 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:45:5: 53:16 (#0)",
          "src/xstrtoimax.rs:128:1: 129:16 (#0)",
          "src/xstrtoimax.rs:233:1: 235:12 (#0)",
          "src/xstrtoimax.rs:352:1: 363:8 (#0)",
          "src/xstrtoimax.rs:385:1: 387:23 (#0)"
        ],
        "num_lines": 29,
        "source": "let mut scaled: intmax_t = 0;\n    if if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { *x })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_long {\n               <<chunk 0>>            } else {\n               <<chunk 1>>            }\n        } else {\n           <<chunk 2>>        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n       <<chunk 3>>    }\n    *x = scaled;\n    return LONGINT_OK;",
        "sub_chunks": [
          0,
          1,
          2,
          3
        ],
        "live_in": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut i64",
          "mut scale_factor: i32",
          "mut scaled: i64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:1314 ~ rust[fc84]::src::xstrtoimax::bkm_scale_by_power)",
    "span": "src/xstrtoimax.rs:389:1: 402:2 (#0)",
    "pieces": [
      "src/xstrtoimax.rs:389:1: 402:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn bkm_scale_by_power(\n    mut x: *mut intmax_t,\n    mut base: libc::c_int,\n    mut power: libc::c_int,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    loop {\n        let fresh8 = power;\n        power = power - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);\n    }\n    return err;\n}",
    "calls": [
      {
        "caller": "DefId(0:1530 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:527:13: 527:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 3);"
      },
      {
        "caller": "DefId(0:1530 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:524:13: 524:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 6);"
      },
      {
        "caller": "DefId(0:1530 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:539:13: 539:63 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 10);"
      },
      {
        "caller": "DefId(0:1530 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:533:13: 533:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 2);"
      },
      {
        "caller": "DefId(0:1530 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:530:13: 530:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 1);"
      },
      {
        "caller": "DefId(0:1530 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:554:13: 554:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 7);"
      },
      {
        "caller": "DefId(0:1530 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:545:13: 545:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 4);"
      },
      {
        "caller": "DefId(0:1530 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:536:13: 536:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 5);"
      },
      {
        "caller": "DefId(0:1530 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:542:13: 542:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 9);"
      },
      {
        "caller": "DefId(0:1530 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:551:13: 551:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 8);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoimax.rs:27:1: 27:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoimax.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:734 ~ rust[fc84]::src::mkstemp_safer::mkstemp_safer)",
    "span": "src/mkstemp_safer.rs:12:1: 19:2 (#0)",
    "pieces": [
      "src/mkstemp_safer.rs:12:1: 19:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn mkstemp_safer(mut templ: *mut libc::c_char) -> libc::c_int {\n    return fd_safer(mkstemp(templ));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/mkstemp_safer.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/mkstemp_safer.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1036 ~ rust[fc84]::src::stdbit::__gl_stdbit_clzll)",
    "span": "src/stdbit.rs:33:1: 40:2 (#0)",
    "pieces": [
      "src/stdbit.rs:33:1: 40:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:5:1: 5:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdbit.rs:3:1: 3:14 (#0)",
        "source": "use std::u32;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1276 ~ rust[fc84]::src::xmalloc::xcalloc)",
    "span": "src/xmalloc.rs:962:1: 965:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:962:1: 965:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1274 ~ rust[fc84]::src::xmalloc::xzalloc)",
    "span": "src/xmalloc.rs:950:1: 953:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:950:1: 953:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1195 ~ rust[fc84]::src::xbinary_io::xset_binary_mode_error)",
    "span": "src/xbinary_io.rs:18:1: 44:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:18:1: 44:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 1,
    "source": "pub unsafe extern \"C\" fn xset_binary_mode_error() {}",
    "calls": [
      {
        "caller": "DefId(0:1369 ~ rust[fc84]::src::xbinary_io::xset_binary_mode)",
        "span": "src/xbinary_io.rs:11:9: 11:34 (#0)",
        "source": "xset_binary_mode_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:23:22: 23:29 (#0)",
        "source": "termios"
      },
      {
        "span": "src/xbinary_io.rs:22:5: 22:36 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:23:5: 23:39 (#0)",
        "source": "use libc::{self, termios, TCSETA};"
      },
      {
        "span": "src/xbinary_io.rs:21:25: 21:30 (#0)",
        "source": "Write"
      },
      {
        "span": "src/xbinary_io.rs:23:16: 23:20 (#0)",
        "source": "self"
      },
      {
        "span": "src/xbinary_io.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xbinary_io.rs:21:5: 21:32 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/xbinary_io.rs:21:19: 21:23 (#0)",
        "source": "self"
      },
      {
        "span": "src/xbinary_io.rs:23:31: 23:37 (#0)",
        "source": "TCSETA"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:147 ~ rust[fc84]::src::fadvise::fdadvise)",
    "span": "src/fadvise.rs:61:1: 68:2 (#0)",
    "pieces": [
      "src/fadvise.rs:61:1: 68:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn fdadvise(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut len: off_t,\n    mut advice: fadvice_t,\n) {\n    posix_fadvise(fd, offset, len, advice as libc::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:187 ~ rust[fc84]::src::fadvise::fadvise)",
        "span": "src/fadvise.rs:72:9: 77:11 (#0)",
        "source": "fdadvise(\n            fileno(fp),\n            0 as libc::c_int as off_t,\n            0 as libc::c_int as off_t,\n            advice,\n        );"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fadvise.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1178 ~ rust[fc84]::src::xalignalloc::alignalloc)",
    "span": "src/xalignalloc.rs:11:1: 21:2 (#0)",
    "pieces": [
      "src/xalignalloc.rs:11:1: 21:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn alignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    if (-(1 as libc::c_int) as size_t) < alignment as libc::c_ulong {\n        alignment = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    if (-(1 as libc::c_int) as size_t) < size as libc::c_ulong {\n        size = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    return aligned_alloc(alignment as libc::c_ulong, size as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:1351 ~ rust[fc84]::src::xalignalloc::xalignalloc)",
        "span": "src/xalignalloc.rs:28:5: 28:100 (#0)",
        "source": "let p: *mut libc::c_void = alignalloc(alignment.try_into().unwrap(), size.try_into().unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xalignalloc.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1121 ~ rust[fc84]::src::tmpdir::direxists)",
    "span": "src/tmpdir.rs:53:1: 75:2 (#0)",
    "pieces": [
      "src/tmpdir.rs:53:1: 75:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "unsafe extern \"C\" fn direxists(mut dir: *const libc::c_char) -> bool {\n    let mut buf: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    return stat(dir, &mut buf) == 0 as libc::c_int\n        && buf.st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o40000 as libc::c_int as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tmpdir.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:56 ~ rust[fc84]::src::c_strcasecmp::c_tolower)",
    "span": "src/c_strcasecmp.rs:4:1: 12:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:4:1: 12:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:57 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
    "span": "src/c_strcasecmp.rs:14:1: 30:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:14:1: 30:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "pub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:168 ~ rust[fc84]::src::fclose::rpl_fclose)",
    "span": "src/fclose.rs:54:1: 77:2 (#0)",
    "pieces": [
      "src/fclose.rs:54:1: 77:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fclose.rs:1:1: 1:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/fclose.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:42 ~ rust[fc84]::src::c_ctype::c_isdigit)",
    "span": "src/c_ctype.rs:58:1: 60:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:58:1: 60:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:302 ~ rust[fc84]::src::ialloc::ireallocarray)",
    "span": "src/ialloc.rs:28:1: 54:2 (#0)",
    "pieces": [
      "src/ialloc.rs:28:1: 54:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:6:1: 6:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/ialloc.rs:2:1: 2:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:868 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
    "span": "src/quotearg.rs:1395:1: 1403:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1395:1: 1403:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:983 ~ rust[fc84]::src::quotearg::quotearg_mem)",
        "span": "src/quotearg.rs:1417:1: 1417:36 (#0)",
        "source": "return quotearg_n_mem(0, arg_cstr);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:178:1: 184:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:51 ~ rust[fc84]::src::c_ctype::c_toupper)",
    "span": "src/c_ctype.rs:141:1: 148:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:141:1: 148:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:887 ~ rust[fc84]::src::quotearg::quote_n_mem)",
    "span": "src/quotearg.rs:1611:1: 1619:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1611:1: 1619:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:1002 ~ rust[fc84]::src::quotearg::quote_n)",
        "span": "src/quotearg.rs:1628:59: 1630:2 (#0)",
        "source": "{\n    quote_n_mem(n, arg)\n}"
      },
      {
        "caller": "DefId(0:1001 ~ rust[fc84]::src::quotearg::quote_mem)",
        "span": "src/quotearg.rs:1623:5: 1623:42 (#0)",
        "source": "let quoted_ptr = quote_n_mem(0, arg);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1600:1: 1609:3 (#0)",
        "source": "pub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:16 ~ rust[fc84]::src::alignalloc::alignfree)",
    "span": "src/alignalloc.rs:29:1: 33:2 (#0)",
    "pieces": [
      "src/alignalloc.rs:29:1: 33:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn alignfree(mut ptr: *mut libc::c_void) {\n    free(ptr);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/alignalloc.rs:1:1: 1:19 (#0)",
        "source": "use std::any::Any;"
      },
      {
        "span": "src/alignalloc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:50 ~ rust[fc84]::src::c_ctype::c_tolower)",
    "span": "src/c_ctype.rs:129:1: 136:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:129:1: 136:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1038 ~ rust[fc84]::src::stdbit::__gl_stdbit_ctzl)",
    "span": "src/stdbit.rs:55:1: 61:2 (#0)",
    "pieces": [
      "src/stdbit.rs:55:1: 61:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_ctzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:3:1: 3:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:5:1: 5:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1045 ~ rust[fc84]::src::stdc_leading_zeros::__gl_stdbit_clzl)",
    "span": "src/stdc_leading_zeros.rs:23:1: 29:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:23:1: 29:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn __gl_stdbit_clzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:1184 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ul)",
        "span": "src/stdc_leading_zeros.rs:70:5: 70:39 (#0)",
        "source": "return __gl_stdbit_clzl(n) as u32;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1050 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ul)",
    "span": "src/stdc_leading_zeros.rs:69:1: 71:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:69:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_ul(mut n: libc::c_ulong) -> libc::c_uint {\n    return __gl_stdbit_clzl(n) as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:769 ~ rust[fc84]::src::progname::set_program_name)",
    "span": "src/progname.rs:62:1: 90:2 (#0)",
    "pieces": [
      "src/progname.rs:62:1: 90:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "pub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/progname.rs:60:1: 60:77 (#0)",
        "source": "pub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/progname.rs:2:1: 2:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/progname.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/progname.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:778 ~ rust[fc84]::src::propername_lite::proper_name_lite)",
    "span": "src/propername_lite.rs:8:1: 24:2 (#0)",
    "pieces": [
      "src/propername_lite.rs:8:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "pub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/propername_lite.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1093 ~ rust[fc84]::src::temp_stream::record_or_unlink_tempfile)",
    "span": "src/temp_stream.rs:92:1: 94:2 (#0)",
    "pieces": [
      "src/temp_stream.rs:92:1: 94:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn record_or_unlink_tempfile(\n    mut fn_0: *const libc::c_char,\n    mut _fp: *mut FILE,\n) {\n    unlink(fn_0);\n}",
    "calls": [
      {
        "caller": "DefId(0:1240 ~ rust[fc84]::src::temp_stream::temp_stream)",
        "span": "src/temp_stream.rs:217:9: 217:100 (#0)",
        "source": "record_or_unlink_tempfile(unsafe { std::ffi::CStr::from_ptr(tempfile).to_str().unwrap() });"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/temp_stream.rs:105:1: 105:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/temp_stream.rs:101:29: 101:33 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/temp_stream.rs:103:1: 103:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/temp_stream.rs:7:1: 7:13 (#0)",
        "source": "use std::fs;"
      },
      {
        "span": "src/temp_stream.rs:9:1: 9:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/temp_stream.rs:101:5: 101:35 (#0)",
        "source": "use std::ffi::{CString, CStr};"
      },
      {
        "span": "src/temp_stream.rs:4:1: 4:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/temp_stream.rs:103:15: 103:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/temp_stream.rs:104:1: 104:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/temp_stream.rs:6:1: 6:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/temp_stream.rs:3:1: 3:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "src/temp_stream.rs:101:20: 101:27 (#0)",
        "source": "CString"
      },
      {
        "span": "src/temp_stream.rs:103:21: 103:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/temp_stream.rs:102:1: 102:19 (#0)",
        "source": "use std::fs::File;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1235 ~ rust[fc84]::src::xdectoumax::xnumtoumax)",
    "span": "src/xdectoumax.rs:51:1: 96:2 (#0)",
    "pieces": [
      "src/xdectoumax.rs:51:1: 96:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 96,
    "source": "pub unsafe extern \"C\" fn xnumtoumax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: uintmax_t = 0;\n    s_err = xstrtoumax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_ulong {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}",
    "calls": [
      {
        "caller": "DefId(0:1435 ~ rust[fc84]::src::xdectoumax::xdectoumax)",
        "span": "src/xdectoumax.rs:39:5: 47:3 (#0)",
        "source": "let result = xnumtoumax(\n    std::ffi::CStr::from_ptr(n_str).to_str().unwrap(),\n    10,\n    min,\n    max,\n    suffixes.as_ref().map(|s| std::ffi::CStr::from_ptr(s).to_str().unwrap()),\n    std::ffi::CStr::from_ptr(err).to_str().unwrap(),\n    err_exit,\n);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xdectoumax.rs:2:1: 2:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/xdectoumax.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/xdectoumax.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1234 ~ rust[fc84]::src::xdectoumax::xdectoumax)",
    "span": "src/xdectoumax.rs:31:1: 49:2 (#0)",
    "pieces": [
      "src/xdectoumax.rs:31:1: 49:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xdectoumax(\n    mut n_str: *const libc::c_char,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    return xnumtoumax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xdectoumax.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/xdectoumax.rs:2:1: 2:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/xdectoumax.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1025 ~ rust[fc84]::src::sig2str::str2signum)",
    "span": "src/sig2str.rs:381:1: 449:2 (#0)",
    "pieces": [
      "src/sig2str.rs:381:1: 449:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 69,
    "source": "unsafe extern \"C\" fn str2signum(mut signame: *const libc::c_char) -> libc::c_int {\n    if (*signame as libc::c_uint).wrapping_sub('0' as i32 as libc::c_uint)\n        <= 9 as libc::c_int as libc::c_uint\n    {\n        let mut endp: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut n: libc::c_long = strtol(signame, &mut endp, 10 as libc::c_int);\n        if *endp == 0\n            && n\n                <= (64 as libc::c_int + 1 as libc::c_int - 1 as libc::c_int)\n                    as libc::c_long\n        {\n            return n as libc::c_int;\n        }\n    } else {\n        let mut i: libc::c_uint = 0;\n        i = 0 as libc::c_int as libc::c_uint;\n        while (i as libc::c_ulong)\n            < (::core::mem::size_of::<[numname; 35]>() as libc::c_ulong)\n                .wrapping_div(::core::mem::size_of::<numname>() as libc::c_ulong)\n        {\n            if strcmp((numname_table[i as usize].name).as_ptr(), signame)\n                == 0 as libc::c_int\n            {\n                return numname_table[i as usize].num;\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        let mut endp_0: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut rtmin: libc::c_int = __libc_current_sigrtmin();\n        let mut rtmax: libc::c_int = __libc_current_sigrtmax();\n        if (0 as libc::c_int) < rtmin\n            && strncmp(\n                signame,\n                b\"RTMIN\\0\" as *const u8 as *const libc::c_char,\n                5 as libc::c_int as libc::c_ulong,\n            ) == 0 as libc::c_int\n        {\n            let mut n_0: libc::c_long = strtol(\n                signame.offset(5 as libc::c_int as isize),\n                &mut endp_0,\n                10 as libc::c_int,\n            );\n            if *endp_0 == 0 && 0 as libc::c_int as libc::c_long <= n_0\n                && n_0 <= (rtmax - rtmin) as libc::c_long\n            {\n                return (rtmin as libc::c_long + n_0) as libc::c_int;\n            }\n        } else if (0 as libc::c_int) < rtmax\n            && strncmp(\n                signame,\n                b\"RTMAX\\0\" as *const u8 as *const libc::c_char,\n                5 as libc::c_int as libc::c_ulong,\n            ) == 0 as libc::c_int\n        {\n            let mut n_1: libc::c_long = strtol(\n                signame.offset(5 as libc::c_int as isize),\n                &mut endp_0,\n                10 as libc::c_int,\n            );\n            if *endp_0 == 0 && (rtmin - rtmax) as libc::c_long <= n_1\n                && n_1 <= 0 as libc::c_int as libc::c_long\n            {\n                return (rtmax as libc::c_long + n_1) as libc::c_int;\n            }\n        }\n    }\n    return -(1 as libc::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:1146 ~ rust[fc84]::src::sig2str::str2sig)",
        "span": "src/sig2str.rs:454:9: 454:50 (#0)",
        "source": "*signum = str2signum(c_signame.as_ptr());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/sig2str.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/sig2str.rs:1:1: 1:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1027 ~ rust[fc84]::src::sig2str::str2sig)",
    "span": "src/sig2str.rs:451:1: 461:2 (#0)",
    "pieces": [
      "src/sig2str.rs:451:1: 461:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn str2sig(\n    mut signame: *const libc::c_char,\n    mut signum: *mut libc::c_int,\n) -> libc::c_int {\n    *signum = str2signum(signame);\n    return if *signum < 0 as libc::c_int {\n        -(1 as libc::c_int)\n    } else {\n        0 as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/sig2str.rs:1:1: 1:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/sig2str.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1351 ~ rust[fc84]::src::xstrtoumax::bkm_scale)",
    "span": "src/xstrtoumax.rs:43:1: 352:2 (#0)",
    "pieces": [
      "src/xstrtoumax.rs:43:1: 47:4 (#0)",
      "src/xstrtoumax.rs:352:1: 352:2 (#0)"
    ],
    "sub_chunks": [
      4
    ],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn bkm_scale(\n    mut x: *mut uintmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n   <<chunk 4>>}",
    "calls": [
      {
        "caller": "DefId(0:1571 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:515:13: 515:47 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 2);"
      },
      {
        "caller": "DefId(0:1571 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:485:13: 485:50 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 1024);"
      },
      {
        "caller": "DefId(0:1571 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:482:13: 482:49 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 512);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoumax.rs:28:1: 28:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xstrtoumax.rs:29:1: 29:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoumax.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xstrtoumax.rs:3:1: 3:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/xstrtoumax.rs:56:17: 137:18 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:56:17: 137:18 (#0)"
        ],
        "num_lines": 82,
        "source": "if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        -(1 as libc::c_int) as uintmax_t\n                    })\n                        .wrapping_add(scale_factor as libc::c_ulong)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    (*x\n                        < (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(scale_factor as libc::c_ulong)) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(-(1 as libc::c_int) as uintmax_t)\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(-scale_factor as libc::c_ulong)\n                    }) <= (-(1 as libc::c_int) as libc::c_ulong).wrapping_sub(*x))\n                        as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut u64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut u64",
          "mut scale_factor: i32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/xstrtoumax.rs:139:17: 177:2 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:139:17: 177:2 (#0)"
        ],
        "num_lines": 127,
        "source": "if (if (if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    !((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                }) < 0 as libc::c_int as libc::c_ulong\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                        < (if (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_ulong)\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            < 0 as libc::c_int as libc::c_ulong\n                        {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                << (::core::mem::size_of::<libc::c_ulong>()\n                                    as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        })\n                            .wrapping_neg()) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_ulong)\n                        < ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        *x\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (*x).wrapping_add(0 as libc::c_int as uintmax_t))\n                            as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong) < *x\n                            && (-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (*x).wrapping_sub(1 as libc::c_int as libc::c_ulong))\n                            as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut u64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut u64",
          "mut scale_factor: i32",
          "scale_factor_value: i32",
          "x_value: u64",
          "condition1: bool",
          "condition2: u64",
          "result: i32"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/xstrtoumax.rs:181:13: 313:14 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:181:13: 313:14 (#0)"
        ],
        "num_lines": 133,
        "source": "if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_ulong {\n                    if (if (if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        !((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                    }) < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                            < (if (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    *x\n                                })\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                < 0 as libc::c_int as libc::c_ulong\n                            {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                    << (::core::mem::size_of::<libc::c_ulong>()\n                                        as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            })\n                                .wrapping_neg()) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_ulong\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_ulong)\n                                < (scale_factor as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_ulong)\n                                as libc::c_int\n                        }\n                    } else {\n                        ((0 as libc::c_int as uintmax_t).wrapping_div(*x)\n                            < scale_factor as libc::c_ulong) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut u64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut u64",
          "mut scale_factor: i32"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/xstrtoumax.rs:325:9: 348:33 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:325:9: 348:33 (#0)"
        ],
        "num_lines": 24,
        "source": "*x = if *x < 0 as libc::c_int as libc::c_ulong {\n            !if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n                -(1 as libc::c_int) as uintmax_t\n            } else {\n                ((1 as libc::c_int as uintmax_t)\n                    << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            }\n        } else if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n            -(1 as libc::c_int) as uintmax_t\n        } else {\n            ((1 as libc::c_int as uintmax_t)\n                << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        };\n        return LONGINT_OVERFLOW;",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut u64"
        ],
        "live_out": [
          "mut x: *mut u64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/xstrtoumax.rs:47:5: 351:23 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:47:5: 56:16 (#0)",
          "src/xstrtoumax.rs:138:1: 139:16 (#0)",
          "src/xstrtoumax.rs:179:1: 181:12 (#0)",
          "src/xstrtoumax.rs:314:1: 325:8 (#0)",
          "src/xstrtoumax.rs:349:1: 351:23 (#0)"
        ],
        "num_lines": 30,
        "source": "let mut scaled: uintmax_t = 0;\n    if if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t\n        && (if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_ulong } else { *x })\n            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n            < 0 as libc::c_int as libc::c_ulong\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_ulong {\n               <<chunk 0>>            } else {\n               <<chunk 1>>            }\n        } else {\n           <<chunk 2>>        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n       <<chunk 3>>    }\n    *x = scaled;\n    return LONGINT_OK;",
        "sub_chunks": [
          0,
          1,
          2,
          3
        ],
        "live_in": [
          "mut x: *mut u64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut u64",
          "mut scale_factor: i32",
          "mut scaled: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:1352 ~ rust[fc84]::src::xstrtoumax::bkm_scale_by_power)",
    "span": "src/xstrtoumax.rs:353:1: 369:2 (#0)",
    "pieces": [
      "src/xstrtoumax.rs:353:1: 369:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn bkm_scale_by_power(\n    mut x: *mut uintmax_t,\n    mut base: libc::c_int,\n    mut power: libc::c_int,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    loop {\n        let fresh8 = power;\n        power = power - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);\n    }\n    return err;\n}",
    "calls": [
      {
        "caller": "DefId(0:1571 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:500:13: 500:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 2);"
      },
      {
        "caller": "DefId(0:1571 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:497:13: 497:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 1);"
      },
      {
        "caller": "DefId(0:1571 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:521:13: 521:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 7);"
      },
      {
        "caller": "DefId(0:1571 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:494:13: 494:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 3);"
      },
      {
        "caller": "DefId(0:1571 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:518:13: 518:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 8);"
      },
      {
        "caller": "DefId(0:1571 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:509:13: 509:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 9);"
      },
      {
        "caller": "DefId(0:1571 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:503:13: 503:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 5);"
      },
      {
        "caller": "DefId(0:1571 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:506:13: 506:63 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 10);"
      },
      {
        "caller": "DefId(0:1571 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:512:13: 512:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 4);"
      },
      {
        "caller": "DefId(0:1571 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:491:13: 491:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 6);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoumax.rs:29:1: 29:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoumax.rs:3:1: 3:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/xstrtoumax.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1353 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
    "span": "src/xstrtoumax.rs:372:1: 538:2 (#0)",
    "pieces": [
      "src/xstrtoumax.rs:372:1: 379:4 (#0)",
      "src/xstrtoumax.rs:449:1: 449:4 (#0)",
      "src/xstrtoumax.rs:538:1: 538:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xstrtoumax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut uintmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [],
    "globals": [
      {
        "span": "src/xstrtoumax.rs:28:1: 28:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xstrtoumax.rs:27:1: 27:57 (#0)",
        "source": "pub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;"
      },
      {
        "span": "src/xstrtoumax.rs:29:1: 29:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      },
      {
        "span": "src/xstrtoumax.rs:25:1: 25:45 (#0)",
        "source": "pub const LONGINT_INVALID: strtol_error = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoumax.rs:3:1: 3:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/xstrtoumax.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/xstrtoumax.rs:379:5: 448:6 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:379:5: 448:6 (#0)"
        ],
        "num_lines": 70,
        "source": "let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: uintmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 79],\n                &[libc::c_char; 79],\n            >(\n                b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2256: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 79],\n                    &[libc::c_char; 79],\n                >(\n                    b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoumax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as uintmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *const i8",
          "mut ptr: *mut *mut i8",
          "mut strtol_base: i32",
          "mut val: *mut u64",
          "mut valid_suffixes: *const i8"
        ],
        "live_out": [
          "mut s: *const i8",
          "mut ptr: *mut *mut i8",
          "mut strtol_base: i32",
          "mut val: *mut u64",
          "mut valid_suffixes: *const i8",
          "mut t_ptr: *mut i8",
          "mut p: *mut *mut i8",
          "mut tmp: u64",
          "mut err: u32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/xstrtoumax.rs:449:5: 536:12 (#0)",
        "pieces": [
          "src/xstrtoumax.rs:449:5: 536:12 (#0)"
        ],
        "num_lines": 102,
        "source": "if **p as libc::c_int != '\\0' as i32 {\n        let mut base: libc::c_int = 1024 as libc::c_int;\n        let mut suffixes: libc::c_int = 1 as libc::c_int;\n        let mut overflow: strtol_error = LONGINT_OK;\n        if (strchr(valid_suffixes, **p as libc::c_int)).is_null() {\n            *val = tmp;\n            return (err as libc::c_uint\n                | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                as strtol_error;\n        }\n        match **p as libc::c_int {\n            69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n                if !(strchr(valid_suffixes, '0' as i32)).is_null() {\n                    match *(*p.offset(0 as libc::c_int as isize))\n                        .offset(1 as libc::c_int as isize) as libc::c_int\n                    {\n                        105 => {\n                            if *(*p.offset(0 as libc::c_int as isize))\n                                .offset(2 as libc::c_int as isize) as libc::c_int\n                                == 'B' as i32\n                            {\n                                suffixes += 2 as libc::c_int;\n                            }\n                        }\n                        66 | 68 => {\n                            base = 1000 as libc::c_int;\n                            suffixes += 1;\n                            suffixes;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n            _ => {}\n        }\n        match **p as libc::c_int {\n            98 => {\n                overflow = bkm_scale(&mut tmp, 512 as libc::c_int);\n            }\n            66 => {\n                overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);\n            }\n            99 => {\n                overflow = LONGINT_OK;\n            }\n            69 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);\n            }\n            71 | 103 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);\n            }\n            107 | 75 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);\n            }\n            77 | 109 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);\n            }\n            80 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);\n            }\n            81 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);\n            }\n            82 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);\n            }\n            84 | 116 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);\n            }\n            119 => {\n                overflow = bkm_scale(&mut tmp, 2 as libc::c_int);\n            }\n            89 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);\n            }\n            90 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);\n            }\n            _ => {\n                *val = tmp;\n                return (err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                    as strtol_error;\n            }\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | overflow as libc::c_uint);\n        *p = (*p).offset(suffixes as isize);\n        if **p != 0 {\n            err = ::core::mem::transmute::<\n                libc::c_uint,\n                strtol_error,\n            >(\n                err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint,\n            );\n        }\n    }\n    *val = tmp;\n    return err;",
        "sub_chunks": [],
        "live_in": [
          "mut val: *mut u64",
          "mut valid_suffixes: *const i8",
          "mut p: *mut *mut i8",
          "mut tmp: u64",
          "mut err: u32"
        ],
        "live_out": [
          "mut val: *mut u64",
          "mut valid_suffixes: *const i8",
          "mut p: *mut *mut i8",
          "mut tmp: u64",
          "mut err: u32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:1044 ~ rust[fc84]::src::stdc_leading_zeros::__gl_stdbit_clz)",
    "span": "src/stdc_leading_zeros.rs:14:1: 20:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:14:1: 20:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn __gl_stdbit_clz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1280 ~ rust[fc84]::src::xmalloc::ximemdup0)",
    "span": "src/xmalloc.rs:991:1: 997:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:991:1: 997:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:180 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD)",
    "span": "src/fcntl.rs:87:1: 91:2 (#0)",
    "pieces": [
      "src/fcntl.rs:87:1: 91:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn rpl_fcntl_DUPFD(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    result = fcntl(fd, 0 as libc::c_int, target);\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:227 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD_CLOEXEC)",
        "span": "src/fcntl.rs:110:13: 110:50 (#0)",
        "source": "result = rpl_fcntl_DUPFD(fd, target);"
      },
      {
        "caller": "DefId(0:224 ~ rust[fc84]::src::fcntl::rpl_fcntl)",
        "span": "src/fcntl.rs:36:13: 36:50 (#0)",
        "source": "result = rpl_fcntl_DUPFD(fd, target);"
      },
      {
        "caller": "DefId(0:227 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD_CLOEXEC)",
        "span": "src/fcntl.rs:104:17: 104:54 (#0)",
        "source": "result = rpl_fcntl_DUPFD(fd, target);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fcntl.rs:3:1: 3:22 (#0)",
        "source": "use std::ffi::VaList;"
      },
      {
        "span": "src/fcntl.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:182 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD_CLOEXEC)",
    "span": "src/fcntl.rs:94:1: 124:2 (#0)",
    "pieces": [
      "src/fcntl.rs:94:1: 124:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 32,
    "source": "unsafe extern \"C\" fn rpl_fcntl_DUPFD_CLOEXEC(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    if 0 as libc::c_int <= have_dupfd_cloexec {\n        result = fcntl(fd, 1030 as libc::c_int, target);\n        if 0 as libc::c_int <= result || *__errno_location() != 22 as libc::c_int {\n            have_dupfd_cloexec = 1 as libc::c_int;\n        } else {\n            result = rpl_fcntl_DUPFD(fd, target);\n            if result >= 0 as libc::c_int {\n                have_dupfd_cloexec = -(1 as libc::c_int);\n            }\n        }\n    } else {\n        result = rpl_fcntl_DUPFD(fd, target);\n    }\n    if 0 as libc::c_int <= result && have_dupfd_cloexec == -(1 as libc::c_int) {\n        let mut flags: libc::c_int = fcntl(result, 1 as libc::c_int);\n        if flags < 0 as libc::c_int\n            || fcntl(result, 2 as libc::c_int, flags | 1 as libc::c_int)\n                == -(1 as libc::c_int)\n        {\n            let mut saved_errno: libc::c_int = *__errno_location();\n            close(result);\n            *__errno_location() = saved_errno;\n            result = -(1 as libc::c_int);\n        }\n    }\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:224 ~ rust[fc84]::src::fcntl::rpl_fcntl)",
        "span": "src/fcntl.rs:43:13: 43:58 (#0)",
        "source": "result = rpl_fcntl_DUPFD_CLOEXEC(fd, target);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fcntl.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fcntl.rs:3:1: 3:22 (#0)",
        "source": "use std::ffi::VaList;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:179 ~ rust[fc84]::src::fcntl::rpl_fcntl)",
    "span": "src/fcntl.rs:23:1: 85:2 (#0)",
    "pieces": [
      "src/fcntl.rs:23:1: 85:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 136,
    "source": "pub unsafe extern \"C\" fn rpl_fcntl(\n    mut fd: libc::c_int,\n    mut action: libc::c_int,\n    mut args: ...\n) -> libc::c_int {\n    let mut arg: ::core::ffi::VaListImpl;\n    let mut result: libc::c_int = -(1 as libc::c_int);\n    arg = args.clone();\n    match action {\n        0 => {\n            let mut target: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD(fd, target);\n        }\n        1030 => {\n            let mut target_0: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD_CLOEXEC(fd, target_0);\n        }\n        _ => {\n            let mut current_block_7: u64;\n            match action {\n                1 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                3 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                1025 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                9 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                1032 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                1034 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                11 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                1033 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                0 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                1030 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                1026 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                2 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                4 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                8 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1031 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1024 | 10 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {\n                    let mut p: *mut libc::c_void = arg.arg::<*mut libc::c_void>();\n                    result = fcntl(fd, action, p);\n                    current_block_7 = 7175849428784450219;\n                }\n            }\n            match current_block_7 {\n                4046302689674688614 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                8871774344836507656 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                12013198723313890981 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6453289516101043606 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                5351856672558463576 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                13722137258147953758 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                9332010126091029806 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                12766345184754617216 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                17966572639739034653 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6940526744265269810 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                15280576717888187136 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                7022052692272556539 => {\n                    result = fcntl(fd, action);\n                }\n                14034191772621753005 => {\n                    let mut x: libc::c_int = arg.arg::<libc::c_int>();\n                    result = fcntl(fd, action, x);\n                }\n                _ => {}\n            }\n        }\n    }\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fcntl.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fcntl.rs:3:1: 3:22 (#0)",
        "source": "use std::ffi::VaList;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:75 ~ rust[fc84]::src::close_stream::close_stream)",
    "span": "src/close_stream.rs:51:1: 63:2 (#0)",
    "pieces": [
      "src/close_stream.rs:51:1: 63:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/close_stream.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1197 ~ rust[fc84]::src::xbinary_io::__gl_setmode)",
    "span": "src/xbinary_io.rs:55:1: 60:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:55:1: 60:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:1391 ~ rust[fc84]::src::xbinary_io::set_binary_mode)",
        "span": "src/xbinary_io.rs:51:5: 51:41 (#0)",
        "source": "let result = __gl_setmode(fd, mode);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:23:31: 23:37 (#0)",
        "source": "TCSETA"
      },
      {
        "span": "src/xbinary_io.rs:23:5: 23:39 (#0)",
        "source": "use libc::{self, termios, TCSETA};"
      },
      {
        "span": "src/xbinary_io.rs:21:5: 21:32 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/xbinary_io.rs:22:5: 22:36 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:21:25: 21:30 (#0)",
        "source": "Write"
      },
      {
        "span": "src/xbinary_io.rs:23:22: 23:29 (#0)",
        "source": "termios"
      },
      {
        "span": "src/xbinary_io.rs:23:16: 23:20 (#0)",
        "source": "self"
      },
      {
        "span": "src/xbinary_io.rs:21:19: 21:23 (#0)",
        "source": "self"
      },
      {
        "span": "src/xbinary_io.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:37 ~ rust[fc84]::src::c_ctype::c_isalnum)",
    "span": "src/c_ctype.rs:21:1: 23:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:21:1: 23:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1257 ~ rust[fc84]::src::xmalloc::icalloc)",
    "span": "src/xmalloc.rs:55:1: 76:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:55:1: 76:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1277 ~ rust[fc84]::src::xmalloc::xicalloc)",
    "span": "src/xmalloc.rs:967:1: 973:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:967:1: 973:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1275 ~ rust[fc84]::src::xmalloc::xizalloc)",
    "span": "src/xmalloc.rs:956:1: 959:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:956:1: 959:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:714 ~ rust[fc84]::src::mbrtoc32::mbszero)",
    "span": "src/mbrtoc32.rs:36:1: 42:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:36:1: 42:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:797 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
        "span": "src/mbrtoc32.rs:64:9: 64:21 (#0)",
        "source": "mbszero(ps);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1153 ~ rust[fc84]::src::version_etc::version_etc_arn)",
    "span": "src/version_etc.rs:67:1: 249:2 (#0)",
    "pieces": [
      "src/version_etc.rs:67:1: 75:4 (#0)",
      "src/version_etc.rs:107:1: 107:4 (#0)",
      "src/version_etc.rs:249:1: 249:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:1327 ~ rust[fc84]::src::version_etc::version_etc_va)",
        "span": "src/version_etc.rs:286:5: 293:7 (#0)",
        "source": "version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );"
      },
      {
        "caller": "DefId(0:1326 ~ rust[fc84]::src::version_etc::version_etc_ar)",
        "span": "src/version_etc.rs:264:5: 264:81 (#0)",
        "source": "version_etc_arn(stream, command_name, package, version, authors, n_authors);"
      }
    ],
    "globals": [
      {
        "span": "src/version_etc.rs:64:1: 64:48 (#0)",
        "source": "pub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;"
      }
    ],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/version_etc.rs:75:5: 106:73 (#0)",
        "pieces": [
          "src/version_etc.rs:75:5: 106:73 (#0)"
        ],
        "num_lines": 32,
        "source": "if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);",
        "sub_chunks": [],
        "live_in": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut command_name: *const i8",
          "mut package: *const i8",
          "mut version: *const i8"
        ],
        "live_out": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut command_name: *const i8",
          "mut package: *const i8",
          "mut version: *const i8"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/version_etc.rs:107:5: 248:7 (#0)",
        "pieces": [
          "src/version_etc.rs:107:5: 248:7 (#0)"
        ],
        "num_lines": 142,
        "source": "match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };",
        "sub_chunks": [],
        "live_in": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut authors: *const *const i8",
          "mut n_authors: u64"
        ],
        "live_out": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut authors: *const *const i8",
          "mut n_authors: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:1155 ~ rust[fc84]::src::version_etc::version_etc_va)",
    "span": "src/version_etc.rs:267:1: 294:2 (#0)",
    "pieces": [
      "src/version_etc.rs:267:1: 294:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "pub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:1330 ~ rust[fc84]::src::version_etc::version_etc)",
        "span": "src/version_etc.rs:305:5: 305:82 (#0)",
        "source": "version_etc_va(stream, command_name, package, version, authors.as_va_list());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1158 ~ rust[fc84]::src::version_etc::version_etc)",
    "span": "src/version_etc.rs:296:1: 306:2 (#0)",
    "pieces": [
      "src/version_etc.rs:296:1: 306:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:46 ~ rust[fc84]::src::c_ctype::c_ispunct)",
    "span": "src/c_ctype.rs:91:1: 98:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:91:1: 98:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:854 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
    "span": "src/quotearg.rs:1178:1: 1206:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1178:1: 1206:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:178:1: 184:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1258 ~ rust[fc84]::src::xmalloc::ireallocarray)",
    "span": "src/xmalloc.rs:79:1: 103:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:79:1: 103:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1483 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:193:5: 193:56 (#0)",
        "source": "let ptr = ireallocarray(p, n as usize, s as usize);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1268 ~ rust[fc84]::src::xmalloc::xireallocarray)",
    "span": "src/xmalloc.rs:188:1: 195:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:188:1: 195:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:43 ~ rust[fc84]::src::c_ctype::c_isgraph)",
    "span": "src/c_ctype.rs:65:1: 72:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:65:1: 72:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:206 ~ rust[fc84]::src::fd_safer::fd_safer)",
    "span": "src/fd_safer.rs:9:1: 19:2 (#0)",
    "pieces": [
      "src/fd_safer.rs:9:1: 19:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn fd_safer(mut fd: libc::c_int) -> libc::c_int {\n    if 0 as libc::c_int <= fd && fd <= 2 as libc::c_int {\n        let mut f: libc::c_int = dup_safer(fd);\n        let mut e: libc::c_int = *__errno_location();\n        close(fd);\n        *__errno_location() = e;\n        fd = f;\n    }\n    return fd;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fd_safer.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:856 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
    "span": "src/quotearg.rs:1217:1: 1264:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1217:1: 1264:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}",
    "calls": [
      {
        "caller": "DefId(0:968 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
        "span": "src/quotearg.rs:1214:5: 1214:66 (#0)",
        "source": "return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:94:1: 94:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      },
      {
        "span": "src/quotearg.rs:178:1: 184:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1270 ~ rust[fc84]::src::xmalloc::xinmalloc)",
    "span": "src/xmalloc.rs:201:1: 205:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:201:1: 205:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:15 ~ rust[fc84]::src::alignalloc::alignalloc)",
    "span": "src/alignalloc.rs:14:1: 25:2 (#0)",
    "pieces": [
      "src/alignalloc.rs:14:1: 25:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn alignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    if (-(1 as libc::c_int) as size_t) < alignment as libc::c_ulong {\n        alignment = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    if (-(1 as libc::c_int) as size_t) < size as libc::c_ulong {\n        size = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    return aligned_alloc(alignment as libc::c_ulong, size as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/alignalloc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/alignalloc.rs:1:1: 1:19 (#0)",
        "source": "use std::any::Any;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:104 ~ rust[fc84]::src::closeout::close_stdout)",
    "span": "src/closeout.rs:81:1: 157:2 (#0)",
    "pieces": [
      "src/closeout.rs:81:1: 157:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 96,
    "source": "pub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:66:1: 66:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:1:1: 1:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/closeout.rs:3:1: 3:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/closeout.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:4:1: 4:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:148 ~ rust[fc84]::src::fadvise::fadvise)",
    "span": "src/fadvise.rs:70:1: 79:2 (#0)",
    "pieces": [
      "src/fadvise.rs:70:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn fadvise(mut fp: *mut FILE, mut advice: fadvice_t) {\n    if !fp.is_null() {\n        fdadvise(\n            fileno(fp),\n            0 as libc::c_int as off_t,\n            0 as libc::c_int as off_t,\n            advice,\n        );\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fadvise.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:735 ~ rust[fc84]::src::mkstemp_safer::mkostemp_safer)",
    "span": "src/mkstemp_safer.rs:22:1: 27:2 (#0)",
    "pieces": [
      "src/mkstemp_safer.rs:22:1: 27:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn mkostemp_safer(\n    mut templ: *mut libc::c_char,\n    mut flags: libc::c_int,\n) -> libc::c_int {\n    return fd_safer_flag(mkostemp(templ, flags), flags);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/mkstemp_safer.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/mkstemp_safer.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:716 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
    "span": "src/mbrtoc32.rs:48:1: 78:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:48:1: 78:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 31,
    "source": "pub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/mbrtoc32.rs:43:1: 46:3 (#0)",
        "source": "static mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};"
      }
    ],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:44 ~ rust[fc84]::src::c_ctype::c_islower)",
    "span": "src/c_ctype.rs:77:1: 79:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:77:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:101 ~ rust[fc84]::src::closeout::close_stdout_set_file_name)",
    "span": "src/closeout.rs:68:1: 73:2 (#0)",
    "pieces": [
      "src/closeout.rs:68:1: 73:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:66:1: 66:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:1:1: 1:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/closeout.rs:4:1: 4:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/closeout.rs:3:1: 3:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/closeout.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:111 ~ rust[fc84]::src::dup_safer::dup_safer)",
    "span": "src/dup_safer.rs:8:1: 14:2 (#0)",
    "pieces": [
      "src/dup_safer.rs:8:1: 14:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn dup_safer(mut fd: libc::c_int) -> libc::c_int {\n    return rpl_fcntl(fd, 0 as libc::c_int, 2 as libc::c_int + 1 as libc::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/dup_safer.rs:1:1: 1:34 (#0)",
        "source": "use std::os::unix::io::FromRawFd;"
      },
      {
        "span": "src/dup_safer.rs:9:5: 9:36 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/dup_safer.rs:10:5: 10:38 (#0)",
        "source": "use std::os::unix::io::FromRawFd;"
      },
      {
        "span": "src/dup_safer.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:845 ~ rust[fc84]::src::quotearg::clone_quoting_options)",
    "span": "src/quotearg.rs:186:1: 193:2 (#0)",
    "pieces": [
      "src/quotearg.rs:186:1: 193:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:178:1: 184:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1047 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ui)",
    "span": "src/stdc_leading_zeros.rs:43:1: 46:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:43:1: 46:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_ui(mut n: libc::c_uint) -> libc::c_uint {\n    return __gl_stdbit_clz(n) as libc::c_uint;\n}",
    "calls": [
      {
        "caller": "DefId(0:1182 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_uc)",
        "span": "src/stdc_leading_zeros.rs:52:5: 52:57 (#0)",
        "source": "let leading_zeros = stdc_leading_zeros_ui(n as u32);"
      },
      {
        "caller": "DefId(0:1183 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_us)",
        "span": "src/stdc_leading_zeros.rs:61:5: 61:57 (#0)",
        "source": "let leading_zeros = stdc_leading_zeros_ui(n as u32);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1048 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_uc)",
    "span": "src/stdc_leading_zeros.rs:51:1: 55:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:51:1: 55:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_uc(mut n: libc::c_uchar) -> libc::c_uint {\n    return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)\n        .wrapping_sub(\n            (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(\n                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n                        .wrapping_sub(\n                            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong,\n                        ),\n                ),\n        ) as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:878 ~ rust[fc84]::src::quotearg::quotearg_colon)",
    "span": "src/quotearg.rs:1491:1: 1493:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1491:1: 1493:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:889 ~ rust[fc84]::src::quotearg::quote_n)",
    "span": "src/quotearg.rs:1628:1: 1630:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1628:1: 1630:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:1003 ~ rust[fc84]::src::quotearg::quote)",
        "span": "src/quotearg.rs:1633:49: 1635:2 (#0)",
        "source": "{\n    quote_n(0, arg)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:890 ~ rust[fc84]::src::quotearg::quote)",
    "span": "src/quotearg.rs:1633:1: 1635:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1633:1: 1635:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1035 ~ rust[fc84]::src::stdbit::__gl_stdbit_clzl)",
    "span": "src/stdbit.rs:22:1: 28:2 (#0)",
    "pieces": [
      "src/stdbit.rs:22:1: 28:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_clzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:3:1: 3:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:5:1: 5:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:25 ~ rust[fc84]::src::basename_lgpl::base_len)",
    "span": "src/basename_lgpl.rs:31:1: 55:2 (#0)",
    "pieces": [
      "src/basename_lgpl.rs:31:1: 55:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 25,
    "source": "pub unsafe extern \"C\" fn base_len(mut name: *const libc::c_char) -> size_t {\n    let mut len: size_t = 0;\n    let mut prefix_len: size_t = 0 as libc::c_int as size_t;\n    len = strlen(name);\n    while (1 as libc::c_int as libc::c_ulong) < len\n        && *name.offset(len.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_int == '/' as i32\n    {\n        len = len.wrapping_sub(1);\n        len;\n    }\n    if 0 as libc::c_int != 0 && len == 1 as libc::c_int as libc::c_ulong\n        && *name.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32\n        && *name.offset(1 as libc::c_int as isize) as libc::c_int == '/' as i32\n        && *name.offset(2 as libc::c_int as isize) == 0\n    {\n        return 2 as libc::c_int as size_t;\n    }\n    if 0 as libc::c_int != 0 && prefix_len != 0 && len == prefix_len\n        && *name.offset(prefix_len as isize) as libc::c_int == '/' as i32\n    {\n        return prefix_len.wrapping_add(1 as libc::c_int as libc::c_ulong);\n    }\n    return len;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/basename_lgpl.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:879 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
    "span": "src/quotearg.rs:1496:1: 1500:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1496:1: 1500:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:869 ~ rust[fc84]::src::quotearg::quotearg)",
    "span": "src/quotearg.rs:1406:1: 1409:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1406:1: 1409:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1094 ~ rust[fc84]::src::temp_stream::temp_stream)",
    "span": "src/temp_stream.rs:97:1: 290:2 (#0)",
    "pieces": [
      "src/temp_stream.rs:97:1: 101:4 (#0)",
      "src/temp_stream.rs:290:1: 290:2 (#0)"
    ],
    "sub_chunks": [
      3
    ],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn temp_stream(\n    mut fp: *mut *mut FILE,\n    mut file_name: *mut *mut libc::c_char,\n) -> bool {\n   <<chunk 3>>}",
    "calls": [],
    "globals": [
      {
        "span": "src/temp_stream.rs:87:1: 87:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/temp_stream.rs:4:1: 4:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/temp_stream.rs:101:20: 101:27 (#0)",
        "source": "CString"
      },
      {
        "span": "src/temp_stream.rs:105:1: 105:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/temp_stream.rs:103:1: 103:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/temp_stream.rs:102:1: 102:19 (#0)",
        "source": "use std::fs::File;"
      },
      {
        "span": "src/temp_stream.rs:9:1: 9:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/temp_stream.rs:103:15: 103:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/temp_stream.rs:104:1: 104:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/temp_stream.rs:3:1: 3:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "src/temp_stream.rs:7:1: 7:13 (#0)",
        "source": "use std::fs;"
      },
      {
        "span": "src/temp_stream.rs:101:5: 101:35 (#0)",
        "source": "use std::ffi::{CString, CStr};"
      },
      {
        "span": "src/temp_stream.rs:6:1: 6:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/temp_stream.rs:103:21: 103:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/temp_stream.rs:101:29: 101:33 (#0)",
        "source": "CStr"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/temp_stream.rs:112:9: 145:51 (#0)",
        "pieces": [
          "src/temp_stream.rs:112:9: 145:51 (#0)"
        ],
        "num_lines": 129,
        "source": "let mut tempbuf: *mut libc::c_char = 0 as *mut libc::c_char;\n            let mut tempbuf_len: size_t = 128 as libc::c_int as size_t;\n            loop {\n                tempbuf = realloc(tempbuf as *mut libc::c_void, tempbuf_len)\n                    as *mut libc::c_char;\n                if tempbuf.is_null() {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to make temporary file name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"failed to make temporary file name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"failed to make temporary file name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    return 0 as libc::c_int != 0;\n                }\n                if path_search(\n                    tempbuf,\n                    tempbuf_len,\n                    0 as *const libc::c_char,\n                    b\"cutmp\\0\" as *const u8 as *const libc::c_char,\n                    1 as libc::c_int != 0,\n                ) == 0 as libc::c_int\n                {\n                    break;\n                }\n                if *__errno_location() != 22 as libc::c_int\n                    || ((4096 as libc::c_int / 2 as libc::c_int) as libc::c_ulong)\n                        < tempbuf_len\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            if *__errno_location() == 22 as libc::c_int {\n                                36 as libc::c_int\n                            } else {\n                                *__errno_location()\n                            },\n                            gettext(\n                                b\"failed to make temporary file name\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                if *__errno_location() == 22 as libc::c_int {\n                                    36 as libc::c_int\n                                } else {\n                                    *__errno_location()\n                                },\n                                gettext(\n                                    b\"failed to make temporary file name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                if *__errno_location() == 22 as libc::c_int {\n                                    36 as libc::c_int\n                                } else {\n                                    *__errno_location()\n                                },\n                                gettext(\n                                    b\"failed to make temporary file name\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    return 0 as libc::c_int != 0;\n                }\n                tempbuf_len = (tempbuf_len as libc::c_ulong)\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong) as size_t as size_t;\n            }\n            tempfile = tempbuf;\n            let mut fd: libc::c_int = mkstemp_safer(tempfile);",
        "sub_chunks": [],
        "live_in": [],
        "live_out": [
          "mut tempbuf: std::vec::Vec<i8>",
          "mut tempbuf_len: usize",
          "tempfile_ptr: *mut i8",
          "fd: i32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/temp_stream.rs:147:12: 223:14 (#0)",
        "pieces": [
          "src/temp_stream.rs:147:12: 223:14 (#0)"
        ],
        "num_lines": 115,
        "source": "if fd < 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to create temporary file %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, tempfile),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to create temporary file %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, tempfile),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to create temporary file %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, tempfile),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            } else {\n                tmp_fp = fdopen(\n                    fd,\n                    if 0 as libc::c_int != 0 {\n                        b\"w+b\\0\" as *const u8 as *const libc::c_char\n                    } else {\n                        b\"w+\\0\" as *const u8 as *const libc::c_char\n                    },\n                );\n                if tmp_fp.is_null() {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to open %s for writing\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, tempfile),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"failed to open %s for writing\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, tempfile),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"failed to open %s for writing\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, tempfile),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    close(fd);\n                    unlink(tempfile);\n                } else {\n                    record_or_unlink_tempfile(tempfile, tmp_fp);\n                    break 's_103;\n                }\n            }\n            free(tempfile as *mut libc::c_void);\n            tempfile = 0 as *mut libc::c_char;\n            return 0 as libc::c_int != 0;",
        "sub_chunks": [],
        "live_in": [
          "fd: i32"
        ],
        "live_out": []
      },
      {
        "chunk_id": 2,
        "span": "src/temp_stream.rs:227:4: 280:10 (#0)",
        "pieces": [
          "src/temp_stream.rs:227:4: 280:10 (#0)"
        ],
        "num_lines": 54,
        "source": "clearerr_unlocked(tmp_fp);\n        if rpl_fseeko(tmp_fp, 0 as libc::c_int as off_t, 0 as libc::c_int)\n            < 0 as libc::c_int\n            || ftruncate(fileno(tmp_fp), 0 as libc::c_int as __off_t) < 0 as libc::c_int\n        {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to rewind stream for %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, tempfile),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to rewind stream for %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, tempfile),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to rewind stream for %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, tempfile),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }",
        "sub_chunks": [],
        "live_in": [],
        "live_out": []
      },
      {
        "chunk_id": 3,
        "span": "src/temp_stream.rs:101:5: 288:15 (#0)",
        "pieces": [
          "src/temp_stream.rs:101:5: 112:8 (#0)",
          "src/temp_stream.rs:147:1: 147:11 (#0)",
          "src/temp_stream.rs:225:1: 227:3 (#0)",
          "src/temp_stream.rs:281:1: 288:15 (#0)"
        ],
        "num_lines": 16,
        "source": "static mut tempfile: *mut libc::c_char = 0 as *const libc::c_char\n        as *mut libc::c_char;\n    static mut tmp_fp: *mut FILE = 0 as *const FILE as *mut FILE;\n    if tempfile.is_null() {\n        's_103: {\n           <<chunk 0>>           <<chunk 1>>        }\n    } else {\n       <<chunk 2>>    }\n    *fp = tmp_fp;\n    if !file_name.is_null() {\n        *file_name = tempfile;\n    }\n    return 1 as libc::c_int != 0;",
        "sub_chunks": [
          0,
          1,
          2
        ],
        "live_in": [
          "mut fp: *mut *mut src::temp_stream::_IO_FILE",
          "mut file_name: *mut *mut i8"
        ],
        "live_out": [
          "mut fp: *mut *mut src::temp_stream::_IO_FILE",
          "mut file_name: *mut *mut i8"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:903 ~ rust[fc84]::src::safe_write::safe_write)",
    "span": "src/safe_write.rs:12:1: 34:2 (#0)",
    "pieces": [
      "src/safe_write.rs:12:1: 34:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn safe_write(\n    mut fd: libc::c_int,\n    mut buf: *const libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = write(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/safe_write.rs:9:1: 9:55 (#0)",
        "source": "pub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;"
      }
    ],
    "imports": [
      {
        "span": "src/safe_write.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1179 ~ rust[fc84]::src::xalignalloc::xalignalloc)",
    "span": "src/xalignalloc.rs:24:1: 33:2 (#0)",
    "pieces": [
      "src/xalignalloc.rs:24:1: 33:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xalignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    let mut p: *mut libc::c_void = alignalloc(alignment, size);\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalignalloc.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1215 ~ rust[fc84]::src::xdectoimax::xnumtoimax)",
    "span": "src/xdectoimax.rs:28:1: 128:2 (#0)",
    "pieces": [
      "src/xdectoimax.rs:28:1: 128:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 101,
    "source": "pub unsafe extern \"C\" fn xnumtoimax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: intmax_t = 0;\n    s_err = xstrtoimax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_long {\n                *__errno_location() = 75 as libc::c_int;\n            } else if tnum\n                < ((-(2147483647 as libc::c_int) - 1 as libc::c_int) / 2 as libc::c_int)\n                    as libc::c_long\n            {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}",
    "calls": [
      {
        "caller": "DefId(0:1411 ~ rust[fc84]::src::xdectoimax::xdectoimax)",
        "span": "src/xdectoimax.rs:138:5: 138:84 (#0)",
        "source": "return xnumtoimax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);"
      }
    ],
    "globals": [
      {
        "span": "src/xdectoimax.rs:21:1: 21:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      },
      {
        "span": "src/xdectoimax.rs:26:1: 26:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/xdectoimax.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1272 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
    "span": "src/xmalloc.rs:215:1: 241:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:215:1: 241:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:1486 ~ rust[fc84]::src::xmalloc::x2realloc)",
        "span": "src/xmalloc.rs:212:5: 212:58 (#0)",
        "source": "return x2nrealloc(p, ps, 1 as libc::c_int as size_t);"
      }
    ],
    "globals": [
      {
        "span": "src/xmalloc.rs:38:1: 38:47 (#0)",
        "source": "pub const DEFAULT_MXFAST: C2RustUnnamed = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1271 ~ rust[fc84]::src::xmalloc::x2realloc)",
    "span": "src/xmalloc.rs:208:1: 213:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:208:1: 213:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:303 ~ rust[fc84]::src::ialloc::icalloc)",
    "span": "src/ialloc.rs:59:1: 75:2 (#0)",
    "pieces": [
      "src/ialloc.rs:59:1: 75:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:2:1: 2:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:919 ~ rust[fc84]::src::same_inode::psame_inode)",
    "span": "src/same_inode.rs:42:1: 44:2 (#0)",
    "pieces": [
      "src/same_inode.rs:42:1: 44:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn psame_inode(mut a: *const stat, mut b: *const stat) -> bool {\n    return (*a).st_dev ^ (*b).st_dev | (*a).st_ino ^ (*b).st_ino == 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/same_inode.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:197 ~ rust[fc84]::src::fd_reopen::fd_reopen)",
    "span": "src/fd_reopen.rs:11:1: 27:2 (#0)",
    "pieces": [
      "src/fd_reopen.rs:11:1: 27:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "pub unsafe extern \"C\" fn fd_reopen(\n    mut desired_fd: libc::c_int,\n    mut file: *const libc::c_char,\n    mut flags: libc::c_int,\n    mut mode: mode_t,\n) -> libc::c_int {\n    let mut fd: libc::c_int = open(file, flags, mode);\n    if fd == desired_fd || fd < 0 as libc::c_int {\n        return fd\n    } else {\n        let mut fd2: libc::c_int = dup2(fd, desired_fd);\n        let mut saved_errno: libc::c_int = *__errno_location();\n        close(fd);\n        *__errno_location() = saved_errno;\n        return fd2;\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fd_reopen.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:880 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
    "span": "src/quotearg.rs:1503:1: 1529:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1503:1: 1529:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:90:1: 90:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1278 ~ rust[fc84]::src::xmalloc::xmemdup)",
    "span": "src/xmalloc.rs:976:1: 981:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:976:1: 981:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}",
    "calls": [
      {
        "caller": "DefId(0:1496 ~ rust[fc84]::src::xmalloc::xstrdup)",
        "span": "src/xmalloc.rs:1001:5: 1004:28 (#0)",
        "source": "return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:267 ~ rust[fc84]::src::fseeko::rpl_fseeko)",
    "span": "src/fseeko.rs:50:1: 67:2 (#0)",
    "pieces": [
      "src/fseeko.rs:50:1: 67:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fseeko.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1196 ~ rust[fc84]::src::xbinary_io::set_binary_mode)",
    "span": "src/xbinary_io.rs:47:1: 53:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:47:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [
      {
        "caller": "DefId(0:1369 ~ rust[fc84]::src::xbinary_io::xset_binary_mode)",
        "span": "src/xbinary_io.rs:9:18: 9:54 (#0)",
        "source": "unsafe { set_binary_mode(fd, mode) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:22:5: 22:36 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:23:5: 23:39 (#0)",
        "source": "use libc::{self, termios, TCSETA};"
      },
      {
        "span": "src/xbinary_io.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xbinary_io.rs:21:5: 21:32 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/xbinary_io.rs:21:19: 21:23 (#0)",
        "source": "self"
      },
      {
        "span": "src/xbinary_io.rs:23:31: 23:37 (#0)",
        "source": "TCSETA"
      },
      {
        "span": "src/xbinary_io.rs:21:25: 21:30 (#0)",
        "source": "Write"
      },
      {
        "span": "src/xbinary_io.rs:23:16: 23:20 (#0)",
        "source": "self"
      },
      {
        "span": "src/xbinary_io.rs:23:22: 23:29 (#0)",
        "source": "termios"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:49 ~ rust[fc84]::src::c_ctype::c_isxdigit)",
    "span": "src/c_ctype.rs:119:1: 125:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:119:1: 125:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1049 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_us)",
    "span": "src/stdc_leading_zeros.rs:60:1: 64:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:60:1: 64:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_us(mut n: libc::c_ushort) -> libc::c_uint {\n    return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)\n        .wrapping_sub(\n            (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(\n                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n                        .wrapping_sub(\n                            ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong,\n                        ),\n                ),\n        ) as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:939 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:16:1: 21:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:16:1: 21:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:1056 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
        "span": "src/setlocale_null_unlocked.rs:28:5: 28:77 (#0)",
        "source": "let mut result: *const libc::c_char = setlocale_null_unlocked(category);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:940 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:23:1: 58:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:23:1: 58:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1039 ~ rust[fc84]::src::stdbit::__gl_stdbit_ctzll)",
    "span": "src/stdbit.rs:66:1: 73:2 (#0)",
    "pieces": [
      "src/stdbit.rs:66:1: 73:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_ctzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:3:1: 3:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:5:1: 5:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:31 ~ rust[fc84]::src::binary_io::__gl_setmode)",
    "span": "src/binary_io.rs:14:1: 19:2 (#0)",
    "pieces": [
      "src/binary_io.rs:14:1: 19:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:33 ~ rust[fc84]::src::binary_io::set_binary_mode)",
        "span": "src/binary_io.rs:9:5: 9:35 (#0)",
        "source": "return __gl_setmode(fd, mode);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/binary_io.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:30 ~ rust[fc84]::src::binary_io::set_binary_mode)",
    "span": "src/binary_io.rs:5:1: 10:2 (#0)",
    "pieces": [
      "src/binary_io.rs:5:1: 10:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/binary_io.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:928 ~ rust[fc84]::src::setlocale_null::setlocale_null_r)",
    "span": "src/setlocale_null.rs:14:1: 20:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:14:1: 20:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:40 ~ rust[fc84]::src::c_ctype::c_isblank)",
    "span": "src/c_ctype.rs:42:1: 44:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:42:1: 44:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:103 ~ rust[fc84]::src::closeout::close_stdout_set_ignore_EPIPE)",
    "span": "src/closeout.rs:77:1: 79:2 (#0)",
    "pieces": [
      "src/closeout.rs:77:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:75:1: 75:39 (#0)",
        "source": "static mut ignore_EPIPE: bool = false;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:3:1: 3:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/closeout.rs:4:1: 4:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/closeout.rs:1:1: 1:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:837 ~ rust[fc84]::src::quotearg::c32isprint)",
    "span": "src/quotearg.rs:140:1: 142:2 (#0)",
    "pieces": [
      "src/quotearg.rs:140:1: 142:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1154 ~ rust[fc84]::src::version_etc::version_etc_ar)",
    "span": "src/version_etc.rs:251:1: 265:2 (#0)",
    "pieces": [
      "src/version_etc.rs:251:1: 265:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1281 ~ rust[fc84]::src::xmalloc::xstrdup)",
    "span": "src/xmalloc.rs:1000:1: 1005:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1000:1: 1005:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1266 ~ rust[fc84]::src::xmalloc::xirealloc)",
    "span": "src/xmalloc.rs:168:1: 174:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:168:1: 174:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:305 ~ rust[fc84]::src::ialloc::imalloc)",
    "span": "src/ialloc.rs:101:1: 113:2 (#0)",
    "pieces": [
      "src/ialloc.rs:101:1: 113:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:2:1: 2:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:16 (#0)",
        "source": "use std::alloc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1028 ~ rust[fc84]::src::sig2str::sig2str)",
    "span": "src/sig2str.rs:464:1: 504:2 (#0)",
    "pieces": [
      "src/sig2str.rs:464:1: 504:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "pub unsafe extern \"C\" fn sig2str(\n    mut signum: libc::c_int,\n    mut signame: *mut libc::c_char,\n) -> libc::c_int {\n    let mut i: libc::c_uint = 0;\n    i = 0 as libc::c_int as libc::c_uint;\n    while (i as libc::c_ulong)\n        < (::core::mem::size_of::<[numname; 35]>() as libc::c_ulong)\n            .wrapping_div(::core::mem::size_of::<numname>() as libc::c_ulong)\n    {\n        if numname_table[i as usize].num == signum {\n            strcpy(signame, (numname_table[i as usize].name).as_ptr());\n            return 0 as libc::c_int;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    let mut rtmin: libc::c_int = __libc_current_sigrtmin();\n    let mut rtmax: libc::c_int = __libc_current_sigrtmax();\n    let mut base: libc::c_int = 0;\n    let mut delta: libc::c_int = 0;\n    if !(rtmin <= signum && signum <= rtmax) {\n        return -(1 as libc::c_int);\n    }\n    if signum <= rtmin + (rtmax - rtmin) / 2 as libc::c_int {\n        strcpy(signame, b\"RTMIN\\0\" as *const u8 as *const libc::c_char);\n        base = rtmin;\n    } else {\n        strcpy(signame, b\"RTMAX\\0\" as *const u8 as *const libc::c_char);\n        base = rtmax;\n    }\n    delta = signum - base;\n    if delta != 0 as libc::c_int {\n        sprintf(\n            signame.offset(5 as libc::c_int as isize),\n            b\"%+d\\0\" as *const u8 as *const libc::c_char,\n            delta,\n        );\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/sig2str.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/sig2str.rs:1:1: 1:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:183 ~ rust[fc84]::src::fcntl::run_static_initializers)",
    "span": "src/fcntl.rs:126:1: 132:2 (#0)",
    "pieces": [
      "src/fcntl.rs:126:1: 132:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn run_static_initializers() {\n    have_dupfd_cloexec = if 0 as libc::c_int != 0 {\n        -(1 as libc::c_int)\n    } else {\n        0 as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/fcntl.rs:93:1: 93:48 (#0)",
        "source": "static mut have_dupfd_cloexec: libc::c_int = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/fcntl.rs:3:1: 3:22 (#0)",
        "source": "use std::ffi::VaList;"
      },
      {
        "span": "src/fcntl.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:888 ~ rust[fc84]::src::quotearg::quote_mem)",
    "span": "src/quotearg.rs:1622:1: 1625:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1622:1: 1625:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:276 ~ rust[fc84]::src::full_write::full_write)",
    "span": "src/full_write.rs:8:1: 30:2 (#0)",
    "pieces": [
      "src/full_write.rs:8:1: 30:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn full_write(\n    mut fd: libc::c_int,\n    mut buf: *const libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    let mut total: size_t = 0 as libc::c_int as size_t;\n    let mut ptr: *const libc::c_char = buf as *const libc::c_char;\n    while count > 0 as libc::c_int as libc::c_ulong {\n        let mut n_rw: size_t = safe_write(fd, ptr as *const libc::c_void, count);\n        if n_rw == -(1 as libc::c_int) as size_t {\n            break;\n        }\n        if n_rw == 0 as libc::c_int as libc::c_ulong {\n            *__errno_location() = 28 as libc::c_int;\n            break;\n        } else {\n            total = (total as libc::c_ulong).wrapping_add(n_rw) as size_t as size_t;\n            ptr = ptr.offset(n_rw as isize);\n            count = (count as libc::c_ulong).wrapping_sub(n_rw) as size_t as size_t;\n        }\n    }\n    return total;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/full_write.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:24 ~ rust[fc84]::src::basename_lgpl::last_component)",
    "span": "src/basename_lgpl.rs:7:1: 29:2 (#0)",
    "pieces": [
      "src/basename_lgpl.rs:7:1: 29:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn last_component(\n    mut name: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut base: *const libc::c_char = name.offset(0 as libc::c_int as isize);\n    let mut p: *const libc::c_char = 0 as *const libc::c_char;\n    let mut last_was_slash: bool = 0 as libc::c_int != 0;\n    while *base as libc::c_int == '/' as i32 {\n        base = base.offset(1);\n        base;\n    }\n    p = base;\n    while *p != 0 {\n        if *p as libc::c_int == '/' as i32 {\n            last_was_slash = 1 as libc::c_int != 0;\n        } else if last_was_slash {\n            base = p;\n            last_was_slash = 0 as libc::c_int != 0;\n        }\n        p = p.offset(1);\n        p;\n    }\n    return base as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/basename_lgpl.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1315 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
    "span": "src/xstrtoimax.rs:405:1: 571:2 (#0)",
    "pieces": [
      "src/xstrtoimax.rs:405:1: 412:4 (#0)",
      "src/xstrtoimax.rs:482:1: 482:4 (#0)",
      "src/xstrtoimax.rs:571:1: 571:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xstrtoimax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut intmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [],
    "globals": [
      {
        "span": "src/xstrtoimax.rs:23:1: 23:45 (#0)",
        "source": "pub const LONGINT_INVALID: strtol_error = 4;"
      },
      {
        "span": "src/xstrtoimax.rs:26:1: 26:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xstrtoimax.rs:25:1: 25:57 (#0)",
        "source": "pub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;"
      },
      {
        "span": "src/xstrtoimax.rs:27:1: 27:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoimax.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/xstrtoimax.rs:412:5: 481:6 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:412:5: 481:6 (#0)"
        ],
        "num_lines": 70,
        "source": "let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: intmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 78],\n                &[libc::c_char; 78],\n            >(\n                b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2247: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 78],\n                    &[libc::c_char; 78],\n                >(\n                    b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoimax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as intmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *const i8",
          "mut ptr: *mut *mut i8",
          "mut strtol_base: i32",
          "mut val: *mut i64",
          "mut valid_suffixes: *const i8"
        ],
        "live_out": [
          "mut s: *const i8",
          "mut ptr: *mut *mut i8",
          "mut strtol_base: i32",
          "mut val: *mut i64",
          "mut valid_suffixes: *const i8",
          "mut t_ptr: *mut i8",
          "mut p: *mut *mut i8",
          "mut tmp: i64",
          "mut err: u32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/xstrtoimax.rs:482:5: 569:12 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:482:5: 569:12 (#0)"
        ],
        "num_lines": 102,
        "source": "if **p as libc::c_int != '\\0' as i32 {\n        let mut base: libc::c_int = 1024 as libc::c_int;\n        let mut suffixes: libc::c_int = 1 as libc::c_int;\n        let mut overflow: strtol_error = LONGINT_OK;\n        if (strchr(valid_suffixes, **p as libc::c_int)).is_null() {\n            *val = tmp;\n            return (err as libc::c_uint\n                | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                as strtol_error;\n        }\n        match **p as libc::c_int {\n            69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n                if !(strchr(valid_suffixes, '0' as i32)).is_null() {\n                    match *(*p.offset(0 as libc::c_int as isize))\n                        .offset(1 as libc::c_int as isize) as libc::c_int\n                    {\n                        105 => {\n                            if *(*p.offset(0 as libc::c_int as isize))\n                                .offset(2 as libc::c_int as isize) as libc::c_int\n                                == 'B' as i32\n                            {\n                                suffixes += 2 as libc::c_int;\n                            }\n                        }\n                        66 | 68 => {\n                            base = 1000 as libc::c_int;\n                            suffixes += 1;\n                            suffixes;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n            _ => {}\n        }\n        match **p as libc::c_int {\n            98 => {\n                overflow = bkm_scale(&mut tmp, 512 as libc::c_int);\n            }\n            66 => {\n                overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);\n            }\n            99 => {\n                overflow = LONGINT_OK;\n            }\n            69 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);\n            }\n            71 | 103 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);\n            }\n            107 | 75 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);\n            }\n            77 | 109 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);\n            }\n            80 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);\n            }\n            81 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);\n            }\n            82 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);\n            }\n            84 | 116 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);\n            }\n            119 => {\n                overflow = bkm_scale(&mut tmp, 2 as libc::c_int);\n            }\n            89 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);\n            }\n            90 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);\n            }\n            _ => {\n                *val = tmp;\n                return (err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                    as strtol_error;\n            }\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | overflow as libc::c_uint);\n        *p = (*p).offset(suffixes as isize);\n        if **p != 0 {\n            err = ::core::mem::transmute::<\n                libc::c_uint,\n                strtol_error,\n            >(\n                err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint,\n            );\n        }\n    }\n    *val = tmp;\n    return err;",
        "sub_chunks": [],
        "live_in": [
          "mut val: *mut i64",
          "mut valid_suffixes: *const i8",
          "mut p: *mut *mut i8",
          "mut tmp: i64",
          "mut err: u32"
        ],
        "live_out": [
          "mut val: *mut i64",
          "mut valid_suffixes: *const i8",
          "mut p: *mut *mut i8",
          "mut tmp: i64",
          "mut err: u32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:870 ~ rust[fc84]::src::quotearg::quotearg_mem)",
    "span": "src/quotearg.rs:1412:1: 1418:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1412:1: 1418:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:871 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
    "span": "src/quotearg.rs:1420:1: 1429:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1420:1: 1429:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:986 ~ rust[fc84]::src::quotearg::quotearg_style)",
        "span": "src/quotearg.rs:1450:5: 1450:50 (#0)",
        "source": "let result_ptr = quotearg_n_style(0, s, arg);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:249 ~ rust[fc84]::src::fpurge::fpurge)",
    "span": "src/fpurge.rs:48:1: 53:2 (#0)",
    "pieces": [
      "src/fpurge.rs:48:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn fpurge(mut fp: *mut FILE) -> libc::c_int {\n    __fpurge(fp);\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fpurge.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:855 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
    "span": "src/quotearg.rs:1209:1: 1215:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1209:1: 1215:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:838 ~ rust[fc84]::src::quotearg::mbszero)",
    "span": "src/quotearg.rs:144:1: 150:2 (#0)",
    "pieces": [
      "src/quotearg.rs:144:1: 150:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1265 ~ rust[fc84]::src::xmalloc::xrealloc)",
    "span": "src/xmalloc.rs:157:1: 166:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:157:1: 166:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:1488 ~ rust[fc84]::src::xmalloc::xpalloc)",
        "span": "src/xmalloc.rs:945:5: 945:41 (#0)",
        "source": "pa = xrealloc(pa, nbytes as size_t);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1273 ~ rust[fc84]::src::xmalloc::xpalloc)",
    "span": "src/xmalloc.rs:243:1: 948:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:243:1: 250:4 (#0)",
      "src/xmalloc.rs:948:1: 948:2 (#0)"
    ],
    "sub_chunks": [
      7
    ],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n   <<chunk 7>>}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:40:1: 40:51 (#0)",
        "source": "pub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:10:1: 10:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:8:1: 8:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:12:1: 12:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:14:5: 14:13 (#0)",
        "source": "std::vec"
      },
      {
        "span": "src/xmalloc.rs:14:1: 14:14 (#0)",
        "source": "use std::vec;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/xmalloc.rs:269:17: 348:18 (#0)",
        "pieces": [
          "src/xmalloc.rs:269:17: 348:18 (#0)"
        ],
        "num_lines": 80,
        "source": "if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/xmalloc.rs:350:17: 455:18 (#0)",
        "pieces": [
          "src/xmalloc.rs:350:17: 455:18 (#0)"
        ],
        "num_lines": 106,
        "source": "if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/xmalloc.rs:458:13: 571:14 (#0)",
        "pieces": [
          "src/xmalloc.rs:458:13: 571:14 (#0)"
        ],
        "num_lines": 114,
        "source": "if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/xmalloc.rs:625:29: 706:30 (#0)",
        "pieces": [
          "src/xmalloc.rs:625:29: 706:30 (#0)"
        ],
        "num_lines": 82,
        "source": "if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/xmalloc.rs:708:29: 814:30 (#0)",
        "pieces": [
          "src/xmalloc.rs:708:29: 814:30 (#0)"
        ],
        "num_lines": 107,
        "source": "if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/xmalloc.rs:817:25: 930:26 (#0)",
        "pieces": [
          "src/xmalloc.rs:817:25: 930:26 (#0)"
        ],
        "num_lines": 114,
        "source": "if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/xmalloc.rs:606:13: 940:24 (#0)",
        "pieces": [
          "src/xmalloc.rs:606:13: 625:28 (#0)",
          "src/xmalloc.rs:707:1: 708:28 (#0)",
          "src/xmalloc.rs:815:1: 817:24 (#0)",
          "src/xmalloc.rs:931:1: 940:24 (#0)"
        ],
        "num_lines": 35,
        "source": "let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                           <<chunk 3>>                        } else {\n                           <<chunk 4>>                        }\n                    } else {\n                       <<chunk 5>>                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0",
        "sub_chunks": [
          3,
          4,
          5
        ],
        "live_in": [
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64",
          "mut n0: i64",
          "mut n: i64",
          "mut nbytes: i64"
        ],
        "live_out": [
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64",
          "mut n0: i64",
          "mut n: i64",
          "mut nbytes: i64",
          "fresh12: i64",
          "fresh13: bool"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/xmalloc.rs:250:5: 947:15 (#0)",
        "pieces": [
          "src/xmalloc.rs:250:5: 269:16 (#0)",
          "src/xmalloc.rs:349:1: 350:16 (#0)",
          "src/xmalloc.rs:456:1: 458:12 (#0)",
          "src/xmalloc.rs:572:1: 606:12 (#0)",
          "src/xmalloc.rs:941:1: 947:15 (#0)"
        ],
        "num_lines": 67,
        "source": "let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n               <<chunk 0>>            } else {\n               <<chunk 1>>            }\n        } else {\n           <<chunk 2>>        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n           <<chunk 6>>        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;",
        "sub_chunks": [
          0,
          1,
          2,
          6
        ],
        "live_in": [
          "mut pa: *mut libc::c_void",
          "mut pn: *mut i64",
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64"
        ],
        "live_out": [
          "mut pa: *mut libc::c_void",
          "mut pn: *mut i64",
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:285 ~ rust[fc84]::src::hard_locale::hard_locale)",
    "span": "src/hard_locale.rs:14:1: 32:2 (#0)",
    "pieces": [
      "src/hard_locale.rs:14:1: 32:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hard_locale.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hard_locale.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1034 ~ rust[fc84]::src::stdbit::__gl_stdbit_clz)",
    "span": "src/stdbit.rs:11:1: 17:2 (#0)",
    "pieces": [
      "src/stdbit.rs:11:1: 17:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_clz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:3:1: 3:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:5:1: 5:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1037 ~ rust[fc84]::src::stdbit::__gl_stdbit_ctz)",
    "span": "src/stdbit.rs:44:1: 50:2 (#0)",
    "pieces": [
      "src/stdbit.rs:44:1: 50:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_ctz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:3:1: 3:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:5:1: 5:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1189 ~ rust[fc84]::src::xalloc_die::xalloc_die)",
    "span": "src/xalloc_die.rs:16:1: 53:2 (#0)",
    "pieces": [
      "src/xalloc_die.rs:16:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "pub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalloc_die.rs:1:1: 1:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/xalloc_die.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:849 ~ rust[fc84]::src::quotearg::set_quoting_flags)",
    "span": "src/quotearg.rs:240:1: 253:2 (#0)",
    "pieces": [
      "src/quotearg.rs:240:1: 253:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:178:1: 184:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:118 ~ rust[fc84]::src::dup_safer_flag::dup_safer_flag)",
    "span": "src/dup_safer_flag.rs:8:1: 20:2 (#0)",
    "pieces": [
      "src/dup_safer_flag.rs:8:1: 20:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn dup_safer_flag(\n    mut fd: libc::c_int,\n    mut flag: libc::c_int,\n) -> libc::c_int {\n    return rpl_fcntl(\n        fd,\n        if flag & 0o2000000 as libc::c_int != 0 {\n            1030 as libc::c_int\n        } else {\n            0 as libc::c_int\n        },\n        2 as libc::c_int + 1 as libc::c_int,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/dup_safer_flag.rs:1:1: 1:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/dup_safer_flag.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1159 ~ rust[fc84]::src::version_etc::emit_bug_reporting_address)",
    "span": "src/version_etc.rs:308:1: 325:2 (#0)",
    "pieces": [
      "src/version_etc.rs:308:1: 325:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1194 ~ rust[fc84]::src::xbinary_io::xset_binary_mode)",
    "span": "src/xbinary_io.rs:8:1: 13:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:8:1: 13:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:21:25: 21:30 (#0)",
        "source": "Write"
      },
      {
        "span": "src/xbinary_io.rs:23:22: 23:29 (#0)",
        "source": "termios"
      },
      {
        "span": "src/xbinary_io.rs:23:5: 23:39 (#0)",
        "source": "use libc::{self, termios, TCSETA};"
      },
      {
        "span": "src/xbinary_io.rs:21:5: 21:32 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/xbinary_io.rs:22:5: 22:36 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:21:19: 21:23 (#0)",
        "source": "self"
      },
      {
        "span": "src/xbinary_io.rs:23:16: 23:20 (#0)",
        "source": "self"
      },
      {
        "span": "src/xbinary_io.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xbinary_io.rs:23:31: 23:37 (#0)",
        "source": "TCSETA"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1123 ~ rust[fc84]::src::tmpdir::path_search)",
    "span": "src/tmpdir.rs:77:1: 144:2 (#0)",
    "pieces": [
      "src/tmpdir.rs:77:1: 144:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 68,
    "source": "pub unsafe extern \"C\" fn path_search(\n    mut tmpl: *mut libc::c_char,\n    mut tmpl_len: size_t,\n    mut dir: *const libc::c_char,\n    mut pfx: *const libc::c_char,\n    mut try_tmpdir: bool,\n) -> libc::c_int {\n    let mut d: *const libc::c_char = 0 as *const libc::c_char;\n    let mut dlen: size_t = 0;\n    let mut plen: size_t = 0;\n    let mut add_slash: bool = false;\n    if pfx.is_null() || *pfx.offset(0 as libc::c_int as isize) == 0 {\n        pfx = b\"file\\0\" as *const u8 as *const libc::c_char;\n        plen = 4 as libc::c_int as size_t;\n    } else {\n        plen = strlen(pfx);\n        if plen > 5 as libc::c_int as libc::c_ulong {\n            plen = 5 as libc::c_int as size_t;\n        }\n    }\n    if try_tmpdir {\n        d = secure_getenv(b\"TMPDIR\\0\" as *const u8 as *const libc::c_char);\n        if !d.is_null() && direxists(d) as libc::c_int != 0 {\n            dir = d;\n        } else if !(!dir.is_null() && direxists(dir) as libc::c_int != 0) {\n            dir = 0 as *const libc::c_char;\n        }\n    }\n    if dir.is_null() {\n        if direxists(b\"/tmp\\0\" as *const u8 as *const libc::c_char) {\n            dir = b\"/tmp\\0\" as *const u8 as *const libc::c_char;\n        } else if strcmp(\n            b\"/tmp\\0\" as *const u8 as *const libc::c_char,\n            b\"/tmp\\0\" as *const u8 as *const libc::c_char,\n        ) != 0 as libc::c_int\n            && direxists(b\"/tmp\\0\" as *const u8 as *const libc::c_char) as libc::c_int\n                != 0\n        {\n            dir = b\"/tmp\\0\" as *const u8 as *const libc::c_char;\n        } else {\n            *__errno_location() = 2 as libc::c_int;\n            return -(1 as libc::c_int);\n        }\n    }\n    dlen = strlen(dir);\n    add_slash = dlen != 0 as libc::c_int as libc::c_ulong\n        && !(*dir.offset(dlen.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_int == '/' as i32);\n    if tmpl_len\n        < dlen\n            .wrapping_add(add_slash as libc::c_ulong)\n            .wrapping_add(plen)\n            .wrapping_add(6 as libc::c_int as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        *__errno_location() = 22 as libc::c_int;\n        return -(1 as libc::c_int);\n    }\n    memcpy(tmpl as *mut libc::c_void, dir as *const libc::c_void, dlen);\n    sprintf(\n        tmpl.offset(dlen as isize),\n        &*(b\"/%.*sXXXXXX\\0\" as *const u8 as *const libc::c_char)\n            .offset(!add_slash as libc::c_int as isize) as *const libc::c_char,\n        plen as libc::c_int,\n        pfx,\n    );\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/tmpdir.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:698 ~ rust[fc84]::src::localcharset::locale_charset)",
    "span": "src/localcharset.rs:391:1: 401:2 (#0)",
    "pieces": [
      "src/localcharset.rs:391:1: 401:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/localcharset.rs:5:1: 5:39 (#0)",
        "source": "pub const CODESET: C2RustUnnamed = 14;"
      }
    ],
    "imports": [
      {
        "span": "src/localcharset.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:724 ~ rust[fc84]::src::mbszero::mbszero)",
    "span": "src/mbszero.rs:27:1: 32:2 (#0)",
    "pieces": [
      "src/mbszero.rs:27:1: 32:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/mbszero.rs:1:1: 1:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/mbszero.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:847 ~ rust[fc84]::src::quotearg::set_quoting_style)",
    "span": "src/quotearg.rs:205:1: 216:2 (#0)",
    "pieces": [
      "src/quotearg.rs:205:1: 216:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:178:1: 184:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:47 ~ rust[fc84]::src::c_ctype::c_isspace)",
    "span": "src/c_ctype.rs:103:1: 108:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:103:1: 108:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:41 ~ rust[fc84]::src::c_ctype::c_iscntrl)",
    "span": "src/c_ctype.rs:48:1: 53:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:48:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:846 ~ rust[fc84]::src::quotearg::get_quoting_style)",
    "span": "src/quotearg.rs:196:1: 202:2 (#0)",
    "pieces": [
      "src/quotearg.rs:196:1: 202:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:178:1: 184:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:38 ~ rust[fc84]::src::c_ctype::c_isalpha)",
    "span": "src/c_ctype.rs:28:1: 30:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:28:1: 30:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:885 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
    "span": "src/quotearg.rs:1581:1: 1597:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1581:1: 1597:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1046 ~ rust[fc84]::src::stdc_leading_zeros::__gl_stdbit_clzll)",
    "span": "src/stdc_leading_zeros.rs:32:1: 38:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:32:1: 38:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1051 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ull)",
    "span": "src/stdc_leading_zeros.rs:76:1: 78:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:76:1: 78:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_ull(\n    mut n: libc::c_ulonglong,\n) -> libc::c_uint {\n    return __gl_stdbit_clzll(n) as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:873 ~ rust[fc84]::src::quotearg::quotearg_style)",
    "span": "src/quotearg.rs:1446:1: 1452:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1446:1: 1452:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:48 ~ rust[fc84]::src::c_ctype::c_isupper)",
    "span": "src/c_ctype.rs:112:1: 114:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:112:1: 114:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:15:1: 15:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:11:1: 11:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:9:1: 9:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:13:1: 13:27 (#0)",
        "source": "use std::convert::TryFrom;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1216 ~ rust[fc84]::src::xdectoimax::xdectoimax)",
    "span": "src/xdectoimax.rs:130:1: 139:2 (#0)",
    "pieces": [
      "src/xdectoimax.rs:130:1: 139:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xdectoimax(\n    mut n_str: *const libc::c_char,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    return xnumtoimax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xdectoimax.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:191 ~ split[1dd7]::__gl_setmode)",
    "span": "src/split.rs:647:1: 649:2 (#0)",
    "pieces": [
      "src/split.rs:647:1: 649:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:212 ~ split[1dd7]::set_binary_mode)",
        "span": "src/split.rs:655:5: 655:38 (#0)",
        "source": "unsafe { __gl_setmode(fd, mode) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:179 ~ split[1dd7]::psame_inode)",
    "span": "src/split.rs:409:1: 411:2 (#0)",
    "pieces": [
      "src/split.rs:409:1: 411:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn psame_inode(mut a: *const stat, mut b: *const stat) -> bool {\n    return (*a).st_dev ^ (*b).st_dev | (*a).st_ino ^ (*b).st_ino == 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:237 ~ split[1dd7]::closeout)",
    "span": "src/split.rs:2052:1: 2425:2 (#0)",
    "pieces": [
      "src/split.rs:2052:1: 2058:4 (#0)",
      "src/split.rs:2425:1: 2425:2 (#0)"
    ],
    "sub_chunks": [
      4
    ],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn closeout(\n    mut fp: *mut FILE,\n    mut fd: libc::c_int,\n    mut pid: pid_t,\n    mut name: *const libc::c_char,\n) {\n   <<chunk 4>>}",
    "calls": [
      {
        "caller": "DefId(0:260 ~ split[1dd7]::cwrite)",
        "span": "src/split.rs:2437:9: 2437:68 (#0)",
        "source": "closeout(0 as *mut FILE, output_desc, filter_pid, outfile);"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:5192:5: 5192:64 (#0)",
        "source": "closeout(0 as *mut FILE, output_desc, filter_pid, outfile);"
      }
    ],
    "globals": [
      {
        "span": "src/split.rs:356:1: 356:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/split.rs:669:1: 669:75 (#0)",
        "source": "static mut filter_command: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/split.rs:2182:13: 2225:15 (#0)",
        "pieces": [
          "src/split.rs:2182:13: 2225:15 (#0)"
        ],
        "num_lines": 44,
        "source": "if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"waiting for child process\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"waiting for child process\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"waiting for child process\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };",
        "sub_chunks": [],
        "live_in": [],
        "live_out": []
      },
      {
        "chunk_id": 1,
        "span": "src/split.rs:2229:13: 2304:14 (#0)",
        "pieces": [
          "src/split.rs:2229:13: 2304:14 (#0)"
        ],
        "num_lines": 76,
        "source": "let mut sig: libc::c_int = wstatus & 0x7f as libc::c_int;\n            if sig != 13 as libc::c_int {\n                let mut signame: [libc::c_char; 19] = [0; 19];\n                if sig2str(sig, signame.as_mut_ptr()) != 0 as libc::c_int {\n                    sprintf(\n                        signame.as_mut_ptr(),\n                        b\"%d\\0\" as *const u8 as *const libc::c_char,\n                        sig,\n                    );\n                }\n                if 0 != 0 {\n                    error(\n                        sig + 128 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"with FILE=%s, signal %s from command: %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                        signame.as_mut_ptr(),\n                        filter_command,\n                    );\n                    if sig + 128 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = sig + 128 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"with FILE=%s, signal %s from command: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                name,\n                            ),\n                            signame.as_mut_ptr(),\n                            filter_command,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = sig + 128 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"with FILE=%s, signal %s from command: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                name,\n                            ),\n                            signame.as_mut_ptr(),\n                            filter_command,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut name: *const i8",
          "mut wstatus: i32"
        ],
        "live_out": [
          "mut name: *const i8",
          "mut wstatus: i32",
          "mut sig: i32"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/split.rs:2306:13: 2374:14 (#0)",
        "pieces": [
          "src/split.rs:2306:13: 2374:14 (#0)"
        ],
        "num_lines": 69,
        "source": "let mut ex: libc::c_int = (wstatus & 0xff00 as libc::c_int)\n                >> 8 as libc::c_int;\n            if ex != 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        ex,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"with FILE=%s, exit %d from command: %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                        ex,\n                        filter_command,\n                    );\n                    if ex != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = ex;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"with FILE=%s, exit %d from command: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                name,\n                            ),\n                            ex,\n                            filter_command,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = ex;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"with FILE=%s, exit %d from command: %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                name,\n                            ),\n                            ex,\n                            filter_command,\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut name: *const i8",
          "mut wstatus: i32"
        ],
        "live_out": [
          "mut name: *const i8",
          "mut wstatus: i32",
          "mut ex: i32"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/split.rs:2376:13: 2422:15 (#0)",
        "pieces": [
          "src/split.rs:2376:13: 2422:15 (#0)"
        ],
        "num_lines": 47,
        "source": "if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"unknown status from command (0x%X)\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    (wstatus as libc::c_uint).wrapping_add(0 as libc::c_uint),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"unknown status from command (0x%X)\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        (wstatus as libc::c_uint).wrapping_add(0 as libc::c_uint),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"unknown status from command (0x%X)\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        (wstatus as libc::c_uint).wrapping_add(0 as libc::c_uint),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };",
        "sub_chunks": [],
        "live_in": [
          "mut wstatus: i32"
        ],
        "live_out": [
          "mut wstatus: i32"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/split.rs:2058:5: 2424:6 (#0)",
        "pieces": [
          "src/split.rs:2058:5: 2182:12 (#0)",
          "src/split.rs:2226:1: 2229:12 (#0)",
          "src/split.rs:2305:1: 2306:12 (#0)",
          "src/split.rs:2375:1: 2376:12 (#0)",
          "src/split.rs:2423:1: 2424:6 (#0)"
        ],
        "num_lines": 135,
        "source": "if !fp.is_null() && rpl_fclose(fp) != 0 as libc::c_int\n        && !ignorable(*__errno_location())\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    name,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if fd >= 0 as libc::c_int {\n        if fp.is_null() && close(fd) < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        let mut j: libc::c_int = 0;\n        j = 0 as libc::c_int;\n        while j < n_open_pipes {\n            if *open_pipes.offset(j as isize) == fd {\n                n_open_pipes -= 1;\n                *open_pipes\n                    .offset(j as isize) = *open_pipes.offset(n_open_pipes as isize);\n                break;\n            } else {\n                j += 1;\n                j;\n            }\n        }\n    }\n    if pid > 0 as libc::c_int {\n        let mut wstatus: libc::c_int = 0;\n        if waitpid(pid, &mut wstatus, 0 as libc::c_int) < 0 as libc::c_int {\n           <<chunk 0>>        } else if ((wstatus & 0x7f as libc::c_int) + 1 as libc::c_int) as libc::c_schar\n            as libc::c_int >> 1 as libc::c_int > 0 as libc::c_int\n        {\n           <<chunk 1>>        } else if wstatus & 0x7f as libc::c_int == 0 as libc::c_int {\n           <<chunk 2>>        } else {\n           <<chunk 3>>        }\n    }",
        "sub_chunks": [
          0,
          1,
          2,
          3
        ],
        "live_in": [
          "mut fp: *mut _IO_FILE",
          "mut fd: i32",
          "mut pid: i32",
          "mut name: *const i8"
        ],
        "live_out": [
          "mut fp: *mut _IO_FILE",
          "mut fd: i32",
          "mut pid: i32",
          "mut name: *const i8",
          "mut wstatus: i32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:182 ~ split[1dd7]::emit_size_note)",
    "span": "src/split.rs:434:1: 439:2 (#0)",
    "pieces": [
      "src/split.rs:434:1: 439:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_size_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\\nUnits are K,M,G,T,P,E,Z,Y,R,Q (powers of 1024) or KB,MB,... (powers of 1000).\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:241 ~ split[1dd7]::usage)",
        "span": "src/split.rs:1030:9: 1030:26 (#0)",
        "source": "emit_size_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:183 ~ split[1dd7]::emit_ancillary_info)",
    "span": "src/split.rs:442:1: 504:2 (#0)",
    "pieces": [
      "src/split.rs:442:1: 504:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 115,
    "source": "unsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:241 ~ split[1dd7]::usage)",
        "span": "src/split.rs:1038:9: 1038:77 (#0)",
        "source": "emit_ancillary_info(CStr::from_bytes_with_nul(b\"split\\0\").unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:181 ~ split[1dd7]::emit_mandatory_arg_note)",
    "span": "src/split.rs:426:1: 431:2 (#0)",
    "pieces": [
      "src/split.rs:426:1: 431:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_mandatory_arg_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nMandatory arguments to long options are mandatory for short options too.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:241 ~ split[1dd7]::usage)",
        "span": "src/split.rs:1000:9: 1000:35 (#0)",
        "source": "emit_mandatory_arg_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:180 ~ split[1dd7]::emit_stdin_note)",
    "span": "src/split.rs:414:1: 423:2 (#0)",
    "pieces": [
      "src/split.rs:414:1: 423:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_stdin_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nWith no FILE, or when FILE is -, read standard input.\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:241 ~ split[1dd7]::usage)",
        "span": "src/split.rs:999:9: 999:27 (#0)",
        "source": "emit_stdin_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:221 ~ split[1dd7]::usage)",
    "span": "src/split.rs:974:1: 1041:2 (#0)",
    "pieces": [
      "src/split.rs:974:1: 1041:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 68,
    "source": "pub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [FILE [PREFIX]]\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Output pieces of FILE to PREFIXaa, PREFIXab, ...;\\ndefault size is 1000 lines, and default PREFIX is 'x'.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_stdin_note();\n        emit_mandatory_arg_note();\n        fprintf(\n            stdout,\n            gettext(\n                b\"  -a, --suffix-length=N   generate suffixes of length N (default %d)\\n      --additional-suffix=SUFFIX  append an additional SUFFIX to file names\\n  -b, --bytes=SIZE        put SIZE bytes per output file\\n  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file\\n  -d                      use numeric suffixes starting at 0, not alphabetic\\n      --numeric-suffixes[=FROM]  same as -d, but allow setting the start value\\n  -x                      use hex suffixes starting at 0, not alphabetic\\n      --hex-suffixes[=FROM]  same as -x, but allow setting the start value\\n  -e, --elide-empty-files  do not generate empty output files with '-n'\\n      --filter=COMMAND    write to shell COMMAND; file name is $FILE\\n  -l, --lines=NUMBER      put NUMBER lines/records per output file\\n  -n, --number=CHUNKS     generate CHUNKS output files; see explanation below\\n  -t, --separator=SEP     use SEP instead of newline as the record separator;\\n                            '\\\\0' (zero) specifies the NUL character\\n  -u, --unbuffered        immediately copy input to output with '-n r/...'\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            2 as libc::c_int,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --verbose           print a diagnostic just before each\\n                            output file is opened\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_size_note();\n        fputs_unlocked(\n            gettext(\n                b\"\\nCHUNKS may be:\\n  N       split into N files based on size of input\\n  K/N     output Kth of N to stdout\\n  l/N     split into N files without splitting lines/records\\n  l/K/N   output Kth of N to stdout without splitting lines/records\\n  r/N     like 'l' but use round robin distribution\\n  r/K/N   likewise but only output Kth of N to stdout\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_ancillary_info(b\"split\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}",
    "calls": [
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4133:5: 4133:14 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4079:5: 4079:14 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4048:5: 4048:14 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4744:9: 4744:18 (#0)",
        "source": "usage(0);"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4767:9: 4767:18 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4010:5: 4010:14 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4110:5: 4110:14 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4894:5: 4894:14 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4875:9: 4875:33 (#0)",
        "source": "usage(1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4259:21: 4259:45 (#0)",
        "source": "usage(1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4900:5: 4900:14 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4822:9: 4822:33 (#0)",
        "source": "usage(1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4687:25: 4687:49 (#0)",
        "source": "usage(1 as libc::c_int);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:233 ~ split[1dd7]::create)",
    "span": "src/split.rs:1370:1: 2051:2 (#0)",
    "pieces": [
      "src/split.rs:1370:1: 1372:8 (#0)",
      "src/split.rs:1516:1: 1516:8 (#0)",
      "src/split.rs:1579:1: 1580:8 (#0)",
      "src/split.rs:1939:1: 1939:8 (#0)",
      "src/split.rs:2050:1: 2051:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1,
      4,
      5
    ],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn create(mut name: *const libc::c_char) -> libc::c_int {\n    if filter_command.is_null() {\n       <<chunk 0>>       <<chunk 1>>    } else {\n       <<chunk 4>>       <<chunk 5>>    };\n}",
    "calls": [
      {
        "caller": "DefId(0:260 ~ split[1dd7]::cwrite)",
        "span": "src/split.rs:2439:9: 2439:39 (#0)",
        "source": "output_desc = create(outfile);"
      },
      {
        "caller": "DefId(0:270 ~ split[1dd7]::ofile_open)",
        "span": "src/split.rs:3317:5: 3317:60 (#0)",
        "source": "fd = create((*files.offset(i_check as isize)).of_name);"
      }
    ],
    "globals": [
      {
        "span": "src/split.rs:672:1: 672:40 (#0)",
        "source": "static mut open_pipes_alloc: idx_t = 0;"
      },
      {
        "span": "src/split.rs:670:1: 670:34 (#0)",
        "source": "static mut filter_pid: pid_t = 0;"
      },
      {
        "span": "src/split.rs:669:1: 669:75 (#0)",
        "source": "static mut filter_command: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/split.rs:673:1: 673:42 (#0)",
        "source": "static mut n_open_pipes: libc::c_int = 0;"
      },
      {
        "span": "src/split.rs:355:1: 355:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/split.rs:356:1: 356:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/split.rs:671:1: 671:87 (#0)",
        "source": "static mut open_pipes: *mut libc::c_int = 0 as *const libc::c_int as *mut libc::c_int;"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/split.rs:1372:9: 1515:10 (#0)",
        "pieces": [
          "src/split.rs:1372:9: 1515:10 (#0)"
        ],
        "num_lines": 144,
        "source": "if verbose {\n            fprintf(\n                stdout,\n                gettext(b\"creating file %s\\n\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, name),\n            );\n        }\n        let mut oflags: libc::c_int = 0o1 as libc::c_int | 0o100 as libc::c_int\n            | 0 as libc::c_int;\n        let mut fd: libc::c_int = open_safer(\n            name,\n            oflags | 0o200 as libc::c_int,\n            0o400 as libc::c_int | 0o200 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int,\n        );\n        if 0 as libc::c_int <= fd || *__errno_location() != 17 as libc::c_int {\n            return fd;\n        }\n        fd = open_safer(\n            name,\n            oflags,\n            0o400 as libc::c_int | 0o200 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int,\n        );\n        if fd < 0 as libc::c_int {\n            return fd;\n        }\n        let mut out_stat_buf: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        if fstat(fd, &mut out_stat_buf) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, name),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if psame_inode(&mut in_stat_buf, &mut out_stat_buf) {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s would overwrite input; aborting\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, name),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s would overwrite input; aborting\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s would overwrite input; aborting\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, name),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut name: *const i8"
        ],
        "live_out": [
          "mut name: *const i8",
          "mut oflags: i32",
          "mut fd: i32",
          "mut out_stat_buf: stat"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/split.rs:1516:9: 1578:19 (#0)",
        "pieces": [
          "src/split.rs:1516:9: 1578:19 (#0)"
        ],
        "num_lines": 63,
        "source": "if ftruncate(fd, 0 as libc::c_int as __off_t) < 0 as libc::c_int\n            && (out_stat_buf.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                == 0o100000 as libc::c_int as libc::c_uint\n                || (out_stat_buf.st_mode).wrapping_sub(out_stat_buf.st_mode) != 0)\n        {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: error truncating\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        name,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: error truncating\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: error truncating\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        return fd;",
        "sub_chunks": [],
        "live_in": [
          "mut name: *const i8",
          "mut fd: i32",
          "mut out_stat_buf: stat"
        ],
        "live_out": [
          "mut name: *const i8",
          "mut fd: i32",
          "mut out_stat_buf: stat"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/split.rs:1696:13: 1787:14 (#0)",
        "pieces": [
          "src/split.rs:1696:13: 1787:14 (#0)"
        ],
        "num_lines": 92,
        "source": "let mut j: libc::c_int = 0;\n            j = 0 as libc::c_int;\n            while j < n_open_pipes {\n                if close(*open_pipes.offset(j as isize)) != 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"closing prior pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"closing prior pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"closing prior pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                j += 1;\n                j;\n            }\n            if close(fd_pair[1 as libc::c_int as usize]) != 0 {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"closing output pipe\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"closing output pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"closing output pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut fd_pair: [i32; 2]"
        ],
        "live_out": [
          "mut fd_pair: [i32; 2]",
          "mut j: i32"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/split.rs:1788:13: 1937:15 (#0)",
        "pieces": [
          "src/split.rs:1788:13: 1937:15 (#0)"
        ],
        "num_lines": 150,
        "source": "if fd_pair[0 as libc::c_int as usize] != 0 as libc::c_int {\n                if dup2(fd_pair[0 as libc::c_int as usize], 0 as libc::c_int)\n                    != 0 as libc::c_int\n                {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"moving input pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"moving input pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"moving input pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                if close(fd_pair[0 as libc::c_int as usize]) != 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"closing input pipe\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"closing input pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"closing input pipe\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n            }\n            if default_SIGPIPE {\n                signal(13 as libc::c_int, None);\n            }\n            execl(\n                shell_prog,\n                last_component(shell_prog),\n                b\"-c\\0\" as *const u8 as *const libc::c_char,\n                filter_command,\n                0 as *mut libc::c_void as *mut libc::c_char,\n            );\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to run command: \\\"%s -c %s\\\"\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    shell_prog,\n                    filter_command,\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to run command: \\\"%s -c %s\\\"\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        shell_prog,\n                        filter_command,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to run command: \\\"%s -c %s\\\"\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        shell_prog,\n                        filter_command,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };",
        "sub_chunks": [],
        "live_in": [
          "mut fd_pair: [i32; 2]",
          "mut shell_prog: *const i8"
        ],
        "live_out": [
          "mut fd_pair: [i32; 2]",
          "mut shell_prog: *const i8"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/split.rs:1580:9: 1938:10 (#0)",
        "pieces": [
          "src/split.rs:1580:9: 1696:12 (#0)",
          "src/split.rs:1788:1: 1788:12 (#0)",
          "src/split.rs:1938:1: 1938:10 (#0)"
        ],
        "num_lines": 119,
        "source": "let mut fd_pair: [libc::c_int; 2] = [0; 2];\n        let mut child_pid: pid_t = 0;\n        let mut shell_prog: *const libc::c_char = getenv(\n            b\"SHELL\\0\" as *const u8 as *const libc::c_char,\n        );\n        if shell_prog.is_null() {\n            shell_prog = b\"/bin/sh\\0\" as *const u8 as *const libc::c_char;\n        }\n        if setenv(b\"FILE\\0\" as *const u8 as *const libc::c_char, name, 1 as libc::c_int)\n            != 0 as libc::c_int\n        {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to set FILE environment variable\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to set FILE environment variable\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to set FILE environment variable\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if verbose {\n            fprintf(\n                stdout,\n                gettext(\n                    b\"executing with FILE=%s\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    name,\n                ),\n            );\n        }\n        if pipe(fd_pair.as_mut_ptr()) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to create pipe\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to create pipe\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to create pipe\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        child_pid = fork();\n        if child_pid == 0 as libc::c_int {\n           <<chunk 2>>           <<chunk 3>>        }",
        "sub_chunks": [
          2,
          3
        ],
        "live_in": [
          "mut name: *const i8"
        ],
        "live_out": [
          "mut name: *const i8",
          "mut fd_pair: [i32; 2]",
          "mut child_pid: i32",
          "mut shell_prog: *const i8"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/split.rs:1939:9: 2049:51 (#0)",
        "pieces": [
          "src/split.rs:1939:9: 2049:51 (#0)"
        ],
        "num_lines": 111,
        "source": "if child_pid < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"fork system call failed\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"fork system call failed\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"fork system call failed\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if close(fd_pair[0 as libc::c_int as usize]) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to close input pipe\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to close input pipe\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to close input pipe\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        filter_pid = child_pid;\n        if n_open_pipes as libc::c_long == open_pipes_alloc {\n            open_pipes = xpalloc(\n                open_pipes as *mut libc::c_void,\n                &mut open_pipes_alloc,\n                1 as libc::c_int as idx_t,\n                if (2147483647 as libc::c_int as libc::c_long)\n                    < 9223372036854775807 as libc::c_long\n                {\n                    2147483647 as libc::c_int as libc::c_long\n                } else {\n                    9223372036854775807 as libc::c_long\n                },\n                ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as idx_t,\n            ) as *mut libc::c_int;\n        }\n        let fresh15 = n_open_pipes;\n        n_open_pipes = n_open_pipes + 1;\n        *open_pipes.offset(fresh15 as isize) = fd_pair[1 as libc::c_int as usize];\n        return fd_pair[1 as libc::c_int as usize];",
        "sub_chunks": [],
        "live_in": [
          "mut fd_pair: [i32; 2]",
          "mut child_pid: i32"
        ],
        "live_out": []
      }
    ]
  },
  {
    "func_defid": "DefId(0:224 ~ split[1dd7]::next_file_name)",
    "span": "src/split.rs:1157:1: 1369:2 (#0)",
    "pieces": [
      "src/split.rs:1157:1: 1158:4 (#0)",
      "src/split.rs:1255:1: 1255:4 (#0)",
      "src/split.rs:1369:1: 1369:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn next_file_name() {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:260 ~ split[1dd7]::cwrite)",
        "span": "src/split.rs:2438:9: 2438:26 (#0)",
        "source": "next_file_name();"
      }
    ],
    "globals": [
      {
        "span": "src/split.rs:675:1: 675:68 (#0)",
        "source": "static mut outbase: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/split.rs:684:1: 684:78 (#0)",
        "source": "static mut additional_suffix: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/split.rs:677:1: 678:26 (#0)",
        "source": "static mut outfile_mid: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      },
      {
        "span": "src/split.rs:683:1: 683:81 (#0)",
        "source": "static mut numeric_suffix_start: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/split.rs:681:1: 682:41 (#0)",
        "source": "static mut suffix_alphabet: *const libc::c_char = b\"abcdefghijklmnopqrstuvwxyz\\0\"\n    as *const u8 as *const libc::c_char;"
      },
      {
        "span": "src/split.rs:676:1: 676:87 (#0)",
        "source": "static mut outfile: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;"
      },
      {
        "span": "src/split.rs:680:1: 680:37 (#0)",
        "source": "static mut suffix_length: idx_t = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/split.rs:1158:5: 1254:6 (#0)",
        "pieces": [
          "src/split.rs:1158:5: 1254:6 (#0)"
        ],
        "num_lines": 97,
        "source": "static mut sufindex: *mut idx_t = 0 as *const idx_t as *mut idx_t;\n    static mut outbase_length: idx_t = 0;\n    static mut outfile_length: idx_t = 0;\n    static mut addsuf_length: idx_t = 0;\n    let mut overflow: bool = false;\n    let mut widen: bool = false;\n    let mut current_block_37: u64;\n    if outfile.is_null() {\n        overflow = false;\n        widen = false;\n        current_block_37 = 9769017674192345533;\n    } else {\n        let mut i_0: idx_t = suffix_length;\n        loop {\n            let fresh13 = i_0;\n            i_0 = i_0 - 1;\n            if !(fresh13 != 0 as libc::c_int as libc::c_long) {\n                current_block_37 = 14434620278749266018;\n                break;\n            }\n            let ref mut fresh14 = *sufindex.offset(i_0 as isize);\n            *fresh14 += 1;\n            let _ = *fresh14;\n            if suffix_auto as libc::c_int != 0 && i_0 == 0 as libc::c_int as libc::c_long\n                && *suffix_alphabet\n                    .offset(\n                        (*sufindex.offset(0 as libc::c_int as isize)\n                            + 1 as libc::c_int as libc::c_long) as isize,\n                    ) == 0\n            {\n                current_block_37 = 9769017674192345533;\n                break;\n            }\n            *outfile_mid\n                .offset(\n                    i_0 as isize,\n                ) = *suffix_alphabet.offset(*sufindex.offset(i_0 as isize) as isize);\n            if *outfile_mid.offset(i_0 as isize) != 0 {\n                return;\n            }\n            *sufindex.offset(i_0 as isize) = 0 as libc::c_int as idx_t;\n            *outfile_mid\n                .offset(\n                    i_0 as isize,\n                ) = *suffix_alphabet.offset(*sufindex.offset(i_0 as isize) as isize);\n        }\n        match current_block_37 {\n            9769017674192345533 => {}\n            _ => {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"output file suffixes exhausted\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"output file suffixes exhausted\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"output file suffixes exhausted\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                current_block_37 = 2873832966593178012;\n            }\n        }\n    }",
        "sub_chunks": [],
        "live_in": [],
        "live_out": [
          "mut overflow: bool",
          "mut widen: bool",
          "mut current_block_37: u64",
          "mut i_0: i64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/split.rs:1255:5: 1368:7 (#0)",
        "pieces": [
          "src/split.rs:1255:5: 1368:7 (#0)"
        ],
        "num_lines": 114,
        "source": "match current_block_37 {\n        9769017674192345533 => {\n            widen = outfile_length != 0;\n            if !widen {\n                outbase_length = strlen(outbase) as idx_t;\n                addsuf_length = (if !additional_suffix.is_null() {\n                    strlen(additional_suffix)\n                } else {\n                    0 as libc::c_int as libc::c_ulong\n                }) as idx_t;\n                let (fresh6, fresh7) = (outbase_length + addsuf_length)\n                    .overflowing_add(suffix_length);\n                *(&mut outfile_length as *mut idx_t) = fresh6;\n                overflow = fresh7;\n            } else {\n                let (fresh8, fresh9) = outfile_length.overflowing_add((2 as libc::c_int).into());\n                *(&mut outfile_length as *mut idx_t) = fresh8;\n                overflow = fresh9;\n                suffix_length += 1;\n                suffix_length;\n            }\n            let mut outfile_size: idx_t = 0;\n            let (fresh10, fresh11) = outfile_length.overflowing_add((1 as libc::c_int).into());\n            *(&mut outfile_size as *mut idx_t) = fresh10;\n            overflow = (overflow as libc::c_int | fresh11 as libc::c_int) != 0;\n            if overflow {\n                xalloc_die();\n            }\n            outfile = xirealloc(outfile as *mut libc::c_void, outfile_size)\n                as *mut libc::c_char;\n            if !widen {\n                memcpy(\n                    outfile as *mut libc::c_void,\n                    outbase as *const libc::c_void,\n                    outbase_length as libc::c_ulong,\n                );\n            } else {\n                *outfile\n                    .offset(\n                        outbase_length as isize,\n                    ) = *suffix_alphabet\n                    .offset(*sufindex.offset(0 as libc::c_int as isize) as isize);\n                outbase_length += 1;\n                outbase_length;\n            }\n            outfile_mid = outfile.offset(outbase_length as isize);\n            memset(\n                outfile_mid as *mut libc::c_void,\n                *suffix_alphabet.offset(0 as libc::c_int as isize) as libc::c_int,\n                suffix_length as libc::c_ulong,\n            );\n            if !additional_suffix.is_null() {\n                memcpy(\n                    outfile_mid.offset(suffix_length as isize) as *mut libc::c_void,\n                    additional_suffix as *const libc::c_void,\n                    addsuf_length as libc::c_ulong,\n                );\n            }\n            *outfile.offset(outfile_length as isize) = 0 as libc::c_int as libc::c_char;\n            free(sufindex as *mut libc::c_void);\n            sufindex = xicalloc(\n                suffix_length,\n                ::core::mem::size_of::<idx_t>() as libc::c_ulong as idx_t,\n            ) as *mut idx_t;\n            if !numeric_suffix_start.is_null() {\n                if !widen {} else {\n                    __assert_fail(\n                        b\"! widen\\0\" as *const u8 as *const libc::c_char,\n                        b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                        423 as libc::c_int as libc::c_uint,\n                        (*::core::mem::transmute::<\n                            &[u8; 26],\n                            &[libc::c_char; 26],\n                        >(b\"void next_file_name(void)\\0\"))\n                            .as_ptr(),\n                    );\n                }\n                'c_9037: {\n                    if !widen {} else {\n                        __assert_fail(\n                            b\"! widen\\0\" as *const u8 as *const libc::c_char,\n                            b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                            423 as libc::c_int as libc::c_uint,\n                            (*::core::mem::transmute::<\n                                &[u8; 26],\n                                &[libc::c_char; 26],\n                            >(b\"void next_file_name(void)\\0\"))\n                                .as_ptr(),\n                        );\n                    }\n                };\n                let mut i: idx_t = strlen(numeric_suffix_start) as idx_t;\n                memcpy(\n                    outfile_mid.offset(suffix_length as isize).offset(-(i as isize))\n                        as *mut libc::c_void,\n                    numeric_suffix_start as *const libc::c_void,\n                    i as libc::c_ulong,\n                );\n                let mut sufindex_end: *mut idx_t = sufindex\n                    .offset(suffix_length as isize);\n                loop {\n                    let fresh12 = i;\n                    i = i - 1;\n                    if !(fresh12 != 0 as libc::c_int as libc::c_long) {\n                        break;\n                    }\n                    sufindex_end = sufindex_end.offset(-1);\n                    *sufindex_end = (*numeric_suffix_start.offset(i as isize)\n                        as libc::c_int - '0' as i32) as idx_t;\n                }\n            }\n        }\n        _ => {}\n    };",
        "sub_chunks": [],
        "live_in": [
          "mut overflow: bool",
          "mut widen: bool",
          "mut current_block_37: u64"
        ],
        "live_out": [
          "mut overflow: bool",
          "mut widen: bool",
          "mut current_block_37: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:240 ~ split[1dd7]::cwrite)",
    "span": "src/split.rs:2426:1: 2552:2 (#0)",
    "pieces": [
      "src/split.rs:2426:1: 2552:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 127,
    "source": "unsafe extern \"C\" fn cwrite(\n    mut new_file_flag: bool,\n    mut bp: *const libc::c_char,\n    mut bytes: idx_t,\n) -> bool {\n    if new_file_flag {\n        if bp.is_null() && bytes == 0 as libc::c_int as libc::c_long\n            && elide_empty_files as libc::c_int != 0\n        {\n            return 1 as libc::c_int != 0;\n        }\n        closeout(0 as *mut FILE, output_desc, filter_pid, outfile);\n        next_file_name();\n        output_desc = create(outfile);\n        if output_desc < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        outfile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            outfile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            outfile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    }\n    if full_write(output_desc, bp as *const libc::c_void, bytes as size_t)\n        == bytes as libc::c_ulong\n    {\n        return 1 as libc::c_int != 0\n    } else {\n        if !ignorable(*__errno_location()) {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        outfile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            outfile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            outfile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        return 0 as libc::c_int != 0;\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:261 ~ split[1dd7]::bytes_split)",
        "span": "src/split.rs:2675:9: 2679:11 (#0)",
        "source": "cwrite(\n            1 as libc::c_int != 0,\n            0 as *const libc::c_char,\n            0 as libc::c_int as idx_t,\n        );"
      },
      {
        "caller": "DefId(0:262 ~ split[1dd7]::lines_split)",
        "span": "src/split.rs:2756:21: 2756:56 (#0)",
        "source": "cwrite(new_file_flag, bp_out, len);"
      },
      {
        "caller": "DefId(0:263 ~ split[1dd7]::line_bytes_split)",
        "span": "src/split.rs:2924:9: 2924:73 (#0)",
        "source": "cwrite(n_out == 0 as libc::c_int as libc::c_long, hold, n_hold);"
      },
      {
        "caller": "DefId(0:264 ~ split[1dd7]::lines_chunk_split)",
        "span": "src/split.rs:3139:9: 3139:62 (#0)",
        "source": "cwrite(new_file_flag as i32 != 0, 0 as *const i8, 0);"
      },
      {
        "caller": "DefId(0:262 ~ split[1dd7]::lines_split)",
        "span": "src/split.rs:2765:21: 2769:23 (#0)",
        "source": "cwrite(\n                        new_file_flag,\n                        bp_out,\n                        bp.offset_from(bp_out) as libc::c_long,\n                    );"
      }
    ],
    "globals": [
      {
        "span": "src/split.rs:670:1: 670:34 (#0)",
        "source": "static mut filter_pid: pid_t = 0;"
      },
      {
        "span": "src/split.rs:676:1: 676:87 (#0)",
        "source": "static mut outfile: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;"
      },
      {
        "span": "src/split.rs:356:1: 356:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/split.rs:704:1: 704:59 (#0)",
        "source": "static mut output_desc: libc::c_int = -(1 as libc::c_int);"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:222 ~ split[1dd7]::copy_to_tmpfile)",
    "span": "src/split.rs:1042:1: 1085:2 (#0)",
    "pieces": [
      "src/split.rs:1042:1: 1085:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 44,
    "source": "unsafe extern \"C\" fn copy_to_tmpfile(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n) -> off_t {\n    let mut tmp: *mut FILE = 0 as *mut FILE;\n    if !temp_stream(&mut tmp, 0 as *mut *mut libc::c_char) {\n        return -(1 as libc::c_int) as off_t;\n    }\n    let mut copied: off_t = 0 as libc::c_int as off_t;\n    let mut r: off_t = 0;\n    loop {\n        r = read(fd, buf as *mut libc::c_void, bufsize as size_t);\n        if !((0 as libc::c_int as libc::c_long) < r) {\n            break;\n        }\n        if fwrite_unlocked(\n            buf as *const libc::c_void,\n            1 as libc::c_int as size_t,\n            r as size_t,\n            tmp,\n        ) != r as libc::c_ulong\n        {\n            return -(1 as libc::c_int) as off_t;\n        }\n        let (fresh2, fresh3) = copied.overflowing_add(r);\n        *(&mut copied as *mut off_t) = fresh2;\n        if fresh3 {\n            *__errno_location() = 75 as libc::c_int;\n            return -(1 as libc::c_int) as off_t;\n        }\n    }\n    if r < 0 as libc::c_int as libc::c_long {\n        return r;\n    }\n    r = dup2(fileno(tmp), fd) as off_t;\n    if r < 0 as libc::c_int as libc::c_long {\n        return r;\n    }\n    if rpl_fclose(tmp) < 0 as libc::c_int {\n        return -(1 as libc::c_int) as off_t;\n    }\n    return copied;\n}",
    "calls": [
      {
        "caller": "DefId(0:243 ~ split[1dd7]::input_file_size)",
        "span": "src/split.rs:1121:9: 1121:52 (#0)",
        "source": "end = copy_to_tmpfile(fd, tmpbuf, bufsize);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:188 ~ split[1dd7]::__gl_stdbit_clzll)",
    "span": "src/split.rs:564:1: 570:2 (#0)",
    "pieces": [
      "src/split.rs:564:1: 570:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:209 ~ split[1dd7]::stdc_leading_zeros_ull)",
        "span": "src/split.rs:574:5: 574:51 (#0)",
        "source": "let result: u32 = __gl_stdbit_clzll(n) as u32;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:243 ~ split[1dd7]::line_bytes_split)",
    "span": "src/split.rs:2781:1: 2927:2 (#0)",
    "pieces": [
      "src/split.rs:2781:1: 2927:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 147,
    "source": "unsafe extern \"C\" fn line_bytes_split(\n    mut n_bytes: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n) {\n    let mut n_read: ssize_t = 0;\n    let mut n_out: intmax_t = 0 as libc::c_int as intmax_t;\n    let mut n_hold: idx_t = 0 as libc::c_int as idx_t;\n    let mut hold: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut hold_size: idx_t = 0 as libc::c_int as idx_t;\n    let mut split_line: bool = 0 as libc::c_int != 0;\n    loop {\n        n_read = read(0 as libc::c_int, buf as *mut libc::c_void, bufsize as size_t);\n        if n_read < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        let mut n_left: idx_t = n_read;\n        let mut sob: *mut libc::c_char = buf;\n        while n_left != 0 {\n            let mut split_rest: idx_t = 0 as libc::c_int as idx_t;\n            let mut eoc: *mut libc::c_char = 0 as *mut libc::c_char;\n            let mut eol: *mut libc::c_char = 0 as *mut libc::c_char;\n            if n_bytes - n_out - n_hold <= n_left {\n                split_rest = n_bytes - n_out - n_hold;\n                eoc = sob\n                    .offset(split_rest as isize)\n                    .offset(-(1 as libc::c_int as isize));\n                eol = memrchr(sob as *const libc::c_void, eolchar, split_rest as size_t)\n                    as *mut libc::c_char;\n            } else {\n                eol = memrchr(sob as *const libc::c_void, eolchar, n_left as size_t)\n                    as *mut libc::c_char;\n            }\n            if n_hold != 0 && !(eol.is_null() && n_out != 0) {\n                cwrite(n_out == 0 as libc::c_int as libc::c_long, hold, n_hold);\n                n_out += n_hold;\n                n_hold = 0 as libc::c_int as idx_t;\n            }\n            if !eol.is_null() {\n                split_line = 1 as libc::c_int != 0;\n                let mut n_write: idx_t = eol.offset_from(sob) as libc::c_long\n                    + 1 as libc::c_int as libc::c_long;\n                cwrite(n_out == 0 as libc::c_int as libc::c_long, sob, n_write);\n                n_out += n_write;\n                n_left -= n_write;\n                sob = sob.offset(n_write as isize);\n                if !eoc.is_null() {\n                    split_rest -= n_write;\n                }\n            }\n            if n_left != 0 && !split_line {\n                let mut n_write_0: idx_t = if !eoc.is_null() {\n                    split_rest\n                } else {\n                    n_left\n                };\n                cwrite(n_out == 0 as libc::c_int as libc::c_long, sob, n_write_0);\n                n_out += n_write_0;\n                n_left -= n_write_0;\n                sob = sob.offset(n_write_0 as isize);\n                if !eoc.is_null() {\n                    split_rest -= n_write_0;\n                }\n            }\n            if !eoc.is_null() && split_rest != 0 || eoc.is_null() && n_left != 0 {\n                let mut n_buf: idx_t = if !eoc.is_null() { split_rest } else { n_left };\n                if hold_size - n_hold < n_buf {\n                    hold = xpalloc(\n                        hold as *mut libc::c_void,\n                        &mut hold_size,\n                        n_buf - (hold_size - n_hold),\n                        -(1 as libc::c_int) as ptrdiff_t,\n                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong as idx_t,\n                    ) as *mut libc::c_char;\n                }\n                memcpy(\n                    hold.offset(n_hold as isize) as *mut libc::c_void,\n                    sob as *const libc::c_void,\n                    n_buf as libc::c_ulong,\n                );\n                n_hold += n_buf;\n                n_left -= n_buf;\n                sob = sob.offset(n_buf as isize);\n            }\n            if !eoc.is_null() {\n                n_out = 0 as libc::c_int as intmax_t;\n                split_line = 0 as libc::c_int != 0;\n            }\n        }\n        if !(n_read != 0) {\n            break;\n        }\n    }\n    if n_hold != 0 {\n        cwrite(n_out == 0 as libc::c_int as libc::c_long, hold, n_hold);\n    }\n    free(hold as *mut libc::c_void);\n}",
    "calls": [
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:5078:13: 5078:57 (#0)",
        "source": "line_bytes_split(n_units, buf, in_blk_size);"
      }
    ],
    "globals": [
      {
        "span": "src/split.rs:685:1: 685:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/split.rs:356:1: 356:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:244 ~ split[1dd7]::lines_chunk_split)",
    "span": "src/split.rs:2928:1: 3143:2 (#0)",
    "pieces": [
      "src/split.rs:2928:1: 2936:4 (#0)",
      "src/split.rs:3143:1: 3143:2 (#0)"
    ],
    "sub_chunks": [
      1
    ],
    "num_lines": 10,
    "source": "unsafe extern \"C\" fn lines_chunk_split(\n    mut k: intmax_t,\n    mut n: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n    mut initial_read: ssize_t,\n    mut file_size: off_t,\n) {\n   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:5102:13: 5109:15 (#0)",
        "source": "lines_chunk_split(\n                k_units,\n                n_units,\n                buf,\n                in_blk_size,\n                initial_read,\n                file_size,\n            );"
      }
    ],
    "globals": [
      {
        "span": "src/split.rs:356:1: 356:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/split.rs:685:1: 685:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/split.rs:2975:5: 3124:10 (#0)",
        "pieces": [
          "src/split.rs:2975:5: 3124:10 (#0)"
        ],
        "num_lines": 150,
        "source": "let mut bp: *mut libc::c_char = buf;\n        let mut eob: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut n_read: ssize_t = 0;\n        if 0 as libc::c_int as libc::c_long <= initial_read {\n            n_read = initial_read;\n            initial_read = -(1 as libc::c_int) as ssize_t;\n        } else {\n            n_read = read(\n                0 as libc::c_int,\n                buf as *mut libc::c_void,\n                (if bufsize < file_size - n_written {\n                    bufsize\n                } else {\n                    file_size - n_written\n                }) as size_t,\n            );\n            if n_read < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        }\n        if n_read == 0 as libc::c_int as libc::c_long {\n            break;\n        }\n        chunk_truncated = 0 as libc::c_int != 0;\n        eob = buf.offset(n_read as isize);\n        while bp != eob {\n            let mut to_write: idx_t = 0;\n            let mut next: bool = 0 as libc::c_int != 0;\n            let mut skip: off_t = if n_read\n                < (if 0 as libc::c_int as libc::c_long\n                    > chunk_end - 1 as libc::c_int as libc::c_long - n_written\n                {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    chunk_end - 1 as libc::c_int as libc::c_long - n_written\n                })\n            {\n                n_read\n            } else if 0 as libc::c_int as libc::c_long\n                > chunk_end - 1 as libc::c_int as libc::c_long - n_written\n            {\n                0 as libc::c_int as libc::c_long\n            } else {\n                chunk_end - 1 as libc::c_int as libc::c_long - n_written\n            };\n            let mut bp_out: *mut libc::c_char = memchr(\n                bp.offset(skip as isize) as *const libc::c_void,\n                eolchar,\n                (n_read - skip) as libc::c_ulong,\n            ) as *mut libc::c_char;\n            if !bp_out.is_null() {\n                bp_out = bp_out.offset(1);\n                bp_out;\n                next = 1 as libc::c_int != 0;\n            } else {\n                bp_out = eob;\n            }\n            to_write = bp_out.offset_from(bp) as libc::c_long;\n            if k == chunk_no {\n                if full_write(\n                    1 as libc::c_int,\n                    bp as *const libc::c_void,\n                    to_write as size_t,\n                ) != to_write as libc::c_ulong\n                {\n                    write_error();\n                }\n            } else if k == 0 {\n                cwrite(new_file_flag, bp, to_write);\n            }\n            n_written += to_write;\n            bp = bp.offset(to_write as isize);\n            n_read -= to_write;\n            new_file_flag = next;\n            while next as libc::c_int != 0 || chunk_end <= n_written {\n                if !next && bp == eob {\n                    chunk_truncated = 1 as libc::c_int != 0;\n                    break;\n                } else {\n                    if k == chunk_no {\n                        return;\n                    }\n                    chunk_end\n                        += chunk_size\n                            + (chunk_no < rem_bytes) as libc::c_int as libc::c_long;\n                    chunk_no += 1;\n                    chunk_no;\n                    if chunk_end <= n_written {\n                        if k == 0 {\n                            cwrite(\n                                1 as libc::c_int != 0,\n                                0 as *const libc::c_char,\n                                0 as libc::c_int as idx_t,\n                            );\n                        }\n                    } else {\n                        next = 0 as libc::c_int != 0;\n                    }\n                }\n            }\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut k: i64",
          "mut buf: *mut i8",
          "mut bufsize: i64",
          "mut initial_read: i64",
          "mut file_size: i64",
          "rem_bytes: i64",
          "chunk_size: i64",
          "mut chunk_no: i64",
          "mut chunk_end: i64",
          "mut n_written: i64",
          "mut new_file_flag: bool",
          "mut chunk_truncated: bool"
        ],
        "live_out": [
          "mut k: i64",
          "mut buf: *mut i8",
          "mut bufsize: i64",
          "mut initial_read: i64",
          "mut file_size: i64",
          "rem_bytes: i64",
          "chunk_size: i64",
          "mut chunk_no: i64",
          "mut chunk_end: i64",
          "mut n_written: i64",
          "mut new_file_flag: bool",
          "mut chunk_truncated: bool",
          "mut bp: *mut i8",
          "mut eob: *mut i8",
          "mut n_read: i64",
          "mut to_write: i64",
          "mut next: bool",
          "mut skip: i64",
          "mut bp_out: *mut i8"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/split.rs:2936:5: 3141:2 (#0)",
        "pieces": [
          "src/split.rs:2936:5: 2975:4 (#0)",
          "src/split.rs:3125:1: 3141:2 (#0)"
        ],
        "num_lines": 138,
        "source": "if n != 0 && k <= n {} else {\n        __assert_fail(\n            b\"n && k <= n\\0\" as *const u8 as *const libc::c_char,\n            b\"split.c\\0\" as *const u8 as *const libc::c_char,\n            880 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 74],\n                &[libc::c_char; 74],\n            >(\n                b\"void lines_chunk_split(intmax_t, intmax_t, char *, idx_t, ssize_t, off_t)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_13572: {\n        if n != 0 && k <= n {} else {\n            __assert_fail(\n                b\"n && k <= n\\0\" as *const u8 as *const libc::c_char,\n                b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                880 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 74],\n                    &[libc::c_char; 74],\n                >(\n                    b\"void lines_chunk_split(intmax_t, intmax_t, char *, idx_t, ssize_t, off_t)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    let mut rem_bytes: intmax_t = file_size % n;\n    let mut chunk_size: off_t = file_size / n;\n    let mut chunk_no: intmax_t = 1 as libc::c_int as intmax_t;\n    let mut chunk_end: off_t = chunk_size\n        + ((0 as libc::c_int as libc::c_long) < rem_bytes) as libc::c_int\n            as libc::c_long;\n    let mut n_written: off_t = 0 as libc::c_int as off_t;\n    let mut new_file_flag: bool = 1 as libc::c_int != 0;\n    let mut chunk_truncated: bool = 0 as libc::c_int != 0;\n    if k > 1 as libc::c_int as libc::c_long\n        && (0 as libc::c_int as libc::c_long) < file_size\n    {\n        let mut start: off_t = (k - 1 as libc::c_int as libc::c_long) * chunk_size\n            + (if (k - 1 as libc::c_int as libc::c_long) < rem_bytes {\n                k - 1 as libc::c_int as libc::c_long\n            } else {\n                rem_bytes\n            }) - 1 as libc::c_int as libc::c_long;\n        if start < initial_read {\n            memmove(\n                buf as *mut libc::c_void,\n                buf.offset(start as isize) as *const libc::c_void,\n                (initial_read - start) as libc::c_ulong,\n            );\n            initial_read -= start;\n        } else {\n            if initial_read < start\n                && lseek(0 as libc::c_int, start - initial_read, 1 as libc::c_int)\n                    < 0 as libc::c_int as libc::c_long\n            {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            initial_read = -(1 as libc::c_int) as ssize_t;\n        }\n        n_written = start;\n        chunk_no = k - 1 as libc::c_int as libc::c_long;\n        chunk_end = start + 1 as libc::c_int as libc::c_long;\n    }\n    while n_written < file_size {\n       <<chunk 0>>    }\n    if chunk_truncated {\n        chunk_no += 1;\n        chunk_no;\n    }\n    if k == 0 {\n        loop {\n            let fresh17 = chunk_no;\n            chunk_no = chunk_no + 1;\n            if !(fresh17 <= n) {\n                break;\n            }\n            cwrite(\n                1 as libc::c_int != 0,\n                0 as *const libc::c_char,\n                0 as libc::c_int as idx_t,\n            );\n        }\n    }",
        "sub_chunks": [
          0
        ],
        "live_in": [
          "mut k: i64",
          "mut n: i64",
          "mut buf: *mut i8",
          "mut bufsize: i64",
          "mut initial_read: i64",
          "mut file_size: i64"
        ],
        "live_out": [
          "mut k: i64",
          "mut n: i64",
          "mut buf: *mut i8",
          "mut bufsize: i64",
          "mut initial_read: i64",
          "mut file_size: i64",
          "rem_bytes: i64",
          "chunk_size: i64",
          "mut chunk_no: i64",
          "mut chunk_end: i64",
          "mut n_written: i64",
          "mut new_file_flag: bool",
          "mut chunk_truncated: bool"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:255 ~ split[1dd7]::lines_rr)",
    "span": "src/split.rs:3489:1: 3808:2 (#0)",
    "pieces": [
      "src/split.rs:3489:1: 3496:4 (#0)",
      "src/split.rs:3808:1: 3808:2 (#0)"
    ],
    "sub_chunks": [
      5
    ],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn lines_rr(\n    mut k: intmax_t,\n    mut n: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n    mut filesp: *mut *mut of_t,\n) {\n   <<chunk 5>>}",
    "calls": [
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:5113:13: 5113:70 (#0)",
        "source": "lines_rr(k_units, n_units, buf, in_blk_size, &mut files);"
      }
    ],
    "globals": [
      {
        "span": "src/split.rs:356:1: 356:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/split.rs:685:1: 685:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/split.rs:3606:17: 3631:18 (#0)",
        "pieces": [
          "src/split.rs:3606:17: 3631:18 (#0)"
        ],
        "num_lines": 26,
        "source": "if line_no == k && unbuffered as libc::c_int != 0 {\n                    if full_write(\n                        1 as libc::c_int,\n                        bp as *const libc::c_void,\n                        to_write as size_t,\n                    ) != to_write as libc::c_ulong\n                    {\n                        write_error();\n                    }\n                } else if line_no == k\n                    && fwrite_unlocked(\n                        bp as *const libc::c_void,\n                        to_write as size_t,\n                        1 as libc::c_int as size_t,\n                        stdout,\n                    ) != 1 as libc::c_int as libc::c_ulong\n                {\n                    write_error();\n                }\n                if next {\n                    line_no = if line_no == n {\n                        1 as libc::c_int as libc::c_long\n                    } else {\n                        line_no + 1 as libc::c_int as libc::c_long\n                    };\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut k: i64",
          "mut n: i64",
          "mut line_no: i64",
          "mut bp: *mut i8",
          "mut to_write: i64",
          "mut next: bool"
        ],
        "live_out": [
          "mut k: i64",
          "mut n: i64",
          "mut line_no: i64",
          "mut bp: *mut i8",
          "mut to_write: i64",
          "mut next: bool"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/split.rs:3633:17: 3753:18 (#0)",
        "pieces": [
          "src/split.rs:3633:17: 3753:18 (#0)"
        ],
        "num_lines": 121,
        "source": "file_limit = (file_limit as libc::c_int\n                    | ofile_open(files, i_file, n) as libc::c_int) != 0;\n                if unbuffered {\n                    if full_write(\n                        (*files.offset(i_file as isize)).ofd,\n                        bp as *const libc::c_void,\n                        to_write as size_t,\n                    ) != to_write as libc::c_ulong && !ignorable(*__errno_location())\n                    {\n                        if 0 != 0 {\n                            error(\n                                1 as libc::c_int,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_file as isize)).of_name,\n                                ),\n                            );\n                            if 1 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        (*files.offset(i_file as isize)).of_name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        (*files.offset(i_file as isize)).of_name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    }\n                } else if fwrite_unlocked(\n                    bp as *const libc::c_void,\n                    to_write as size_t,\n                    1 as libc::c_int as size_t,\n                    (*files.offset(i_file as isize)).ofile,\n                ) != 1 as libc::c_int as libc::c_ulong && !ignorable(*__errno_location())\n                {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_file as isize)).of_name,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_file as isize)).of_name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_file as isize)).of_name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                if !ignorable(*__errno_location()) {\n                    wrote = 1 as libc::c_int != 0;\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut n: i64",
          "mut wrote: bool",
          "mut file_limit: bool",
          "mut i_file: i64",
          "mut files: *mut of_info",
          "mut bp: *mut i8",
          "mut to_write: i64"
        ],
        "live_out": [
          "mut n: i64",
          "mut wrote: bool",
          "mut file_limit: bool",
          "mut i_file: i64",
          "mut files: *mut of_info",
          "mut bp: *mut i8",
          "mut to_write: i64"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/split.rs:3754:17: 3781:2 (#0)",
        "pieces": [
          "src/split.rs:3754:17: 3781:2 (#0)"
        ],
        "num_lines": 72,
        "source": "if file_limit {\n                    if rpl_fclose((*files.offset(i_file as isize)).ofile)\n                        != 0 as libc::c_int\n                    {\n                        if 0 != 0 {\n                            error(\n                                1 as libc::c_int,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_file as isize)).of_name,\n                                ),\n                            );\n                            if 1 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        (*files.offset(i_file as isize)).of_name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        (*files.offset(i_file as isize)).of_name,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    }\n                    let ref mut fresh22 = (*files.offset(i_file as isize)).ofile;\n                    *fresh22 = 0 as *mut FILE;\n                    (*files.offset(i_file as isize)).ofd = OFD_APPEND as libc::c_int;\n                }\n                if next as libc::c_int != 0\n                    && {\n                        i_file += 1;\n                        i_file == n\n                    }\n                {\n                    wrapped = 1 as libc::c_int != 0;\n                    if !wrote {\n                        break 's_76;\n                    }\n                    wrote = 0 as libc::c_int != 0;\n                    i_file = 0 as libc::c_int as idx_t;\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut n: i64",
          "mut wrapped: bool",
          "mut wrote: bool",
          "mut file_limit: bool",
          "mut i_file: i64",
          "mut files: *mut of_info",
          "mut next: bool"
        ],
        "live_out": [
          "mut n: i64",
          "mut wrapped: bool",
          "mut wrote: bool",
          "mut file_limit: bool",
          "mut i_file: i64",
          "mut files: *mut of_info",
          "mut next: bool"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/split.rs:3590:13: 3784:25 (#0)",
        "pieces": [
          "src/split.rs:3590:13: 3606:16 (#0)",
          "src/split.rs:3632:1: 3633:16 (#0)",
          "src/split.rs:3754:1: 3754:16 (#0)",
          "src/split.rs:3783:1: 3784:25 (#0)"
        ],
        "num_lines": 22,
        "source": "let mut to_write: idx_t = 0;\n            let mut next: bool = 0 as libc::c_int != 0;\n            let mut bp_out: *mut libc::c_char = memchr(\n                bp as *const libc::c_void,\n                eolchar,\n                eob.offset_from(bp) as libc::c_long as libc::c_ulong,\n            ) as *mut libc::c_char;\n            if !bp_out.is_null() {\n                bp_out = bp_out.offset(1);\n                bp_out;\n                next = 1 as libc::c_int != 0;\n            } else {\n                bp_out = eob;\n            }\n            to_write = bp_out.offset_from(bp) as libc::c_long;\n            if k != 0 {\n               <<chunk 0>>            } else {\n               <<chunk 1>>               <<chunk 2>>            }\n            bp = bp_out;",
        "sub_chunks": [
          0,
          1,
          2
        ],
        "live_in": [
          "mut k: i64",
          "mut n: i64",
          "mut wrapped: bool",
          "mut wrote: bool",
          "mut file_limit: bool",
          "mut i_file: i64",
          "mut files: *mut of_info",
          "mut line_no: i64",
          "mut bp: *mut i8",
          "mut eob: *mut i8"
        ],
        "live_out": [
          "mut k: i64",
          "mut n: i64",
          "mut wrapped: bool",
          "mut wrote: bool",
          "mut file_limit: bool",
          "mut i_file: i64",
          "mut files: *mut of_info",
          "mut line_no: i64",
          "mut bp: *mut i8",
          "mut eob: *mut i8"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/split.rs:3527:9: 3785:10 (#0)",
        "pieces": [
          "src/split.rs:3527:9: 3590:12 (#0)",
          "src/split.rs:3785:1: 3785:10 (#0)"
        ],
        "num_lines": 65,
        "source": "let mut bp: *mut libc::c_char = buf;\n        let mut eob: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut n_read: ssize_t = read(\n            0 as libc::c_int,\n            buf as *mut libc::c_void,\n            bufsize as size_t,\n        );\n        if n_read < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else if n_read == 0 as libc::c_int as libc::c_long {\n            break;\n        }\n        eob = buf.offset(n_read as isize);\n        while bp != eob {\n           <<chunk 3>>        }",
        "sub_chunks": [
          3
        ],
        "live_in": [
          "mut k: i64",
          "mut n: i64",
          "mut buf: *mut i8",
          "mut bufsize: i64",
          "mut wrapped: bool",
          "mut wrote: bool",
          "mut file_limit: bool",
          "mut i_file: i64",
          "mut files: *mut of_info",
          "mut line_no: i64"
        ],
        "live_out": [
          "mut k: i64",
          "mut n: i64",
          "mut buf: *mut i8",
          "mut bufsize: i64",
          "mut wrapped: bool",
          "mut wrote: bool",
          "mut file_limit: bool",
          "mut i_file: i64",
          "mut files: *mut of_info",
          "mut line_no: i64",
          "mut bp: *mut i8",
          "mut eob: *mut i8",
          "mut n_read: i64"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/split.rs:3496:5: 3807:6 (#0)",
        "pieces": [
          "src/split.rs:3496:5: 3527:8 (#0)",
          "src/split.rs:3786:1: 3807:6 (#0)"
        ],
        "num_lines": 54,
        "source": "let mut wrapped: bool = 0 as libc::c_int != 0;\n    let mut wrote: bool = 0 as libc::c_int != 0;\n    let mut file_limit: bool = false;\n    let mut i_file: idx_t = 0;\n    let mut files: *mut of_t = 0 as *mut of_t;\n    let mut line_no: intmax_t = 0;\n    if k != 0 {\n        line_no = 1 as libc::c_int as intmax_t;\n    } else {\n        if (9223372036854775807 as libc::c_long) < n {\n            xalloc_die();\n        }\n        *filesp = xinmalloc(n, ::core::mem::size_of::<of_t>() as libc::c_ulong as idx_t)\n            as *mut of_t;\n        files = *filesp;\n        i_file = 0 as libc::c_int as idx_t;\n        while i_file < n {\n            next_file_name();\n            let ref mut fresh20 = (*files.offset(i_file as isize)).of_name;\n            *fresh20 = xstrdup(outfile);\n            (*files.offset(i_file as isize)).ofd = OFD_NEW as libc::c_int;\n            let ref mut fresh21 = (*files.offset(i_file as isize)).ofile;\n            *fresh21 = 0 as *mut FILE;\n            (*files.offset(i_file as isize)).opid = 0 as libc::c_int;\n            i_file += 1;\n            i_file;\n        }\n        i_file = 0 as libc::c_int as idx_t;\n        file_limit = 0 as libc::c_int != 0;\n    }\n    's_76: loop {\n       <<chunk 4>>    }\n    if k == 0 {\n        let mut ceiling: idx_t = if wrapped as libc::c_int != 0 { n } else { i_file };\n        i_file = 0 as libc::c_int as idx_t;\n        while i_file < n {\n            if i_file >= ceiling && !elide_empty_files {\n                file_limit = (file_limit as libc::c_int\n                    | ofile_open(files, i_file, n) as libc::c_int) != 0;\n            }\n            if (*files.offset(i_file as isize)).ofd >= 0 as libc::c_int {\n                closeout(\n                    (*files.offset(i_file as isize)).ofile,\n                    (*files.offset(i_file as isize)).ofd,\n                    (*files.offset(i_file as isize)).opid,\n                    (*files.offset(i_file as isize)).of_name,\n                );\n            }\n            (*files.offset(i_file as isize)).ofd = OFD_APPEND as libc::c_int;\n            i_file += 1;\n            i_file;\n        }\n    }",
        "sub_chunks": [
          4
        ],
        "live_in": [
          "mut k: i64",
          "mut n: i64",
          "mut buf: *mut i8",
          "mut bufsize: i64",
          "mut filesp: *mut *mut of_info"
        ],
        "live_out": [
          "mut k: i64",
          "mut n: i64",
          "mut buf: *mut i8",
          "mut bufsize: i64",
          "mut filesp: *mut *mut of_info",
          "mut wrapped: bool",
          "mut wrote: bool",
          "mut file_limit: bool",
          "mut i_file: i64",
          "mut files: *mut of_info",
          "mut line_no: i64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:241 ~ split[1dd7]::bytes_split)",
    "span": "src/split.rs:2553:1: 2681:2 (#0)",
    "pieces": [
      "src/split.rs:2553:1: 2681:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 129,
    "source": "unsafe extern \"C\" fn bytes_split(\n    mut n_bytes: intmax_t,\n    mut rem_bytes: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n    mut initial_read: ssize_t,\n    mut max_files: intmax_t,\n) {\n    let mut new_file_flag: bool = 1 as libc::c_int != 0;\n    let mut filter_ok: bool = 1 as libc::c_int != 0;\n    let mut opened: intmax_t = 0 as libc::c_int as intmax_t;\n    let mut to_write: intmax_t = n_bytes\n        + ((0 as libc::c_int as libc::c_long) < rem_bytes) as libc::c_int\n            as libc::c_long;\n    let mut eof: bool = to_write == 0;\n    while !eof {\n        let mut n_read: ssize_t = 0;\n        if 0 as libc::c_int as libc::c_long <= initial_read {\n            n_read = initial_read;\n            initial_read = -(1 as libc::c_int) as ssize_t;\n            eof = n_read < bufsize;\n        } else {\n            if !filter_ok\n                && 0 as libc::c_int as libc::c_long\n                    <= lseek(0 as libc::c_int, to_write, 1 as libc::c_int)\n            {\n                to_write = n_bytes\n                    + ((opened + 1 as libc::c_int as libc::c_long) < rem_bytes)\n                        as libc::c_int as libc::c_long;\n                new_file_flag = 1 as libc::c_int != 0;\n            }\n            n_read = read(0 as libc::c_int, buf as *mut libc::c_void, bufsize as size_t);\n            if n_read < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            eof = n_read == 0 as libc::c_int as libc::c_long;\n        }\n        let mut bp_out: *mut libc::c_char = buf;\n        while (0 as libc::c_int as libc::c_long) < to_write && to_write <= n_read {\n            if filter_ok as libc::c_int != 0 || new_file_flag as libc::c_int != 0 {\n                filter_ok = cwrite(new_file_flag, bp_out, to_write);\n            }\n            opened += new_file_flag as libc::c_long;\n            new_file_flag = max_files == 0 || opened < max_files;\n            if !filter_ok && !new_file_flag {\n                n_read = 0 as libc::c_int as ssize_t;\n                eof = 1 as libc::c_int != 0;\n                break;\n            } else {\n                bp_out = bp_out.offset(to_write as isize);\n                n_read -= to_write;\n                to_write = n_bytes + (opened < rem_bytes) as libc::c_int as libc::c_long;\n            }\n        }\n        if !((0 as libc::c_int as libc::c_long) < n_read) {\n            continue;\n        }\n        if filter_ok as libc::c_int != 0 || new_file_flag as libc::c_int != 0 {\n            filter_ok = cwrite(new_file_flag, bp_out, n_read);\n        }\n        opened += new_file_flag as libc::c_long;\n        new_file_flag = 0 as libc::c_int != 0;\n        if !filter_ok && opened == max_files {\n            break;\n        }\n        to_write -= n_read;\n    }\n    loop {\n        let fresh16 = opened;\n        opened = opened + 1;\n        if !(fresh16 < max_files) {\n            break;\n        }\n        cwrite(\n            1 as libc::c_int != 0,\n            0 as *const libc::c_char,\n            0 as libc::c_int as idx_t,\n        );\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:5068:13: 5075:15 (#0)",
        "source": "bytes_split(\n                n_units,\n                0 as libc::c_int as intmax_t,\n                buf,\n                in_blk_size,\n                -(1 as libc::c_int) as ssize_t,\n                0 as libc::c_int as intmax_t,\n            );"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:5082:17: 5089:19 (#0)",
        "source": "bytes_split(\n                    file_size / n_units,\n                    file_size % n_units,\n                    buf,\n                    in_blk_size,\n                    initial_read,\n                    n_units,\n                );"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:249 ~ split[1dd7]::bytes_chunk_extract)",
    "span": "src/split.rs:3144:1: 3301:2 (#0)",
    "pieces": [
      "src/split.rs:3144:1: 3152:4 (#0)",
      "src/split.rs:3260:1: 3260:4 (#0)",
      "src/split.rs:3301:1: 3301:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn bytes_chunk_extract(\n    mut k: intmax_t,\n    mut n: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n    mut initial_read: ssize_t,\n    mut file_size: off_t,\n) {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:5091:17: 5098:19 (#0)",
        "source": "bytes_chunk_extract(\n                    k_units,\n                    n_units,\n                    buf,\n                    in_blk_size,\n                    initial_read,\n                    file_size,\n                );"
      }
    ],
    "globals": [
      {
        "span": "src/split.rs:356:1: 356:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/split.rs:685:1: 685:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/split.rs:3152:5: 3259:6 (#0)",
        "pieces": [
          "src/split.rs:3152:5: 3259:6 (#0)"
        ],
        "num_lines": 108,
        "source": "let mut start: off_t = 0;\n    let mut end: off_t = 0;\n    if (0 as libc::c_int as libc::c_long) < k && k <= n {} else {\n        __assert_fail(\n            b\"0 < k && k <= n\\0\" as *const u8 as *const libc::c_char,\n            b\"split.c\\0\" as *const u8 as *const libc::c_char,\n            1009 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 76],\n                &[libc::c_char; 76],\n            >(\n                b\"void bytes_chunk_extract(intmax_t, intmax_t, char *, idx_t, ssize_t, off_t)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_14132: {\n        if (0 as libc::c_int as libc::c_long) < k && k <= n {} else {\n            __assert_fail(\n                b\"0 < k && k <= n\\0\" as *const u8 as *const libc::c_char,\n                b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                1009 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 76],\n                    &[libc::c_char; 76],\n                >(\n                    b\"void bytes_chunk_extract(intmax_t, intmax_t, char *, idx_t, ssize_t, off_t)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    start = (k - 1 as libc::c_int as libc::c_long) * (file_size / n)\n        + (if (k - 1 as libc::c_int as libc::c_long) < file_size % n {\n            k - 1 as libc::c_int as libc::c_long\n        } else {\n            file_size % n\n        });\n    end = if k == n {\n        file_size\n    } else {\n        k * (file_size / n) + (if k < file_size % n { k } else { file_size % n })\n    };\n    if start < initial_read {\n        memmove(\n            buf as *mut libc::c_void,\n            buf.offset(start as isize) as *const libc::c_void,\n            (initial_read - start) as libc::c_ulong,\n        );\n        initial_read -= start;\n    } else {\n        if initial_read < start\n            && lseek(0 as libc::c_int, start - initial_read, 1 as libc::c_int)\n                < 0 as libc::c_int as libc::c_long\n        {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        initial_read = -(1 as libc::c_int) as ssize_t;\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut k: i64",
          "mut n: i64",
          "mut buf: *mut i8",
          "mut initial_read: i64",
          "mut file_size: i64"
        ],
        "live_out": [
          "mut k: i64",
          "mut n: i64",
          "mut buf: *mut i8",
          "mut initial_read: i64",
          "mut file_size: i64",
          "mut start: i64",
          "mut end: i64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/split.rs:3260:5: 3299:2 (#0)",
        "pieces": [
          "src/split.rs:3260:5: 3299:2 (#0)"
        ],
        "num_lines": 120,
        "source": "while start < end {\n        let mut n_read: ssize_t = 0;\n        if 0 as libc::c_int as libc::c_long <= initial_read {\n            n_read = initial_read;\n            initial_read = -(1 as libc::c_int) as ssize_t;\n        } else {\n            n_read = read(0 as libc::c_int, buf as *mut libc::c_void, bufsize as size_t);\n            if n_read < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n        }\n        if n_read == 0 as libc::c_int as libc::c_long {\n            break;\n        }\n        n_read = if n_read < end - start { n_read } else { end - start };\n        if full_write(1 as libc::c_int, buf as *const libc::c_void, n_read as size_t)\n            != n_read as libc::c_ulong && !ignorable(*__errno_location())\n        {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        b\"-\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            b\"-\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            b\"-\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        start += n_read;\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut buf: *mut i8",
          "mut bufsize: i64",
          "mut initial_read: i64",
          "mut start: i64",
          "mut end: i64"
        ],
        "live_out": [
          "mut buf: *mut i8",
          "mut bufsize: i64",
          "mut initial_read: i64",
          "mut start: i64",
          "mut end: i64",
          "mut n_read: i64",
          "buffer: &[u8]",
          "written: std::result::Result<usize, std::io::Error>"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:242 ~ split[1dd7]::lines_split)",
    "span": "src/split.rs:2682:1: 2780:2 (#0)",
    "pieces": [
      "src/split.rs:2682:1: 2780:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 99,
    "source": "unsafe extern \"C\" fn lines_split(\n    mut n_lines: intmax_t,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n) {\n    let mut n_read: ssize_t = 0;\n    let mut bp: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut bp_out: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut eob: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut new_file_flag: bool = 1 as libc::c_int != 0;\n    let mut n: intmax_t = 0 as libc::c_int as intmax_t;\n    loop {\n        n_read = read(0 as libc::c_int, buf as *mut libc::c_void, bufsize as size_t);\n        if n_read < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        bp_out = buf;\n        bp = bp_out;\n        eob = bp.offset(n_read as isize);\n        *eob = eolchar as libc::c_char;\n        loop {\n            bp = rawmemchr(bp as *const libc::c_void, eolchar) as *mut libc::c_char;\n            if bp == eob {\n                if eob != bp_out {\n                    let mut len: idx_t = eob.offset_from(bp_out) as libc::c_long;\n                    cwrite(new_file_flag, bp_out, len);\n                    new_file_flag = 0 as libc::c_int != 0;\n                }\n                break;\n            } else {\n                bp = bp.offset(1);\n                bp;\n                n += 1;\n                if n >= n_lines {\n                    cwrite(\n                        new_file_flag,\n                        bp_out,\n                        bp.offset_from(bp_out) as libc::c_long,\n                    );\n                    bp_out = bp;\n                    new_file_flag = 1 as libc::c_int != 0;\n                    n = 0 as libc::c_int as intmax_t;\n                }\n            }\n        }\n        if !(n_read != 0) {\n            break;\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:5065:13: 5065:52 (#0)",
        "source": "lines_split(n_units, buf, in_blk_size);"
      }
    ],
    "globals": [
      {
        "span": "src/split.rs:685:1: 685:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/split.rs:708:1: 708:55 (#0)",
        "source": "static mut eolchar: libc::c_int = -(1 as libc::c_int);"
      },
      {
        "span": "src/split.rs:356:1: 356:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:223 ~ split[1dd7]::input_file_size)",
    "span": "src/split.rs:1086:1: 1156:2 (#0)",
    "pieces": [
      "src/split.rs:1086:1: 1156:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 71,
    "source": "unsafe extern \"C\" fn input_file_size(\n    mut fd: libc::c_int,\n    mut st: *const stat,\n    mut buf: *mut libc::c_char,\n    mut bufsize: idx_t,\n) -> off_t {\n    let mut size: off_t = 0 as libc::c_int as off_t;\n    loop {\n        let mut n_read: ssize_t = read(\n            fd,\n            buf.offset(size as isize) as *mut libc::c_void,\n            (bufsize - size) as size_t,\n        );\n        if n_read <= 0 as libc::c_int as libc::c_long {\n            return if n_read < 0 as libc::c_int as libc::c_long { n_read } else { size };\n        }\n        size += n_read;\n        if !(size < bufsize) {\n            break;\n        }\n    }\n    let mut cur: off_t = 0;\n    let mut end: off_t = 0;\n    if usable_st_size(st) as libc::c_int != 0 && (*st).st_size < size\n        || {\n            cur = lseek(fd, 0 as libc::c_int as __off_t, 1 as libc::c_int);\n            cur < 0 as libc::c_int as libc::c_long\n        } || cur < size\n        || {\n            end = lseek(fd, 0 as libc::c_int as __off_t, 2 as libc::c_int);\n            end < 0 as libc::c_int as libc::c_long\n        }\n    {\n        let mut tmpbuf: *mut libc::c_char = xmalloc(bufsize as size_t)\n            as *mut libc::c_char;\n        end = copy_to_tmpfile(fd, tmpbuf, bufsize);\n        free(tmpbuf as *mut libc::c_void);\n        if end < 0 as libc::c_int as libc::c_long {\n            return end;\n        }\n        cur = 0 as libc::c_int as off_t;\n    }\n    if end\n        == (if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n            -(1 as libc::c_int) as off_t\n        } else {\n            (((1 as libc::c_int as off_t)\n                << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        })\n        || cur < end\n            && {\n                let (fresh4, fresh5) = size.overflowing_add(end - cur);\n                *(&mut size as *mut off_t) = fresh4;\n                fresh5 as libc::c_int != 0\n            }\n    {\n        *__errno_location() = 75 as libc::c_int;\n        return -(1 as libc::c_int) as off_t;\n    }\n    if cur < end {\n        let mut r: off_t = lseek(fd, cur, 0 as libc::c_int);\n        if r < 0 as libc::c_int as libc::c_long {\n            return r;\n        }\n    }\n    return size;\n}",
    "calls": [
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4984:9: 4989:11 (#0)",
        "source": "file_size = input_file_size(\n            0 as libc::c_int,\n            &mut in_stat_buf,\n            buf,\n            in_blk_size,\n        );"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:189 ~ split[1dd7]::stdc_leading_zeros_ull)",
    "span": "src/split.rs:573:1: 576:2 (#0)",
    "pieces": [
      "src/split.rs:573:1: 576:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn stdc_leading_zeros_ull(mut n: libc::c_ulonglong) -> libc::c_uint {\n    return __gl_stdbit_clzll(n) as libc::c_uint;\n}",
    "calls": [
      {
        "caller": "DefId(0:210 ~ split[1dd7]::io_blksize)",
        "span": "src/split.rs:608:9: 610:26 (#0)",
        "source": "let mut leading_zeros: libc::c_int = stdc_leading_zeros_ull(\n            blocksize as libc::c_ulonglong,\n        ) as libc::c_int;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:190 ~ split[1dd7]::io_blksize)",
    "span": "src/split.rs:578:1: 645:2 (#0)",
    "pieces": [
      "src/split.rs:578:1: 645:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 68,
    "source": "unsafe extern \"C\" fn io_blksize(mut st: *const stat) -> idx_t {\n    let mut blocksize: idx_t = (if (if (0 as libc::c_int) < (*st).st_blksize\n        && (*st).st_blksize as libc::c_ulong\n            <= (-(1 as libc::c_int) as size_t)\n                .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        (*st).st_blksize\n    } else {\n        512 as libc::c_int\n    }) <= 0 as libc::c_int\n    {\n        IO_BUFSIZE as libc::c_int\n    } else if (0 as libc::c_int) < (*st).st_blksize\n        && (*st).st_blksize as libc::c_ulong\n            <= (-(1 as libc::c_int) as size_t)\n                .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        (*st).st_blksize\n    } else {\n        512 as libc::c_int\n    }) as idx_t;\n    blocksize\n        += (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long\n            - (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long % blocksize;\n    if (*st).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        && blocksize & blocksize - 1 as libc::c_int as libc::c_long != 0\n    {\n        let mut leading_zeros: libc::c_int = stdc_leading_zeros_ull(\n            blocksize as libc::c_ulonglong,\n        ) as libc::c_int;\n        if (9223372036854775807 as libc::c_long as libc::c_ulonglong)\n            < (9223372036854775807 as libc::c_longlong as libc::c_ulonglong)\n                .wrapping_mul(2 as libc::c_ulonglong)\n                .wrapping_add(1 as libc::c_ulonglong) || leading_zeros != 0\n        {\n            let mut power: libc::c_ulonglong = (1 as libc::c_ulonglong)\n                << 64 as libc::c_int - leading_zeros;\n            if power <= 9223372036854775807 as libc::c_long as libc::c_ulonglong {\n                blocksize = power as idx_t;\n            }\n        }\n    }\n    return (if (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n        < 18446744073709551615 as libc::c_ulong\n    {\n        9223372036854775807 as libc::c_long as libc::c_ulong\n    } else {\n        18446744073709551615 as libc::c_ulong\n    })\n        .wrapping_div(2 as libc::c_int as libc::c_ulong)\n        .wrapping_add(1 as libc::c_int as libc::c_ulong) < blocksize as libc::c_ulong\n    {\n        (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        })\n            .wrapping_div(2 as libc::c_int as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    } else {\n        blocksize as libc::c_ulong\n    }) as idx_t;\n}",
    "calls": [
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4971:9: 4971:52 (#0)",
        "source": "in_blk_size = io_blksize(&mut in_stat_buf);"
      }
    ],
    "globals": [
      {
        "span": "src/split.rs:368:1: 368:48 (#0)",
        "source": "pub const IO_BUFSIZE: C2RustUnnamed_1 = 262144;"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:193 ~ split[1dd7]::xset_binary_mode_error)",
    "span": "src/split.rs:659:1: 659:49 (#0)",
    "pieces": [
      "src/split.rs:659:1: 659:49 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 1,
    "source": "unsafe extern \"C\" fn xset_binary_mode_error() {}",
    "calls": [
      {
        "caller": "DefId(0:214 ~ split[1dd7]::xset_binary_mode)",
        "span": "src/split.rs:664:13: 664:38 (#0)",
        "source": "xset_binary_mode_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:194 ~ split[1dd7]::xset_binary_mode)",
    "span": "src/split.rs:661:1: 667:2 (#0)",
    "pieces": [
      "src/split.rs:661:1: 667:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4910:1: 4910:24 (#0)",
        "source": "xset_binary_mode(0, 0);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:220 ~ split[1dd7]::set_suffix_length)",
    "span": "src/split.rs:870:1: 972:2 (#0)",
    "pieces": [
      "src/split.rs:870:1: 972:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 103,
    "source": "unsafe extern \"C\" fn set_suffix_length(\n    mut n_units: intmax_t,\n    mut split_type: Split_type,\n) {\n    let mut suffix_length_needed: libc::c_int = 0 as libc::c_int;\n    if !numeric_suffix_start.is_null() {\n        suffix_auto = 0 as libc::c_int != 0;\n    }\n    if split_type as libc::c_uint == type_chunk_bytes as libc::c_int as libc::c_uint\n        || split_type as libc::c_uint == type_chunk_lines as libc::c_int as libc::c_uint\n        || split_type as libc::c_uint == type_rr as libc::c_int as libc::c_uint\n    {\n        let mut n_units_end: intmax_t = n_units - 1 as libc::c_int as libc::c_long;\n        if !numeric_suffix_start.is_null() {\n            let mut n_start: intmax_t = 0;\n            let mut e: strtol_error = xstrtoimax(\n                numeric_suffix_start,\n                0 as *mut *mut libc::c_char,\n                10 as libc::c_int,\n                &mut n_start,\n                b\"\\0\" as *const u8 as *const libc::c_char,\n            );\n            if e as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint\n                && n_start < n_units\n            {\n                let (fresh0, fresh1) = n_units_end.overflowing_add(n_start);\n                *(&mut n_units_end as *mut intmax_t) = fresh0;\n                if fresh1 {\n                    n_units_end = 9223372036854775807 as libc::c_long;\n                }\n            }\n        }\n        let mut alphabet_len: idx_t = strlen(suffix_alphabet) as idx_t;\n        loop {\n            suffix_length_needed += 1;\n            suffix_length_needed;\n            n_units_end /= alphabet_len;\n            if !(n_units_end != 0) {\n                break;\n            }\n        }\n        suffix_auto = 0 as libc::c_int != 0;\n    }\n    if suffix_length != 0 {\n        if suffix_length < suffix_length_needed as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"the suffix length needs to be at least %d\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    suffix_length_needed,\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"the suffix length needs to be at least %d\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        suffix_length_needed,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"the suffix length needs to be at least %d\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        suffix_length_needed,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        suffix_auto = 0 as libc::c_int != 0;\n        return;\n    } else {\n        suffix_length = (if 2 as libc::c_int > suffix_length_needed {\n            2 as libc::c_int\n        } else {\n            suffix_length_needed\n        }) as idx_t;\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4880:5: 4880:44 (#0)",
        "source": "set_suffix_length(n_units, split_type);"
      }
    ],
    "globals": [
      {
        "span": "src/split.rs:679:1: 679:54 (#0)",
        "source": "static mut suffix_auto: bool = 1 as libc::c_int != 0;"
      },
      {
        "span": "src/split.rs:680:1: 680:37 (#0)",
        "source": "static mut suffix_length: idx_t = 0;"
      },
      {
        "span": "src/split.rs:681:1: 682:41 (#0)",
        "source": "static mut suffix_alphabet: *const libc::c_char = b\"abcdefghijklmnopqrstuvwxyz\\0\"\n    as *const u8 as *const libc::c_char;"
      },
      {
        "span": "src/split.rs:683:1: 683:81 (#0)",
        "source": "static mut numeric_suffix_start: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:256 ~ split[1dd7]::strtoint_die)",
    "span": "src/split.rs:3809:1: 3829:2 (#0)",
    "pieces": [
      "src/split.rs:3809:1: 3829:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 58,
    "source": "unsafe extern \"C\" fn strtoint_die(\n    mut msgid: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) {\n    if 0 != 0 {\n        error(\n            1 as libc::c_int,\n            if *__errno_location() == 22 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                *__errno_location()\n            },\n            b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n            gettext(msgid),\n            quote(arg),\n        );\n        if 1 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                gettext(msgid),\n                quote(arg),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                gettext(msgid),\n                quote(arg),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:273 ~ split[1dd7]::parse_n_units)",
        "span": "src/split.rs:3846:9: 3846:34 (#0)",
        "source": "strtoint_die(msgid, arg);"
      },
      {
        "caller": "DefId(0:274 ~ split[1dd7]::parse_chunk)",
        "span": "src/split.rs:3924:9: 3927:3 (#0)",
        "source": "strtoint_die(\n    b\"invalid number of chunks\\0\" as *const u8 as *const libc::c_char,\n    arg,\n);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:257 ~ split[1dd7]::parse_n_units)",
    "span": "src/split.rs:3831:1: 3849:2 (#0)",
    "pieces": [
      "src/split.rs:3831:1: 3849:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn parse_n_units(\n    mut arg: *const libc::c_char,\n    mut multipliers: *const libc::c_char,\n    mut msgid: *const libc::c_char,\n) -> intmax_t {\n    let mut n: intmax_t = 0;\n    if (LONGINT_OVERFLOW as libc::c_int as libc::c_uint)\n        < xstrtoimax(\n            arg,\n            0 as *mut *mut libc::c_char,\n            10 as libc::c_int,\n            &mut n,\n            multipliers,\n        ) as libc::c_uint || n < 1 as libc::c_int as libc::c_long\n    {\n        strtoint_die(msgid, arg);\n    }\n    return n;\n}",
    "calls": [
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4051:11: 4057:2 (#0)",
        "source": "unsafe {\n    parse_n_units(\n        optarg,\n        multipliers.as_ptr(),\n        b\"invalid number of bytes\\0\".as_ptr() as *const libc::c_char,\n    )\n}"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4082:1: 4086:3 (#0)",
        "source": "n_units = parse_n_units(\n    optarg,\n    b\"\\0\".as_ptr() as *const libc::c_char,\n    b\"invalid number of lines\\0\".as_ptr() as *const libc::c_char,\n);"
      },
      {
        "caller": "DefId(0:274 ~ split[1dd7]::parse_chunk)",
        "span": "src/split.rs:3867:9: 3871:11 (#0)",
        "source": "*n_units = parse_n_units(\n            argend.offset(1 as libc::c_int as isize),\n            b\"\\0\" as *const u8 as *const libc::c_char,\n            b\"invalid number of chunks\\0\" as *const u8 as *const libc::c_char,\n        );"
      },
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4113:1: 4117:3 (#0)",
        "source": "n_units = parse_n_units(\n    optarg,\n    multipliers.as_ptr(),\n    b\"invalid number of lines\\0\".as_ptr() as *const libc::c_char,\n);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:258 ~ split[1dd7]::parse_chunk)",
    "span": "src/split.rs:3850:1: 3929:2 (#0)",
    "pieces": [
      "src/split.rs:3850:1: 3929:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 80,
    "source": "unsafe extern \"C\" fn parse_chunk(\n    mut k_units: *mut intmax_t,\n    mut n_units: *mut intmax_t,\n    mut arg: *const libc::c_char,\n) {\n    let mut argend: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut e: strtol_error = xstrtoimax(\n        arg,\n        &mut argend,\n        10 as libc::c_int,\n        n_units,\n        b\"\\0\" as *const u8 as *const libc::c_char,\n    );\n    if e as libc::c_uint == LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint\n        && *argend as libc::c_int == '/' as i32\n    {\n        *k_units = *n_units;\n        *n_units = parse_n_units(\n            argend.offset(1 as libc::c_int as isize),\n            b\"\\0\" as *const u8 as *const libc::c_char,\n            b\"invalid number of chunks\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !((0 as libc::c_int as libc::c_long) < *k_units && *k_units <= *n_units) {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    0 as libc::c_int,\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(\n                        b\"invalid chunk number\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_mem(arg, argend.offset_from(arg) as libc::c_long as size_t),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        gettext(\n                            b\"invalid chunk number\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quote_mem(arg, argend.offset_from(arg) as libc::c_long as size_t),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        gettext(\n                            b\"invalid chunk number\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quote_mem(arg, argend.offset_from(arg) as libc::c_long as size_t),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n    } else if !(e as libc::c_uint <= LONGINT_OVERFLOW as libc::c_int as libc::c_uint\n        && (0 as libc::c_int as libc::c_long) < *n_units)\n    {\n        strtoint_die(\n            b\"invalid number of chunks\\0\" as *const u8 as *const libc::c_char,\n            arg,\n        );\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:275 ~ split[1dd7]::main_0)",
        "span": "src/split.rs:4153:1: 4153:89 (#0)",
        "source": "parse_chunk(&mut k_units, &mut n_units, trimmed_optarg.as_ptr() as *const libc::c_char);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:259 ~ split[1dd7]::main_0)",
    "span": "src/split.rs:3930:1: 5194:2 (#0)",
    "pieces": [
      "src/split.rs:3930:1: 3934:4 (#0)",
      "src/split.rs:4891:1: 4891:4 (#0)",
      "src/split.rs:4912:1: 4912:4 (#0)",
      "src/split.rs:5053:1: 5053:4 (#0)",
      "src/split.rs:5194:1: 5194:2 (#0)"
    ],
    "sub_chunks": [
      15,
      16,
      17,
      18
    ],
    "num_lines": 9,
    "source": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n   <<chunk 15>>   <<chunk 16>>   <<chunk 17>>   <<chunk 18>>}",
    "calls": [
      {
        "caller": "DefId(0:285 ~ split[1dd7]::main)",
        "span": "src/split.rs:5207:9: 5207:97 (#0)",
        "source": "::std::process::exit(main_0((argv.len() - 1) as libc::c_int, argv.as_mut_ptr()) as i32);"
      }
    ],
    "globals": [
      {
        "span": "src/split.rs:706:1: 706:44 (#0)",
        "source": "static mut elide_empty_files: bool = false;"
      },
      {
        "span": "src/split.rs:670:1: 670:34 (#0)",
        "source": "static mut filter_pid: pid_t = 0;"
      },
      {
        "span": "src/split.rs:704:1: 704:59 (#0)",
        "source": "static mut output_desc: libc::c_int = -(1 as libc::c_int);"
      },
      {
        "span": "src/split.rs:707:1: 707:37 (#0)",
        "source": "static mut unbuffered: bool = false;"
      },
      {
        "span": "src/split.rs:674:1: 674:42 (#0)",
        "source": "static mut default_SIGPIPE: bool = false;"
      },
      {
        "span": "src/split.rs:680:1: 680:37 (#0)",
        "source": "static mut suffix_length: idx_t = 0;"
      },
      {
        "span": "src/split.rs:380:1: 380:44 (#0)",
        "source": "pub const type_chunk_bytes: Split_type = 5;"
      },
      {
        "span": "src/split.rs:365:1: 365:45 (#0)",
        "source": "pub const FADVISE_SEQUENTIAL: fadvice_t = 2;"
      },
      {
        "span": "src/split.rs:379:1: 379:44 (#0)",
        "source": "pub const type_chunk_lines: Split_type = 6;"
      },
      {
        "span": "src/split.rs:378:1: 378:35 (#0)",
        "source": "pub const type_rr: Split_type = 7;"
      },
      {
        "span": "src/split.rs:381:1: 381:39 (#0)",
        "source": "pub const type_digits: Split_type = 4;"
      },
      {
        "span": "src/split.rs:356:1: 356:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/split.rs:705:1: 705:34 (#0)",
        "source": "static mut verbose: bool = false;"
      },
      {
        "span": "src/split.rs:370:1: 370:57 (#0)",
        "source": "pub const SYS_BUFSIZE_MAX: C2RustUnnamed_2 = 2146435072;"
      },
      {
        "span": "src/split.rs:675:1: 675:68 (#0)",
        "source": "static mut outbase: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/split.rs:686:1: 703:3 (#0)",
        "source": "static mut in_stat_buf: stat = stat {\n    st_dev: 0,\n    st_ino: 0,\n    st_mode: 0,\n    st_nlink: 0,\n    st_uid: 0,\n    st_gid: 0,\n    st_rdev: 0,\n    __pad1: 0,\n    st_size: 0,\n    st_blksize: 0,\n    __pad2: 0,\n    st_blocks: 0,\n    st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n    st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n    st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n    __glibc_reserved: [0; 2],\n};"
      },
      {
        "span": "src/split.rs:708:1: 708:55 (#0)",
        "source": "static mut eolchar: libc::c_int = -(1 as libc::c_int);"
      },
      {
        "span": "src/split.rs:685:1: 685:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/split.rs:676:1: 676:87 (#0)",
        "source": "static mut outfile: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;"
      },
      {
        "span": "src/split.rs:669:1: 669:75 (#0)",
        "source": "static mut filter_command: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/split.rs:384:1: 384:38 (#0)",
        "source": "pub const type_bytes: Split_type = 1;"
      },
      {
        "span": "src/split.rs:681:1: 682:41 (#0)",
        "source": "static mut suffix_alphabet: *const libc::c_char = b\"abcdefghijklmnopqrstuvwxyz\\0\"\n    as *const u8 as *const libc::c_char;"
      },
      {
        "span": "src/split.rs:382:1: 382:38 (#0)",
        "source": "pub const type_lines: Split_type = 3;"
      },
      {
        "span": "src/split.rs:684:1: 684:78 (#0)",
        "source": "static mut additional_suffix: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/split.rs:385:1: 385:38 (#0)",
        "source": "pub const type_undef: Split_type = 0;"
      },
      {
        "span": "src/split.rs:709:1: 863:3 (#0)",
        "source": "static mut longopts: [option; 17] = [\n    {\n        let mut init = option {\n            name: b\"bytes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'b' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"lines\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'l' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"line-bytes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'C' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"number\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'n' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"elide-empty-files\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'e' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"unbuffered\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'u' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"suffix-length\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'a' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"additional-suffix\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: ADDITIONAL_SUFFIX_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"numeric-suffixes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 2 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'd' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"hex-suffixes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 2 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'x' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"filter\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: FILTER_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"verbose\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: VERBOSE_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"separator\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 't' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"-io-blksize\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: IO_BLKSIZE_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];"
      },
      {
        "span": "src/split.rs:383:1: 383:43 (#0)",
        "source": "pub const type_byteslines: Split_type = 2;"
      },
      {
        "span": "src/split.rs:683:1: 683:81 (#0)",
        "source": "static mut numeric_suffix_start: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/split.rs:3987:9: 3994:19 (#0)",
        "pieces": [
          "src/split.rs:3987:9: 3994:19 (#0)"
        ],
        "num_lines": 10,
        "source": "suffix_length = xdectoimax(\n                    optarg,\n                    0 as libc::c_int as intmax_t,\n                    9223372036854775807 as libc::c_long,\n                    b\"\\0\" as *const u8 as *const libc::c_char,\n                    gettext(\n                        b\"invalid suffix length\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as libc::c_int,\n                );",
        "sub_chunks": [],
        "live_in": [],
        "live_out": []
      },
      {
        "chunk_id": 1,
        "span": "src/split.rs:3999:9: 4012:28 (#0)",
        "pieces": [
          "src/split.rs:3999:9: 4012:28 (#0)"
        ],
        "num_lines": 56,
        "source": "let mut suffix_len: libc::c_int = strlen(optarg) as libc::c_int;\n                if last_component(optarg) != optarg\n                    || suffix_len != 0\n                        && *optarg.offset((suffix_len - 1 as libc::c_int) as isize)\n                            as libc::c_int == '/' as i32\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"invalid suffix %s, contains directory separator\\0\"\n                                    as *const u8 as *const libc::c_char,\n                            ),\n                            quote(optarg),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid suffix %s, contains directory separator\\0\"\n                                        as *const u8 as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid suffix %s, contains directory separator\\0\"\n                                        as *const u8 as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n                additional_suffix = optarg;",
        "sub_chunks": [],
        "live_in": [],
        "live_out": [
          "suffix_len: i32",
          "optarg_str: &str"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/split.rs:4017:9: 4057:3 (#0)",
        "pieces": [
          "src/split.rs:4017:9: 4057:3 (#0)"
        ],
        "num_lines": 55,
        "source": "if split_type as libc::c_uint\n                    != type_undef as libc::c_int as libc::c_uint\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"cannot split in more than one way\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n                split_type = type_bytes;\n                n_units = parse_n_units(\n                    optarg,\n                    multipliers.as_ptr(),\n                    b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char,\n                );",
        "sub_chunks": [],
        "live_in": [
          "mut split_type: u32",
          "mut n_units: i64"
        ],
        "live_out": [
          "mut split_type: u32",
          "mut n_units: i64"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/split.rs:4062:9: 4086:3 (#0)",
        "pieces": [
          "src/split.rs:4062:9: 4086:3 (#0)"
        ],
        "num_lines": 55,
        "source": "if split_type as libc::c_uint\n                    != type_undef as libc::c_int as libc::c_uint\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"cannot split in more than one way\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n                split_type = type_lines;\n                n_units = parse_n_units(\n                    optarg,\n                    b\"\\0\" as *const u8 as *const libc::c_char,\n                    b\"invalid number of lines\\0\" as *const u8 as *const libc::c_char,\n                );",
        "sub_chunks": [],
        "live_in": [
          "mut split_type: u32",
          "mut n_units: i64"
        ],
        "live_out": [
          "mut split_type: u32",
          "mut n_units: i64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/split.rs:4091:9: 4117:3 (#0)",
        "pieces": [
          "src/split.rs:4091:9: 4117:3 (#0)"
        ],
        "num_lines": 55,
        "source": "if split_type as libc::c_uint\n                    != type_undef as libc::c_int as libc::c_uint\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"cannot split in more than one way\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n                split_type = type_byteslines;\n                n_units = parse_n_units(\n                    optarg,\n                    multipliers.as_ptr(),\n                    b\"invalid number of lines\\0\" as *const u8 as *const libc::c_char,\n                );",
        "sub_chunks": [],
        "live_in": [
          "mut split_type: u32",
          "mut n_units: i64"
        ],
        "live_out": [
          "mut split_type: u32",
          "mut n_units: i64"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/split.rs:4122:9: 4153:89 (#0)",
        "pieces": [
          "src/split.rs:4122:9: 4153:89 (#0)"
        ],
        "num_lines": 78,
        "source": "if split_type as libc::c_uint\n                    != type_undef as libc::c_int as libc::c_uint\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"cannot split in more than one way\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n                while *(*__ctype_b_loc())\n                    .offset(to_uchar(*optarg) as libc::c_int as isize) as libc::c_int\n                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n                {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                if strncmp(\n                    optarg,\n                    b\"r/\\0\" as *const u8 as *const libc::c_char,\n                    (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong)\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                ) == 0 as libc::c_int\n                {\n                    split_type = type_rr;\n                    optarg = optarg.offset(2 as libc::c_int as isize);\n                } else if strncmp(\n                    optarg,\n                    b\"l/\\0\" as *const u8 as *const libc::c_char,\n                    (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong)\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                ) == 0 as libc::c_int\n                {\n                    split_type = type_chunk_lines;\n                    optarg = optarg.offset(2 as libc::c_int as isize);\n                } else {\n                    split_type = type_chunk_bytes;\n                }\n                parse_chunk(&mut k_units, &mut n_units, optarg);",
        "sub_chunks": [],
        "live_in": [
          "mut split_type: u32",
          "mut k_units: i64",
          "mut n_units: i64",
          "mut c: i32"
        ],
        "live_out": [
          "mut split_type: u32",
          "mut k_units: i64",
          "mut n_units: i64",
          "mut c: i32",
          "mut local_optarg: std::borrow::Cow<str>"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/split.rs:4161:9: 4199:25 (#0)",
        "pieces": [
          "src/split.rs:4161:9: 4199:25 (#0)"
        ],
        "num_lines": 149,
        "source": "let mut neweol: libc::c_char = *optarg.offset(0 as libc::c_int as isize);\n                if neweol == 0 {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"empty record separator\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"empty record separator\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"empty record separator\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                if *optarg.offset(1 as libc::c_int as isize) != 0 {\n                    if strcmp(optarg, b\"\\\\0\\0\" as *const u8 as *const libc::c_char)\n                        == 0 as libc::c_int\n                    {\n                        neweol = '\\0' as i32 as libc::c_char;\n                    } else {\n                        if 0 != 0 {\n                            error(\n                                1 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"multi-character separator %s\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quote(optarg),\n                            );\n                            if 1 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"multi-character separator %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 1 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"multi-character separator %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                    }\n                }\n                if 0 as libc::c_int <= eolchar && neweol as libc::c_int != eolchar {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"multiple separator characters specified\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"multiple separator characters specified\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"multiple separator characters specified\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                eolchar = neweol as libc::c_int;",
        "sub_chunks": [],
        "live_in": [],
        "live_out": [
          "optarg_str: std::borrow::Cow<str>"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/split.rs:4279:29: 4357:30 (#0)",
        "pieces": [
          "src/split.rs:4279:29: 4357:30 (#0)"
        ],
        "num_lines": 79,
        "source": "if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as intmax_t\n                                }) + 10 as libc::c_int as libc::c_long\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n_units\n                                    < -(1 as libc::c_int) as intmax_t\n                                        / 10 as libc::c_int as libc::c_long) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    10 as libc::c_int\n                                }) - 1 as libc::c_int) < 0 as libc::c_int\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) + 1 as libc::c_int)\n                                        << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) + 0 as libc::c_int\n                                }) < 0 as libc::c_int\n                                {\n                                    ((10 as libc::c_int)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) + 1 as libc::c_int)\n                                                << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) - 1 as libc::c_int\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int) < 10 as libc::c_int) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + -(1 as libc::c_int) as intmax_t\n                                        >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as intmax_t\n                                        / -(10 as libc::c_int) as libc::c_long\n                                }) <= -(1 as libc::c_int) as libc::c_long - n_units)\n                                    as libc::c_int\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut n_units: i64"
        ],
        "live_out": [
          "mut n_units: i64"
        ]
      },
      {
        "chunk_id": 8,
        "span": "src/split.rs:4359:29: 4468:30 (#0)",
        "pieces": [
          "src/split.rs:4359:29: 4468:30 (#0)"
        ],
        "num_lines": 110,
        "source": "if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    10 as libc::c_int\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    10 as libc::c_int\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int\n                                        } else {\n                                            10 as libc::c_int\n                                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int\n                                            } else {\n                                                10 as libc::c_int\n                                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                                    as libc::c_int\n                            }) != 0 && 10 as libc::c_int == -(1 as libc::c_int)\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n_units\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n_units + 0 as libc::c_int as intmax_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n_units\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as intmax_t)\n                                            < n_units - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                ((0 as libc::c_int as intmax_t\n                                    / 10 as libc::c_int as libc::c_long) < n_units)\n                                    as libc::c_int\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut n_units: i64"
        ],
        "live_out": [
          "mut n_units: i64"
        ]
      },
      {
        "chunk_id": 9,
        "span": "src/split.rs:4471:25: 4588:26 (#0)",
        "pieces": [
          "src/split.rs:4471:25: 4588:26 (#0)"
        ],
        "num_lines": 118,
        "source": "if 10 as libc::c_int == 0 as libc::c_int {\n                            0 as libc::c_int\n                        } else {\n                            if n_units < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n_units\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n_units\n                                        }) + 0 as libc::c_int as intmax_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n_units\n                                        }) + 0 as libc::c_int as intmax_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n_units\n                                    }) + 0 as libc::c_int as intmax_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n_units\n                                            }) + 0 as libc::c_int as intmax_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n_units\n                                                }) + 0 as libc::c_int as intmax_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n_units\n                                                }) + 0 as libc::c_int as intmax_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n_units\n                                        }) + 0 as libc::c_int as intmax_t) as libc::c_int\n                                }) != 0 && n_units == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        10 as libc::c_int\n                                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < 10 as libc::c_int as libc::c_long\n                                                + 0 as libc::c_int as intmax_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as intmax_t)\n                                            < (10 as libc::c_int - 1 as libc::c_int) as libc::c_long)\n                                            as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as intmax_t / n_units\n                                        < 10 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                ((-(1 as libc::c_int) as intmax_t\n                                    / 10 as libc::c_int as libc::c_long) < n_units)\n                                    as libc::c_int\n                            }\n                        }",
        "sub_chunks": [],
        "live_in": [
          "mut n_units: i64"
        ],
        "live_out": [
          "mut n_units: i64"
        ]
      },
      {
        "chunk_id": 10,
        "span": "src/split.rs:4204:9: 4606:18 (#0)",
        "pieces": [
          "src/split.rs:4204:9: 4279:28 (#0)",
          "src/split.rs:4358:1: 4359:28 (#0)",
          "src/split.rs:4469:1: 4471:24 (#0)",
          "src/split.rs:4589:1: 4606:18 (#0)"
        ],
        "num_lines": 99,
        "source": "if split_type as libc::c_uint\n                    == type_undef as libc::c_int as libc::c_uint\n                {\n                    split_type = type_digits;\n                    n_units = 0 as libc::c_int as intmax_t;\n                }\n                if split_type as libc::c_uint\n                    != type_undef as libc::c_int as libc::c_uint\n                    && split_type as libc::c_uint\n                        != type_digits as libc::c_int as libc::c_uint\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"cannot split in more than one way\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"cannot split in more than one way\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n                if digits_optind != 0 as libc::c_int && digits_optind != this_optind {\n                    n_units = 0 as libc::c_int as intmax_t;\n                }\n                digits_optind = this_optind;\n                if (if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n_units\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        10 as libc::c_int\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    && (if (10 as libc::c_int) < 0 as libc::c_int {\n                        if n_units < 0 as libc::c_int as libc::c_long {\n                           <<chunk 7>>                        } else {\n                           <<chunk 8>>                        }\n                    } else {\n                       <<chunk 9>>                    }) != 0\n                {\n                    let (fresh27, _fresh28) = n_units.overflowing_mul((10 as libc::c_int).into());\n                    *(&mut n_units as *mut intmax_t) = fresh27;\n                    1 as libc::c_int\n                } else {\n                    let (fresh29, fresh30) = n_units.overflowing_mul((10 as libc::c_int).into());\n                    *(&mut n_units as *mut intmax_t) = fresh29;\n                    fresh30 as libc::c_int\n                }) != 0\n                    || {\n                        let (fresh31, fresh32) = n_units.overflowing_add((c - '0' as i32).into());\n                        *(&mut n_units as *mut intmax_t) = fresh31;\n                        fresh32 as libc::c_int != 0\n                    }\n                {\n                    n_units = 9223372036854775807 as libc::c_long;\n                }",
        "sub_chunks": [
          7,
          8,
          9
        ],
        "live_in": [
          "mut split_type: u32",
          "mut n_units: i64",
          "mut c: i32",
          "mut digits_optind: i32",
          "this_optind: i32"
        ],
        "live_out": [
          "mut split_type: u32",
          "mut n_units: i64",
          "mut c: i32",
          "mut digits_optind: i32",
          "this_optind: i32"
        ]
      },
      {
        "chunk_id": 11,
        "span": "src/split.rs:4610:9: 4698:18 (#0)",
        "pieces": [
          "src/split.rs:4610:9: 4698:18 (#0)"
        ],
        "num_lines": 89,
        "source": "if c == 'd' as i32 {\n                    suffix_alphabet = b\"0123456789\\0\" as *const u8\n                        as *const libc::c_char;\n                } else {\n                    suffix_alphabet = b\"0123456789abcdef\\0\" as *const u8\n                        as *const libc::c_char;\n                }\n                if !optarg.is_null() {\n                    if strlen(optarg) != strspn(optarg, suffix_alphabet) {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                0 as libc::c_int,\n                                if c == 'd' as i32 {\n                                    gettext(\n                                        b\"%s: invalid start value for numerical suffix\\0\"\n                                            as *const u8 as *const libc::c_char,\n                                    )\n                                } else {\n                                    gettext(\n                                        b\"%s: invalid start value for hexadecimal suffix\\0\"\n                                            as *const u8 as *const libc::c_char,\n                                    )\n                                },\n                                quote(optarg),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    if c == 'd' as i32 {\n                                        gettext(\n                                            b\"%s: invalid start value for numerical suffix\\0\"\n                                                as *const u8 as *const libc::c_char,\n                                        )\n                                    } else {\n                                        gettext(\n                                            b\"%s: invalid start value for hexadecimal suffix\\0\"\n                                                as *const u8 as *const libc::c_char,\n                                        )\n                                    },\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    if c == 'd' as i32 {\n                                        gettext(\n                                            b\"%s: invalid start value for numerical suffix\\0\"\n                                                as *const u8 as *const libc::c_char,\n                                        )\n                                    } else {\n                                        gettext(\n                                            b\"%s: invalid start value for hexadecimal suffix\\0\"\n                                                as *const u8 as *const libc::c_char,\n                                        )\n                                    },\n                                    quote(optarg),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                        usage(1 as libc::c_int);\n                    } else {\n                        while *optarg as libc::c_int == '0' as i32\n                            && *optarg.offset(1 as libc::c_int as isize) as libc::c_int\n                                != '\\0' as i32\n                        {\n                            optarg = optarg.offset(1);\n                            optarg;\n                        }\n                        numeric_suffix_start = optarg;\n                    }\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut c: i32"
        ],
        "live_out": [
          "mut c: i32"
        ]
      },
      {
        "chunk_id": 12,
        "span": "src/split.rs:4708:9: 4737:28 (#0)",
        "pieces": [
          "src/split.rs:4708:9: 4737:28 (#0)"
        ],
        "num_lines": 30,
        "source": "in_blk_size = xdectoumax(\n                    optarg,\n                    1 as libc::c_int as uintmax_t,\n                    if (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong)\n                        < (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n                            < 18446744073709551615 as libc::c_ulong\n                        {\n                            9223372036854775807 as libc::c_long as libc::c_ulong\n                        } else {\n                            18446744073709551615 as libc::c_ulong\n                        })\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    {\n                        SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong\n                    } else {\n                        (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n                            < 18446744073709551615 as libc::c_ulong\n                        {\n                            9223372036854775807 as libc::c_long as libc::c_ulong\n                        } else {\n                            18446744073709551615 as libc::c_ulong\n                        })\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    },\n                    multipliers.as_ptr(),\n                    gettext(\n                        b\"invalid IO block size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as libc::c_int,\n                ) as idx_t;",
        "sub_chunks": [],
        "live_in": [
          "mut in_blk_size: i64"
        ],
        "live_out": [
          "mut in_blk_size: i64"
        ]
      },
      {
        "chunk_id": 13,
        "span": "src/split.rs:4747:9: 4762:23 (#0)",
        "pieces": [
          "src/split.rs:4747:9: 4762:23 (#0)"
        ],
        "num_lines": 16,
        "source": "version_etc(\n                    stdout,\n                    b\"split\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Torbjorn Granlund\\0\" as *const u8 as *const libc::c_char,\n                        b\"Torbj\\xC3\\xB6rn Granlund\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                        b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);",
        "sub_chunks": [],
        "live_in": [],
        "live_out": []
      },
      {
        "chunk_id": 14,
        "span": "src/split.rs:3967:9: 4774:3 (#0)",
        "pieces": [
          "src/split.rs:3967:9: 3987:8 (#0)",
          "src/split.rs:3996:1: 3999:8 (#0)",
          "src/split.rs:4014:1: 4017:8 (#0)",
          "src/split.rs:4059:1: 4062:8 (#0)",
          "src/split.rs:4088:1: 4091:8 (#0)",
          "src/split.rs:4119:1: 4122:8 (#0)",
          "src/split.rs:4155:1: 4161:8 (#0)",
          "src/split.rs:4201:1: 4204:8 (#0)",
          "src/split.rs:4607:1: 4610:8 (#0)",
          "src/split.rs:4699:1: 4708:8 (#0)",
          "src/split.rs:4738:1: 4747:8 (#0)",
          "src/split.rs:4764:1: 4774:3 (#0)"
        ],
        "num_lines": 68,
        "source": "let mut this_optind: libc::c_int = if optind != 0 {\n            optind\n        } else {\n            1 as libc::c_int\n        };\n        c = getopt_long(\n            argc,\n            argv,\n            b\"0123456789C:a:b:del:n:t:ux\\0\" as *const u8 as *const libc::c_char,\n            longopts.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if c == -(1 as libc::c_int) {\n            break;\n        }\n        match c {\n            97 => {\n               <<chunk 0>>            }\n            259 => {\n               <<chunk 1>>            }\n            98 => {\n               <<chunk 2>>            }\n            108 => {\n               <<chunk 3>>            }\n            67 => {\n               <<chunk 4>>            }\n            110 => {\n               <<chunk 5>>            }\n            117 => {\n                unbuffered = 1 as libc::c_int != 0;\n            }\n            116 => {\n               <<chunk 6>>            }\n            48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => {\n               <<chunk 10>>            }\n            100 | 120 => {\n               <<chunk 11>>            }\n            101 => {\n                elide_empty_files = 1 as libc::c_int != 0;\n            }\n            257 => {\n                filter_command = optarg;\n            }\n            258 => {\n               <<chunk 12>>            }\n            256 => {\n                verbose = 1 as libc::c_int != 0;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n            }\n            -3 => {\n               <<chunk 13>>            }\n            _ => {\n                usage(1 as libc::c_int);\n            }\n        }",
        "sub_chunks": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          10,
          11,
          12,
          13
        ],
        "live_in": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut split_type: u32",
          "mut in_blk_size: i64",
          "mut k_units: i64",
          "mut n_units: i64",
          "mut c: i32",
          "mut digits_optind: i32"
        ],
        "live_out": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut split_type: u32",
          "mut in_blk_size: i64",
          "mut k_units: i64",
          "mut n_units: i64",
          "mut c: i32",
          "mut digits_optind: i32",
          "this_optind: i32"
        ]
      },
      {
        "chunk_id": 15,
        "span": "src/split.rs:3934:5: 4890:6 (#0)",
        "pieces": [
          "src/split.rs:3934:5: 3967:8 (#0)",
          "src/split.rs:4776:1: 4890:6 (#0)"
        ],
        "num_lines": 149,
        "source": "let mut split_type: Split_type = type_undef;\n    let mut in_blk_size: idx_t = 0 as libc::c_int as idx_t;\n    let mut page_size: idx_t = getpagesize() as idx_t;\n    let mut k_units: intmax_t = 0 as libc::c_int as intmax_t;\n    let mut n_units: intmax_t = 0 as libc::c_int as intmax_t;\n    static mut multipliers: [libc::c_char; 15] = unsafe {\n        *::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b\"bEGKkMmPQRTYZ0\\0\")\n    };\n    let mut c: libc::c_int = 0;\n    let mut digits_optind: libc::c_int = 0 as libc::c_int;\n    let mut file_size: off_t = if (0 as libc::c_int as off_t)\n        < -(1 as libc::c_int) as off_t\n    {\n        -(1 as libc::c_int) as off_t\n    } else {\n        (((1 as libc::c_int as off_t)\n            << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n            - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n            + 1 as libc::c_int as libc::c_long\n    };\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    infile = b\"-\\0\" as *const u8 as *const libc::c_char;\n    outbase = b\"x\\0\" as *const u8 as *const libc::c_char;\n    loop {\n       <<chunk 14>>    }\n    if k_units != 0 as libc::c_int as libc::c_long && !filter_command.is_null() {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"--filter does not process a chunk extracted to stdout\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"--filter does not process a chunk extracted to stdout\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"--filter does not process a chunk extracted to stdout\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if split_type as libc::c_uint == type_undef as libc::c_int as libc::c_uint {\n        split_type = type_lines;\n        n_units = 1000 as libc::c_int as intmax_t;\n    }\n    if n_units == 0 as libc::c_int as libc::c_long {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"invalid number of lines: %s\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote(b\"0\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"invalid number of lines: %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote(b\"0\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"invalid number of lines: %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote(b\"0\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if eolchar < 0 as libc::c_int {\n        eolchar = '\\n' as i32;\n    }\n    set_suffix_length(n_units, split_type);\n    if optind < argc {\n        let fresh33 = optind;\n        optind = optind + 1;\n        infile = *argv.offset(fresh33 as isize);\n    }\n    if optind < argc {\n        let fresh34 = optind;\n        optind = optind + 1;\n        outbase = *argv.offset(fresh34 as isize);\n    }",
        "sub_chunks": [
          14
        ],
        "live_in": [
          "mut argc: i32",
          "mut argv: *mut *mut i8"
        ],
        "live_out": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut split_type: u32",
          "mut in_blk_size: i64",
          "mut page_size: i64",
          "mut k_units: i64",
          "mut n_units: i64",
          "mut c: i32",
          "mut digits_optind: i32",
          "mut file_size: i64"
        ]
      },
      {
        "chunk_id": 16,
        "span": "src/split.rs:4891:5: 4910:24 (#0)",
        "pieces": [
          "src/split.rs:4891:5: 4910:24 (#0)"
        ],
        "num_lines": 146,
        "source": "if optind < argc {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(b\"extra operand %s\\0\" as *const u8 as *const libc::c_char),\n                quote(*argv.offset(optind as isize)),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(b\"extra operand %s\\0\" as *const u8 as *const libc::c_char),\n                    quote(*argv.offset(optind as isize)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(b\"extra operand %s\\0\" as *const u8 as *const libc::c_char),\n                    quote(*argv.offset(optind as isize)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if !numeric_suffix_start.is_null()\n        && strlen(numeric_suffix_start) > suffix_length as libc::c_ulong\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"numerical suffix start value is too large for the suffix length\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"numerical suffix start value is too large for the suffix length\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"numerical suffix start value is too large for the suffix length\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if !(strcmp(infile, b\"-\\0\" as *const u8 as *const libc::c_char) == 0 as libc::c_int)\n        && fd_reopen(\n            0 as libc::c_int,\n            infile,\n            0 as libc::c_int,\n            0 as libc::c_int as mode_t,\n        ) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"cannot open %s for reading\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, infile),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open %s for reading\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, infile),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open %s for reading\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, infile),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    xset_binary_mode(0 as libc::c_int, 0 as libc::c_int);",
        "sub_chunks": [],
        "live_in": [
          "mut argc: i32",
          "mut argv: *mut *mut i8"
        ],
        "live_out": [
          "mut argc: i32",
          "mut argv: *mut *mut i8"
        ]
      },
      {
        "chunk_id": 17,
        "span": "src/split.rs:4912:5: 5052:6 (#0)",
        "pieces": [
          "src/split.rs:4912:5: 5052:6 (#0)"
        ],
        "num_lines": 141,
        "source": "fdadvise(\n        0 as libc::c_int,\n        0 as libc::c_int as off_t,\n        0 as libc::c_int as off_t,\n        FADVISE_SEQUENTIAL,\n    );\n    if fstat(0 as libc::c_int, &mut in_stat_buf) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    infile,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if in_blk_size == 0 as libc::c_int as libc::c_long {\n        in_blk_size = io_blksize(&mut in_stat_buf);\n        if (SYS_BUFSIZE_MAX as libc::c_int as libc::c_long) < in_blk_size {\n            in_blk_size = SYS_BUFSIZE_MAX as libc::c_int as idx_t;\n        }\n    }\n    let mut buf: *mut libc::c_char = xalignalloc(\n        page_size,\n        in_blk_size + 1 as libc::c_int as libc::c_long,\n    ) as *mut libc::c_char;\n    let mut initial_read: ssize_t = -(1 as libc::c_int) as ssize_t;\n    if split_type as libc::c_uint == type_chunk_bytes as libc::c_int as libc::c_uint\n        || split_type as libc::c_uint == type_chunk_lines as libc::c_int as libc::c_uint\n    {\n        file_size = input_file_size(\n            0 as libc::c_int,\n            &mut in_stat_buf,\n            buf,\n            in_blk_size,\n        );\n        if file_size < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: cannot determine file size\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot determine file size\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: cannot determine file size\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        initial_read = if file_size < in_blk_size { file_size } else { in_blk_size };\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut split_type: u32",
          "mut in_blk_size: i64",
          "mut page_size: i64",
          "mut file_size: i64"
        ],
        "live_out": [
          "mut split_type: u32",
          "mut in_blk_size: i64",
          "mut page_size: i64",
          "mut file_size: i64",
          "mut buf: *mut i8",
          "mut initial_read: i64"
        ]
      },
      {
        "chunk_id": 18,
        "span": "src/split.rs:5053:5: 5193:28 (#0)",
        "pieces": [
          "src/split.rs:5053:5: 5193:28 (#0)"
        ],
        "num_lines": 141,
        "source": "if !filter_command.is_null() {\n        default_SIGPIPE = (signal(\n            13 as libc::c_int,\n            ::core::mem::transmute::<\n                libc::intptr_t,\n                __sighandler_t,\n            >(1 as libc::c_int as libc::intptr_t),\n        ))\n            .is_none();\n    }\n    match split_type as libc::c_uint {\n        4 | 3 => {\n            lines_split(n_units, buf, in_blk_size);\n        }\n        1 => {\n            bytes_split(\n                n_units,\n                0 as libc::c_int as intmax_t,\n                buf,\n                in_blk_size,\n                -(1 as libc::c_int) as ssize_t,\n                0 as libc::c_int as intmax_t,\n            );\n        }\n        2 => {\n            line_bytes_split(n_units, buf, in_blk_size);\n        }\n        5 => {\n            if k_units == 0 as libc::c_int as libc::c_long {\n                bytes_split(\n                    file_size / n_units,\n                    file_size % n_units,\n                    buf,\n                    in_blk_size,\n                    initial_read,\n                    n_units,\n                );\n            } else {\n                bytes_chunk_extract(\n                    k_units,\n                    n_units,\n                    buf,\n                    in_blk_size,\n                    initial_read,\n                    file_size,\n                );\n            }\n        }\n        6 => {\n            lines_chunk_split(\n                k_units,\n                n_units,\n                buf,\n                in_blk_size,\n                initial_read,\n                file_size,\n            );\n        }\n        7 => {\n            let mut files: *mut of_t = 0 as *mut of_t;\n            lines_rr(k_units, n_units, buf, in_blk_size, &mut files);\n        }\n        _ => {\n            __assert_fail(\n                b\"0\\0\" as *const u8 as *const libc::c_char,\n                b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                1686 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 23],\n                    &[libc::c_char; 23],\n                >(b\"int main(int, char **)\\0\"))\n                    .as_ptr(),\n            );\n            'c_16295: {\n                __assert_fail(\n                    b\"0\\0\" as *const u8 as *const libc::c_char,\n                    b\"split.c\\0\" as *const u8 as *const libc::c_char,\n                    1686 as libc::c_int as libc::c_uint,\n                    (*::core::mem::transmute::<\n                        &[u8; 23],\n                        &[libc::c_char; 23],\n                    >(b\"int main(int, char **)\\0\"))\n                        .as_ptr(),\n                );\n            };\n        }\n    }\n    if close(0 as libc::c_int) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    infile,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    closeout(0 as *mut FILE, output_desc, filter_pid, outfile);\n    exit(0 as libc::c_int);",
        "sub_chunks": [],
        "live_in": [
          "mut split_type: u32",
          "mut in_blk_size: i64",
          "mut k_units: i64",
          "mut n_units: i64",
          "mut c: i32",
          "mut file_size: i64",
          "mut buf: *mut i8",
          "mut initial_read: i64"
        ],
        "live_out": [
          "mut split_type: u32",
          "mut in_blk_size: i64",
          "mut k_units: i64",
          "mut n_units: i64",
          "mut c: i32",
          "mut file_size: i64",
          "mut buf: *mut i8",
          "mut initial_read: i64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:186 ~ split[1dd7]::usable_st_size)",
    "span": "src/split.rs:507:1: 512:2 (#0)",
    "pieces": [
      "src/split.rs:507:1: 512:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn usable_st_size(mut sb: *const stat) -> bool {\n    return (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        || (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o120000 as libc::c_int as libc::c_uint\n        || ((*sb).st_mode).wrapping_sub((*sb).st_mode) != 0 || 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:178 ~ split[1dd7]::to_uchar)",
    "span": "src/split.rs:404:1: 406:2 (#0)",
    "pieces": [
      "src/split.rs:404:1: 406:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn to_uchar(mut ch: libc::c_char) -> libc::c_uchar {\n    return ch as libc::c_uchar;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:187 ~ split[1dd7]::write_error)",
    "span": "src/split.rs:515:1: 561:2 (#0)",
    "pieces": [
      "src/split.rs:515:1: 561:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "unsafe extern \"C\" fn write_error() {\n    let mut saved_errno: libc::c_int = *__errno_location();\n    fflush_unlocked(stdout);\n    fpurge(stdout);\n    clearerr_unlocked(stdout);\n    if 0 != 0 {\n        error(\n            1 as libc::c_int,\n            saved_errno,\n            gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n        );\n        if 1 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:219 ~ split[1dd7]::ignorable)",
    "span": "src/split.rs:865:1: 868:2 (#0)",
    "pieces": [
      "src/split.rs:865:1: 868:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn ignorable(mut err: libc::c_int) -> bool {\n    return !filter_command.is_null() && err == 32 as libc::c_int;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/split.rs:669:1: 669:75 (#0)",
        "source": "static mut filter_command: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:192 ~ split[1dd7]::set_binary_mode)",
    "span": "src/split.rs:652:1: 656:2 (#0)",
    "pieces": [
      "src/split.rs:652:1: 656:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:254 ~ split[1dd7]::ofile_open)",
    "span": "src/split.rs:3302:1: 3488:2 (#0)",
    "pieces": [
      "src/split.rs:3302:1: 3309:8 (#0)",
      "src/split.rs:3486:1: 3488:2 (#0)"
    ],
    "sub_chunks": [
      2
    ],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn ofile_open(\n    mut files: *mut of_t,\n    mut i_check: idx_t,\n    mut nfiles: idx_t,\n) -> bool {\n    let mut file_limit: bool = 0 as libc::c_int != 0;\n    if (*files.offset(i_check as isize)).ofd <= OFD_NEW as libc::c_int {\n       <<chunk 2>>    }\n    return file_limit;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/split.rs:401:1: 401:44 (#0)",
        "source": "pub const OFD_APPEND: C2RustUnnamed_4 = -2;"
      },
      {
        "span": "src/split.rs:356:1: 356:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/split.rs:670:1: 670:34 (#0)",
        "source": "static mut filter_pid: pid_t = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/split.rs:3316:13: 3367:2 (#0)",
        "pieces": [
          "src/split.rs:3316:13: 3367:2 (#0)"
        ],
        "num_lines": 126,
        "source": "if (*files.offset(i_check as isize)).ofd == OFD_NEW as libc::c_int {\n                fd = create((*files.offset(i_check as isize)).of_name);\n            } else {\n                fd = open_safer(\n                    (*files.offset(i_check as isize)).of_name,\n                    0o1 as libc::c_int | 0 as libc::c_int | 0o2000 as libc::c_int\n                        | 0o4000 as libc::c_int,\n                );\n            }\n            if 0 as libc::c_int <= fd {\n                break;\n            }\n            if !(*__errno_location() == 24 as libc::c_int\n                || *__errno_location() == 23 as libc::c_int)\n            {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            (*files.offset(i_check as isize)).of_name,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_check as isize)).of_name,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_check as isize)).of_name,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            file_limit = 1 as libc::c_int != 0;\n            while (*files.offset(i_reopen as isize)).ofd < 0 as libc::c_int {\n                i_reopen = if i_reopen != 0 {\n                    i_reopen - 1 as libc::c_int as libc::c_long\n                } else {\n                    nfiles - 1 as libc::c_int as libc::c_long\n                };\n                if i_reopen == i_check {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_check as isize)).of_name,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_check as isize)).of_name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    (*files.offset(i_check as isize)).of_name,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut files: *mut of_info",
          "mut i_check: i64",
          "mut nfiles: i64",
          "mut file_limit: bool",
          "mut fd: i32",
          "mut i_reopen: i64"
        ],
        "live_out": [
          "mut files: *mut of_info",
          "mut i_check: i64",
          "mut nfiles: i64",
          "mut file_limit: bool",
          "mut fd: i32",
          "mut i_reopen: i64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/split.rs:3369:13: 3423:80 (#0)",
        "pieces": [
          "src/split.rs:3369:13: 3423:80 (#0)"
        ],
        "num_lines": 55,
        "source": "if rpl_fclose((*files.offset(i_reopen as isize)).ofile) != 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        1 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            (*files.offset(i_reopen as isize)).of_name,\n                        ),\n                    );\n                    if 1 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_reopen as isize)).of_name,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 1 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                (*files.offset(i_reopen as isize)).of_name,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n            }\n            let ref mut fresh18 = (*files.offset(i_reopen as isize)).ofile;\n            *fresh18 = 0 as *mut FILE;\n            (*files.offset(i_reopen as isize)).ofd = OFD_APPEND as libc::c_int;",
        "sub_chunks": [],
        "live_in": [
          "mut files: *mut of_info",
          "mut i_reopen: i64"
        ],
        "live_out": [
          "mut files: *mut of_info",
          "mut i_reopen: i64"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/split.rs:3309:9: 3485:39 (#0)",
        "pieces": [
          "src/split.rs:3309:9: 3316:12 (#0)",
          "src/split.rs:3369:1: 3369:12 (#0)",
          "src/split.rs:3424:1: 3485:39 (#0)"
        ],
        "num_lines": 71,
        "source": "let mut fd: libc::c_int = 0;\n        let mut i_reopen: idx_t = if i_check != 0 {\n            i_check - 1 as libc::c_int as libc::c_long\n        } else {\n            nfiles - 1 as libc::c_int as libc::c_long\n        };\n        loop {\n           <<chunk 0>>           <<chunk 1>>        }\n        (*files.offset(i_check as isize)).ofd = fd;\n        let mut ofile: *mut FILE = fdopen(\n            fd,\n            b\"a\\0\" as *const u8 as *const libc::c_char,\n        );\n        if ofile.is_null() {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        (*files.offset(i_check as isize)).of_name,\n                    ),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            (*files.offset(i_check as isize)).of_name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            (*files.offset(i_check as isize)).of_name,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        let ref mut fresh19 = (*files.offset(i_check as isize)).ofile;\n        *fresh19 = ofile;\n        (*files.offset(i_check as isize)).opid = filter_pid;\n        filter_pid = 0 as libc::c_int;",
        "sub_chunks": [
          0,
          1
        ],
        "live_in": [
          "mut files: *mut of_info",
          "mut i_check: i64",
          "mut nfiles: i64",
          "mut file_limit: bool"
        ],
        "live_out": [
          "mut files: *mut of_info",
          "mut i_check: i64",
          "mut nfiles: i64",
          "mut file_limit: bool"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:270 ~ split[1dd7]::main)",
    "span": "src/split.rs:5195:1: 5209:2 (#0)",
    "pieces": [
      "src/split.rs:5195:1: 5209:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/split.rs:34:1: 34:19 (#0)",
        "source": "use std::io::Read;"
      },
      {
        "span": "src/split.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/split.rs:31:1: 31:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/split.rs:27:1: 27:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/split.rs:29:1: 29:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/split.rs:32:1: 32:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/split.rs:37:1: 37:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/split.rs:39:1: 39:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  }
]